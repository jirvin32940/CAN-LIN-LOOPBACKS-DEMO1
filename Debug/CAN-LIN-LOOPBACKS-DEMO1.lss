
CAN-LIN-LOOPBACKS-DEMO1.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002008  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000540c  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  80007600  80007600  00007a00  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00000238  80007800  80007800  00007c00  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  6 .data         000000b5  00000008  80007a38  00008008  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .balign       00000003  000000bd  80007aed  000080bd  2**0
                  ALLOC
  8 .bss          00000b18  000000c0  000000c0  00000000  2**2
                  ALLOC
  9 .heap         0000e428  00000bd8  00000bd8  00000000  2**0
                  ALLOC
 10 .comment      00000030  00000000  00000000  000080bd  2**0
                  CONTENTS, READONLY
 11 .debug_aranges 00000818  00000000  00000000  000080f0  2**3
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_pubnames 0000167c  00000000  00000000  00008908  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_info   00015381  00000000  00000000  00009f84  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_abbrev 00001946  00000000  00000000  0001f305  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   00007457  00000000  00000000  00020c4b  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  00001834  00000000  00000000  000280a4  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_str    0000439e  00000000  00000000  000298d8  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_loc    00002a78  00000000  00000000  0002dc76  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_macinfo 00dad4f2  00000000  00000000  000306ee  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .stack        00001000  0000f000  0000f000  00000000  2**0
                  ALLOC
 21 .debug_ranges 000007d0  00000000  00000000  00dddbe0  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:

  .global _start
  .type _start, @function
_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80000000:	fe cf ae 3c 	sub	pc,pc,-20932

80000004 <_trampoline>:
80000004:	e0 8f 10 00 	bral	80002004 <program_start>
	...

80002004 <program_start>:
  rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002004:	fe cf ce 40 	sub	pc,pc,-12736

Disassembly of section .text:

80002008 <io_pin>:
80002008:	eb cd 40 80 	pushm	r7,lr

#define SS_ONE_MICROSECOND 8


unsigned char io_pin(unsigned char idx)
{
8000200c:	1a 97       	mov	r7,sp
8000200e:	20 1d       	sub	sp,4
80002010:	18 98       	mov	r8,r12
80002012:	ef 68 ff fc 	st.b	r7[-4],r8
	switch (idx)
80002016:	ef 38 ff fc 	ld.ub	r8,r7[-4]
8000201a:	58 28       	cp.w	r8,2
8000201c:	c1 10       	breq	8000203e <io_pin+0x36>
8000201e:	e0 89 00 07 	brgt	8000202c <io_pin+0x24>
80002022:	58 08       	cp.w	r8,0
80002024:	c0 90       	breq	80002036 <io_pin+0x2e>
80002026:	58 18       	cp.w	r8,1
80002028:	c0 90       	breq	8000203a <io_pin+0x32>
8000202a:	c1 08       	rjmp	8000204a <io_pin+0x42>
8000202c:	58 38       	cp.w	r8,3
8000202e:	c0 a0       	breq	80002042 <io_pin+0x3a>
80002030:	58 48       	cp.w	r8,4
80002032:	c0 a0       	breq	80002046 <io_pin+0x3e>
80002034:	c0 b8       	rjmp	8000204a <io_pin+0x42>
	{
		case 0:
			return SEALSHIELD_SERIAL_ID0;
80002036:	33 38       	mov	r8,51
80002038:	c0 a8       	rjmp	8000204c <io_pin+0x44>
			break;
		case 1:
			return SEALSHIELD_SERIAL_ID1;
8000203a:	33 48       	mov	r8,52
8000203c:	c0 88       	rjmp	8000204c <io_pin+0x44>
			break;
		case 2:
			return SEALSHIELD_SERIAL_ID2;
8000203e:	33 58       	mov	r8,53
80002040:	c0 68       	rjmp	8000204c <io_pin+0x44>
			break;
		case 3:
			return SEALSHIELD_SERIAL_ID3;
80002042:	33 68       	mov	r8,54
80002044:	c0 48       	rjmp	8000204c <io_pin+0x44>
			break;
		case 4:
			return SEALSHIELD_SERIAL_ID4;
80002046:	33 78       	mov	r8,55
80002048:	c0 28       	rjmp	8000204c <io_pin+0x44>
8000204a:	c0 18       	rjmp	8000204c <io_pin+0x44>
			break;
	}
}
8000204c:	10 9c       	mov	r12,r8
8000204e:	2f fd       	sub	sp,-4
80002050:	e3 cd 80 80 	ldm	sp++,r7,pc

80002054 <drive_DQ_low>:


void drive_DQ_low(unsigned char idx)
{
80002054:	eb cd 40 80 	pushm	r7,lr
80002058:	1a 97       	mov	r7,sp
8000205a:	20 2d       	sub	sp,8
8000205c:	18 98       	mov	r8,r12
8000205e:	ef 68 ff f8 	st.b	r7[-8],r8
	unsigned char ioPin;
	
	ioPin = io_pin(idx);
80002062:	ef 38 ff f8 	ld.ub	r8,r7[-8]
80002066:	10 9c       	mov	r12,r8
80002068:	f0 1f 00 07 	mcall	80002084 <drive_DQ_low+0x30>
8000206c:	18 98       	mov	r8,r12
8000206e:	ef 68 ff ff 	st.b	r7[-1],r8
	
	gpio_set_pin_low(ioPin);
80002072:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002076:	10 9c       	mov	r12,r8
80002078:	f0 1f 00 04 	mcall	80002088 <drive_DQ_low+0x34>
}
8000207c:	2f ed       	sub	sp,-8
8000207e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002082:	00 00       	add	r0,r0
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	20 08       	sub	r8,0
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	42 58       	lddsp	r8,sp[0x94]

8000208c <release_the_bus>:

void release_the_bus(unsigned char idx)
{
8000208c:	eb cd 40 80 	pushm	r7,lr
80002090:	1a 97       	mov	r7,sp
80002092:	20 2d       	sub	sp,8
80002094:	18 98       	mov	r8,r12
80002096:	ef 68 ff f8 	st.b	r7[-8],r8
	unsigned char ioPin;
	
	ioPin = io_pin(idx);
8000209a:	ef 38 ff f8 	ld.ub	r8,r7[-8]
8000209e:	10 9c       	mov	r12,r8
800020a0:	f0 1f 00 07 	mcall	800020bc <release_the_bus+0x30>
800020a4:	18 98       	mov	r8,r12
800020a6:	ef 68 ff ff 	st.b	r7[-1],r8
	
	gpio_set_pin_high(ioPin);
800020aa:	ef 38 ff ff 	ld.ub	r8,r7[-1]
800020ae:	10 9c       	mov	r12,r8
800020b0:	f0 1f 00 04 	mcall	800020c0 <release_the_bus+0x34>
	
}
800020b4:	2f ed       	sub	sp,-8
800020b6:	e3 cd 80 80 	ldm	sp++,r7,pc
800020ba:	00 00       	add	r0,r0
800020bc:	80 00       	ld.sh	r0,r0[0x0]
800020be:	20 08       	sub	r8,0
800020c0:	80 00       	ld.sh	r0,r0[0x0]
800020c2:	42 1e       	lddsp	lr,sp[0x84]

800020c4 <sample_line>:

unsigned char sample_line(unsigned char idx)
{
800020c4:	eb cd 40 80 	pushm	r7,lr
800020c8:	1a 97       	mov	r7,sp
800020ca:	20 3d       	sub	sp,12
800020cc:	18 98       	mov	r8,r12
800020ce:	ef 68 ff f4 	st.b	r7[-12],r8
		uint32_t ioFlags;
		unsigned char retVal, ioPin;
		
		ioPin = io_pin(idx);
800020d2:	ef 38 ff f4 	ld.ub	r8,r7[-12]
800020d6:	10 9c       	mov	r12,r8
800020d8:	f0 1f 00 14 	mcall	80002128 <sample_line+0x64>
800020dc:	18 98       	mov	r8,r12
800020de:	ef 68 ff ff 	st.b	r7[-1],r8
		
		ioFlags = (GPIO_DIR_INPUT);
800020e2:	30 08       	mov	r8,0
800020e4:	ef 48 ff f8 	st.w	r7[-8],r8
		gpio_configure_pin(ioPin, ioFlags);
800020e8:	ef 38 ff ff 	ld.ub	r8,r7[-1]
800020ec:	ee fb ff f8 	ld.w	r11,r7[-8]
800020f0:	10 9c       	mov	r12,r8
800020f2:	f0 1f 00 0f 	mcall	8000212c <sample_line+0x68>

		retVal = gpio_get_pin_value(ioPin);
800020f6:	ef 38 ff ff 	ld.ub	r8,r7[-1]
800020fa:	10 9c       	mov	r12,r8
800020fc:	f0 1f 00 0d 	mcall	80002130 <sample_line+0x6c>
80002100:	18 98       	mov	r8,r12
80002102:	ef 68 ff fe 	st.b	r7[-2],r8

		ioFlags = (GPIO_DIR_OUTPUT);
80002106:	30 18       	mov	r8,1
80002108:	ef 48 ff f8 	st.w	r7[-8],r8
		gpio_configure_pin(ioPin, ioFlags);
8000210c:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002110:	ee fb ff f8 	ld.w	r11,r7[-8]
80002114:	10 9c       	mov	r12,r8
80002116:	f0 1f 00 06 	mcall	8000212c <sample_line+0x68>

		return retVal;
8000211a:	ef 38 ff fe 	ld.ub	r8,r7[-2]
}
8000211e:	10 9c       	mov	r12,r8
80002120:	2f dd       	sub	sp,-12
80002122:	e3 cd 80 80 	ldm	sp++,r7,pc
80002126:	00 00       	add	r0,r0
80002128:	80 00       	ld.sh	r0,r0[0x0]
8000212a:	20 08       	sub	r8,0
8000212c:	80 00       	ld.sh	r0,r0[0x0]
8000212e:	3f 44       	mov	r4,-12
80002130:	80 00       	ld.sh	r0,r0[0x0]
80002132:	41 e2       	lddsp	r2,sp[0x78]

80002134 <SetSpeed>:

//-----------------------------------------------------------------------------
// Set the 1-Wire timing to 'standard' (standard=1) or 'overdrive' (standard=0).
//
void SetSpeed(int standard)
{
80002134:	eb cd 40 80 	pushm	r7,lr
80002138:	1a 97       	mov	r7,sp
8000213a:	20 1d       	sub	sp,4
8000213c:	ef 4c ff fc 	st.w	r7[-4],r12
	// Adjust tick values depending on speed
	if (standard)
80002140:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002144:	58 08       	cp.w	r8,0
80002146:	c2 20       	breq	8000218a <SetSpeed+0x56>
	{
		// Standard Speed
		A = 6; //us
80002148:	4a 18       	lddpc	r8,800021cc <SetSpeed+0x98>
8000214a:	30 69       	mov	r9,6
8000214c:	91 09       	st.w	r8[0x0],r9
		B = 64;
8000214e:	4a 18       	lddpc	r8,800021d0 <SetSpeed+0x9c>
80002150:	34 09       	mov	r9,64
80002152:	91 09       	st.w	r8[0x0],r9
		C = 60;
80002154:	4a 08       	lddpc	r8,800021d4 <SetSpeed+0xa0>
80002156:	33 c9       	mov	r9,60
80002158:	91 09       	st.w	r8[0x0],r9
		D = 10;
8000215a:	4a 08       	lddpc	r8,800021d8 <SetSpeed+0xa4>
8000215c:	30 a9       	mov	r9,10
8000215e:	91 09       	st.w	r8[0x0],r9
		E = 9;
80002160:	49 f8       	lddpc	r8,800021dc <SetSpeed+0xa8>
80002162:	30 99       	mov	r9,9
80002164:	91 09       	st.w	r8[0x0],r9
		F = 55;
80002166:	49 f8       	lddpc	r8,800021e0 <SetSpeed+0xac>
80002168:	33 79       	mov	r9,55
8000216a:	91 09       	st.w	r8[0x0],r9
		G = 0;
8000216c:	49 e8       	lddpc	r8,800021e4 <SetSpeed+0xb0>
8000216e:	30 09       	mov	r9,0
80002170:	91 09       	st.w	r8[0x0],r9
		H = 480;
80002172:	49 e8       	lddpc	r8,800021e8 <SetSpeed+0xb4>
80002174:	e0 69 01 e0 	mov	r9,480
80002178:	91 09       	st.w	r8[0x0],r9
		I = 70;
8000217a:	49 d8       	lddpc	r8,800021ec <SetSpeed+0xb8>
8000217c:	34 69       	mov	r9,70
8000217e:	91 09       	st.w	r8[0x0],r9
		J = 410;
80002180:	49 c8       	lddpc	r8,800021f0 <SetSpeed+0xbc>
80002182:	e0 69 01 9a 	mov	r9,410
80002186:	91 09       	st.w	r8[0x0],r9
80002188:	c1 f8       	rjmp	800021c6 <SetSpeed+0x92>
	}
	else
	{
		// Overdrive Speed
		A = 1.5;
8000218a:	49 18       	lddpc	r8,800021cc <SetSpeed+0x98>
8000218c:	30 19       	mov	r9,1
8000218e:	91 09       	st.w	r8[0x0],r9
		B = 7.5;
80002190:	49 08       	lddpc	r8,800021d0 <SetSpeed+0x9c>
80002192:	30 79       	mov	r9,7
80002194:	91 09       	st.w	r8[0x0],r9
		C = 7.5;
80002196:	49 08       	lddpc	r8,800021d4 <SetSpeed+0xa0>
80002198:	30 79       	mov	r9,7
8000219a:	91 09       	st.w	r8[0x0],r9
		D = 2.5;
8000219c:	48 f8       	lddpc	r8,800021d8 <SetSpeed+0xa4>
8000219e:	30 29       	mov	r9,2
800021a0:	91 09       	st.w	r8[0x0],r9
		E = 0.75;
800021a2:	48 f8       	lddpc	r8,800021dc <SetSpeed+0xa8>
800021a4:	30 09       	mov	r9,0
800021a6:	91 09       	st.w	r8[0x0],r9
		F = 7;
800021a8:	48 e8       	lddpc	r8,800021e0 <SetSpeed+0xac>
800021aa:	30 79       	mov	r9,7
800021ac:	91 09       	st.w	r8[0x0],r9
		G = 2.5;
800021ae:	48 e8       	lddpc	r8,800021e4 <SetSpeed+0xb0>
800021b0:	30 29       	mov	r9,2
800021b2:	91 09       	st.w	r8[0x0],r9
		H = 70;
800021b4:	48 d8       	lddpc	r8,800021e8 <SetSpeed+0xb4>
800021b6:	34 69       	mov	r9,70
800021b8:	91 09       	st.w	r8[0x0],r9
		I = 8.5;
800021ba:	48 d8       	lddpc	r8,800021ec <SetSpeed+0xb8>
800021bc:	30 89       	mov	r9,8
800021be:	91 09       	st.w	r8[0x0],r9
		J = 40;
800021c0:	48 c8       	lddpc	r8,800021f0 <SetSpeed+0xbc>
800021c2:	32 89       	mov	r9,40
800021c4:	91 09       	st.w	r8[0x0],r9
	}
}
800021c6:	2f fd       	sub	sp,-4
800021c8:	e3 cd 80 80 	ldm	sp++,r7,pc
800021cc:	00 00       	add	r0,r0
800021ce:	02 bc       	st.h	r1++,r12
800021d0:	00 00       	add	r0,r0
800021d2:	02 c0       	st.b	r1++,r0
800021d4:	00 00       	add	r0,r0
800021d6:	02 c8       	st.b	r1++,r8
800021d8:	00 00       	add	r0,r0
800021da:	02 b8       	st.h	r1++,r8
800021dc:	00 00       	add	r0,r0
800021de:	02 d4       	st.w	--r1,r4
800021e0:	00 00       	add	r0,r0
800021e2:	02 dc       	st.w	--r1,r12
800021e4:	00 00       	add	r0,r0
800021e6:	02 cc       	st.b	r1++,r12
800021e8:	00 00       	add	r0,r0
800021ea:	02 d0       	st.w	--r1,r0
800021ec:	00 00       	add	r0,r0
800021ee:	02 d8       	st.w	--r1,r8
800021f0:	00 00       	add	r0,r0
800021f2:	02 c4       	st.b	r1++,r4

800021f4 <OWTouchReset>:
// Generate a 1-Wire reset, return 1 if no presence detect was found,
// return 0 otherwise.
// (NOTE: Does not handle alarm presence from DS2404/DS1994)
//
int OWTouchReset(unsigned char idx)
{
800021f4:	eb cd 40 8f 	pushm	r0-r3,r7,lr
800021f8:	1a 97       	mov	r7,sp
800021fa:	fa cd 00 e0 	sub	sp,sp,224
800021fe:	18 98       	mov	r8,r12
80002200:	ef 68 ff 48 	st.b	r7[-184],r8
	int result;

	cpu_delay_us(A, 8000000);
80002204:	fe f8 05 88 	ld.w	r8,pc[1416]
80002208:	70 08       	ld.w	r8,r8[0x0]
8000220a:	ef 48 ff 84 	st.w	r7[-124],r8
8000220e:	e0 68 12 00 	mov	r8,4608
80002212:	ea 18 00 7a 	orh	r8,0x7a
80002216:	ef 48 ff 80 	st.w	r7[-128],r8
8000221a:	ee f8 ff 84 	ld.w	r8,r7[-124]
8000221e:	ef 48 ff 8c 	st.w	r7[-116],r8
80002222:	ee f8 ff 80 	ld.w	r8,r7[-128]
80002226:	ef 48 ff 88 	st.w	r7[-120],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_us_2_cy(unsigned long us, unsigned long fcpu_hz)
{
  return ((unsigned long long)us * fcpu_hz + 999999) / 1000000;
8000222a:	ee f2 ff 8c 	ld.w	r2,r7[-116]
8000222e:	30 03       	mov	r3,0
80002230:	ee fa ff 88 	ld.w	r10,r7[-120]
80002234:	30 0b       	mov	r11,0
80002236:	e6 0a 02 49 	mul	r9,r3,r10
8000223a:	f6 02 02 48 	mul	r8,r11,r2
8000223e:	10 09       	add	r9,r8
80002240:	e4 0a 06 4a 	mulu.d	r10,r2,r10
80002244:	16 09       	add	r9,r11
80002246:	12 9b       	mov	r11,r9
80002248:	ee 78 42 3f 	mov	r8,999999
8000224c:	30 09       	mov	r9,0
8000224e:	10 0a       	add	r10,r8
80002250:	f6 09 00 4b 	adc	r11,r11,r9
80002254:	ee 78 42 40 	mov	r8,1000000
80002258:	30 09       	mov	r9,0
8000225a:	f0 1f 01 4e 	mcall	80002790 <OWTouchReset+0x59c>
8000225e:	14 98       	mov	r8,r10
80002260:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_us(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_us_2_cy(delay, fcpu_hz), &timer);
80002262:	ef 48 ff 94 	st.w	r7[-108],r8
80002266:	ee c8 00 b4 	sub	r8,r7,180
8000226a:	ef 48 ff 90 	st.w	r7[-112],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000226e:	e1 b8 00 42 	mfsr	r8,0x108
80002272:	10 99       	mov	r9,r8
80002274:	ee f8 ff 90 	ld.w	r8,r7[-112]
80002278:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000227a:	ee f8 ff 90 	ld.w	r8,r7[-112]
8000227e:	70 09       	ld.w	r9,r8[0x0]
80002280:	ee f8 ff 94 	ld.w	r8,r7[-108]
80002284:	10 09       	add	r9,r8
80002286:	ee f8 ff 90 	ld.w	r8,r7[-112]
8000228a:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
8000228c:	ee f9 ff 90 	ld.w	r9,r7[-112]
80002290:	30 08       	mov	r8,0
80002292:	f3 68 00 08 	st.b	r9[8],r8
80002296:	ee c8 00 b4 	sub	r8,r7,180
8000229a:	ef 48 ff 98 	st.w	r7[-104],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000229e:	e1 b8 00 42 	mfsr	r8,0x108
800022a2:	ef 48 ff 9c 	st.w	r7[-100],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
800022a6:	ee f8 ff 98 	ld.w	r8,r7[-104]
800022aa:	f1 39 00 08 	ld.ub	r9,r8[8]
800022ae:	30 28       	mov	r8,2
800022b0:	f0 09 18 00 	cp.b	r9,r8
800022b4:	c0 31       	brne	800022ba <OWTouchReset+0xc6>
    return false;
800022b6:	30 08       	mov	r8,0
800022b8:	c4 38       	rjmp	8000233e <OWTouchReset+0x14a>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
800022ba:	ee f8 ff 98 	ld.w	r8,r7[-104]
800022be:	f1 39 00 08 	ld.ub	r9,r8[8]
800022c2:	30 18       	mov	r8,1
800022c4:	f0 09 18 00 	cp.b	r9,r8
800022c8:	c0 31       	brne	800022ce <OWTouchReset+0xda>
    return true;
800022ca:	30 18       	mov	r8,1
800022cc:	c3 98       	rjmp	8000233e <OWTouchReset+0x14a>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800022ce:	ee f8 ff 98 	ld.w	r8,r7[-104]
800022d2:	70 09       	ld.w	r9,r8[0x0]
800022d4:	ee f8 ff 98 	ld.w	r8,r7[-104]
800022d8:	70 18       	ld.w	r8,r8[0x4]
800022da:	10 39       	cp.w	r9,r8
800022dc:	e0 88 00 1a 	brls	80002310 <OWTouchReset+0x11c>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800022e0:	ee f8 ff 98 	ld.w	r8,r7[-104]
800022e4:	70 08       	ld.w	r8,r8[0x0]
800022e6:	ee f9 ff 9c 	ld.w	r9,r7[-100]
800022ea:	10 39       	cp.w	r9,r8
800022ec:	c1 02       	brcc	8000230c <OWTouchReset+0x118>
800022ee:	ee f8 ff 98 	ld.w	r8,r7[-104]
800022f2:	70 18       	ld.w	r8,r8[0x4]
800022f4:	ee f9 ff 9c 	ld.w	r9,r7[-100]
800022f8:	10 39       	cp.w	r9,r8
800022fa:	e0 88 00 09 	brls	8000230c <OWTouchReset+0x118>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
800022fe:	ee f9 ff 98 	ld.w	r9,r7[-104]
80002302:	30 18       	mov	r8,1
80002304:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002308:	30 18       	mov	r8,1
8000230a:	c1 a8       	rjmp	8000233e <OWTouchReset+0x14a>
    }
    return false;
8000230c:	30 08       	mov	r8,0
8000230e:	c1 88       	rjmp	8000233e <OWTouchReset+0x14a>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002310:	ee f8 ff 98 	ld.w	r8,r7[-104]
80002314:	70 08       	ld.w	r8,r8[0x0]
80002316:	ee f9 ff 9c 	ld.w	r9,r7[-100]
8000231a:	10 39       	cp.w	r9,r8
8000231c:	c0 93       	brcs	8000232e <OWTouchReset+0x13a>
8000231e:	ee f8 ff 98 	ld.w	r8,r7[-104]
80002322:	70 18       	ld.w	r8,r8[0x4]
80002324:	ee f9 ff 9c 	ld.w	r9,r7[-100]
80002328:	10 39       	cp.w	r9,r8
8000232a:	e0 88 00 09 	brls	8000233c <OWTouchReset+0x148>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
8000232e:	ee f9 ff 98 	ld.w	r9,r7[-104]
80002332:	30 18       	mov	r8,1
80002334:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002338:	30 18       	mov	r8,1
8000233a:	c0 28       	rjmp	8000233e <OWTouchReset+0x14a>
    }
    return false;
8000233c:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_us(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_us_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
8000233e:	58 08       	cp.w	r8,0
80002340:	ca b0       	breq	80002296 <OWTouchReset+0xa2>
	drive_DQ_low(idx);
80002342:	ef 38 ff 48 	ld.ub	r8,r7[-184]
80002346:	10 9c       	mov	r12,r8
80002348:	f0 1f 01 13 	mcall	80002794 <OWTouchReset+0x5a0>
	cpu_delay_us(H, 8000000);
8000234c:	fe f8 04 4c 	ld.w	r8,pc[1100]
80002350:	70 08       	ld.w	r8,r8[0x0]
80002352:	ef 48 ff a4 	st.w	r7[-92],r8
80002356:	e0 68 12 00 	mov	r8,4608
8000235a:	ea 18 00 7a 	orh	r8,0x7a
8000235e:	ef 48 ff a0 	st.w	r7[-96],r8
80002362:	ee f8 ff a4 	ld.w	r8,r7[-92]
80002366:	ef 48 ff ac 	st.w	r7[-84],r8
8000236a:	ee f8 ff a0 	ld.w	r8,r7[-96]
8000236e:	ef 48 ff a8 	st.w	r7[-88],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_us_2_cy(unsigned long us, unsigned long fcpu_hz)
{
  return ((unsigned long long)us * fcpu_hz + 999999) / 1000000;
80002372:	ee fc ff ac 	ld.w	r12,r7[-84]
80002376:	ef 4c ff 2c 	st.w	r7[-212],r12
8000237a:	30 0b       	mov	r11,0
8000237c:	ef 4b ff 28 	st.w	r7[-216],r11
80002380:	ee f9 ff a8 	ld.w	r9,r7[-88]
80002384:	ef 49 ff 24 	st.w	r7[-220],r9
80002388:	30 08       	mov	r8,0
8000238a:	ef 48 ff 20 	st.w	r7[-224],r8
8000238e:	ee fa ff 28 	ld.w	r10,r7[-216]
80002392:	ee fc ff 24 	ld.w	r12,r7[-220]
80002396:	b9 3a       	mul	r10,r12
80002398:	ee f8 ff 20 	ld.w	r8,r7[-224]
8000239c:	ee fb ff 2c 	ld.w	r11,r7[-212]
800023a0:	b7 38       	mul	r8,r11
800023a2:	10 0a       	add	r10,r8
800023a4:	ee fc ff 2c 	ld.w	r12,r7[-212]
800023a8:	ee fb ff 24 	ld.w	r11,r7[-220]
800023ac:	f8 0b 06 48 	mulu.d	r8,r12,r11
800023b0:	12 0a       	add	r10,r9
800023b2:	14 99       	mov	r9,r10
800023b4:	ee 7a 42 3f 	mov	r10,999999
800023b8:	30 0b       	mov	r11,0
800023ba:	f0 0a 00 0a 	add	r10,r8,r10
800023be:	f2 0b 00 4b 	adc	r11,r9,r11
800023c2:	ee 78 42 40 	mov	r8,1000000
800023c6:	30 09       	mov	r9,0
800023c8:	f0 1f 00 f2 	mcall	80002790 <OWTouchReset+0x59c>
800023cc:	14 98       	mov	r8,r10
800023ce:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_us(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_us_2_cy(delay, fcpu_hz), &timer);
800023d0:	ef 48 ff b4 	st.w	r7[-76],r8
800023d4:	ee c8 00 a8 	sub	r8,r7,168
800023d8:	ef 48 ff b0 	st.w	r7[-80],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800023dc:	e1 b8 00 42 	mfsr	r8,0x108
800023e0:	10 99       	mov	r9,r8
800023e2:	ee f8 ff b0 	ld.w	r8,r7[-80]
800023e6:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800023e8:	ee f8 ff b0 	ld.w	r8,r7[-80]
800023ec:	70 09       	ld.w	r9,r8[0x0]
800023ee:	ee f8 ff b4 	ld.w	r8,r7[-76]
800023f2:	10 09       	add	r9,r8
800023f4:	ee f8 ff b0 	ld.w	r8,r7[-80]
800023f8:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
800023fa:	ee f9 ff b0 	ld.w	r9,r7[-80]
800023fe:	30 08       	mov	r8,0
80002400:	f3 68 00 08 	st.b	r9[8],r8
80002404:	ee c8 00 a8 	sub	r8,r7,168
80002408:	ef 48 ff b8 	st.w	r7[-72],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000240c:	e1 b8 00 42 	mfsr	r8,0x108
80002410:	ef 48 ff bc 	st.w	r7[-68],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
80002414:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002418:	f1 39 00 08 	ld.ub	r9,r8[8]
8000241c:	30 28       	mov	r8,2
8000241e:	f0 09 18 00 	cp.b	r9,r8
80002422:	c0 31       	brne	80002428 <OWTouchReset+0x234>
    return false;
80002424:	30 08       	mov	r8,0
80002426:	c4 38       	rjmp	800024ac <OWTouchReset+0x2b8>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
80002428:	ee f8 ff b8 	ld.w	r8,r7[-72]
8000242c:	f1 39 00 08 	ld.ub	r9,r8[8]
80002430:	30 18       	mov	r8,1
80002432:	f0 09 18 00 	cp.b	r9,r8
80002436:	c0 31       	brne	8000243c <OWTouchReset+0x248>
    return true;
80002438:	30 18       	mov	r8,1
8000243a:	c3 98       	rjmp	800024ac <OWTouchReset+0x2b8>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000243c:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002440:	70 09       	ld.w	r9,r8[0x0]
80002442:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002446:	70 18       	ld.w	r8,r8[0x4]
80002448:	10 39       	cp.w	r9,r8
8000244a:	e0 88 00 1a 	brls	8000247e <OWTouchReset+0x28a>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000244e:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002452:	70 08       	ld.w	r8,r8[0x0]
80002454:	ee f9 ff bc 	ld.w	r9,r7[-68]
80002458:	10 39       	cp.w	r9,r8
8000245a:	c1 02       	brcc	8000247a <OWTouchReset+0x286>
8000245c:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002460:	70 18       	ld.w	r8,r8[0x4]
80002462:	ee f9 ff bc 	ld.w	r9,r7[-68]
80002466:	10 39       	cp.w	r9,r8
80002468:	e0 88 00 09 	brls	8000247a <OWTouchReset+0x286>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
8000246c:	ee f9 ff b8 	ld.w	r9,r7[-72]
80002470:	30 18       	mov	r8,1
80002472:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002476:	30 18       	mov	r8,1
80002478:	c1 a8       	rjmp	800024ac <OWTouchReset+0x2b8>
    }
    return false;
8000247a:	30 08       	mov	r8,0
8000247c:	c1 88       	rjmp	800024ac <OWTouchReset+0x2b8>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000247e:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002482:	70 08       	ld.w	r8,r8[0x0]
80002484:	ee f9 ff bc 	ld.w	r9,r7[-68]
80002488:	10 39       	cp.w	r9,r8
8000248a:	c0 93       	brcs	8000249c <OWTouchReset+0x2a8>
8000248c:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002490:	70 18       	ld.w	r8,r8[0x4]
80002492:	ee f9 ff bc 	ld.w	r9,r7[-68]
80002496:	10 39       	cp.w	r9,r8
80002498:	e0 88 00 09 	brls	800024aa <OWTouchReset+0x2b6>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
8000249c:	ee f9 ff b8 	ld.w	r9,r7[-72]
800024a0:	30 18       	mov	r8,1
800024a2:	f3 68 00 08 	st.b	r9[8],r8
      return true;
800024a6:	30 18       	mov	r8,1
800024a8:	c0 28       	rjmp	800024ac <OWTouchReset+0x2b8>
    }
    return false;
800024aa:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_us(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_us_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
800024ac:	58 08       	cp.w	r8,0
800024ae:	ca b0       	breq	80002404 <OWTouchReset+0x210>
	release_the_bus(idx);
800024b0:	ef 38 ff 48 	ld.ub	r8,r7[-184]
800024b4:	10 9c       	mov	r12,r8
800024b6:	f0 1f 00 ba 	mcall	8000279c <OWTouchReset+0x5a8>
	cpu_delay_us(I, 8000000);
800024ba:	fe f8 02 e6 	ld.w	r8,pc[742]
800024be:	70 08       	ld.w	r8,r8[0x0]
800024c0:	ef 48 ff c4 	st.w	r7[-60],r8
800024c4:	e0 68 12 00 	mov	r8,4608
800024c8:	ea 18 00 7a 	orh	r8,0x7a
800024cc:	ef 48 ff c0 	st.w	r7[-64],r8
800024d0:	ee f8 ff c4 	ld.w	r8,r7[-60]
800024d4:	ef 48 ff cc 	st.w	r7[-52],r8
800024d8:	ee f8 ff c0 	ld.w	r8,r7[-64]
800024dc:	ef 48 ff c8 	st.w	r7[-56],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_us_2_cy(unsigned long us, unsigned long fcpu_hz)
{
  return ((unsigned long long)us * fcpu_hz + 999999) / 1000000;
800024e0:	ee f9 ff cc 	ld.w	r9,r7[-52]
800024e4:	ef 49 ff 3c 	st.w	r7[-196],r9
800024e8:	30 08       	mov	r8,0
800024ea:	ef 48 ff 38 	st.w	r7[-200],r8
800024ee:	ee fc ff c8 	ld.w	r12,r7[-56]
800024f2:	ef 4c ff 34 	st.w	r7[-204],r12
800024f6:	30 0b       	mov	r11,0
800024f8:	ef 4b ff 30 	st.w	r7[-208],r11
800024fc:	ee fa ff 38 	ld.w	r10,r7[-200]
80002500:	ee f9 ff 34 	ld.w	r9,r7[-204]
80002504:	b3 3a       	mul	r10,r9
80002506:	ee f8 ff 30 	ld.w	r8,r7[-208]
8000250a:	ee fc ff 3c 	ld.w	r12,r7[-196]
8000250e:	b9 38       	mul	r8,r12
80002510:	10 0a       	add	r10,r8
80002512:	ee fb ff 3c 	ld.w	r11,r7[-196]
80002516:	ee fc ff 34 	ld.w	r12,r7[-204]
8000251a:	f6 0c 06 48 	mulu.d	r8,r11,r12
8000251e:	12 0a       	add	r10,r9
80002520:	14 99       	mov	r9,r10
80002522:	ee 7a 42 3f 	mov	r10,999999
80002526:	30 0b       	mov	r11,0
80002528:	f0 0a 00 0a 	add	r10,r8,r10
8000252c:	f2 0b 00 4b 	adc	r11,r9,r11
80002530:	ee 78 42 40 	mov	r8,1000000
80002534:	30 09       	mov	r9,0
80002536:	f0 1f 00 97 	mcall	80002790 <OWTouchReset+0x59c>
8000253a:	14 98       	mov	r8,r10
8000253c:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_us(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_us_2_cy(delay, fcpu_hz), &timer);
8000253e:	ef 48 ff d4 	st.w	r7[-44],r8
80002542:	ee c8 00 9c 	sub	r8,r7,156
80002546:	ef 48 ff d0 	st.w	r7[-48],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000254a:	e1 b8 00 42 	mfsr	r8,0x108
8000254e:	10 99       	mov	r9,r8
80002550:	ee f8 ff d0 	ld.w	r8,r7[-48]
80002554:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002556:	ee f8 ff d0 	ld.w	r8,r7[-48]
8000255a:	70 09       	ld.w	r9,r8[0x0]
8000255c:	ee f8 ff d4 	ld.w	r8,r7[-44]
80002560:	10 09       	add	r9,r8
80002562:	ee f8 ff d0 	ld.w	r8,r7[-48]
80002566:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
80002568:	ee f9 ff d0 	ld.w	r9,r7[-48]
8000256c:	30 08       	mov	r8,0
8000256e:	f3 68 00 08 	st.b	r9[8],r8
80002572:	ee c8 00 9c 	sub	r8,r7,156
80002576:	ef 48 ff d8 	st.w	r7[-40],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000257a:	e1 b8 00 42 	mfsr	r8,0x108
8000257e:	ef 48 ff dc 	st.w	r7[-36],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
80002582:	ee f8 ff d8 	ld.w	r8,r7[-40]
80002586:	f1 39 00 08 	ld.ub	r9,r8[8]
8000258a:	30 28       	mov	r8,2
8000258c:	f0 09 18 00 	cp.b	r9,r8
80002590:	c0 31       	brne	80002596 <OWTouchReset+0x3a2>
    return false;
80002592:	30 08       	mov	r8,0
80002594:	c4 38       	rjmp	8000261a <OWTouchReset+0x426>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
80002596:	ee f8 ff d8 	ld.w	r8,r7[-40]
8000259a:	f1 39 00 08 	ld.ub	r9,r8[8]
8000259e:	30 18       	mov	r8,1
800025a0:	f0 09 18 00 	cp.b	r9,r8
800025a4:	c0 31       	brne	800025aa <OWTouchReset+0x3b6>
    return true;
800025a6:	30 18       	mov	r8,1
800025a8:	c3 98       	rjmp	8000261a <OWTouchReset+0x426>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800025aa:	ee f8 ff d8 	ld.w	r8,r7[-40]
800025ae:	70 09       	ld.w	r9,r8[0x0]
800025b0:	ee f8 ff d8 	ld.w	r8,r7[-40]
800025b4:	70 18       	ld.w	r8,r8[0x4]
800025b6:	10 39       	cp.w	r9,r8
800025b8:	e0 88 00 1a 	brls	800025ec <OWTouchReset+0x3f8>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800025bc:	ee f8 ff d8 	ld.w	r8,r7[-40]
800025c0:	70 08       	ld.w	r8,r8[0x0]
800025c2:	ee f9 ff dc 	ld.w	r9,r7[-36]
800025c6:	10 39       	cp.w	r9,r8
800025c8:	c1 02       	brcc	800025e8 <OWTouchReset+0x3f4>
800025ca:	ee f8 ff d8 	ld.w	r8,r7[-40]
800025ce:	70 18       	ld.w	r8,r8[0x4]
800025d0:	ee f9 ff dc 	ld.w	r9,r7[-36]
800025d4:	10 39       	cp.w	r9,r8
800025d6:	e0 88 00 09 	brls	800025e8 <OWTouchReset+0x3f4>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
800025da:	ee f9 ff d8 	ld.w	r9,r7[-40]
800025de:	30 18       	mov	r8,1
800025e0:	f3 68 00 08 	st.b	r9[8],r8
      return true;
800025e4:	30 18       	mov	r8,1
800025e6:	c1 a8       	rjmp	8000261a <OWTouchReset+0x426>
    }
    return false;
800025e8:	30 08       	mov	r8,0
800025ea:	c1 88       	rjmp	8000261a <OWTouchReset+0x426>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800025ec:	ee f8 ff d8 	ld.w	r8,r7[-40]
800025f0:	70 08       	ld.w	r8,r8[0x0]
800025f2:	ee f9 ff dc 	ld.w	r9,r7[-36]
800025f6:	10 39       	cp.w	r9,r8
800025f8:	c0 93       	brcs	8000260a <OWTouchReset+0x416>
800025fa:	ee f8 ff d8 	ld.w	r8,r7[-40]
800025fe:	70 18       	ld.w	r8,r8[0x4]
80002600:	ee f9 ff dc 	ld.w	r9,r7[-36]
80002604:	10 39       	cp.w	r9,r8
80002606:	e0 88 00 09 	brls	80002618 <OWTouchReset+0x424>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
8000260a:	ee f9 ff d8 	ld.w	r9,r7[-40]
8000260e:	30 18       	mov	r8,1
80002610:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002614:	30 18       	mov	r8,1
80002616:	c0 28       	rjmp	8000261a <OWTouchReset+0x426>
    }
    return false;
80002618:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_us(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_us_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
8000261a:	58 08       	cp.w	r8,0
8000261c:	ca b0       	breq	80002572 <OWTouchReset+0x37e>
	result = sample_line(idx);
8000261e:	ef 38 ff 48 	ld.ub	r8,r7[-184]
80002622:	10 9c       	mov	r12,r8
80002624:	f0 1f 00 60 	mcall	800027a4 <OWTouchReset+0x5b0>
80002628:	18 98       	mov	r8,r12
8000262a:	ef 48 ff 7c 	st.w	r7[-132],r8
	cpu_delay_us(J, 8000000); // Complete the reset sequence recovery
8000262e:	4d f8       	lddpc	r8,800027a8 <OWTouchReset+0x5b4>
80002630:	70 08       	ld.w	r8,r8[0x0]
80002632:	ef 48 ff e4 	st.w	r7[-28],r8
80002636:	e0 68 12 00 	mov	r8,4608
8000263a:	ea 18 00 7a 	orh	r8,0x7a
8000263e:	ef 48 ff e0 	st.w	r7[-32],r8
80002642:	ee f8 ff e4 	ld.w	r8,r7[-28]
80002646:	ef 48 ff ec 	st.w	r7[-20],r8
8000264a:	ee f8 ff e0 	ld.w	r8,r7[-32]
8000264e:	ef 48 ff e8 	st.w	r7[-24],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_us_2_cy(unsigned long us, unsigned long fcpu_hz)
{
  return ((unsigned long long)us * fcpu_hz + 999999) / 1000000;
80002652:	ee fb ff ec 	ld.w	r11,r7[-20]
80002656:	ef 4b ff 44 	st.w	r7[-188],r11
8000265a:	30 09       	mov	r9,0
8000265c:	ef 49 ff 40 	st.w	r7[-192],r9
80002660:	ee f0 ff e8 	ld.w	r0,r7[-24]
80002664:	30 01       	mov	r1,0
80002666:	ee fa ff 40 	ld.w	r10,r7[-192]
8000266a:	a1 3a       	mul	r10,r0
8000266c:	ee fc ff 44 	ld.w	r12,r7[-188]
80002670:	e2 0c 02 48 	mul	r8,r1,r12
80002674:	10 0a       	add	r10,r8
80002676:	ee fb ff 44 	ld.w	r11,r7[-188]
8000267a:	f6 00 06 48 	mulu.d	r8,r11,r0
8000267e:	12 0a       	add	r10,r9
80002680:	14 99       	mov	r9,r10
80002682:	ee 7a 42 3f 	mov	r10,999999
80002686:	30 0b       	mov	r11,0
80002688:	f0 0a 00 0a 	add	r10,r8,r10
8000268c:	f2 0b 00 4b 	adc	r11,r9,r11
80002690:	ee 78 42 40 	mov	r8,1000000
80002694:	30 09       	mov	r9,0
80002696:	f0 1f 00 3f 	mcall	80002790 <OWTouchReset+0x59c>
8000269a:	14 98       	mov	r8,r10
8000269c:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_us(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_us_2_cy(delay, fcpu_hz), &timer);
8000269e:	ef 48 ff f4 	st.w	r7[-12],r8
800026a2:	ee c8 00 90 	sub	r8,r7,144
800026a6:	ef 48 ff f0 	st.w	r7[-16],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800026aa:	e1 b8 00 42 	mfsr	r8,0x108
800026ae:	10 99       	mov	r9,r8
800026b0:	ee f8 ff f0 	ld.w	r8,r7[-16]
800026b4:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800026b6:	ee f8 ff f0 	ld.w	r8,r7[-16]
800026ba:	70 09       	ld.w	r9,r8[0x0]
800026bc:	ee f8 ff f4 	ld.w	r8,r7[-12]
800026c0:	10 09       	add	r9,r8
800026c2:	ee f8 ff f0 	ld.w	r8,r7[-16]
800026c6:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
800026c8:	ee f9 ff f0 	ld.w	r9,r7[-16]
800026cc:	30 08       	mov	r8,0
800026ce:	f3 68 00 08 	st.b	r9[8],r8
800026d2:	ee c8 00 90 	sub	r8,r7,144
800026d6:	ef 48 ff f8 	st.w	r7[-8],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800026da:	e1 b8 00 42 	mfsr	r8,0x108
800026de:	ef 48 ff fc 	st.w	r7[-4],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
800026e2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800026e6:	f1 39 00 08 	ld.ub	r9,r8[8]
800026ea:	30 28       	mov	r8,2
800026ec:	f0 09 18 00 	cp.b	r9,r8
800026f0:	c0 31       	brne	800026f6 <OWTouchReset+0x502>
    return false;
800026f2:	30 08       	mov	r8,0
800026f4:	c4 38       	rjmp	8000277a <OWTouchReset+0x586>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
800026f6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800026fa:	f1 39 00 08 	ld.ub	r9,r8[8]
800026fe:	30 18       	mov	r8,1
80002700:	f0 09 18 00 	cp.b	r9,r8
80002704:	c0 31       	brne	8000270a <OWTouchReset+0x516>
    return true;
80002706:	30 18       	mov	r8,1
80002708:	c3 98       	rjmp	8000277a <OWTouchReset+0x586>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000270a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000270e:	70 09       	ld.w	r9,r8[0x0]
80002710:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002714:	70 18       	ld.w	r8,r8[0x4]
80002716:	10 39       	cp.w	r9,r8
80002718:	e0 88 00 1a 	brls	8000274c <OWTouchReset+0x558>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000271c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002720:	70 08       	ld.w	r8,r8[0x0]
80002722:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002726:	10 39       	cp.w	r9,r8
80002728:	c1 02       	brcc	80002748 <OWTouchReset+0x554>
8000272a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000272e:	70 18       	ld.w	r8,r8[0x4]
80002730:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002734:	10 39       	cp.w	r9,r8
80002736:	e0 88 00 09 	brls	80002748 <OWTouchReset+0x554>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
8000273a:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000273e:	30 18       	mov	r8,1
80002740:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002744:	30 18       	mov	r8,1
80002746:	c1 a8       	rjmp	8000277a <OWTouchReset+0x586>
    }
    return false;
80002748:	30 08       	mov	r8,0
8000274a:	c1 88       	rjmp	8000277a <OWTouchReset+0x586>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000274c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002750:	70 08       	ld.w	r8,r8[0x0]
80002752:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002756:	10 39       	cp.w	r9,r8
80002758:	c0 93       	brcs	8000276a <OWTouchReset+0x576>
8000275a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000275e:	70 18       	ld.w	r8,r8[0x4]
80002760:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002764:	10 39       	cp.w	r9,r8
80002766:	e0 88 00 09 	brls	80002778 <OWTouchReset+0x584>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
8000276a:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000276e:	30 18       	mov	r8,1
80002770:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002774:	30 18       	mov	r8,1
80002776:	c0 28       	rjmp	8000277a <OWTouchReset+0x586>
    }
    return false;
80002778:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_us(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_us_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
8000277a:	58 08       	cp.w	r8,0
8000277c:	ca b0       	breq	800026d2 <OWTouchReset+0x4de>
	return result; // Return sample presence pulse result
8000277e:	ee f8 ff 7c 	ld.w	r8,r7[-132]
}
80002782:	10 9c       	mov	r12,r8
80002784:	2c 8d       	sub	sp,-224
80002786:	e3 cd 80 8f 	ldm	sp++,r0-r3,r7,pc
8000278a:	00 00       	add	r0,r0
8000278c:	00 00       	add	r0,r0
8000278e:	02 bc       	st.h	r1++,r12
80002790:	80 00       	ld.sh	r0,r0[0x0]
80002792:	71 b0       	ld.w	r0,r8[0x6c]
80002794:	80 00       	ld.sh	r0,r0[0x0]
80002796:	20 54       	sub	r4,5
80002798:	00 00       	add	r0,r0
8000279a:	02 d0       	st.w	--r1,r0
8000279c:	80 00       	ld.sh	r0,r0[0x0]
8000279e:	20 8c       	sub	r12,8
800027a0:	00 00       	add	r0,r0
800027a2:	02 d8       	st.w	--r1,r8
800027a4:	80 00       	ld.sh	r0,r0[0x0]
800027a6:	20 c4       	sub	r4,12
800027a8:	00 00       	add	r0,r0
800027aa:	02 c4       	st.b	r1++,r4

800027ac <OWWriteBit>:

//-----------------------------------------------------------------------------
// Send a 1-Wire write bit. Provide 10us recovery time.
//
void OWWriteBit(unsigned char idx, int bit)
{
800027ac:	eb cd 40 8f 	pushm	r0-r3,r7,lr
800027b0:	1a 97       	mov	r7,sp
800027b2:	fa cd 00 e8 	sub	sp,sp,232
800027b6:	18 98       	mov	r8,r12
800027b8:	ef 4b ff 48 	st.w	r7[-184],r11
800027bc:	ef 68 ff 4c 	st.b	r7[-180],r8
	if (bit)
800027c0:	ee f8 ff 48 	ld.w	r8,r7[-184]
800027c4:	58 08       	cp.w	r8,0
800027c6:	e0 80 01 71 	breq	80002aa8 <OWWriteBit+0x2fc>
	{
		// Write '1' bit
		drive_DQ_low(idx);
800027ca:	ef 38 ff 4c 	ld.ub	r8,r7[-180]
800027ce:	10 9c       	mov	r12,r8
800027d0:	f0 1f 01 65 	mcall	80002d64 <OWWriteBit+0x5b8>
		cpu_delay_us(A, 8000000);
800027d4:	fe f8 05 94 	ld.w	r8,pc[1428]
800027d8:	70 08       	ld.w	r8,r8[0x0]
800027da:	ef 48 ff 84 	st.w	r7[-124],r8
800027de:	e0 68 12 00 	mov	r8,4608
800027e2:	ea 18 00 7a 	orh	r8,0x7a
800027e6:	ef 48 ff 80 	st.w	r7[-128],r8
800027ea:	ee f8 ff 84 	ld.w	r8,r7[-124]
800027ee:	ef 48 ff 8c 	st.w	r7[-116],r8
800027f2:	ee f8 ff 80 	ld.w	r8,r7[-128]
800027f6:	ef 48 ff 88 	st.w	r7[-120],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_us_2_cy(unsigned long us, unsigned long fcpu_hz)
{
  return ((unsigned long long)us * fcpu_hz + 999999) / 1000000;
800027fa:	ee fc ff 8c 	ld.w	r12,r7[-116]
800027fe:	ef 4c ff 24 	st.w	r7[-220],r12
80002802:	30 0b       	mov	r11,0
80002804:	ef 4b ff 20 	st.w	r7[-224],r11
80002808:	ee f9 ff 88 	ld.w	r9,r7[-120]
8000280c:	ef 49 ff 1c 	st.w	r7[-228],r9
80002810:	30 08       	mov	r8,0
80002812:	ef 48 ff 18 	st.w	r7[-232],r8
80002816:	ee fa ff 20 	ld.w	r10,r7[-224]
8000281a:	ee fc ff 1c 	ld.w	r12,r7[-228]
8000281e:	b9 3a       	mul	r10,r12
80002820:	ee f8 ff 18 	ld.w	r8,r7[-232]
80002824:	ee fb ff 24 	ld.w	r11,r7[-220]
80002828:	b7 38       	mul	r8,r11
8000282a:	10 0a       	add	r10,r8
8000282c:	ee fc ff 24 	ld.w	r12,r7[-220]
80002830:	ee fb ff 1c 	ld.w	r11,r7[-228]
80002834:	f8 0b 06 48 	mulu.d	r8,r12,r11
80002838:	12 0a       	add	r10,r9
8000283a:	14 99       	mov	r9,r10
8000283c:	ee 7a 42 3f 	mov	r10,999999
80002840:	30 0b       	mov	r11,0
80002842:	f0 0a 00 0a 	add	r10,r8,r10
80002846:	f2 0b 00 4b 	adc	r11,r9,r11
8000284a:	ee 78 42 40 	mov	r8,1000000
8000284e:	30 09       	mov	r9,0
80002850:	f0 1f 01 47 	mcall	80002d6c <OWWriteBit+0x5c0>
80002854:	14 98       	mov	r8,r10
80002856:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_us(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_us_2_cy(delay, fcpu_hz), &timer);
80002858:	ef 48 ff 94 	st.w	r7[-108],r8
8000285c:	ee c8 00 b0 	sub	r8,r7,176
80002860:	ef 48 ff 90 	st.w	r7[-112],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002864:	e1 b8 00 42 	mfsr	r8,0x108
80002868:	10 99       	mov	r9,r8
8000286a:	ee f8 ff 90 	ld.w	r8,r7[-112]
8000286e:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002870:	ee f8 ff 90 	ld.w	r8,r7[-112]
80002874:	70 09       	ld.w	r9,r8[0x0]
80002876:	ee f8 ff 94 	ld.w	r8,r7[-108]
8000287a:	10 09       	add	r9,r8
8000287c:	ee f8 ff 90 	ld.w	r8,r7[-112]
80002880:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
80002882:	ee f9 ff 90 	ld.w	r9,r7[-112]
80002886:	30 08       	mov	r8,0
80002888:	f3 68 00 08 	st.b	r9[8],r8
8000288c:	ee c8 00 b0 	sub	r8,r7,176
80002890:	ef 48 ff 98 	st.w	r7[-104],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002894:	e1 b8 00 42 	mfsr	r8,0x108
80002898:	ef 48 ff 9c 	st.w	r7[-100],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
8000289c:	ee f8 ff 98 	ld.w	r8,r7[-104]
800028a0:	f1 39 00 08 	ld.ub	r9,r8[8]
800028a4:	30 28       	mov	r8,2
800028a6:	f0 09 18 00 	cp.b	r9,r8
800028aa:	c0 31       	brne	800028b0 <OWWriteBit+0x104>
    return false;
800028ac:	30 08       	mov	r8,0
800028ae:	c4 38       	rjmp	80002934 <OWWriteBit+0x188>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
800028b0:	ee f8 ff 98 	ld.w	r8,r7[-104]
800028b4:	f1 39 00 08 	ld.ub	r9,r8[8]
800028b8:	30 18       	mov	r8,1
800028ba:	f0 09 18 00 	cp.b	r9,r8
800028be:	c0 31       	brne	800028c4 <OWWriteBit+0x118>
    return true;
800028c0:	30 18       	mov	r8,1
800028c2:	c3 98       	rjmp	80002934 <OWWriteBit+0x188>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800028c4:	ee f8 ff 98 	ld.w	r8,r7[-104]
800028c8:	70 09       	ld.w	r9,r8[0x0]
800028ca:	ee f8 ff 98 	ld.w	r8,r7[-104]
800028ce:	70 18       	ld.w	r8,r8[0x4]
800028d0:	10 39       	cp.w	r9,r8
800028d2:	e0 88 00 1a 	brls	80002906 <OWWriteBit+0x15a>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800028d6:	ee f8 ff 98 	ld.w	r8,r7[-104]
800028da:	70 08       	ld.w	r8,r8[0x0]
800028dc:	ee f9 ff 9c 	ld.w	r9,r7[-100]
800028e0:	10 39       	cp.w	r9,r8
800028e2:	c1 02       	brcc	80002902 <OWWriteBit+0x156>
800028e4:	ee f8 ff 98 	ld.w	r8,r7[-104]
800028e8:	70 18       	ld.w	r8,r8[0x4]
800028ea:	ee f9 ff 9c 	ld.w	r9,r7[-100]
800028ee:	10 39       	cp.w	r9,r8
800028f0:	e0 88 00 09 	brls	80002902 <OWWriteBit+0x156>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
800028f4:	ee f9 ff 98 	ld.w	r9,r7[-104]
800028f8:	30 18       	mov	r8,1
800028fa:	f3 68 00 08 	st.b	r9[8],r8
      return true;
800028fe:	30 18       	mov	r8,1
80002900:	c1 a8       	rjmp	80002934 <OWWriteBit+0x188>
    }
    return false;
80002902:	30 08       	mov	r8,0
80002904:	c1 88       	rjmp	80002934 <OWWriteBit+0x188>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002906:	ee f8 ff 98 	ld.w	r8,r7[-104]
8000290a:	70 08       	ld.w	r8,r8[0x0]
8000290c:	ee f9 ff 9c 	ld.w	r9,r7[-100]
80002910:	10 39       	cp.w	r9,r8
80002912:	c0 93       	brcs	80002924 <OWWriteBit+0x178>
80002914:	ee f8 ff 98 	ld.w	r8,r7[-104]
80002918:	70 18       	ld.w	r8,r8[0x4]
8000291a:	ee f9 ff 9c 	ld.w	r9,r7[-100]
8000291e:	10 39       	cp.w	r9,r8
80002920:	e0 88 00 09 	brls	80002932 <OWWriteBit+0x186>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002924:	ee f9 ff 98 	ld.w	r9,r7[-104]
80002928:	30 18       	mov	r8,1
8000292a:	f3 68 00 08 	st.b	r9[8],r8
      return true;
8000292e:	30 18       	mov	r8,1
80002930:	c0 28       	rjmp	80002934 <OWWriteBit+0x188>
    }
    return false;
80002932:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_us(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_us_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
80002934:	58 08       	cp.w	r8,0
80002936:	ca b0       	breq	8000288c <OWWriteBit+0xe0>
		release_the_bus(idx);
80002938:	ef 38 ff 4c 	ld.ub	r8,r7[-180]
8000293c:	10 9c       	mov	r12,r8
8000293e:	f0 1f 01 0d 	mcall	80002d70 <OWWriteBit+0x5c4>
		cpu_delay_us(B, 8000000); // Complete the time slot and 10us recovery
80002942:	fe f8 04 32 	ld.w	r8,pc[1074]
80002946:	70 08       	ld.w	r8,r8[0x0]
80002948:	ef 48 ff a4 	st.w	r7[-92],r8
8000294c:	e0 68 12 00 	mov	r8,4608
80002950:	ea 18 00 7a 	orh	r8,0x7a
80002954:	ef 48 ff a0 	st.w	r7[-96],r8
80002958:	ee f8 ff a4 	ld.w	r8,r7[-92]
8000295c:	ef 48 ff ac 	st.w	r7[-84],r8
80002960:	ee f8 ff a0 	ld.w	r8,r7[-96]
80002964:	ef 48 ff a8 	st.w	r7[-88],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_us_2_cy(unsigned long us, unsigned long fcpu_hz)
{
  return ((unsigned long long)us * fcpu_hz + 999999) / 1000000;
80002968:	ee f9 ff ac 	ld.w	r9,r7[-84]
8000296c:	ef 49 ff 34 	st.w	r7[-204],r9
80002970:	30 08       	mov	r8,0
80002972:	ef 48 ff 30 	st.w	r7[-208],r8
80002976:	ee fc ff a8 	ld.w	r12,r7[-88]
8000297a:	ef 4c ff 2c 	st.w	r7[-212],r12
8000297e:	30 0b       	mov	r11,0
80002980:	ef 4b ff 28 	st.w	r7[-216],r11
80002984:	ee fa ff 30 	ld.w	r10,r7[-208]
80002988:	ee f9 ff 2c 	ld.w	r9,r7[-212]
8000298c:	b3 3a       	mul	r10,r9
8000298e:	ee f8 ff 28 	ld.w	r8,r7[-216]
80002992:	ee fc ff 34 	ld.w	r12,r7[-204]
80002996:	b9 38       	mul	r8,r12
80002998:	10 0a       	add	r10,r8
8000299a:	ee fb ff 34 	ld.w	r11,r7[-204]
8000299e:	ee fc ff 2c 	ld.w	r12,r7[-212]
800029a2:	f6 0c 06 48 	mulu.d	r8,r11,r12
800029a6:	12 0a       	add	r10,r9
800029a8:	14 99       	mov	r9,r10
800029aa:	ee 7a 42 3f 	mov	r10,999999
800029ae:	30 0b       	mov	r11,0
800029b0:	f0 0a 00 0a 	add	r10,r8,r10
800029b4:	f2 0b 00 4b 	adc	r11,r9,r11
800029b8:	ee 78 42 40 	mov	r8,1000000
800029bc:	30 09       	mov	r9,0
800029be:	f0 1f 00 ec 	mcall	80002d6c <OWWriteBit+0x5c0>
800029c2:	14 98       	mov	r8,r10
800029c4:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_us(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_us_2_cy(delay, fcpu_hz), &timer);
800029c6:	ef 48 ff b4 	st.w	r7[-76],r8
800029ca:	ee c8 00 a4 	sub	r8,r7,164
800029ce:	ef 48 ff b0 	st.w	r7[-80],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800029d2:	e1 b8 00 42 	mfsr	r8,0x108
800029d6:	10 99       	mov	r9,r8
800029d8:	ee f8 ff b0 	ld.w	r8,r7[-80]
800029dc:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800029de:	ee f8 ff b0 	ld.w	r8,r7[-80]
800029e2:	70 09       	ld.w	r9,r8[0x0]
800029e4:	ee f8 ff b4 	ld.w	r8,r7[-76]
800029e8:	10 09       	add	r9,r8
800029ea:	ee f8 ff b0 	ld.w	r8,r7[-80]
800029ee:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
800029f0:	ee f9 ff b0 	ld.w	r9,r7[-80]
800029f4:	30 08       	mov	r8,0
800029f6:	f3 68 00 08 	st.b	r9[8],r8
800029fa:	ee c8 00 a4 	sub	r8,r7,164
800029fe:	ef 48 ff b8 	st.w	r7[-72],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002a02:	e1 b8 00 42 	mfsr	r8,0x108
80002a06:	ef 48 ff bc 	st.w	r7[-68],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
80002a0a:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002a0e:	f1 39 00 08 	ld.ub	r9,r8[8]
80002a12:	30 28       	mov	r8,2
80002a14:	f0 09 18 00 	cp.b	r9,r8
80002a18:	c0 31       	brne	80002a1e <OWWriteBit+0x272>
    return false;
80002a1a:	30 08       	mov	r8,0
80002a1c:	c4 38       	rjmp	80002aa2 <OWWriteBit+0x2f6>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
80002a1e:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002a22:	f1 39 00 08 	ld.ub	r9,r8[8]
80002a26:	30 18       	mov	r8,1
80002a28:	f0 09 18 00 	cp.b	r9,r8
80002a2c:	c0 31       	brne	80002a32 <OWWriteBit+0x286>
    return true;
80002a2e:	30 18       	mov	r8,1
80002a30:	c3 98       	rjmp	80002aa2 <OWWriteBit+0x2f6>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002a32:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002a36:	70 09       	ld.w	r9,r8[0x0]
80002a38:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002a3c:	70 18       	ld.w	r8,r8[0x4]
80002a3e:	10 39       	cp.w	r9,r8
80002a40:	e0 88 00 1a 	brls	80002a74 <OWWriteBit+0x2c8>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002a44:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002a48:	70 08       	ld.w	r8,r8[0x0]
80002a4a:	ee f9 ff bc 	ld.w	r9,r7[-68]
80002a4e:	10 39       	cp.w	r9,r8
80002a50:	c1 02       	brcc	80002a70 <OWWriteBit+0x2c4>
80002a52:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002a56:	70 18       	ld.w	r8,r8[0x4]
80002a58:	ee f9 ff bc 	ld.w	r9,r7[-68]
80002a5c:	10 39       	cp.w	r9,r8
80002a5e:	e0 88 00 09 	brls	80002a70 <OWWriteBit+0x2c4>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002a62:	ee f9 ff b8 	ld.w	r9,r7[-72]
80002a66:	30 18       	mov	r8,1
80002a68:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002a6c:	30 18       	mov	r8,1
80002a6e:	c1 a8       	rjmp	80002aa2 <OWWriteBit+0x2f6>
    }
    return false;
80002a70:	30 08       	mov	r8,0
80002a72:	c1 88       	rjmp	80002aa2 <OWWriteBit+0x2f6>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002a74:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002a78:	70 08       	ld.w	r8,r8[0x0]
80002a7a:	ee f9 ff bc 	ld.w	r9,r7[-68]
80002a7e:	10 39       	cp.w	r9,r8
80002a80:	c0 93       	brcs	80002a92 <OWWriteBit+0x2e6>
80002a82:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002a86:	70 18       	ld.w	r8,r8[0x4]
80002a88:	ee f9 ff bc 	ld.w	r9,r7[-68]
80002a8c:	10 39       	cp.w	r9,r8
80002a8e:	e0 88 00 09 	brls	80002aa0 <OWWriteBit+0x2f4>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002a92:	ee f9 ff b8 	ld.w	r9,r7[-72]
80002a96:	30 18       	mov	r8,1
80002a98:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002a9c:	30 18       	mov	r8,1
80002a9e:	c0 28       	rjmp	80002aa2 <OWWriteBit+0x2f6>
    }
    return false;
80002aa0:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_us(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_us_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
80002aa2:	58 08       	cp.w	r8,0
80002aa4:	ca b0       	breq	800029fa <OWWriteBit+0x24e>
80002aa6:	c5 c9       	rjmp	80002d5e <OWWriteBit+0x5b2>
	}
	else
	{
		// Write '0' bit
		drive_DQ_low(idx);
80002aa8:	ef 38 ff 4c 	ld.ub	r8,r7[-180]
80002aac:	10 9c       	mov	r12,r8
80002aae:	f0 1f 00 ae 	mcall	80002d64 <OWWriteBit+0x5b8>
		cpu_delay_us(C, 8000000);
80002ab2:	fe f8 02 c6 	ld.w	r8,pc[710]
80002ab6:	70 08       	ld.w	r8,r8[0x0]
80002ab8:	ef 48 ff c4 	st.w	r7[-60],r8
80002abc:	e0 68 12 00 	mov	r8,4608
80002ac0:	ea 18 00 7a 	orh	r8,0x7a
80002ac4:	ef 48 ff c0 	st.w	r7[-64],r8
80002ac8:	ee f8 ff c4 	ld.w	r8,r7[-60]
80002acc:	ef 48 ff cc 	st.w	r7[-52],r8
80002ad0:	ee f8 ff c0 	ld.w	r8,r7[-64]
80002ad4:	ef 48 ff c8 	st.w	r7[-56],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_us_2_cy(unsigned long us, unsigned long fcpu_hz)
{
  return ((unsigned long long)us * fcpu_hz + 999999) / 1000000;
80002ad8:	ee fb ff cc 	ld.w	r11,r7[-52]
80002adc:	ef 4b ff 44 	st.w	r7[-188],r11
80002ae0:	30 09       	mov	r9,0
80002ae2:	ef 49 ff 40 	st.w	r7[-192],r9
80002ae6:	ee f8 ff c8 	ld.w	r8,r7[-56]
80002aea:	ef 48 ff 3c 	st.w	r7[-196],r8
80002aee:	30 0c       	mov	r12,0
80002af0:	ef 4c ff 38 	st.w	r7[-200],r12
80002af4:	ee fa ff 40 	ld.w	r10,r7[-192]
80002af8:	ee fb ff 3c 	ld.w	r11,r7[-196]
80002afc:	b7 3a       	mul	r10,r11
80002afe:	ee f8 ff 38 	ld.w	r8,r7[-200]
80002b02:	ee f9 ff 44 	ld.w	r9,r7[-188]
80002b06:	b3 38       	mul	r8,r9
80002b08:	10 0a       	add	r10,r8
80002b0a:	ee fc ff 44 	ld.w	r12,r7[-188]
80002b0e:	ee fb ff 3c 	ld.w	r11,r7[-196]
80002b12:	f8 0b 06 48 	mulu.d	r8,r12,r11
80002b16:	12 0a       	add	r10,r9
80002b18:	14 99       	mov	r9,r10
80002b1a:	ee 7a 42 3f 	mov	r10,999999
80002b1e:	30 0b       	mov	r11,0
80002b20:	f0 0a 00 0a 	add	r10,r8,r10
80002b24:	f2 0b 00 4b 	adc	r11,r9,r11
80002b28:	ee 78 42 40 	mov	r8,1000000
80002b2c:	30 09       	mov	r9,0
80002b2e:	f0 1f 00 90 	mcall	80002d6c <OWWriteBit+0x5c0>
80002b32:	14 98       	mov	r8,r10
80002b34:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_us(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_us_2_cy(delay, fcpu_hz), &timer);
80002b36:	ef 48 ff d4 	st.w	r7[-44],r8
80002b3a:	ee c8 00 98 	sub	r8,r7,152
80002b3e:	ef 48 ff d0 	st.w	r7[-48],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002b42:	e1 b8 00 42 	mfsr	r8,0x108
80002b46:	10 99       	mov	r9,r8
80002b48:	ee f8 ff d0 	ld.w	r8,r7[-48]
80002b4c:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002b4e:	ee f8 ff d0 	ld.w	r8,r7[-48]
80002b52:	70 09       	ld.w	r9,r8[0x0]
80002b54:	ee f8 ff d4 	ld.w	r8,r7[-44]
80002b58:	10 09       	add	r9,r8
80002b5a:	ee f8 ff d0 	ld.w	r8,r7[-48]
80002b5e:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
80002b60:	ee f9 ff d0 	ld.w	r9,r7[-48]
80002b64:	30 08       	mov	r8,0
80002b66:	f3 68 00 08 	st.b	r9[8],r8
80002b6a:	ee c8 00 98 	sub	r8,r7,152
80002b6e:	ef 48 ff d8 	st.w	r7[-40],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002b72:	e1 b8 00 42 	mfsr	r8,0x108
80002b76:	ef 48 ff dc 	st.w	r7[-36],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
80002b7a:	ee f8 ff d8 	ld.w	r8,r7[-40]
80002b7e:	f1 39 00 08 	ld.ub	r9,r8[8]
80002b82:	30 28       	mov	r8,2
80002b84:	f0 09 18 00 	cp.b	r9,r8
80002b88:	c0 31       	brne	80002b8e <OWWriteBit+0x3e2>
    return false;
80002b8a:	30 08       	mov	r8,0
80002b8c:	c4 38       	rjmp	80002c12 <OWWriteBit+0x466>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
80002b8e:	ee f8 ff d8 	ld.w	r8,r7[-40]
80002b92:	f1 39 00 08 	ld.ub	r9,r8[8]
80002b96:	30 18       	mov	r8,1
80002b98:	f0 09 18 00 	cp.b	r9,r8
80002b9c:	c0 31       	brne	80002ba2 <OWWriteBit+0x3f6>
    return true;
80002b9e:	30 18       	mov	r8,1
80002ba0:	c3 98       	rjmp	80002c12 <OWWriteBit+0x466>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002ba2:	ee f8 ff d8 	ld.w	r8,r7[-40]
80002ba6:	70 09       	ld.w	r9,r8[0x0]
80002ba8:	ee f8 ff d8 	ld.w	r8,r7[-40]
80002bac:	70 18       	ld.w	r8,r8[0x4]
80002bae:	10 39       	cp.w	r9,r8
80002bb0:	e0 88 00 1a 	brls	80002be4 <OWWriteBit+0x438>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002bb4:	ee f8 ff d8 	ld.w	r8,r7[-40]
80002bb8:	70 08       	ld.w	r8,r8[0x0]
80002bba:	ee f9 ff dc 	ld.w	r9,r7[-36]
80002bbe:	10 39       	cp.w	r9,r8
80002bc0:	c1 02       	brcc	80002be0 <OWWriteBit+0x434>
80002bc2:	ee f8 ff d8 	ld.w	r8,r7[-40]
80002bc6:	70 18       	ld.w	r8,r8[0x4]
80002bc8:	ee f9 ff dc 	ld.w	r9,r7[-36]
80002bcc:	10 39       	cp.w	r9,r8
80002bce:	e0 88 00 09 	brls	80002be0 <OWWriteBit+0x434>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002bd2:	ee f9 ff d8 	ld.w	r9,r7[-40]
80002bd6:	30 18       	mov	r8,1
80002bd8:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002bdc:	30 18       	mov	r8,1
80002bde:	c1 a8       	rjmp	80002c12 <OWWriteBit+0x466>
    }
    return false;
80002be0:	30 08       	mov	r8,0
80002be2:	c1 88       	rjmp	80002c12 <OWWriteBit+0x466>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002be4:	ee f8 ff d8 	ld.w	r8,r7[-40]
80002be8:	70 08       	ld.w	r8,r8[0x0]
80002bea:	ee f9 ff dc 	ld.w	r9,r7[-36]
80002bee:	10 39       	cp.w	r9,r8
80002bf0:	c0 93       	brcs	80002c02 <OWWriteBit+0x456>
80002bf2:	ee f8 ff d8 	ld.w	r8,r7[-40]
80002bf6:	70 18       	ld.w	r8,r8[0x4]
80002bf8:	ee f9 ff dc 	ld.w	r9,r7[-36]
80002bfc:	10 39       	cp.w	r9,r8
80002bfe:	e0 88 00 09 	brls	80002c10 <OWWriteBit+0x464>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002c02:	ee f9 ff d8 	ld.w	r9,r7[-40]
80002c06:	30 18       	mov	r8,1
80002c08:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002c0c:	30 18       	mov	r8,1
80002c0e:	c0 28       	rjmp	80002c12 <OWWriteBit+0x466>
    }
    return false;
80002c10:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_us(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_us_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
80002c12:	58 08       	cp.w	r8,0
80002c14:	ca b0       	breq	80002b6a <OWWriteBit+0x3be>
		release_the_bus(idx);
80002c16:	ef 38 ff 4c 	ld.ub	r8,r7[-180]
80002c1a:	10 9c       	mov	r12,r8
80002c1c:	f0 1f 00 55 	mcall	80002d70 <OWWriteBit+0x5c4>
		cpu_delay_us(D, 8000000);
80002c20:	4d 78       	lddpc	r8,80002d7c <OWWriteBit+0x5d0>
80002c22:	70 08       	ld.w	r8,r8[0x0]
80002c24:	ef 48 ff e4 	st.w	r7[-28],r8
80002c28:	e0 68 12 00 	mov	r8,4608
80002c2c:	ea 18 00 7a 	orh	r8,0x7a
80002c30:	ef 48 ff e0 	st.w	r7[-32],r8
80002c34:	ee f8 ff e4 	ld.w	r8,r7[-28]
80002c38:	ef 48 ff ec 	st.w	r7[-20],r8
80002c3c:	ee f8 ff e0 	ld.w	r8,r7[-32]
80002c40:	ef 48 ff e8 	st.w	r7[-24],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_us_2_cy(unsigned long us, unsigned long fcpu_hz)
{
  return ((unsigned long long)us * fcpu_hz + 999999) / 1000000;
80002c44:	ee f0 ff ec 	ld.w	r0,r7[-20]
80002c48:	30 01       	mov	r1,0
80002c4a:	ee f2 ff e8 	ld.w	r2,r7[-24]
80002c4e:	30 03       	mov	r3,0
80002c50:	e2 02 02 4a 	mul	r10,r1,r2
80002c54:	e6 00 02 48 	mul	r8,r3,r0
80002c58:	10 0a       	add	r10,r8
80002c5a:	e0 02 06 48 	mulu.d	r8,r0,r2
80002c5e:	12 0a       	add	r10,r9
80002c60:	14 99       	mov	r9,r10
80002c62:	ee 7a 42 3f 	mov	r10,999999
80002c66:	30 0b       	mov	r11,0
80002c68:	f0 0a 00 0a 	add	r10,r8,r10
80002c6c:	f2 0b 00 4b 	adc	r11,r9,r11
80002c70:	ee 78 42 40 	mov	r8,1000000
80002c74:	30 09       	mov	r9,0
80002c76:	f0 1f 00 3e 	mcall	80002d6c <OWWriteBit+0x5c0>
80002c7a:	14 98       	mov	r8,r10
80002c7c:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_us(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_us_2_cy(delay, fcpu_hz), &timer);
80002c7e:	ef 48 ff f4 	st.w	r7[-12],r8
80002c82:	ee c8 00 8c 	sub	r8,r7,140
80002c86:	ef 48 ff f0 	st.w	r7[-16],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002c8a:	e1 b8 00 42 	mfsr	r8,0x108
80002c8e:	10 99       	mov	r9,r8
80002c90:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002c94:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002c96:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002c9a:	70 09       	ld.w	r9,r8[0x0]
80002c9c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002ca0:	10 09       	add	r9,r8
80002ca2:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002ca6:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
80002ca8:	ee f9 ff f0 	ld.w	r9,r7[-16]
80002cac:	30 08       	mov	r8,0
80002cae:	f3 68 00 08 	st.b	r9[8],r8
80002cb2:	ee c8 00 8c 	sub	r8,r7,140
80002cb6:	ef 48 ff f8 	st.w	r7[-8],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002cba:	e1 b8 00 42 	mfsr	r8,0x108
80002cbe:	ef 48 ff fc 	st.w	r7[-4],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
80002cc2:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002cc6:	f1 39 00 08 	ld.ub	r9,r8[8]
80002cca:	30 28       	mov	r8,2
80002ccc:	f0 09 18 00 	cp.b	r9,r8
80002cd0:	c0 31       	brne	80002cd6 <OWWriteBit+0x52a>
    return false;
80002cd2:	30 08       	mov	r8,0
80002cd4:	c4 38       	rjmp	80002d5a <OWWriteBit+0x5ae>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
80002cd6:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002cda:	f1 39 00 08 	ld.ub	r9,r8[8]
80002cde:	30 18       	mov	r8,1
80002ce0:	f0 09 18 00 	cp.b	r9,r8
80002ce4:	c0 31       	brne	80002cea <OWWriteBit+0x53e>
    return true;
80002ce6:	30 18       	mov	r8,1
80002ce8:	c3 98       	rjmp	80002d5a <OWWriteBit+0x5ae>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002cea:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002cee:	70 09       	ld.w	r9,r8[0x0]
80002cf0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002cf4:	70 18       	ld.w	r8,r8[0x4]
80002cf6:	10 39       	cp.w	r9,r8
80002cf8:	e0 88 00 1a 	brls	80002d2c <OWWriteBit+0x580>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002cfc:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d00:	70 08       	ld.w	r8,r8[0x0]
80002d02:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002d06:	10 39       	cp.w	r9,r8
80002d08:	c1 02       	brcc	80002d28 <OWWriteBit+0x57c>
80002d0a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d0e:	70 18       	ld.w	r8,r8[0x4]
80002d10:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002d14:	10 39       	cp.w	r9,r8
80002d16:	e0 88 00 09 	brls	80002d28 <OWWriteBit+0x57c>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002d1a:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002d1e:	30 18       	mov	r8,1
80002d20:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002d24:	30 18       	mov	r8,1
80002d26:	c1 a8       	rjmp	80002d5a <OWWriteBit+0x5ae>
    }
    return false;
80002d28:	30 08       	mov	r8,0
80002d2a:	c1 88       	rjmp	80002d5a <OWWriteBit+0x5ae>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002d2c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d30:	70 08       	ld.w	r8,r8[0x0]
80002d32:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002d36:	10 39       	cp.w	r9,r8
80002d38:	c0 93       	brcs	80002d4a <OWWriteBit+0x59e>
80002d3a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d3e:	70 18       	ld.w	r8,r8[0x4]
80002d40:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002d44:	10 39       	cp.w	r9,r8
80002d46:	e0 88 00 09 	brls	80002d58 <OWWriteBit+0x5ac>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002d4a:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002d4e:	30 18       	mov	r8,1
80002d50:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002d54:	30 18       	mov	r8,1
80002d56:	c0 28       	rjmp	80002d5a <OWWriteBit+0x5ae>
    }
    return false;
80002d58:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_us(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_us_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
80002d5a:	58 08       	cp.w	r8,0
80002d5c:	ca b0       	breq	80002cb2 <OWWriteBit+0x506>
	}
}
80002d5e:	2c 6d       	sub	sp,-232
80002d60:	e3 cd 80 8f 	ldm	sp++,r0-r3,r7,pc
80002d64:	80 00       	ld.sh	r0,r0[0x0]
80002d66:	20 54       	sub	r4,5
80002d68:	00 00       	add	r0,r0
80002d6a:	02 bc       	st.h	r1++,r12
80002d6c:	80 00       	ld.sh	r0,r0[0x0]
80002d6e:	71 b0       	ld.w	r0,r8[0x6c]
80002d70:	80 00       	ld.sh	r0,r0[0x0]
80002d72:	20 8c       	sub	r12,8
80002d74:	00 00       	add	r0,r0
80002d76:	02 c0       	st.b	r1++,r0
80002d78:	00 00       	add	r0,r0
80002d7a:	02 c8       	st.b	r1++,r8
80002d7c:	00 00       	add	r0,r0
80002d7e:	02 b8       	st.h	r1++,r8

80002d80 <OWReadBit>:

//-----------------------------------------------------------------------------
// Read a bit from the 1-Wire bus and return it. Provide 10us recovery time.
//
int OWReadBit(unsigned char idx)
{
80002d80:	eb cd 40 8f 	pushm	r0-r3,r7,lr
80002d84:	1a 97       	mov	r7,sp
80002d86:	fa cd 00 ac 	sub	sp,sp,172
80002d8a:	18 98       	mov	r8,r12
80002d8c:	ef 68 ff 74 	st.b	r7[-140],r8
	int result;

	drive_DQ_low(idx);
80002d90:	ef 38 ff 74 	ld.ub	r8,r7[-140]
80002d94:	10 9c       	mov	r12,r8
80002d96:	f0 1f 01 0d 	mcall	800031c8 <OWReadBit+0x448>
	cpu_delay_us(A, 8000000);
80002d9a:	fe f8 04 32 	ld.w	r8,pc[1074]
80002d9e:	70 08       	ld.w	r8,r8[0x0]
80002da0:	ef 48 ff a4 	st.w	r7[-92],r8
80002da4:	e0 68 12 00 	mov	r8,4608
80002da8:	ea 18 00 7a 	orh	r8,0x7a
80002dac:	ef 48 ff a0 	st.w	r7[-96],r8
80002db0:	ee f8 ff a4 	ld.w	r8,r7[-92]
80002db4:	ef 48 ff ac 	st.w	r7[-84],r8
80002db8:	ee f8 ff a0 	ld.w	r8,r7[-96]
80002dbc:	ef 48 ff a8 	st.w	r7[-88],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_us_2_cy(unsigned long us, unsigned long fcpu_hz)
{
  return ((unsigned long long)us * fcpu_hz + 999999) / 1000000;
80002dc0:	ee fc ff ac 	ld.w	r12,r7[-84]
80002dc4:	ef 4c ff 60 	st.w	r7[-160],r12
80002dc8:	30 0b       	mov	r11,0
80002dca:	ef 4b ff 5c 	st.w	r7[-164],r11
80002dce:	ee f9 ff a8 	ld.w	r9,r7[-88]
80002dd2:	ef 49 ff 58 	st.w	r7[-168],r9
80002dd6:	30 08       	mov	r8,0
80002dd8:	ef 48 ff 54 	st.w	r7[-172],r8
80002ddc:	ee fa ff 5c 	ld.w	r10,r7[-164]
80002de0:	ee fc ff 58 	ld.w	r12,r7[-168]
80002de4:	b9 3a       	mul	r10,r12
80002de6:	ee f8 ff 54 	ld.w	r8,r7[-172]
80002dea:	ee fb ff 60 	ld.w	r11,r7[-160]
80002dee:	b7 38       	mul	r8,r11
80002df0:	10 0a       	add	r10,r8
80002df2:	ee fc ff 60 	ld.w	r12,r7[-160]
80002df6:	ee fb ff 58 	ld.w	r11,r7[-168]
80002dfa:	f8 0b 06 48 	mulu.d	r8,r12,r11
80002dfe:	12 0a       	add	r10,r9
80002e00:	14 99       	mov	r9,r10
80002e02:	ee 7a 42 3f 	mov	r10,999999
80002e06:	30 0b       	mov	r11,0
80002e08:	f0 0a 00 0a 	add	r10,r8,r10
80002e0c:	f2 0b 00 4b 	adc	r11,r9,r11
80002e10:	ee 78 42 40 	mov	r8,1000000
80002e14:	30 09       	mov	r9,0
80002e16:	f0 1f 00 ef 	mcall	800031d0 <OWReadBit+0x450>
80002e1a:	14 98       	mov	r8,r10
80002e1c:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_us(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_us_2_cy(delay, fcpu_hz), &timer);
80002e1e:	ef 48 ff b4 	st.w	r7[-76],r8
80002e22:	ee c8 00 88 	sub	r8,r7,136
80002e26:	ef 48 ff b0 	st.w	r7[-80],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002e2a:	e1 b8 00 42 	mfsr	r8,0x108
80002e2e:	10 99       	mov	r9,r8
80002e30:	ee f8 ff b0 	ld.w	r8,r7[-80]
80002e34:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002e36:	ee f8 ff b0 	ld.w	r8,r7[-80]
80002e3a:	70 09       	ld.w	r9,r8[0x0]
80002e3c:	ee f8 ff b4 	ld.w	r8,r7[-76]
80002e40:	10 09       	add	r9,r8
80002e42:	ee f8 ff b0 	ld.w	r8,r7[-80]
80002e46:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
80002e48:	ee f9 ff b0 	ld.w	r9,r7[-80]
80002e4c:	30 08       	mov	r8,0
80002e4e:	f3 68 00 08 	st.b	r9[8],r8
80002e52:	ee c8 00 88 	sub	r8,r7,136
80002e56:	ef 48 ff b8 	st.w	r7[-72],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002e5a:	e1 b8 00 42 	mfsr	r8,0x108
80002e5e:	ef 48 ff bc 	st.w	r7[-68],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
80002e62:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002e66:	f1 39 00 08 	ld.ub	r9,r8[8]
80002e6a:	30 28       	mov	r8,2
80002e6c:	f0 09 18 00 	cp.b	r9,r8
80002e70:	c0 31       	brne	80002e76 <OWReadBit+0xf6>
    return false;
80002e72:	30 08       	mov	r8,0
80002e74:	c4 38       	rjmp	80002efa <OWReadBit+0x17a>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
80002e76:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002e7a:	f1 39 00 08 	ld.ub	r9,r8[8]
80002e7e:	30 18       	mov	r8,1
80002e80:	f0 09 18 00 	cp.b	r9,r8
80002e84:	c0 31       	brne	80002e8a <OWReadBit+0x10a>
    return true;
80002e86:	30 18       	mov	r8,1
80002e88:	c3 98       	rjmp	80002efa <OWReadBit+0x17a>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002e8a:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002e8e:	70 09       	ld.w	r9,r8[0x0]
80002e90:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002e94:	70 18       	ld.w	r8,r8[0x4]
80002e96:	10 39       	cp.w	r9,r8
80002e98:	e0 88 00 1a 	brls	80002ecc <OWReadBit+0x14c>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002e9c:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002ea0:	70 08       	ld.w	r8,r8[0x0]
80002ea2:	ee f9 ff bc 	ld.w	r9,r7[-68]
80002ea6:	10 39       	cp.w	r9,r8
80002ea8:	c1 02       	brcc	80002ec8 <OWReadBit+0x148>
80002eaa:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002eae:	70 18       	ld.w	r8,r8[0x4]
80002eb0:	ee f9 ff bc 	ld.w	r9,r7[-68]
80002eb4:	10 39       	cp.w	r9,r8
80002eb6:	e0 88 00 09 	brls	80002ec8 <OWReadBit+0x148>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002eba:	ee f9 ff b8 	ld.w	r9,r7[-72]
80002ebe:	30 18       	mov	r8,1
80002ec0:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002ec4:	30 18       	mov	r8,1
80002ec6:	c1 a8       	rjmp	80002efa <OWReadBit+0x17a>
    }
    return false;
80002ec8:	30 08       	mov	r8,0
80002eca:	c1 88       	rjmp	80002efa <OWReadBit+0x17a>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002ecc:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002ed0:	70 08       	ld.w	r8,r8[0x0]
80002ed2:	ee f9 ff bc 	ld.w	r9,r7[-68]
80002ed6:	10 39       	cp.w	r9,r8
80002ed8:	c0 93       	brcs	80002eea <OWReadBit+0x16a>
80002eda:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002ede:	70 18       	ld.w	r8,r8[0x4]
80002ee0:	ee f9 ff bc 	ld.w	r9,r7[-68]
80002ee4:	10 39       	cp.w	r9,r8
80002ee6:	e0 88 00 09 	brls	80002ef8 <OWReadBit+0x178>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002eea:	ee f9 ff b8 	ld.w	r9,r7[-72]
80002eee:	30 18       	mov	r8,1
80002ef0:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002ef4:	30 18       	mov	r8,1
80002ef6:	c0 28       	rjmp	80002efa <OWReadBit+0x17a>
    }
    return false;
80002ef8:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_us(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_us_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
80002efa:	58 08       	cp.w	r8,0
80002efc:	ca b0       	breq	80002e52 <OWReadBit+0xd2>
	release_the_bus(idx);
80002efe:	ef 38 ff 74 	ld.ub	r8,r7[-140]
80002f02:	10 9c       	mov	r12,r8
80002f04:	f0 1f 00 b4 	mcall	800031d4 <OWReadBit+0x454>
	cpu_delay_us(E, 8000000);
80002f08:	fe f8 02 d0 	ld.w	r8,pc[720]
80002f0c:	70 08       	ld.w	r8,r8[0x0]
80002f0e:	ef 48 ff c4 	st.w	r7[-60],r8
80002f12:	e0 68 12 00 	mov	r8,4608
80002f16:	ea 18 00 7a 	orh	r8,0x7a
80002f1a:	ef 48 ff c0 	st.w	r7[-64],r8
80002f1e:	ee f8 ff c4 	ld.w	r8,r7[-60]
80002f22:	ef 48 ff cc 	st.w	r7[-52],r8
80002f26:	ee f8 ff c0 	ld.w	r8,r7[-64]
80002f2a:	ef 48 ff c8 	st.w	r7[-56],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_us_2_cy(unsigned long us, unsigned long fcpu_hz)
{
  return ((unsigned long long)us * fcpu_hz + 999999) / 1000000;
80002f2e:	ee f9 ff cc 	ld.w	r9,r7[-52]
80002f32:	ef 49 ff 70 	st.w	r7[-144],r9
80002f36:	30 08       	mov	r8,0
80002f38:	ef 48 ff 6c 	st.w	r7[-148],r8
80002f3c:	ee fc ff c8 	ld.w	r12,r7[-56]
80002f40:	ef 4c ff 68 	st.w	r7[-152],r12
80002f44:	30 0b       	mov	r11,0
80002f46:	ef 4b ff 64 	st.w	r7[-156],r11
80002f4a:	ee fa ff 6c 	ld.w	r10,r7[-148]
80002f4e:	ee f9 ff 68 	ld.w	r9,r7[-152]
80002f52:	b3 3a       	mul	r10,r9
80002f54:	ee f8 ff 64 	ld.w	r8,r7[-156]
80002f58:	ee fc ff 70 	ld.w	r12,r7[-144]
80002f5c:	b9 38       	mul	r8,r12
80002f5e:	10 0a       	add	r10,r8
80002f60:	ee fb ff 70 	ld.w	r11,r7[-144]
80002f64:	ee fc ff 68 	ld.w	r12,r7[-152]
80002f68:	f6 0c 06 48 	mulu.d	r8,r11,r12
80002f6c:	12 0a       	add	r10,r9
80002f6e:	14 99       	mov	r9,r10
80002f70:	ee 7a 42 3f 	mov	r10,999999
80002f74:	30 0b       	mov	r11,0
80002f76:	f0 0a 00 0a 	add	r10,r8,r10
80002f7a:	f2 0b 00 4b 	adc	r11,r9,r11
80002f7e:	ee 78 42 40 	mov	r8,1000000
80002f82:	30 09       	mov	r9,0
80002f84:	f0 1f 00 93 	mcall	800031d0 <OWReadBit+0x450>
80002f88:	14 98       	mov	r8,r10
80002f8a:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_us(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_us_2_cy(delay, fcpu_hz), &timer);
80002f8c:	ef 48 ff d4 	st.w	r7[-44],r8
80002f90:	ee c8 00 7c 	sub	r8,r7,124
80002f94:	ef 48 ff d0 	st.w	r7[-48],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002f98:	e1 b8 00 42 	mfsr	r8,0x108
80002f9c:	10 99       	mov	r9,r8
80002f9e:	ee f8 ff d0 	ld.w	r8,r7[-48]
80002fa2:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002fa4:	ee f8 ff d0 	ld.w	r8,r7[-48]
80002fa8:	70 09       	ld.w	r9,r8[0x0]
80002faa:	ee f8 ff d4 	ld.w	r8,r7[-44]
80002fae:	10 09       	add	r9,r8
80002fb0:	ee f8 ff d0 	ld.w	r8,r7[-48]
80002fb4:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
80002fb6:	ee f9 ff d0 	ld.w	r9,r7[-48]
80002fba:	30 08       	mov	r8,0
80002fbc:	f3 68 00 08 	st.b	r9[8],r8
80002fc0:	ee c8 00 7c 	sub	r8,r7,124
80002fc4:	ef 48 ff d8 	st.w	r7[-40],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002fc8:	e1 b8 00 42 	mfsr	r8,0x108
80002fcc:	ef 48 ff dc 	st.w	r7[-36],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
80002fd0:	ee f8 ff d8 	ld.w	r8,r7[-40]
80002fd4:	f1 39 00 08 	ld.ub	r9,r8[8]
80002fd8:	30 28       	mov	r8,2
80002fda:	f0 09 18 00 	cp.b	r9,r8
80002fde:	c0 31       	brne	80002fe4 <OWReadBit+0x264>
    return false;
80002fe0:	30 08       	mov	r8,0
80002fe2:	c4 38       	rjmp	80003068 <OWReadBit+0x2e8>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
80002fe4:	ee f8 ff d8 	ld.w	r8,r7[-40]
80002fe8:	f1 39 00 08 	ld.ub	r9,r8[8]
80002fec:	30 18       	mov	r8,1
80002fee:	f0 09 18 00 	cp.b	r9,r8
80002ff2:	c0 31       	brne	80002ff8 <OWReadBit+0x278>
    return true;
80002ff4:	30 18       	mov	r8,1
80002ff6:	c3 98       	rjmp	80003068 <OWReadBit+0x2e8>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002ff8:	ee f8 ff d8 	ld.w	r8,r7[-40]
80002ffc:	70 09       	ld.w	r9,r8[0x0]
80002ffe:	ee f8 ff d8 	ld.w	r8,r7[-40]
80003002:	70 18       	ld.w	r8,r8[0x4]
80003004:	10 39       	cp.w	r9,r8
80003006:	e0 88 00 1a 	brls	8000303a <OWReadBit+0x2ba>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000300a:	ee f8 ff d8 	ld.w	r8,r7[-40]
8000300e:	70 08       	ld.w	r8,r8[0x0]
80003010:	ee f9 ff dc 	ld.w	r9,r7[-36]
80003014:	10 39       	cp.w	r9,r8
80003016:	c1 02       	brcc	80003036 <OWReadBit+0x2b6>
80003018:	ee f8 ff d8 	ld.w	r8,r7[-40]
8000301c:	70 18       	ld.w	r8,r8[0x4]
8000301e:	ee f9 ff dc 	ld.w	r9,r7[-36]
80003022:	10 39       	cp.w	r9,r8
80003024:	e0 88 00 09 	brls	80003036 <OWReadBit+0x2b6>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80003028:	ee f9 ff d8 	ld.w	r9,r7[-40]
8000302c:	30 18       	mov	r8,1
8000302e:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80003032:	30 18       	mov	r8,1
80003034:	c1 a8       	rjmp	80003068 <OWReadBit+0x2e8>
    }
    return false;
80003036:	30 08       	mov	r8,0
80003038:	c1 88       	rjmp	80003068 <OWReadBit+0x2e8>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000303a:	ee f8 ff d8 	ld.w	r8,r7[-40]
8000303e:	70 08       	ld.w	r8,r8[0x0]
80003040:	ee f9 ff dc 	ld.w	r9,r7[-36]
80003044:	10 39       	cp.w	r9,r8
80003046:	c0 93       	brcs	80003058 <OWReadBit+0x2d8>
80003048:	ee f8 ff d8 	ld.w	r8,r7[-40]
8000304c:	70 18       	ld.w	r8,r8[0x4]
8000304e:	ee f9 ff dc 	ld.w	r9,r7[-36]
80003052:	10 39       	cp.w	r9,r8
80003054:	e0 88 00 09 	brls	80003066 <OWReadBit+0x2e6>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80003058:	ee f9 ff d8 	ld.w	r9,r7[-40]
8000305c:	30 18       	mov	r8,1
8000305e:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80003062:	30 18       	mov	r8,1
80003064:	c0 28       	rjmp	80003068 <OWReadBit+0x2e8>
    }
    return false;
80003066:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_us(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_us_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
80003068:	58 08       	cp.w	r8,0
8000306a:	ca b0       	breq	80002fc0 <OWReadBit+0x240>
	result = sample_line(idx);
8000306c:	ef 38 ff 74 	ld.ub	r8,r7[-140]
80003070:	10 9c       	mov	r12,r8
80003072:	f0 1f 00 5b 	mcall	800031dc <OWReadBit+0x45c>
80003076:	18 98       	mov	r8,r12
80003078:	ef 48 ff 9c 	st.w	r7[-100],r8
	cpu_delay_us(F, 8000000); // Complete the time slot and 10us recovery
8000307c:	4d 98       	lddpc	r8,800031e0 <OWReadBit+0x460>
8000307e:	70 08       	ld.w	r8,r8[0x0]
80003080:	ef 48 ff e4 	st.w	r7[-28],r8
80003084:	e0 68 12 00 	mov	r8,4608
80003088:	ea 18 00 7a 	orh	r8,0x7a
8000308c:	ef 48 ff e0 	st.w	r7[-32],r8
80003090:	ee f8 ff e4 	ld.w	r8,r7[-28]
80003094:	ef 48 ff ec 	st.w	r7[-20],r8
80003098:	ee f8 ff e0 	ld.w	r8,r7[-32]
8000309c:	ef 48 ff e8 	st.w	r7[-24],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_us_2_cy(unsigned long us, unsigned long fcpu_hz)
{
  return ((unsigned long long)us * fcpu_hz + 999999) / 1000000;
800030a0:	ee f0 ff ec 	ld.w	r0,r7[-20]
800030a4:	30 01       	mov	r1,0
800030a6:	ee f2 ff e8 	ld.w	r2,r7[-24]
800030aa:	30 03       	mov	r3,0
800030ac:	e2 02 02 4a 	mul	r10,r1,r2
800030b0:	e6 00 02 48 	mul	r8,r3,r0
800030b4:	10 0a       	add	r10,r8
800030b6:	e0 02 06 48 	mulu.d	r8,r0,r2
800030ba:	12 0a       	add	r10,r9
800030bc:	14 99       	mov	r9,r10
800030be:	ee 7a 42 3f 	mov	r10,999999
800030c2:	30 0b       	mov	r11,0
800030c4:	f0 0a 00 0a 	add	r10,r8,r10
800030c8:	f2 0b 00 4b 	adc	r11,r9,r11
800030cc:	ee 78 42 40 	mov	r8,1000000
800030d0:	30 09       	mov	r9,0
800030d2:	f0 1f 00 40 	mcall	800031d0 <OWReadBit+0x450>
800030d6:	14 98       	mov	r8,r10
800030d8:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_us(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_us_2_cy(delay, fcpu_hz), &timer);
800030da:	ef 48 ff f4 	st.w	r7[-12],r8
800030de:	ee c8 00 70 	sub	r8,r7,112
800030e2:	ef 48 ff f0 	st.w	r7[-16],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800030e6:	e1 b8 00 42 	mfsr	r8,0x108
800030ea:	10 99       	mov	r9,r8
800030ec:	ee f8 ff f0 	ld.w	r8,r7[-16]
800030f0:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800030f2:	ee f8 ff f0 	ld.w	r8,r7[-16]
800030f6:	70 09       	ld.w	r9,r8[0x0]
800030f8:	ee f8 ff f4 	ld.w	r8,r7[-12]
800030fc:	10 09       	add	r9,r8
800030fe:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003102:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
80003104:	ee f9 ff f0 	ld.w	r9,r7[-16]
80003108:	30 08       	mov	r8,0
8000310a:	f3 68 00 08 	st.b	r9[8],r8
8000310e:	ee c8 00 70 	sub	r8,r7,112
80003112:	ef 48 ff f8 	st.w	r7[-8],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80003116:	e1 b8 00 42 	mfsr	r8,0x108
8000311a:	ef 48 ff fc 	st.w	r7[-4],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
8000311e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003122:	f1 39 00 08 	ld.ub	r9,r8[8]
80003126:	30 28       	mov	r8,2
80003128:	f0 09 18 00 	cp.b	r9,r8
8000312c:	c0 31       	brne	80003132 <OWReadBit+0x3b2>
    return false;
8000312e:	30 08       	mov	r8,0
80003130:	c4 38       	rjmp	800031b6 <OWReadBit+0x436>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
80003132:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003136:	f1 39 00 08 	ld.ub	r9,r8[8]
8000313a:	30 18       	mov	r8,1
8000313c:	f0 09 18 00 	cp.b	r9,r8
80003140:	c0 31       	brne	80003146 <OWReadBit+0x3c6>
    return true;
80003142:	30 18       	mov	r8,1
80003144:	c3 98       	rjmp	800031b6 <OWReadBit+0x436>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80003146:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000314a:	70 09       	ld.w	r9,r8[0x0]
8000314c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003150:	70 18       	ld.w	r8,r8[0x4]
80003152:	10 39       	cp.w	r9,r8
80003154:	e0 88 00 1a 	brls	80003188 <OWReadBit+0x408>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80003158:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000315c:	70 08       	ld.w	r8,r8[0x0]
8000315e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003162:	10 39       	cp.w	r9,r8
80003164:	c1 02       	brcc	80003184 <OWReadBit+0x404>
80003166:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000316a:	70 18       	ld.w	r8,r8[0x4]
8000316c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003170:	10 39       	cp.w	r9,r8
80003172:	e0 88 00 09 	brls	80003184 <OWReadBit+0x404>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80003176:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000317a:	30 18       	mov	r8,1
8000317c:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80003180:	30 18       	mov	r8,1
80003182:	c1 a8       	rjmp	800031b6 <OWReadBit+0x436>
    }
    return false;
80003184:	30 08       	mov	r8,0
80003186:	c1 88       	rjmp	800031b6 <OWReadBit+0x436>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80003188:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000318c:	70 08       	ld.w	r8,r8[0x0]
8000318e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003192:	10 39       	cp.w	r9,r8
80003194:	c0 93       	brcs	800031a6 <OWReadBit+0x426>
80003196:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000319a:	70 18       	ld.w	r8,r8[0x4]
8000319c:	ee f9 ff fc 	ld.w	r9,r7[-4]
800031a0:	10 39       	cp.w	r9,r8
800031a2:	e0 88 00 09 	brls	800031b4 <OWReadBit+0x434>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
800031a6:	ee f9 ff f8 	ld.w	r9,r7[-8]
800031aa:	30 18       	mov	r8,1
800031ac:	f3 68 00 08 	st.b	r9[8],r8
      return true;
800031b0:	30 18       	mov	r8,1
800031b2:	c0 28       	rjmp	800031b6 <OWReadBit+0x436>
    }
    return false;
800031b4:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_us(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_us_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
800031b6:	58 08       	cp.w	r8,0
800031b8:	ca b0       	breq	8000310e <OWReadBit+0x38e>

	return result;
800031ba:	ee f8 ff 9c 	ld.w	r8,r7[-100]
}
800031be:	10 9c       	mov	r12,r8
800031c0:	2d 5d       	sub	sp,-172
800031c2:	e3 cd 80 8f 	ldm	sp++,r0-r3,r7,pc
800031c6:	00 00       	add	r0,r0
800031c8:	80 00       	ld.sh	r0,r0[0x0]
800031ca:	20 54       	sub	r4,5
800031cc:	00 00       	add	r0,r0
800031ce:	02 bc       	st.h	r1++,r12
800031d0:	80 00       	ld.sh	r0,r0[0x0]
800031d2:	71 b0       	ld.w	r0,r8[0x6c]
800031d4:	80 00       	ld.sh	r0,r0[0x0]
800031d6:	20 8c       	sub	r12,8
800031d8:	00 00       	add	r0,r0
800031da:	02 d4       	st.w	--r1,r4
800031dc:	80 00       	ld.sh	r0,r0[0x0]
800031de:	20 c4       	sub	r4,12
800031e0:	00 00       	add	r0,r0
800031e2:	02 dc       	st.w	--r1,r12

800031e4 <OWWriteByte>:

//-----------------------------------------------------------------------------
// Write 1-Wire data byte
//
void OWWriteByte(unsigned char idx, int data)
{
800031e4:	eb cd 40 80 	pushm	r7,lr
800031e8:	1a 97       	mov	r7,sp
800031ea:	20 3d       	sub	sp,12
800031ec:	18 98       	mov	r8,r12
800031ee:	ef 4b ff f4 	st.w	r7[-12],r11
800031f2:	ef 68 ff f8 	st.b	r7[-8],r8
	int loop;

	// Loop to write each bit in the byte, LS-bit first
	for (loop = 0; loop < 8; loop++)
800031f6:	30 08       	mov	r8,0
800031f8:	ef 48 ff fc 	st.w	r7[-4],r8
800031fc:	c1 58       	rjmp	80003226 <OWWriteByte+0x42>
	{
		OWWriteBit(idx, data & 0x01);
800031fe:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003202:	f3 d8 c0 01 	bfextu	r9,r8,0x0,0x1
80003206:	ef 38 ff f8 	ld.ub	r8,r7[-8]
8000320a:	12 9b       	mov	r11,r9
8000320c:	10 9c       	mov	r12,r8
8000320e:	f0 1f 00 0b 	mcall	80003238 <OWWriteByte+0x54>

		// shift the data byte for the next bit
		data >>= 1;
80003212:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003216:	a1 58       	asr	r8,0x1
80003218:	ef 48 ff f4 	st.w	r7[-12],r8
void OWWriteByte(unsigned char idx, int data)
{
	int loop;

	// Loop to write each bit in the byte, LS-bit first
	for (loop = 0; loop < 8; loop++)
8000321c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003220:	2f f8       	sub	r8,-1
80003222:	ef 48 ff fc 	st.w	r7[-4],r8
80003226:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000322a:	58 78       	cp.w	r8,7
8000322c:	fe 9a ff e9 	brle	800031fe <OWWriteByte+0x1a>
		OWWriteBit(idx, data & 0x01);

		// shift the data byte for the next bit
		data >>= 1;
	}
}
80003230:	2f dd       	sub	sp,-12
80003232:	e3 cd 80 80 	ldm	sp++,r7,pc
80003236:	00 00       	add	r0,r0
80003238:	80 00       	ld.sh	r0,r0[0x0]
8000323a:	27 ac       	sub	r12,122

8000323c <OWReadByte>:

//-----------------------------------------------------------------------------
// Read 1-Wire data byte and return it
//
int OWReadByte(unsigned char idx)
{
8000323c:	eb cd 40 80 	pushm	r7,lr
80003240:	1a 97       	mov	r7,sp
80003242:	20 3d       	sub	sp,12
80003244:	18 98       	mov	r8,r12
80003246:	ef 68 ff f4 	st.b	r7[-12],r8
	int loop, result=0;
8000324a:	30 08       	mov	r8,0
8000324c:	ef 48 ff fc 	st.w	r7[-4],r8

	for (loop = 0; loop < 8; loop++)
80003250:	30 08       	mov	r8,0
80003252:	ef 48 ff f8 	st.w	r7[-8],r8
80003256:	c1 88       	rjmp	80003286 <OWReadByte+0x4a>
	{
		// shift the result to get it ready for the next bit
		result >>= 1;
80003258:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000325c:	a1 58       	asr	r8,0x1
8000325e:	ef 48 ff fc 	st.w	r7[-4],r8

		// if result is one, then set MS bit
		if (OWReadBit(idx))
80003262:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80003266:	10 9c       	mov	r12,r8
80003268:	f0 1f 00 0d 	mcall	8000329c <OWReadByte+0x60>
8000326c:	18 98       	mov	r8,r12
8000326e:	58 08       	cp.w	r8,0
80003270:	c0 60       	breq	8000327c <OWReadByte+0x40>
		result |= 0x80;
80003272:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003276:	a7 b8       	sbr	r8,0x7
80003278:	ef 48 ff fc 	st.w	r7[-4],r8
//
int OWReadByte(unsigned char idx)
{
	int loop, result=0;

	for (loop = 0; loop < 8; loop++)
8000327c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003280:	2f f8       	sub	r8,-1
80003282:	ef 48 ff f8 	st.w	r7[-8],r8
80003286:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000328a:	58 78       	cp.w	r8,7
8000328c:	fe 9a ff e6 	brle	80003258 <OWReadByte+0x1c>

		// if result is one, then set MS bit
		if (OWReadBit(idx))
		result |= 0x80;
	}
	return result;
80003290:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80003294:	10 9c       	mov	r12,r8
80003296:	2f dd       	sub	sp,-12
80003298:	e3 cd 80 80 	ldm	sp++,r7,pc
8000329c:	80 00       	ld.sh	r0,r0[0x0]
8000329e:	2d 80       	sub	r0,-40

800032a0 <init_ssdbg_rs232>:
//! ASCII representation of hexadecimal digits.
static const char HEX_DIGITS[16] = "0123456789ABCDEF";


void init_ssdbg_rs232(long pba_hz)
{
800032a0:	eb cd 40 80 	pushm	r7,lr
800032a4:	1a 97       	mov	r7,sp
800032a6:	20 1d       	sub	sp,4
800032a8:	ef 4c ff fc 	st.w	r7[-4],r12
  init_ssdbg_rs232_ex(SSDBG_USART_BAUDRATE, pba_hz);
800032ac:	ee fb ff fc 	ld.w	r11,r7[-4]
800032b0:	e0 7c c2 00 	mov	r12,115200
800032b4:	f0 1f 00 03 	mcall	800032c0 <init_ssdbg_rs232+0x20>
}
800032b8:	2f fd       	sub	sp,-4
800032ba:	e3 cd 80 80 	ldm	sp++,r7,pc
800032be:	00 00       	add	r0,r0
800032c0:	80 00       	ld.sh	r0,r0[0x0]
800032c2:	32 e8       	mov	r8,46

800032c4 <init_display_rs232>:

void init_display_rs232(long pba_hz)
{
800032c4:	eb cd 40 80 	pushm	r7,lr
800032c8:	1a 97       	mov	r7,sp
800032ca:	20 1d       	sub	sp,4
800032cc:	ef 4c ff fc 	st.w	r7[-4],r12
	init_display_rs232_ex(DISPLAY_USART_BAUDRATE, pba_hz);
800032d0:	ee fb ff fc 	ld.w	r11,r7[-4]
800032d4:	e0 6c 12 c0 	mov	r12,4800
800032d8:	f0 1f 00 03 	mcall	800032e4 <init_display_rs232+0x20>
}
800032dc:	2f fd       	sub	sp,-4
800032de:	e3 cd 80 80 	ldm	sp++,r7,pc
800032e2:	00 00       	add	r0,r0
800032e4:	80 00       	ld.sh	r0,r0[0x0]
800032e6:	33 44       	mov	r4,52

800032e8 <init_ssdbg_rs232_ex>:


void init_ssdbg_rs232_ex(unsigned long baudrate, long pba_hz)
{
800032e8:	eb cd 40 80 	pushm	r7,lr
800032ec:	1a 97       	mov	r7,sp
800032ee:	20 5d       	sub	sp,20
800032f0:	ef 4c ff f0 	st.w	r7[-16],r12
800032f4:	ef 4b ff ec 	st.w	r7[-20],r11
    .baudrate = baudrate,
    .charlength = 8,
    .paritytype = USART_NO_PARITY,
    .stopbits = USART_1_STOPBIT,
    .channelmode = USART_NORMAL_CHMODE
  };
800032f8:	ee f8 ff f0 	ld.w	r8,r7[-16]
800032fc:	ef 48 ff f4 	st.w	r7[-12],r8
80003300:	30 88       	mov	r8,8
80003302:	ef 68 ff f8 	st.b	r7[-8],r8
80003306:	30 48       	mov	r8,4
80003308:	ef 68 ff f9 	st.b	r7[-7],r8
8000330c:	30 08       	mov	r8,0
8000330e:	ef 58 ff fa 	st.h	r7[-6],r8
80003312:	30 08       	mov	r8,0
80003314:	ef 68 ff fc 	st.b	r7[-4],r8

  // Setup GPIO for debug USART.
  gpio_enable_module(SSDBG_USART_GPIO_MAP,
80003318:	30 2b       	mov	r11,2
8000331a:	48 8c       	lddpc	r12,80003338 <init_ssdbg_rs232_ex+0x50>
8000331c:	f0 1f 00 08 	mcall	8000333c <init_ssdbg_rs232_ex+0x54>
                     sizeof(SSDBG_USART_GPIO_MAP) / sizeof(SSDBG_USART_GPIO_MAP[0]));

  // Initialize it in RS232 mode.
  usart_init_rs232(SSDBG_USART, &ssdbg_usart_options, pba_hz);
80003320:	ee c8 00 0c 	sub	r8,r7,12
80003324:	ee fa ff ec 	ld.w	r10,r7[-20]
80003328:	10 9b       	mov	r11,r8
8000332a:	fe 7c 28 00 	mov	r12,-55296
8000332e:	f0 1f 00 05 	mcall	80003340 <init_ssdbg_rs232_ex+0x58>
}
80003332:	2f bd       	sub	sp,-20
80003334:	e3 cd 80 80 	ldm	sp++,r7,pc
80003338:	80 00       	ld.sh	r0,r0[0x0]
8000333a:	78 10       	ld.w	r0,r12[0x4]
8000333c:	80 00       	ld.sh	r0,r0[0x0]
8000333e:	3c 58       	mov	r8,-59
80003340:	80 00       	ld.sh	r0,r0[0x0]
80003342:	4f 7c       	lddpc	r12,8000351c <adcifa_configure+0x9c>

80003344 <init_display_rs232_ex>:

void init_display_rs232_ex(unsigned long baudrate, long pba_hz)
{
80003344:	eb cd 40 80 	pushm	r7,lr
80003348:	1a 97       	mov	r7,sp
8000334a:	20 5d       	sub	sp,20
8000334c:	ef 4c ff f0 	st.w	r7[-16],r12
80003350:	ef 4b ff ec 	st.w	r7[-20],r11
		.baudrate = baudrate,
		.charlength = 8,
		.paritytype = USART_NO_PARITY,
		.stopbits = USART_1_STOPBIT,
		.channelmode = USART_NORMAL_CHMODE
	};
80003354:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003358:	ef 48 ff f4 	st.w	r7[-12],r8
8000335c:	30 88       	mov	r8,8
8000335e:	ef 68 ff f8 	st.b	r7[-8],r8
80003362:	30 48       	mov	r8,4
80003364:	ef 68 ff f9 	st.b	r7[-7],r8
80003368:	30 08       	mov	r8,0
8000336a:	ef 58 ff fa 	st.h	r7[-6],r8
8000336e:	30 08       	mov	r8,0
80003370:	ef 68 ff fc 	st.b	r7[-4],r8

	// Setup GPIO for debug USART.
	gpio_enable_module(DISPLAY_USART_GPIO_MAP,
80003374:	30 2b       	mov	r11,2
80003376:	48 8c       	lddpc	r12,80003394 <init_display_rs232_ex+0x50>
80003378:	f0 1f 00 08 	mcall	80003398 <init_display_rs232_ex+0x54>
	sizeof(DISPLAY_USART_GPIO_MAP) / sizeof(DISPLAY_USART_GPIO_MAP[0]));

	// Initialize it in RS232 mode.
	usart_init_rs232(DISPLAY_USART, &display_usart_options, pba_hz);
8000337c:	ee c8 00 0c 	sub	r8,r7,12
80003380:	ee fa ff ec 	ld.w	r10,r7[-20]
80003384:	10 9b       	mov	r11,r8
80003386:	fc 7c 14 00 	mov	r12,-191488
8000338a:	f0 1f 00 05 	mcall	8000339c <init_display_rs232_ex+0x58>
}
8000338e:	2f bd       	sub	sp,-20
80003390:	e3 cd 80 80 	ldm	sp++,r7,pc
80003394:	80 00       	ld.sh	r0,r0[0x0]
80003396:	78 00       	ld.w	r0,r12[0x0]
80003398:	80 00       	ld.sh	r0,r0[0x0]
8000339a:	3c 58       	mov	r8,-59
8000339c:	80 00       	ld.sh	r0,r0[0x0]
8000339e:	4f 7c       	lddpc	r12,80003578 <adcifa_configure+0xf8>

800033a0 <print_ssdbg>:


void print_ssdbg(const char *str)
{
800033a0:	eb cd 40 80 	pushm	r7,lr
800033a4:	1a 97       	mov	r7,sp
800033a6:	20 1d       	sub	sp,4
800033a8:	ef 4c ff fc 	st.w	r7[-4],r12
  // Redirection to the debug USART.
  print(SSDBG_USART, str);
800033ac:	ee fb ff fc 	ld.w	r11,r7[-4]
800033b0:	fe 7c 28 00 	mov	r12,-55296
800033b4:	f0 1f 00 03 	mcall	800033c0 <print_ssdbg+0x20>
}
800033b8:	2f fd       	sub	sp,-4
800033ba:	e3 cd 80 80 	ldm	sp++,r7,pc
800033be:	00 00       	add	r0,r0
800033c0:	80 00       	ld.sh	r0,r0[0x0]
800033c2:	33 c4       	mov	r4,60

800033c4 <print>:
	print_hex(DISPLAY_USART, n);
}


void print(volatile avr32_usart_t *usart, const char *str)
{
800033c4:	eb cd 40 80 	pushm	r7,lr
800033c8:	1a 97       	mov	r7,sp
800033ca:	20 2d       	sub	sp,8
800033cc:	ef 4c ff fc 	st.w	r7[-4],r12
800033d0:	ef 4b ff f8 	st.w	r7[-8],r11
  // Invoke the USART driver to transmit the input string with the given USART.
  usart_write_line(usart, str);
800033d4:	ee fb ff f8 	ld.w	r11,r7[-8]
800033d8:	ee fc ff fc 	ld.w	r12,r7[-4]
800033dc:	f0 1f 00 03 	mcall	800033e8 <print+0x24>
}
800033e0:	2f ed       	sub	sp,-8
800033e2:	e3 cd 80 80 	ldm	sp++,r7,pc
800033e6:	00 00       	add	r0,r0
800033e8:	80 00       	ld.sh	r0,r0[0x0]
800033ea:	51 84       	stdsp	sp[0x60],r4

800033ec <adcifa_get_calibration_data>:
 * \param adcifa       Base address of the ADCIFA
 * \param p_adcifa_opt Structure for the ADCIFA core configuration
 */
void adcifa_get_calibration_data(volatile avr32_adcifa_t *adcifa,
		adcifa_opt_t *p_adcifa_opt)
{
800033ec:	eb cd 40 80 	pushm	r7,lr
800033f0:	1a 97       	mov	r7,sp
800033f2:	20 6d       	sub	sp,24
800033f4:	ef 4c ff ec 	st.w	r7[-20],r12
800033f8:	ef 4b ff e8 	st.w	r7[-24],r11
	/* Get Offset Calibration */
	int32_t adc_ocal
		= ((*(volatile signed int *)(AVR32_FLASHC_FACTORY_PAGE_ADDRESS
800033fc:	e0 68 02 04 	mov	r8,516
80003400:	ea 18 80 80 	orh	r8,0x8080
80003404:	70 08       	ld.w	r8,r8[0x0]
80003406:	e6 18 3f 00 	andh	r8,0x3f00,COH
			+ AVR32_FLASHC_FROW_OCAL_WORD)) &
			AVR32_FLASHC_FROW_OCAL_MASK) >>
			AVR32_FLASHC_FROW_OCAL_OFFSET;
8000340a:	b9 48       	asr	r8,0x18
8000340c:	ef 48 ff f0 	st.w	r7[-16],r8
	/* Get Gain Calibration */
	int32_t adc_gcal
		= ((*(volatile signed int *)(AVR32_FLASHC_FACTORY_PAGE_ADDRESS
			+ AVR32_FLASHC_FROW_GCAL_WORD)) &
			AVR32_FLASHC_FROW_GCAL_MASK) >>
			AVR32_FLASHC_FROW_GCAL_OFFSET;
80003410:	e0 68 02 04 	mov	r8,516
80003414:	ea 18 80 80 	orh	r8,0x8080
			AVR32_FLASHC_FROW_OCAL_MASK) >>
			AVR32_FLASHC_FROW_OCAL_OFFSET;

	/* Get Gain Calibration */
	int32_t adc_gcal
		= ((*(volatile signed int *)(AVR32_FLASHC_FACTORY_PAGE_ADDRESS
80003418:	70 08       	ld.w	r8,r8[0x0]
			+ AVR32_FLASHC_FROW_GCAL_WORD)) &
			AVR32_FLASHC_FROW_GCAL_MASK) >>
			AVR32_FLASHC_FROW_GCAL_OFFSET;
8000341a:	f1 d8 c0 0f 	bfextu	r8,r8,0x0,0xf
8000341e:	ef 48 ff f4 	st.w	r7[-12],r8
	/*  Get S/H Calibration */
	int32_t adc_gain0
		= ((*(volatile signed int *)(AVR32_FLASHC_FACTORY_PAGE_ADDRESS
			+ AVR32_FLASHC_FROW_GAIN0_WORD)) &
			AVR32_FLASHC_FROW_GAIN0_MASK) >>
			AVR32_FLASHC_FROW_GAIN0_OFFSET;
80003422:	e0 68 02 08 	mov	r8,520
80003426:	ea 18 80 80 	orh	r8,0x8080
			AVR32_FLASHC_FROW_GCAL_MASK) >>
			AVR32_FLASHC_FROW_GCAL_OFFSET;

	/*  Get S/H Calibration */
	int32_t adc_gain0
		= ((*(volatile signed int *)(AVR32_FLASHC_FACTORY_PAGE_ADDRESS
8000342a:	70 08       	ld.w	r8,r8[0x0]
			+ AVR32_FLASHC_FROW_GAIN0_WORD)) &
			AVR32_FLASHC_FROW_GAIN0_MASK) >>
			AVR32_FLASHC_FROW_GAIN0_OFFSET;
8000342c:	f1 d8 c0 0a 	bfextu	r8,r8,0x0,0xa
80003430:	ef 48 ff f8 	st.w	r7[-8],r8

	int32_t adc_gain1
		= ((*(volatile signed int *)(AVR32_FLASHC_FACTORY_PAGE_ADDRESS
80003434:	e0 68 02 08 	mov	r8,520
80003438:	ea 18 80 80 	orh	r8,0x8080
8000343c:	70 08       	ld.w	r8,r8[0x0]
8000343e:	e6 18 03 ff 	andh	r8,0x3ff,COH
			+ AVR32_FLASHC_FROW_GAIN1_WORD)) &
			AVR32_FLASHC_FROW_GAIN1_MASK) >>
			AVR32_FLASHC_FROW_GAIN1_OFFSET;
80003442:	b1 48       	asr	r8,0x10
80003444:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Get ADC Offset Calibration */
	p_adcifa_opt->offset_calibration_value = adc_ocal;
80003448:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000344c:	5c 88       	casts.h	r8
8000344e:	ee f9 ff e8 	ld.w	r9,r7[-24]
80003452:	b2 68       	st.h	r9[0xc],r8

	/* Get ADC Gain Calibration */
	p_adcifa_opt->gain_calibration_value = adc_gcal;
80003454:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003458:	5c 88       	casts.h	r8
8000345a:	ee f9 ff e8 	ld.w	r9,r7[-24]
8000345e:	b2 58       	st.h	r9[0xa],r8

	/* Get Sample & Hold Gain Calibration for Seq 0 */
	p_adcifa_opt->sh0_calibration_value = adc_gain0;
80003460:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003464:	5c 88       	casts.h	r8
80003466:	ee f9 ff e8 	ld.w	r9,r7[-24]
8000346a:	b2 78       	st.h	r9[0xe],r8

	/* Get Sample & Hold Gain Calibration for Seq 1 */
	p_adcifa_opt->sh1_calibration_value = adc_gain1;
8000346c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003470:	5c 88       	casts.h	r8
80003472:	ee f9 ff e8 	ld.w	r9,r7[-24]
80003476:	f3 58 00 10 	st.h	r9[16],r8
}
8000347a:	2f ad       	sub	sp,-24
8000347c:	e3 cd 80 80 	ldm	sp++,r7,pc

80003480 <adcifa_configure>:
 * \return ADCIFA_CONFIGURATION_REFUSED or ADCIFA_CONFIGURATION_ACCEPTED
 */
uint8_t adcifa_configure(volatile avr32_adcifa_t *adcifa,
		adcifa_opt_t *p_adcifa_opt,
		uint32_t pb_hz)
{
80003480:	eb cd 40 80 	pushm	r7,lr
80003484:	1a 97       	mov	r7,sp
80003486:	20 3d       	sub	sp,12
80003488:	ef 4c ff fc 	st.w	r7[-4],r12
8000348c:	ef 4b ff f8 	st.w	r7[-8],r11
80003490:	ef 4a ff f4 	st.w	r7[-12],r10
	/* Sanity Check */
	Assert(adcifa != NULL);

	/* Set the ADC configuration */
	AVR32_ADCIFA.cfg
80003494:	fc 7a 24 00 	mov	r10,-187392
		= (p_adcifa_opt->sleep_mode_enable <<
80003498:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000349c:	f1 38 00 08 	ld.ub	r8,r8[8]
800034a0:	f0 09 15 02 	lsl	r9,r8,0x2
			AVR32_ADCIFA_CFG_SLEEP)
			| (p_adcifa_opt->single_sequencer_mode <<
800034a4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800034a8:	11 e8       	ld.ub	r8,r8[0x6]
800034aa:	a3 78       	lsl	r8,0x3
			AVR32_ADCIFA_CFG_SSMQ)
			| (p_adcifa_opt->free_running_mode_enable <<
800034ac:	10 49       	or	r9,r8
800034ae:	ee f8 ff f8 	ld.w	r8,r7[-8]
800034b2:	11 f8       	ld.ub	r8,r8[0x7]
800034b4:	a5 68       	lsl	r8,0x4
			AVR32_ADCIFA_CFG_FRM)
			| (p_adcifa_opt->reference_source <<
800034b6:	10 49       	or	r9,r8
800034b8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800034bc:	11 c8       	ld.ub	r8,r8[0x4]
800034be:	a5 78       	lsl	r8,0x5
			AVR32_ADCIFA_CFG_RS)
			| (p_adcifa_opt->sample_and_hold_disable <<
800034c0:	10 49       	or	r9,r8
800034c2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800034c6:	11 d8       	ld.ub	r8,r8[0x5]
800034c8:	a7 78       	lsl	r8,0x7
			AVR32_ADCIFA_CFG_SHD)
			| (p_adcifa_opt->mux_settle_more_time <<
800034ca:	10 49       	or	r9,r8
800034cc:	ee f8 ff f8 	ld.w	r8,r7[-8]
800034d0:	f1 38 00 09 	ld.ub	r8,r8[9]
800034d4:	ab 68       	lsl	r8,0xa
			AVR32_ADCIFA_CFG_MUXSET)
			| (((ADCIFA_START_UP_TIME *
800034d6:	f3 e8 10 08 	or	r8,r9,r8
	/* Sanity Check */
	Assert(adcifa != NULL);

	/* Set the ADC configuration */
	AVR32_ADCIFA.cfg
		= (p_adcifa_opt->sleep_mode_enable <<
800034da:	10 9b       	mov	r11,r8
			| (p_adcifa_opt->sample_and_hold_disable <<
			AVR32_ADCIFA_CFG_SHD)
			| (p_adcifa_opt->mux_settle_more_time <<
			AVR32_ADCIFA_CFG_MUXSET)
			| (((ADCIFA_START_UP_TIME *
			(p_adcifa_opt->frequency /
800034dc:	ee f8 ff f8 	ld.w	r8,r7[-8]
800034e0:	70 09       	ld.w	r9,r8[0x0]
800034e2:	e0 68 4d d3 	mov	r8,19923
800034e6:	ea 18 10 62 	orh	r8,0x1062
800034ea:	f2 08 06 48 	mulu.d	r8,r9,r8
800034ee:	a7 89       	lsr	r9,0x6
			AVR32_ADCIFA_CFG_RS)
			| (p_adcifa_opt->sample_and_hold_disable <<
			AVR32_ADCIFA_CFG_SHD)
			| (p_adcifa_opt->mux_settle_more_time <<
			AVR32_ADCIFA_CFG_MUXSET)
			| (((ADCIFA_START_UP_TIME *
800034f0:	e0 68 03 e8 	mov	r8,1000
800034f4:	b1 39       	mul	r9,r8
800034f6:	e0 68 4d d3 	mov	r8,19923
800034fa:	ea 18 10 62 	orh	r8,0x1062
800034fe:	f2 08 06 48 	mulu.d	r8,r9,r8
80003502:	f2 08 16 0b 	lsr	r8,r9,0xb
80003506:	b1 68       	lsl	r8,0x10
	/* Sanity Check */
	Assert(adcifa != NULL);

	/* Set the ADC configuration */
	AVR32_ADCIFA.cfg
		= (p_adcifa_opt->sleep_mode_enable <<
80003508:	f7 e8 10 08 	or	r8,r11,r8
{
	/* Sanity Check */
	Assert(adcifa != NULL);

	/* Set the ADC configuration */
	AVR32_ADCIFA.cfg
8000350c:	95 18       	st.w	r10[0x4],r8
			1000)) / 32000) << AVR32_ADCIFA_CFG_SUT);

	/* Configure Clock  (rounded up) */
	adcifa->ckdiv
		= (((pb_hz /
			(2 * p_adcifa_opt->frequency)) - 1) <<
8000350e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003512:	70 08       	ld.w	r8,r8[0x0]
80003514:	f0 09 15 01 	lsl	r9,r8,0x1
			(p_adcifa_opt->frequency /
			1000)) / 32000) << AVR32_ADCIFA_CFG_SUT);

	/* Configure Clock  (rounded up) */
	adcifa->ckdiv
		= (((pb_hz /
80003518:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000351c:	f0 09 0d 08 	divu	r8,r8,r9
80003520:	20 18       	sub	r8,1
80003522:	f3 d8 c0 09 	bfextu	r9,r8,0x0,0x9
			| (((ADCIFA_START_UP_TIME *
			(p_adcifa_opt->frequency /
			1000)) / 32000) << AVR32_ADCIFA_CFG_SUT);

	/* Configure Clock  (rounded up) */
	adcifa->ckdiv
80003526:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000352a:	f1 49 00 44 	st.w	r8[68],r9
			(2 * p_adcifa_opt->frequency)) - 1) <<
			AVR32_ADCIFA_CKDIV_CNT_OFFSET) &
			AVR32_ADCIFA_CKDIV_CNT_MASK;

	/* Set ADC Offset Calibration */
	ADCIFA_set_offset_calibration(p_adcifa_opt->offset_calibration_value);
8000352e:	fc 78 24 00 	mov	r8,-187392
80003532:	fc 79 24 00 	mov	r9,-187392
80003536:	73 a9       	ld.w	r9,r9[0x68]
80003538:	12 9a       	mov	r10,r9
8000353a:	e4 1a c0 ff 	andh	r10,0xc0ff
8000353e:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003542:	92 69       	ld.sh	r9,r9[0xc]
80003544:	b9 69       	lsl	r9,0x18
80003546:	e6 19 3f 00 	andh	r9,0x3f00,COH
8000354a:	f5 e9 10 09 	or	r9,r10,r9
8000354e:	f1 49 00 68 	st.w	r8[104],r9

	/* Set ADC Gain Calibration */
	ADCIFA_set_gain_calibration(p_adcifa_opt->gain_calibration_value);
80003552:	fc 78 24 00 	mov	r8,-187392
80003556:	fc 79 24 00 	mov	r9,-187392
8000355a:	73 a9       	ld.w	r9,r9[0x68]
8000355c:	12 9a       	mov	r10,r9
8000355e:	e0 1a 80 00 	andl	r10,0x8000
80003562:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003566:	92 59       	ld.sh	r9,r9[0xa]
80003568:	f3 d9 c0 0f 	bfextu	r9,r9,0x0,0xf
8000356c:	f5 e9 10 09 	or	r9,r10,r9
80003570:	f1 49 00 68 	st.w	r8[104],r9

	/* Set Sample & Hold Gain Calibration for seq 0 */
	ADCIFA_set_sh0_gain_calibration(p_adcifa_opt->sh0_calibration_value);
80003574:	fc 78 24 00 	mov	r8,-187392
80003578:	fc 79 24 00 	mov	r9,-187392
8000357c:	73 b9       	ld.w	r9,r9[0x6c]
8000357e:	12 9a       	mov	r10,r9
80003580:	e0 1a fc 00 	andl	r10,0xfc00
80003584:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003588:	92 79       	ld.sh	r9,r9[0xe]
8000358a:	f3 d9 c0 0a 	bfextu	r9,r9,0x0,0xa
8000358e:	f5 e9 10 09 	or	r9,r10,r9
80003592:	f1 49 00 6c 	st.w	r8[108],r9

	/* Set Sample & Hold Gain Calibration for seq 1 */
	ADCIFA_set_sh1_gain_calibration(p_adcifa_opt->sh1_calibration_value);
80003596:	fc 78 24 00 	mov	r8,-187392
8000359a:	fc 79 24 00 	mov	r9,-187392
8000359e:	73 b9       	ld.w	r9,r9[0x6c]
800035a0:	12 9a       	mov	r10,r9
800035a2:	e4 1a fc 00 	andh	r10,0xfc00
800035a6:	ee f9 ff f8 	ld.w	r9,r7[-8]
800035aa:	f3 09 00 10 	ld.sh	r9,r9[16]
800035ae:	b1 69       	lsl	r9,0x10
800035b0:	e6 19 03 ff 	andh	r9,0x3ff,COH
800035b4:	f5 e9 10 09 	or	r9,r10,r9
800035b8:	f1 49 00 6c 	st.w	r8[108],r9

	/* Enable ADCIFA */
	ADCIFA_enable();
800035bc:	fc 78 24 00 	mov	r8,-187392
800035c0:	fc 79 24 00 	mov	r9,-187392
800035c4:	72 19       	ld.w	r9,r9[0x4]
800035c6:	a1 a9       	sbr	r9,0x0
800035c8:	91 19       	st.w	r8[0x4],r9
800035ca:	c0 28       	rjmp	800035ce <adcifa_configure+0x14e>
	/* Wait Startup Time */
	while (1) {
		if (ADCIFA_is_startup_time()) {
			break;
		}
	}
800035cc:	d7 03       	nop
	/* Enable ADCIFA */
	ADCIFA_enable();

	/* Wait Startup Time */
	while (1) {
		if (ADCIFA_is_startup_time()) {
800035ce:	fc 78 24 00 	mov	r8,-187392
800035d2:	70 28       	ld.w	r8,r8[0x8]
800035d4:	e2 18 40 00 	andl	r8,0x4000,COH
800035d8:	cf a0       	breq	800035cc <adcifa_configure+0x14c>
			break;
		}
	}

	return ADCIFA_CONFIGURATION_ACCEPTED;
800035da:	30 18       	mov	r8,1
}
800035dc:	10 9c       	mov	r12,r8
800035de:	2f dd       	sub	sp,-12
800035e0:	e3 cd 80 80 	ldm	sp++,r7,pc

800035e4 <adcifa_configure_sequencer>:
 */
uint8_t adcifa_configure_sequencer(volatile avr32_adcifa_t *adcifa,
		uint8_t sequencer,
		adcifa_sequencer_opt_t *p_adcifa_sequencer_opt,
		adcifa_sequencer_conversion_opt_t *p_adcifa_sequencer_conversion_opt)
{
800035e4:	eb cd 40 80 	pushm	r7,lr
800035e8:	1a 97       	mov	r7,sp
800035ea:	21 1d       	sub	sp,68
800035ec:	ef 4c ff c8 	st.w	r7[-56],r12
800035f0:	16 98       	mov	r8,r11
800035f2:	ef 4a ff c0 	st.w	r7[-64],r10
800035f6:	ef 49 ff bc 	st.w	r7[-68],r9
800035fa:	ef 68 ff c4 	st.b	r7[-60],r8
	uint8_t g[16] = {0};
800035fe:	30 08       	mov	r8,0
80003600:	30 09       	mov	r9,0
80003602:	ee e9 ff ec 	st.d	r7[-20],r8
80003606:	30 08       	mov	r8,0
80003608:	30 09       	mov	r9,0
8000360a:	ee e9 ff f4 	st.d	r7[-12],r8
	uint8_t mp[16] = {0};
8000360e:	30 08       	mov	r8,0
80003610:	30 09       	mov	r9,0
80003612:	ee e9 ff dc 	st.d	r7[-36],r8
80003616:	30 08       	mov	r8,0
80003618:	30 09       	mov	r9,0
8000361a:	ee e9 ff e4 	st.d	r7[-28],r8
	uint8_t mn[16] = {0};
8000361e:	30 08       	mov	r8,0
80003620:	30 09       	mov	r9,0
80003622:	ee e9 ff cc 	st.d	r7[-52],r8
80003626:	30 08       	mov	r8,0
80003628:	30 09       	mov	r9,0
8000362a:	ee e9 ff d4 	st.d	r7[-44],r8

	/* Sanity Check */
	Assert( adcifa != NULL );

	/* Switch case with sequencer */
	switch (sequencer) {
8000362e:	ef 38 ff c4 	ld.ub	r8,r7[-60]
80003632:	58 08       	cp.w	r8,0
80003634:	c0 60       	breq	80003640 <adcifa_configure_sequencer+0x5c>
80003636:	58 18       	cp.w	r8,1
80003638:	e0 80 01 65 	breq	80003902 <adcifa_configure_sequencer+0x31e>
8000363c:	e0 8f 02 54 	bral	80003ae4 <adcifa_configure_sequencer+0x500>
	/* Sequencer 0 */
	case 0:
		/* Configure Sequencer 0 */
		ADCIFA_configure_sequencer_0(
80003640:	fc 78 24 00 	mov	r8,-187392
80003644:	ee f9 ff c0 	ld.w	r9,r7[-64]
80003648:	13 89       	ld.ub	r9,r9[0x0]
8000364a:	20 19       	sub	r9,1
8000364c:	f2 0a 15 10 	lsl	r10,r9,0x10
80003650:	ee f9 ff c0 	ld.w	r9,r7[-64]
80003654:	13 99       	ld.ub	r9,r9[0x1]
80003656:	ad 69       	lsl	r9,0xc
80003658:	12 4a       	or	r10,r9
8000365a:	ee f9 ff c0 	ld.w	r9,r7[-64]
8000365e:	13 a9       	ld.ub	r9,r9[0x2]
80003660:	a9 69       	lsl	r9,0x8
80003662:	12 4a       	or	r10,r9
80003664:	ee f9 ff c0 	ld.w	r9,r7[-64]
80003668:	13 b9       	ld.ub	r9,r9[0x3]
8000366a:	a3 69       	lsl	r9,0x2
8000366c:	12 4a       	or	r10,r9
8000366e:	ee f9 ff c0 	ld.w	r9,r7[-64]
80003672:	13 c9       	ld.ub	r9,r9[0x4]
80003674:	a3 79       	lsl	r9,0x3
80003676:	12 4a       	or	r10,r9
80003678:	ee f9 ff c0 	ld.w	r9,r7[-64]
8000367c:	13 d9       	ld.ub	r9,r9[0x5]
8000367e:	a1 79       	lsl	r9,0x1
80003680:	12 4a       	or	r10,r9
80003682:	ee f9 ff c0 	ld.w	r9,r7[-64]
80003686:	13 e9       	ld.ub	r9,r9[0x6]
80003688:	f5 e9 10 09 	or	r9,r10,r9
8000368c:	91 59       	st.w	r8[0x14],r9
				(p_adcifa_sequencer_opt->sh_mode),
#endif
				(p_adcifa_sequencer_opt->half_word_adjustment),
				(p_adcifa_sequencer_opt->software_acknowledge));
		/* Configure Gain for Sequencer 0 */
		for (i = 0; i < p_adcifa_sequencer_opt->convnb; i++) {
8000368e:	30 08       	mov	r8,0
80003690:	ef 68 ff ff 	st.b	r7[-1],r8
80003694:	c1 68       	rjmp	800036c0 <adcifa_configure_sequencer+0xdc>
			g[i] = p_adcifa_sequencer_conversion_opt[i].gain;
80003696:	ef 3a ff ff 	ld.ub	r10,r7[-1]
8000369a:	ef 39 ff ff 	ld.ub	r9,r7[-1]
8000369e:	12 98       	mov	r8,r9
800036a0:	a1 78       	lsl	r8,0x1
800036a2:	12 08       	add	r8,r9
800036a4:	ee f9 ff bc 	ld.w	r9,r7[-68]
800036a8:	f2 08 00 08 	add	r8,r9,r8
800036ac:	11 a8       	ld.ub	r8,r8[0x2]
800036ae:	ee 0a 00 09 	add	r9,r7,r10
800036b2:	f3 68 ff ec 	st.b	r9[-20],r8
				(p_adcifa_sequencer_opt->sh_mode),
#endif
				(p_adcifa_sequencer_opt->half_word_adjustment),
				(p_adcifa_sequencer_opt->software_acknowledge));
		/* Configure Gain for Sequencer 0 */
		for (i = 0; i < p_adcifa_sequencer_opt->convnb; i++) {
800036b6:	ef 38 ff ff 	ld.ub	r8,r7[-1]
800036ba:	2f f8       	sub	r8,-1
800036bc:	ef 68 ff ff 	st.b	r7[-1],r8
800036c0:	ee f8 ff c0 	ld.w	r8,r7[-64]
800036c4:	11 88       	ld.ub	r8,r8[0x0]
800036c6:	ef 39 ff ff 	ld.ub	r9,r7[-1]
800036ca:	f0 09 18 00 	cp.b	r9,r8
800036ce:	ce 43       	brcs	80003696 <adcifa_configure_sequencer+0xb2>
			g[i] = p_adcifa_sequencer_conversion_opt[i].gain;
		}
		ADCIFA_configure_sh0gain(g[7], g[6], g[5], g[4], g[3], g[2],
800036d0:	fc 78 24 00 	mov	r8,-187392
800036d4:	ef 39 ff f3 	ld.ub	r9,r7[-13]
800036d8:	f2 0a 15 1c 	lsl	r10,r9,0x1c
800036dc:	ef 39 ff f2 	ld.ub	r9,r7[-14]
800036e0:	b9 69       	lsl	r9,0x18
800036e2:	12 4a       	or	r10,r9
800036e4:	ef 39 ff f1 	ld.ub	r9,r7[-15]
800036e8:	b5 69       	lsl	r9,0x14
800036ea:	12 4a       	or	r10,r9
800036ec:	ef 39 ff f0 	ld.ub	r9,r7[-16]
800036f0:	b1 69       	lsl	r9,0x10
800036f2:	12 4a       	or	r10,r9
800036f4:	ef 39 ff ef 	ld.ub	r9,r7[-17]
800036f8:	ad 69       	lsl	r9,0xc
800036fa:	12 4a       	or	r10,r9
800036fc:	ef 39 ff ee 	ld.ub	r9,r7[-18]
80003700:	a9 69       	lsl	r9,0x8
80003702:	12 4a       	or	r10,r9
80003704:	ef 39 ff ed 	ld.ub	r9,r7[-19]
80003708:	a5 69       	lsl	r9,0x4
8000370a:	12 4a       	or	r10,r9
8000370c:	ef 39 ff ec 	ld.ub	r9,r7[-20]
80003710:	f5 e9 10 09 	or	r9,r10,r9
80003714:	91 79       	st.w	r8[0x1c],r9
				g[1], g[0]);

		/* Configure Mux for Sequencer 0 */
		for (i = 0; i < p_adcifa_sequencer_opt->convnb; i++) {
80003716:	30 08       	mov	r8,0
80003718:	ef 68 ff ff 	st.b	r7[-1],r8
8000371c:	c2 68       	rjmp	80003768 <adcifa_configure_sequencer+0x184>
			mp[i] = p_adcifa_sequencer_conversion_opt[i].channel_p;
8000371e:	ef 3a ff ff 	ld.ub	r10,r7[-1]
80003722:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80003726:	12 98       	mov	r8,r9
80003728:	a1 78       	lsl	r8,0x1
8000372a:	12 08       	add	r8,r9
8000372c:	ee f9 ff bc 	ld.w	r9,r7[-68]
80003730:	f2 08 00 08 	add	r8,r9,r8
80003734:	11 88       	ld.ub	r8,r8[0x0]
80003736:	ee 0a 00 09 	add	r9,r7,r10
8000373a:	f3 68 ff dc 	st.b	r9[-36],r8
			mn[i] = p_adcifa_sequencer_conversion_opt[i].channel_n;
8000373e:	ef 3a ff ff 	ld.ub	r10,r7[-1]
80003742:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80003746:	12 98       	mov	r8,r9
80003748:	a1 78       	lsl	r8,0x1
8000374a:	12 08       	add	r8,r9
8000374c:	ee f9 ff bc 	ld.w	r9,r7[-68]
80003750:	f2 08 00 08 	add	r8,r9,r8
80003754:	11 98       	ld.ub	r8,r8[0x1]
80003756:	ee 0a 00 09 	add	r9,r7,r10
8000375a:	f3 68 ff cc 	st.b	r9[-52],r8
		}
		ADCIFA_configure_sh0gain(g[7], g[6], g[5], g[4], g[3], g[2],
				g[1], g[0]);

		/* Configure Mux for Sequencer 0 */
		for (i = 0; i < p_adcifa_sequencer_opt->convnb; i++) {
8000375e:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80003762:	2f f8       	sub	r8,-1
80003764:	ef 68 ff ff 	st.b	r7[-1],r8
80003768:	ee f8 ff c0 	ld.w	r8,r7[-64]
8000376c:	11 88       	ld.ub	r8,r8[0x0]
8000376e:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80003772:	f0 09 18 00 	cp.b	r9,r8
80003776:	cd 43       	brcs	8000371e <adcifa_configure_sequencer+0x13a>
			mp[i] = p_adcifa_sequencer_conversion_opt[i].channel_p;
			mn[i] = p_adcifa_sequencer_conversion_opt[i].channel_n;
		}
		ADCIFA_configure_muxsel0p(mp[7], mp[6], mp[5], mp[4], mp[3],
80003778:	fc 78 24 00 	mov	r8,-187392
8000377c:	ef 39 ff e3 	ld.ub	r9,r7[-29]
80003780:	f2 0a 15 18 	lsl	r10,r9,0x18
80003784:	ef 39 ff e2 	ld.ub	r9,r7[-30]
80003788:	b1 69       	lsl	r9,0x10
8000378a:	12 4a       	or	r10,r9
8000378c:	ef 39 ff e1 	ld.ub	r9,r7[-31]
80003790:	a9 69       	lsl	r9,0x8
80003792:	12 4a       	or	r10,r9
80003794:	ef 39 ff e0 	ld.ub	r9,r7[-32]
80003798:	f5 e9 10 09 	or	r9,r10,r9
8000379c:	91 b9       	st.w	r8[0x2c],r9
8000379e:	fc 78 24 00 	mov	r8,-187392
800037a2:	ef 39 ff df 	ld.ub	r9,r7[-33]
800037a6:	f2 0a 15 18 	lsl	r10,r9,0x18
800037aa:	ef 39 ff de 	ld.ub	r9,r7[-34]
800037ae:	b1 69       	lsl	r9,0x10
800037b0:	12 4a       	or	r10,r9
800037b2:	ef 39 ff dd 	ld.ub	r9,r7[-35]
800037b6:	a9 69       	lsl	r9,0x8
800037b8:	12 4a       	or	r10,r9
800037ba:	ef 39 ff dc 	ld.ub	r9,r7[-36]
800037be:	f5 e9 10 09 	or	r9,r10,r9
800037c2:	91 99       	st.w	r8[0x24],r9
				mp[2], mp[1], mp[0]);
		ADCIFA_configure_muxsel0n(mn[7], mn[6], mn[5], mn[4], mn[3],
800037c4:	fc 78 24 00 	mov	r8,-187392
800037c8:	ef 39 ff d3 	ld.ub	r9,r7[-45]
800037cc:	f2 0a 15 18 	lsl	r10,r9,0x18
800037d0:	ef 39 ff d2 	ld.ub	r9,r7[-46]
800037d4:	b1 69       	lsl	r9,0x10
800037d6:	12 4a       	or	r10,r9
800037d8:	ef 39 ff d1 	ld.ub	r9,r7[-47]
800037dc:	a9 69       	lsl	r9,0x8
800037de:	12 4a       	or	r10,r9
800037e0:	ef 39 ff d0 	ld.ub	r9,r7[-48]
800037e4:	f5 e9 10 09 	or	r9,r10,r9
800037e8:	91 f9       	st.w	r8[0x3c],r9
800037ea:	fc 78 24 00 	mov	r8,-187392
800037ee:	ef 39 ff cf 	ld.ub	r9,r7[-49]
800037f2:	f2 0a 15 18 	lsl	r10,r9,0x18
800037f6:	ef 39 ff ce 	ld.ub	r9,r7[-50]
800037fa:	b1 69       	lsl	r9,0x10
800037fc:	12 4a       	or	r10,r9
800037fe:	ef 39 ff cd 	ld.ub	r9,r7[-51]
80003802:	a9 69       	lsl	r9,0x8
80003804:	12 4a       	or	r10,r9
80003806:	ef 39 ff cc 	ld.ub	r9,r7[-52]
8000380a:	f5 e9 10 09 	or	r9,r10,r9
8000380e:	91 d9       	st.w	r8[0x34],r9
		 * This adcifa_seq1_configured variable check if muxsel1p,muxsel1n 
		 * registers are already configured. This may happen if this function is
		 * called first with sequencer 1 as argument and then called with 
		 * sequencer 0 as argument in case dual mode is used.
		 */
		if(!adcifa_seq1_configured)
80003810:	fe f8 02 e0 	ld.w	r8,pc[736]
80003814:	11 88       	ld.ub	r8,r8[0x0]
80003816:	ec 18 00 01 	eorl	r8,0x1
8000381a:	5c 58       	castu.b	r8
8000381c:	e0 80 01 63 	breq	80003ae2 <adcifa_configure_sequencer+0x4fe>
		{
			/*
			 * Configure gain for sequencer 0 (in single sequencer mode for 
			 * conversions 9 to 16)
			 */ 
			ADCIFA_configure_sh1gain(g[15], g[14], g[13], g[12], g[11], g[10], 
80003820:	fc 78 24 00 	mov	r8,-187392
80003824:	ef 39 ff fb 	ld.ub	r9,r7[-5]
80003828:	f2 0a 15 1c 	lsl	r10,r9,0x1c
8000382c:	ef 39 ff fa 	ld.ub	r9,r7[-6]
80003830:	b9 69       	lsl	r9,0x18
80003832:	12 4a       	or	r10,r9
80003834:	ef 39 ff f9 	ld.ub	r9,r7[-7]
80003838:	b5 69       	lsl	r9,0x14
8000383a:	12 4a       	or	r10,r9
8000383c:	ef 39 ff f8 	ld.ub	r9,r7[-8]
80003840:	b1 69       	lsl	r9,0x10
80003842:	12 4a       	or	r10,r9
80003844:	ef 39 ff f7 	ld.ub	r9,r7[-9]
80003848:	ad 69       	lsl	r9,0xc
8000384a:	12 4a       	or	r10,r9
8000384c:	ef 39 ff f6 	ld.ub	r9,r7[-10]
80003850:	a9 69       	lsl	r9,0x8
80003852:	12 4a       	or	r10,r9
80003854:	ef 39 ff f5 	ld.ub	r9,r7[-11]
80003858:	a5 69       	lsl	r9,0x4
8000385a:	12 4a       	or	r10,r9
8000385c:	ef 39 ff f4 	ld.ub	r9,r7[-12]
80003860:	f5 e9 10 09 	or	r9,r10,r9
80003864:	91 89       	st.w	r8[0x20],r9

			/*
			 * Configure Mux for sequencer 0 (in single sequencer mode for 
			 * conversions 9 to 16)
			 */
			ADCIFA_configure_muxsel1p(mp[15], mp[14], mp[13], mp[12], mp[11], 
80003866:	fc 78 24 00 	mov	r8,-187392
8000386a:	ef 39 ff eb 	ld.ub	r9,r7[-21]
8000386e:	f2 0a 15 18 	lsl	r10,r9,0x18
80003872:	ef 39 ff ea 	ld.ub	r9,r7[-22]
80003876:	b1 69       	lsl	r9,0x10
80003878:	12 4a       	or	r10,r9
8000387a:	ef 39 ff e9 	ld.ub	r9,r7[-23]
8000387e:	a9 69       	lsl	r9,0x8
80003880:	12 4a       	or	r10,r9
80003882:	ef 39 ff e8 	ld.ub	r9,r7[-24]
80003886:	f5 e9 10 09 	or	r9,r10,r9
8000388a:	91 c9       	st.w	r8[0x30],r9
8000388c:	fc 78 24 00 	mov	r8,-187392
80003890:	ef 39 ff e7 	ld.ub	r9,r7[-25]
80003894:	f2 0a 15 18 	lsl	r10,r9,0x18
80003898:	ef 39 ff e6 	ld.ub	r9,r7[-26]
8000389c:	b1 69       	lsl	r9,0x10
8000389e:	12 4a       	or	r10,r9
800038a0:	ef 39 ff e5 	ld.ub	r9,r7[-27]
800038a4:	a9 69       	lsl	r9,0x8
800038a6:	12 4a       	or	r10,r9
800038a8:	ef 39 ff e4 	ld.ub	r9,r7[-28]
800038ac:	f5 e9 10 09 	or	r9,r10,r9
800038b0:	91 a9       	st.w	r8[0x28],r9
				mp[10], mp[9], mp[8]);
			ADCIFA_configure_muxsel1n(mn[15], mn[14], mn[13], mn[12], mn[11], 
800038b2:	fc 78 24 00 	mov	r8,-187392
800038b6:	ef 39 ff db 	ld.ub	r9,r7[-37]
800038ba:	f2 0a 15 18 	lsl	r10,r9,0x18
800038be:	ef 39 ff da 	ld.ub	r9,r7[-38]
800038c2:	b1 69       	lsl	r9,0x10
800038c4:	12 4a       	or	r10,r9
800038c6:	ef 39 ff d9 	ld.ub	r9,r7[-39]
800038ca:	a9 69       	lsl	r9,0x8
800038cc:	12 4a       	or	r10,r9
800038ce:	ef 39 ff d8 	ld.ub	r9,r7[-40]
800038d2:	f5 e9 10 09 	or	r9,r10,r9
800038d6:	f1 49 00 40 	st.w	r8[64],r9
800038da:	fc 78 24 00 	mov	r8,-187392
800038de:	ef 39 ff d7 	ld.ub	r9,r7[-41]
800038e2:	f2 0a 15 18 	lsl	r10,r9,0x18
800038e6:	ef 39 ff d6 	ld.ub	r9,r7[-42]
800038ea:	b1 69       	lsl	r9,0x10
800038ec:	12 4a       	or	r10,r9
800038ee:	ef 39 ff d5 	ld.ub	r9,r7[-43]
800038f2:	a9 69       	lsl	r9,0x8
800038f4:	12 4a       	or	r10,r9
800038f6:	ef 39 ff d4 	ld.ub	r9,r7[-44]
800038fa:	f5 e9 10 09 	or	r9,r10,r9
800038fe:	91 e9       	st.w	r8[0x38],r9
				mn[10], mn[9], mn[8]);

		}

		break;
80003900:	cf 28       	rjmp	80003ae4 <adcifa_configure_sequencer+0x500>

	/* Sequencer 1 */
	case 1:
		/* Configure Sequencer 1 */
		ADCIFA_configure_sequencer_1(
80003902:	fc 78 24 00 	mov	r8,-187392
80003906:	ee f9 ff c0 	ld.w	r9,r7[-64]
8000390a:	13 89       	ld.ub	r9,r9[0x0]
8000390c:	20 19       	sub	r9,1
8000390e:	f2 0a 15 10 	lsl	r10,r9,0x10
80003912:	ee f9 ff c0 	ld.w	r9,r7[-64]
80003916:	13 99       	ld.ub	r9,r9[0x1]
80003918:	ad 69       	lsl	r9,0xc
8000391a:	12 4a       	or	r10,r9
8000391c:	ee f9 ff c0 	ld.w	r9,r7[-64]
80003920:	13 a9       	ld.ub	r9,r9[0x2]
80003922:	a9 69       	lsl	r9,0x8
80003924:	12 4a       	or	r10,r9
80003926:	ee f9 ff c0 	ld.w	r9,r7[-64]
8000392a:	13 b9       	ld.ub	r9,r9[0x3]
8000392c:	a3 69       	lsl	r9,0x2
8000392e:	12 4a       	or	r10,r9
80003930:	ee f9 ff c0 	ld.w	r9,r7[-64]
80003934:	13 c9       	ld.ub	r9,r9[0x4]
80003936:	a3 79       	lsl	r9,0x3
80003938:	12 4a       	or	r10,r9
8000393a:	ee f9 ff c0 	ld.w	r9,r7[-64]
8000393e:	13 d9       	ld.ub	r9,r9[0x5]
80003940:	a1 79       	lsl	r9,0x1
80003942:	f5 e9 10 09 	or	r9,r10,r9
80003946:	12 9a       	mov	r10,r9
80003948:	a5 aa       	sbr	r10,0x4
8000394a:	ee f9 ff c0 	ld.w	r9,r7[-64]
8000394e:	13 e9       	ld.ub	r9,r9[0x6]
80003950:	f5 e9 10 09 	or	r9,r10,r9
80003954:	91 69       	st.w	r8[0x18],r9
#endif
				(p_adcifa_sequencer_opt->half_word_adjustment),
				(p_adcifa_sequencer_opt->software_acknowledge));

		/* Configure Gain for Sequencer 1 */
		for (i = 0; i < p_adcifa_sequencer_opt->convnb; i++) {
80003956:	30 08       	mov	r8,0
80003958:	ef 68 ff ff 	st.b	r7[-1],r8
8000395c:	c1 68       	rjmp	80003988 <adcifa_configure_sequencer+0x3a4>
			g[i] = p_adcifa_sequencer_conversion_opt[i].gain;
8000395e:	ef 3a ff ff 	ld.ub	r10,r7[-1]
80003962:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80003966:	12 98       	mov	r8,r9
80003968:	a1 78       	lsl	r8,0x1
8000396a:	12 08       	add	r8,r9
8000396c:	ee f9 ff bc 	ld.w	r9,r7[-68]
80003970:	f2 08 00 08 	add	r8,r9,r8
80003974:	11 a8       	ld.ub	r8,r8[0x2]
80003976:	ee 0a 00 09 	add	r9,r7,r10
8000397a:	f3 68 ff ec 	st.b	r9[-20],r8
#endif
				(p_adcifa_sequencer_opt->half_word_adjustment),
				(p_adcifa_sequencer_opt->software_acknowledge));

		/* Configure Gain for Sequencer 1 */
		for (i = 0; i < p_adcifa_sequencer_opt->convnb; i++) {
8000397e:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80003982:	2f f8       	sub	r8,-1
80003984:	ef 68 ff ff 	st.b	r7[-1],r8
80003988:	ee f8 ff c0 	ld.w	r8,r7[-64]
8000398c:	11 88       	ld.ub	r8,r8[0x0]
8000398e:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80003992:	f0 09 18 00 	cp.b	r9,r8
80003996:	ce 43       	brcs	8000395e <adcifa_configure_sequencer+0x37a>
			g[i] = p_adcifa_sequencer_conversion_opt[i].gain;
		}
		ADCIFA_configure_sh1gain(g[7], g[6], g[5], g[4], g[3], g[2],
80003998:	fc 78 24 00 	mov	r8,-187392
8000399c:	ef 39 ff f3 	ld.ub	r9,r7[-13]
800039a0:	f2 0a 15 1c 	lsl	r10,r9,0x1c
800039a4:	ef 39 ff f2 	ld.ub	r9,r7[-14]
800039a8:	b9 69       	lsl	r9,0x18
800039aa:	12 4a       	or	r10,r9
800039ac:	ef 39 ff f1 	ld.ub	r9,r7[-15]
800039b0:	b5 69       	lsl	r9,0x14
800039b2:	12 4a       	or	r10,r9
800039b4:	ef 39 ff f0 	ld.ub	r9,r7[-16]
800039b8:	b1 69       	lsl	r9,0x10
800039ba:	12 4a       	or	r10,r9
800039bc:	ef 39 ff ef 	ld.ub	r9,r7[-17]
800039c0:	ad 69       	lsl	r9,0xc
800039c2:	12 4a       	or	r10,r9
800039c4:	ef 39 ff ee 	ld.ub	r9,r7[-18]
800039c8:	a9 69       	lsl	r9,0x8
800039ca:	12 4a       	or	r10,r9
800039cc:	ef 39 ff ed 	ld.ub	r9,r7[-19]
800039d0:	a5 69       	lsl	r9,0x4
800039d2:	12 4a       	or	r10,r9
800039d4:	ef 39 ff ec 	ld.ub	r9,r7[-20]
800039d8:	f5 e9 10 09 	or	r9,r10,r9
800039dc:	91 89       	st.w	r8[0x20],r9
				g[1], g[0]);

		/* Configure Mux for Sequencer 1 */
		for (i = 0; i < p_adcifa_sequencer_opt->convnb; i++) {
800039de:	30 08       	mov	r8,0
800039e0:	ef 68 ff ff 	st.b	r7[-1],r8
800039e4:	c2 68       	rjmp	80003a30 <adcifa_configure_sequencer+0x44c>
			mp[i] = p_adcifa_sequencer_conversion_opt[i].channel_p;
800039e6:	ef 3a ff ff 	ld.ub	r10,r7[-1]
800039ea:	ef 39 ff ff 	ld.ub	r9,r7[-1]
800039ee:	12 98       	mov	r8,r9
800039f0:	a1 78       	lsl	r8,0x1
800039f2:	12 08       	add	r8,r9
800039f4:	ee f9 ff bc 	ld.w	r9,r7[-68]
800039f8:	f2 08 00 08 	add	r8,r9,r8
800039fc:	11 88       	ld.ub	r8,r8[0x0]
800039fe:	ee 0a 00 09 	add	r9,r7,r10
80003a02:	f3 68 ff dc 	st.b	r9[-36],r8
			mn[i] = p_adcifa_sequencer_conversion_opt[i].channel_n;
80003a06:	ef 3a ff ff 	ld.ub	r10,r7[-1]
80003a0a:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80003a0e:	12 98       	mov	r8,r9
80003a10:	a1 78       	lsl	r8,0x1
80003a12:	12 08       	add	r8,r9
80003a14:	ee f9 ff bc 	ld.w	r9,r7[-68]
80003a18:	f2 08 00 08 	add	r8,r9,r8
80003a1c:	11 98       	ld.ub	r8,r8[0x1]
80003a1e:	ee 0a 00 09 	add	r9,r7,r10
80003a22:	f3 68 ff cc 	st.b	r9[-52],r8
		}
		ADCIFA_configure_sh1gain(g[7], g[6], g[5], g[4], g[3], g[2],
				g[1], g[0]);

		/* Configure Mux for Sequencer 1 */
		for (i = 0; i < p_adcifa_sequencer_opt->convnb; i++) {
80003a26:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80003a2a:	2f f8       	sub	r8,-1
80003a2c:	ef 68 ff ff 	st.b	r7[-1],r8
80003a30:	ee f8 ff c0 	ld.w	r8,r7[-64]
80003a34:	11 88       	ld.ub	r8,r8[0x0]
80003a36:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80003a3a:	f0 09 18 00 	cp.b	r9,r8
80003a3e:	cd 43       	brcs	800039e6 <adcifa_configure_sequencer+0x402>
			mp[i] = p_adcifa_sequencer_conversion_opt[i].channel_p;
			mn[i] = p_adcifa_sequencer_conversion_opt[i].channel_n;
		}
		ADCIFA_configure_muxsel1p(mp[7], mp[6], mp[5], mp[4], mp[3],
80003a40:	fc 78 24 00 	mov	r8,-187392
80003a44:	ef 39 ff e3 	ld.ub	r9,r7[-29]
80003a48:	f2 0a 15 18 	lsl	r10,r9,0x18
80003a4c:	ef 39 ff e2 	ld.ub	r9,r7[-30]
80003a50:	b1 69       	lsl	r9,0x10
80003a52:	12 4a       	or	r10,r9
80003a54:	ef 39 ff e1 	ld.ub	r9,r7[-31]
80003a58:	a9 69       	lsl	r9,0x8
80003a5a:	12 4a       	or	r10,r9
80003a5c:	ef 39 ff e0 	ld.ub	r9,r7[-32]
80003a60:	f5 e9 10 09 	or	r9,r10,r9
80003a64:	91 c9       	st.w	r8[0x30],r9
80003a66:	fc 78 24 00 	mov	r8,-187392
80003a6a:	ef 39 ff df 	ld.ub	r9,r7[-33]
80003a6e:	f2 0a 15 18 	lsl	r10,r9,0x18
80003a72:	ef 39 ff de 	ld.ub	r9,r7[-34]
80003a76:	b1 69       	lsl	r9,0x10
80003a78:	12 4a       	or	r10,r9
80003a7a:	ef 39 ff dd 	ld.ub	r9,r7[-35]
80003a7e:	a9 69       	lsl	r9,0x8
80003a80:	12 4a       	or	r10,r9
80003a82:	ef 39 ff dc 	ld.ub	r9,r7[-36]
80003a86:	f5 e9 10 09 	or	r9,r10,r9
80003a8a:	91 a9       	st.w	r8[0x28],r9
				mp[2], mp[1], mp[0]);
		ADCIFA_configure_muxsel1n(mn[7], mn[6], mn[5], mn[4], mn[3],
80003a8c:	fc 78 24 00 	mov	r8,-187392
80003a90:	ef 39 ff d3 	ld.ub	r9,r7[-45]
80003a94:	f2 0a 15 18 	lsl	r10,r9,0x18
80003a98:	ef 39 ff d2 	ld.ub	r9,r7[-46]
80003a9c:	b1 69       	lsl	r9,0x10
80003a9e:	12 4a       	or	r10,r9
80003aa0:	ef 39 ff d1 	ld.ub	r9,r7[-47]
80003aa4:	a9 69       	lsl	r9,0x8
80003aa6:	12 4a       	or	r10,r9
80003aa8:	ef 39 ff d0 	ld.ub	r9,r7[-48]
80003aac:	f5 e9 10 09 	or	r9,r10,r9
80003ab0:	f1 49 00 40 	st.w	r8[64],r9
80003ab4:	fc 78 24 00 	mov	r8,-187392
80003ab8:	ef 39 ff cf 	ld.ub	r9,r7[-49]
80003abc:	f2 0a 15 18 	lsl	r10,r9,0x18
80003ac0:	ef 39 ff ce 	ld.ub	r9,r7[-50]
80003ac4:	b1 69       	lsl	r9,0x10
80003ac6:	12 4a       	or	r10,r9
80003ac8:	ef 39 ff cd 	ld.ub	r9,r7[-51]
80003acc:	a9 69       	lsl	r9,0x8
80003ace:	12 4a       	or	r10,r9
80003ad0:	ef 39 ff cc 	ld.ub	r9,r7[-52]
80003ad4:	f5 e9 10 09 	or	r9,r10,r9
80003ad8:	91 e9       	st.w	r8[0x38],r9
				mn[2], mn[1], mn[0]);

		adcifa_seq1_configured = true;
80003ada:	48 69       	lddpc	r9,80003af0 <adcifa_configure_sequencer+0x50c>
80003adc:	30 18       	mov	r8,1
80003ade:	b2 88       	st.b	r9[0x0],r8
80003ae0:	c0 28       	rjmp	80003ae4 <adcifa_configure_sequencer+0x500>
			ADCIFA_configure_muxsel1n(mn[15], mn[14], mn[13], mn[12], mn[11], 
				mn[10], mn[9], mn[8]);

		}

		break;
80003ae2:	d7 03       	nop
		break;

	default:
		break;
	}
	return ADCIFA_CONFIGURATION_ACCEPTED;
80003ae4:	30 18       	mov	r8,1
}
80003ae6:	10 9c       	mov	r12,r8
80003ae8:	2e fd       	sub	sp,-68
80003aea:	e3 cd 80 80 	ldm	sp++,r7,pc
80003aee:	00 00       	add	r0,r0
80003af0:	00 00       	add	r0,r0
80003af2:	00 c0       	st.b	r0++,r0

80003af4 <adcifa_start_sequencer>:
/** \brief Start analog to digital conversion for a specific sequencer
 *  \param adcifa     Base address of the ADCIFA
 *  \param sequencer  Sequencer index
 */
void adcifa_start_sequencer(volatile avr32_adcifa_t *adcifa, uint8_t sequencer)
{
80003af4:	eb cd 40 80 	pushm	r7,lr
80003af8:	1a 97       	mov	r7,sp
80003afa:	20 2d       	sub	sp,8
80003afc:	ef 4c ff fc 	st.w	r7[-4],r12
80003b00:	16 98       	mov	r8,r11
80003b02:	ef 68 ff f8 	st.b	r7[-8],r8
	/* Sanity Check */
	Assert( adcifa != NULL );

	/* Switch Sequencer */
	switch (sequencer) {
80003b06:	ef 38 ff f8 	ld.ub	r8,r7[-8]
80003b0a:	58 18       	cp.w	r8,1
80003b0c:	c0 a0       	breq	80003b20 <adcifa_start_sequencer+0x2c>
80003b0e:	58 38       	cp.w	r8,3
80003b10:	c0 d0       	breq	80003b2a <adcifa_start_sequencer+0x36>
80003b12:	58 08       	cp.w	r8,0
80003b14:	c0 f1       	brne	80003b32 <adcifa_start_sequencer+0x3e>
	case ADCIFA_SEQ0:
		ADCIFA_softsoc_sequencer(AVR32_ADCIFA_CR_SOC0_MASK);
80003b16:	fc 78 24 00 	mov	r8,-187392
80003b1a:	30 19       	mov	r9,1
80003b1c:	91 09       	st.w	r8[0x0],r9
		break;
80003b1e:	c0 a8       	rjmp	80003b32 <adcifa_start_sequencer+0x3e>

	case ADCIFA_SEQ1:
		ADCIFA_softsoc_sequencer(AVR32_ADCIFA_CR_SOC1_MASK);
80003b20:	fc 78 24 00 	mov	r8,-187392
80003b24:	30 29       	mov	r9,2
80003b26:	91 09       	st.w	r8[0x0],r9
		break;
80003b28:	c0 58       	rjmp	80003b32 <adcifa_start_sequencer+0x3e>

	case ADCIFA_SEQ0_SEQ1:
		ADCIFA_softsoc_sequencer(
80003b2a:	fc 78 24 00 	mov	r8,-187392
80003b2e:	30 39       	mov	r9,3
80003b30:	91 09       	st.w	r8[0x0],r9
		break;

	default:
		break;
	}
}
80003b32:	2f ed       	sub	sp,-8
80003b34:	e3 cd 80 80 	ldm	sp++,r7,pc

80003b38 <adcifa_check_eos>:
/** \brief Get End of Conversion status bit
 *  \param adcifa     Base address of the ADCIFA
 *  \param sequencer  Sequencer index
 */
bool adcifa_check_eos(volatile avr32_adcifa_t *adcifa, uint8_t sequencer)
{
80003b38:	eb cd 40 80 	pushm	r7,lr
80003b3c:	1a 97       	mov	r7,sp
80003b3e:	20 2d       	sub	sp,8
80003b40:	ef 4c ff fc 	st.w	r7[-4],r12
80003b44:	16 98       	mov	r8,r11
80003b46:	ef 68 ff f8 	st.b	r7[-8],r8
	/* Sanity Check */
	Assert( adcifa != NULL );

	/* get SR register : EOS bit for channel */
	switch (sequencer) {
80003b4a:	ef 38 ff f8 	ld.ub	r8,r7[-8]
80003b4e:	58 08       	cp.w	r8,0
80003b50:	c0 40       	breq	80003b58 <adcifa_check_eos+0x20>
80003b52:	58 18       	cp.w	r8,1
80003b54:	c0 90       	breq	80003b66 <adcifa_check_eos+0x2e>
80003b56:	c1 08       	rjmp	80003b76 <adcifa_check_eos+0x3e>
	case 0:
		return ((ADCIFA_is_eos_sequencer_0()) ? true : false);
80003b58:	fc 78 24 00 	mov	r8,-187392
80003b5c:	70 28       	ld.w	r8,r8[0x8]
80003b5e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80003b62:	5c 58       	castu.b	r8
80003b64:	c0 a8       	rjmp	80003b78 <adcifa_check_eos+0x40>

	case 1:
		return ((ADCIFA_is_eos_sequencer_1()) ? true : false);
80003b66:	fc 78 24 00 	mov	r8,-187392
80003b6a:	70 28       	ld.w	r8,r8[0x8]
80003b6c:	e2 18 00 10 	andl	r8,0x10,COH
80003b70:	5f 18       	srne	r8
80003b72:	5c 58       	castu.b	r8
80003b74:	c0 28       	rjmp	80003b78 <adcifa_check_eos+0x40>

	default:
		break;
	}
	return false;
80003b76:	30 08       	mov	r8,0
}
80003b78:	10 9c       	mov	r12,r8
80003b7a:	2f ed       	sub	sp,-8
80003b7c:	e3 cd 80 80 	ldm	sp++,r7,pc

80003b80 <adcifa_get_values_from_sequencer>:
 */
uint8_t adcifa_get_values_from_sequencer(volatile avr32_adcifa_t *adcifa,
		uint8_t sequencer,
		adcifa_sequencer_opt_t *p_adcifa_sequencer_opt,
		int16_t *adcifa_values)
{
80003b80:	eb cd 40 80 	pushm	r7,lr
80003b84:	1a 97       	mov	r7,sp
80003b86:	20 5d       	sub	sp,20
80003b88:	ef 4c ff f8 	st.w	r7[-8],r12
80003b8c:	16 98       	mov	r8,r11
80003b8e:	ef 4a ff f0 	st.w	r7[-16],r10
80003b92:	ef 49 ff ec 	st.w	r7[-20],r9
80003b96:	ef 68 ff f4 	st.b	r7[-12],r8

	/* Sanity Check */
	Assert( adcifa != NULL );

	/* wait for end of sequence */
	if (adcifa_check_eos(adcifa, sequencer) != true) {
80003b9a:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80003b9e:	10 9b       	mov	r11,r8
80003ba0:	ee fc ff f8 	ld.w	r12,r7[-8]
80003ba4:	f0 1f 00 2c 	mcall	80003c54 <adcifa_get_values_from_sequencer+0xd4>
80003ba8:	18 98       	mov	r8,r12
80003baa:	ec 18 00 01 	eorl	r8,0x1
80003bae:	5c 58       	castu.b	r8
80003bb0:	c0 30       	breq	80003bb6 <adcifa_get_values_from_sequencer+0x36>
		return ADCIFA_STATUS_NOT_COMPLETED;
80003bb2:	30 38       	mov	r8,3
80003bb4:	c4 b8       	rjmp	80003c4a <adcifa_get_values_from_sequencer+0xca>
	}

	switch (sequencer) {
80003bb6:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80003bba:	58 08       	cp.w	r8,0
80003bbc:	c0 40       	breq	80003bc4 <adcifa_get_values_from_sequencer+0x44>
80003bbe:	58 18       	cp.w	r8,1
80003bc0:	c2 30       	breq	80003c06 <adcifa_get_values_from_sequencer+0x86>
80003bc2:	c4 38       	rjmp	80003c48 <adcifa_get_values_from_sequencer+0xc8>
	case 0:
		/* Read values from Sequencer 0 */
		for (i = 0; i < p_adcifa_sequencer_opt->convnb; i++) {
80003bc4:	30 08       	mov	r8,0
80003bc6:	ef 68 ff ff 	st.b	r7[-1],r8
80003bca:	c1 58       	rjmp	80003bf4 <adcifa_get_values_from_sequencer+0x74>
			adcifa_values[i] = ADCIFA_read_resx_sequencer_0(i);
80003bcc:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80003bd0:	a1 78       	lsl	r8,0x1
80003bd2:	ee f9 ff ec 	ld.w	r9,r7[-20]
80003bd6:	10 09       	add	r9,r8
80003bd8:	fc 78 24 00 	mov	r8,-187392
80003bdc:	ef 3a ff ff 	ld.ub	r10,r7[-1]
80003be0:	2d fa       	sub	r10,-33
80003be2:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
80003be6:	5c 88       	casts.h	r8
80003be8:	b2 08       	st.h	r9[0x0],r8
	}

	switch (sequencer) {
	case 0:
		/* Read values from Sequencer 0 */
		for (i = 0; i < p_adcifa_sequencer_opt->convnb; i++) {
80003bea:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80003bee:	2f f8       	sub	r8,-1
80003bf0:	ef 68 ff ff 	st.b	r7[-1],r8
80003bf4:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003bf8:	11 88       	ld.ub	r8,r8[0x0]
80003bfa:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80003bfe:	f0 09 18 00 	cp.b	r9,r8
80003c02:	ce 53       	brcs	80003bcc <adcifa_get_values_from_sequencer+0x4c>
			adcifa_values[i] = ADCIFA_read_resx_sequencer_0(i);
		}
		break;
80003c04:	c2 28       	rjmp	80003c48 <adcifa_get_values_from_sequencer+0xc8>

	case 1:
		/* Read values from Sequencer 1 */
		for (i = 0; i < p_adcifa_sequencer_opt->convnb; i++) {
80003c06:	30 08       	mov	r8,0
80003c08:	ef 68 ff ff 	st.b	r7[-1],r8
80003c0c:	c1 68       	rjmp	80003c38 <adcifa_get_values_from_sequencer+0xb8>
			adcifa_values[i] = ADCIFA_read_resx_sequencer_1(i);
80003c0e:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80003c12:	a1 78       	lsl	r8,0x1
80003c14:	ee f9 ff ec 	ld.w	r9,r7[-20]
80003c18:	10 09       	add	r9,r8
80003c1a:	fc 78 24 00 	mov	r8,-187392
80003c1e:	ef 3a ff ff 	ld.ub	r10,r7[-1]
80003c22:	2f 8a       	sub	r10,-8
80003c24:	2d fa       	sub	r10,-33
80003c26:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
80003c2a:	5c 88       	casts.h	r8
80003c2c:	b2 08       	st.h	r9[0x0],r8
		}
		break;

	case 1:
		/* Read values from Sequencer 1 */
		for (i = 0; i < p_adcifa_sequencer_opt->convnb; i++) {
80003c2e:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80003c32:	2f f8       	sub	r8,-1
80003c34:	ef 68 ff ff 	st.b	r7[-1],r8
80003c38:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003c3c:	11 88       	ld.ub	r8,r8[0x0]
80003c3e:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80003c42:	f0 09 18 00 	cp.b	r9,r8
80003c46:	ce 43       	brcs	80003c0e <adcifa_get_values_from_sequencer+0x8e>

	default:
		break;
	}

	return ADCIFA_STATUS_COMPLETED;
80003c48:	30 28       	mov	r8,2
}
80003c4a:	10 9c       	mov	r12,r8
80003c4c:	2f bd       	sub	sp,-20
80003c4e:	e3 cd 80 80 	ldm	sp++,r7,pc
80003c52:	00 00       	add	r0,r0
80003c54:	80 00       	ld.sh	r0,r0[0x0]
80003c56:	3b 38       	mov	r8,-77

80003c58 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80003c58:	eb cd 40 80 	pushm	r7,lr
80003c5c:	1a 97       	mov	r7,sp
80003c5e:	20 4d       	sub	sp,16
80003c60:	ef 4c ff f4 	st.w	r7[-12],r12
80003c64:	ef 4b ff f0 	st.w	r7[-16],r11
	uint32_t status = GPIO_SUCCESS;
80003c68:	30 08       	mov	r8,0
80003c6a:	ef 48 ff f8 	st.w	r7[-8],r8
	uint32_t i;

	for (i = 0; i < size; i++) {
80003c6e:	30 08       	mov	r8,0
80003c70:	ef 48 ff fc 	st.w	r7[-4],r8
80003c74:	c1 c8       	rjmp	80003cac <gpio_enable_module+0x54>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
80003c76:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003c7a:	70 19       	ld.w	r9,r8[0x4]
80003c7c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003c80:	70 08       	ld.w	r8,r8[0x0]
80003c82:	12 9b       	mov	r11,r9
80003c84:	10 9c       	mov	r12,r8
80003c86:	f0 1f 00 10 	mcall	80003cc4 <gpio_enable_module+0x6c>
80003c8a:	18 98       	mov	r8,r12
80003c8c:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003c90:	f3 e8 10 08 	or	r8,r9,r8
80003c94:	ef 48 ff f8 	st.w	r7[-8],r8
		gpiomap++;
80003c98:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003c9c:	2f 88       	sub	r8,-8
80003c9e:	ef 48 ff f4 	st.w	r7[-12],r8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80003ca2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003ca6:	2f f8       	sub	r8,-1
80003ca8:	ef 48 ff fc 	st.w	r7[-4],r8
80003cac:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003cb0:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003cb4:	10 39       	cp.w	r9,r8
80003cb6:	ce 03       	brcs	80003c76 <gpio_enable_module+0x1e>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
80003cb8:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
80003cbc:	10 9c       	mov	r12,r8
80003cbe:	2f cd       	sub	sp,-16
80003cc0:	e3 cd 80 80 	ldm	sp++,r7,pc
80003cc4:	80 00       	ld.sh	r0,r0[0x0]
80003cc6:	3c c8       	mov	r8,-52

80003cc8 <gpio_enable_module_pin>:
 * \param function The pin function.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
80003cc8:	eb cd 40 80 	pushm	r7,lr
80003ccc:	1a 97       	mov	r7,sp
80003cce:	20 3d       	sub	sp,12
80003cd0:	ef 4c ff f8 	st.w	r7[-8],r12
80003cd4:	ef 4b ff f4 	st.w	r7[-12],r11
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80003cd8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003cdc:	a5 98       	lsr	r8,0x5
80003cde:	a9 78       	lsl	r8,0x9
80003ce0:	e0 28 e0 00 	sub	r8,57344
80003ce4:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Enable the correct function. */
	switch (function) {
80003ce8:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003cec:	58 78       	cp.w	r8,7
80003cee:	e0 8b 01 16 	brhi	80003f1a <gpio_enable_module_pin+0x252>
80003cf2:	fe f9 02 4e 	ld.w	r9,pc[590]
80003cf6:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80003cfa:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003cfe:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003d02:	30 19       	mov	r9,1
80003d04:	f2 08 09 48 	lsl	r8,r9,r8
80003d08:	10 99       	mov	r9,r8
80003d0a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003d0e:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80003d10:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003d14:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003d18:	30 19       	mov	r9,1
80003d1a:	f2 08 09 48 	lsl	r8,r9,r8
80003d1e:	10 99       	mov	r9,r8
80003d20:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003d24:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
80003d26:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003d2a:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003d2e:	30 19       	mov	r9,1
80003d30:	f2 08 09 48 	lsl	r8,r9,r8
80003d34:	10 99       	mov	r9,r8
80003d36:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003d3a:	91 e9       	st.w	r8[0x38],r9
#endif
		break;
80003d3c:	cf 18       	rjmp	80003f1e <gpio_enable_module_pin+0x256>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80003d3e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003d42:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003d46:	30 19       	mov	r9,1
80003d48:	f2 08 09 48 	lsl	r8,r9,r8
80003d4c:	10 99       	mov	r9,r8
80003d4e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003d52:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80003d54:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003d58:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003d5c:	30 19       	mov	r9,1
80003d5e:	f2 08 09 48 	lsl	r8,r9,r8
80003d62:	10 99       	mov	r9,r8
80003d64:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003d68:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
80003d6a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003d6e:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003d72:	30 19       	mov	r9,1
80003d74:	f2 08 09 48 	lsl	r8,r9,r8
80003d78:	10 99       	mov	r9,r8
80003d7a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003d7e:	91 e9       	st.w	r8[0x38],r9
#endif
		break;
80003d80:	cc f8       	rjmp	80003f1e <gpio_enable_module_pin+0x256>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80003d82:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003d86:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003d8a:	30 19       	mov	r9,1
80003d8c:	f2 08 09 48 	lsl	r8,r9,r8
80003d90:	10 99       	mov	r9,r8
80003d92:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003d96:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80003d98:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003d9c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003da0:	30 19       	mov	r9,1
80003da2:	f2 08 09 48 	lsl	r8,r9,r8
80003da6:	10 99       	mov	r9,r8
80003da8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003dac:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
80003dae:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003db2:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003db6:	30 19       	mov	r9,1
80003db8:	f2 08 09 48 	lsl	r8,r9,r8
80003dbc:	10 99       	mov	r9,r8
80003dbe:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003dc2:	91 e9       	st.w	r8[0x38],r9
#endif
		break;
80003dc4:	ca d8       	rjmp	80003f1e <gpio_enable_module_pin+0x256>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80003dc6:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003dca:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003dce:	30 19       	mov	r9,1
80003dd0:	f2 08 09 48 	lsl	r8,r9,r8
80003dd4:	10 99       	mov	r9,r8
80003dd6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003dda:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80003ddc:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003de0:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003de4:	30 19       	mov	r9,1
80003de6:	f2 08 09 48 	lsl	r8,r9,r8
80003dea:	10 99       	mov	r9,r8
80003dec:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003df0:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
80003df2:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003df6:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003dfa:	30 19       	mov	r9,1
80003dfc:	f2 08 09 48 	lsl	r8,r9,r8
80003e00:	10 99       	mov	r9,r8
80003e02:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003e06:	91 e9       	st.w	r8[0x38],r9
#endif
		break;
80003e08:	c8 b8       	rjmp	80003f1e <gpio_enable_module_pin+0x256>

#if (AVR32_GPIO_H_VERSION >= 210)
	case 4: /* E function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80003e0a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003e0e:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003e12:	30 19       	mov	r9,1
80003e14:	f2 08 09 48 	lsl	r8,r9,r8
80003e18:	10 99       	mov	r9,r8
80003e1a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003e1e:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80003e20:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003e24:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003e28:	30 19       	mov	r9,1
80003e2a:	f2 08 09 48 	lsl	r8,r9,r8
80003e2e:	10 99       	mov	r9,r8
80003e30:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003e34:	91 a9       	st.w	r8[0x28],r9
		gpio_port->pmr2s = 1 << (pin & 0x1F);
80003e36:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003e3a:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003e3e:	30 19       	mov	r9,1
80003e40:	f2 08 09 48 	lsl	r8,r9,r8
80003e44:	10 99       	mov	r9,r8
80003e46:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003e4a:	91 d9       	st.w	r8[0x34],r9
		break;
80003e4c:	c6 98       	rjmp	80003f1e <gpio_enable_module_pin+0x256>

	case 5: /* F function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80003e4e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003e52:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003e56:	30 19       	mov	r9,1
80003e58:	f2 08 09 48 	lsl	r8,r9,r8
80003e5c:	10 99       	mov	r9,r8
80003e5e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003e62:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80003e64:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003e68:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003e6c:	30 19       	mov	r9,1
80003e6e:	f2 08 09 48 	lsl	r8,r9,r8
80003e72:	10 99       	mov	r9,r8
80003e74:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003e78:	91 a9       	st.w	r8[0x28],r9
		gpio_port->pmr2s = 1 << (pin & 0x1F);
80003e7a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003e7e:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003e82:	30 19       	mov	r9,1
80003e84:	f2 08 09 48 	lsl	r8,r9,r8
80003e88:	10 99       	mov	r9,r8
80003e8a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003e8e:	91 d9       	st.w	r8[0x34],r9
		break;
80003e90:	c4 78       	rjmp	80003f1e <gpio_enable_module_pin+0x256>

	case 6: /* G function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80003e92:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003e96:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003e9a:	30 19       	mov	r9,1
80003e9c:	f2 08 09 48 	lsl	r8,r9,r8
80003ea0:	10 99       	mov	r9,r8
80003ea2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003ea6:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80003ea8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003eac:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003eb0:	30 19       	mov	r9,1
80003eb2:	f2 08 09 48 	lsl	r8,r9,r8
80003eb6:	10 99       	mov	r9,r8
80003eb8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003ebc:	91 99       	st.w	r8[0x24],r9
		gpio_port->pmr2s = 1 << (pin & 0x1F);
80003ebe:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003ec2:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003ec6:	30 19       	mov	r9,1
80003ec8:	f2 08 09 48 	lsl	r8,r9,r8
80003ecc:	10 99       	mov	r9,r8
80003ece:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003ed2:	91 d9       	st.w	r8[0x34],r9
		break;
80003ed4:	c2 58       	rjmp	80003f1e <gpio_enable_module_pin+0x256>

	case 7: /* H function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80003ed6:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003eda:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003ede:	30 19       	mov	r9,1
80003ee0:	f2 08 09 48 	lsl	r8,r9,r8
80003ee4:	10 99       	mov	r9,r8
80003ee6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003eea:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80003eec:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003ef0:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003ef4:	30 19       	mov	r9,1
80003ef6:	f2 08 09 48 	lsl	r8,r9,r8
80003efa:	10 99       	mov	r9,r8
80003efc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003f00:	91 99       	st.w	r8[0x24],r9
		gpio_port->pmr2s = 1 << (pin & 0x1F);
80003f02:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003f06:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003f0a:	30 19       	mov	r9,1
80003f0c:	f2 08 09 48 	lsl	r8,r9,r8
80003f10:	10 99       	mov	r9,r8
80003f12:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003f16:	91 d9       	st.w	r8[0x34],r9
		break;
80003f18:	c0 38       	rjmp	80003f1e <gpio_enable_module_pin+0x256>
#endif

	default:
		return GPIO_INVALID_ARGUMENT;
80003f1a:	30 18       	mov	r8,1
80003f1c:	c0 d8       	rjmp	80003f36 <gpio_enable_module_pin+0x26e>
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80003f1e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003f22:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003f26:	30 19       	mov	r9,1
80003f28:	f2 08 09 48 	lsl	r8,r9,r8
80003f2c:	10 99       	mov	r9,r8
80003f2e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003f32:	91 29       	st.w	r8[0x8],r9

	return GPIO_SUCCESS;
80003f34:	30 08       	mov	r8,0
}
80003f36:	10 9c       	mov	r12,r8
80003f38:	2f dd       	sub	sp,-12
80003f3a:	e3 cd 80 80 	ldm	sp++,r7,pc
80003f3e:	00 00       	add	r0,r0
80003f40:	80 00       	ld.sh	r0,r0[0x0]
80003f42:	78 20       	ld.w	r0,r12[0x8]

80003f44 <gpio_configure_pin>:
 *
 * \param pin The pin number.
 * \param flags The configuration.
 */
void gpio_configure_pin(uint32_t pin, uint32_t flags)
{
80003f44:	eb cd 40 80 	pushm	r7,lr
80003f48:	1a 97       	mov	r7,sp
80003f4a:	20 3d       	sub	sp,12
80003f4c:	ef 4c ff f8 	st.w	r7[-8],r12
80003f50:	ef 4b ff f4 	st.w	r7[-12],r11
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80003f54:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003f58:	a5 98       	lsr	r8,0x5
80003f5a:	a9 78       	lsl	r8,0x9
80003f5c:	e0 28 e0 00 	sub	r8,57344
80003f60:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Both pull-up and pull-down set means buskeeper */
#if defined(AVR32_GPIO_200_H_INCLUDED) || defined(AVR32_GPIO_210_H_INCLUDED) ||	\
	defined(AVR32_GPIO_212_H_INCLUDED)
	if (flags & GPIO_PULL_DOWN) {
80003f64:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003f68:	e2 18 00 08 	andl	r8,0x8,COH
80003f6c:	c0 e0       	breq	80003f88 <gpio_configure_pin+0x44>
		gpio_port->pders = 1 << (pin & 0x1F);
80003f6e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003f72:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003f76:	30 19       	mov	r9,1
80003f78:	f2 08 09 48 	lsl	r8,r9,r8
80003f7c:	10 99       	mov	r9,r8
80003f7e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003f82:	f1 49 00 84 	st.w	r8[132],r9
80003f86:	c0 d8       	rjmp	80003fa0 <gpio_configure_pin+0x5c>
	} else {
		gpio_port->pderc = 1 << (pin & 0x1F);
80003f88:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003f8c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003f90:	30 19       	mov	r9,1
80003f92:	f2 08 09 48 	lsl	r8,r9,r8
80003f96:	10 99       	mov	r9,r8
80003f98:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003f9c:	f1 49 00 88 	st.w	r8[136],r9
	}

#endif
	if (flags & GPIO_PULL_UP) {
80003fa0:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003fa4:	e2 18 00 04 	andl	r8,0x4,COH
80003fa8:	c0 e0       	breq	80003fc4 <gpio_configure_pin+0x80>
		gpio_port->puers = 1 << (pin & 0x1F);
80003faa:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003fae:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003fb2:	30 19       	mov	r9,1
80003fb4:	f2 08 09 48 	lsl	r8,r9,r8
80003fb8:	10 99       	mov	r9,r8
80003fba:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003fbe:	f1 49 00 74 	st.w	r8[116],r9
80003fc2:	c0 d8       	rjmp	80003fdc <gpio_configure_pin+0x98>
	} else {
		gpio_port->puerc = 1 << (pin & 0x1F);
80003fc4:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003fc8:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003fcc:	30 19       	mov	r9,1
80003fce:	f2 08 09 48 	lsl	r8,r9,r8
80003fd2:	10 99       	mov	r9,r8
80003fd4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003fd8:	f1 49 00 78 	st.w	r8[120],r9
	}

	/* Enable open-drain mode if requested */
#if defined(AVR32_GPIO_200_H_INCLUDED) || defined(AVR32_GPIO_210_H_INCLUDED) ||	\
	defined(AVR32_GPIO_212_H_INCLUDED)
	if (flags & GPIO_OPEN_DRAIN) {
80003fdc:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003fe0:	e2 18 00 40 	andl	r8,0x40,COH
80003fe4:	c0 e0       	breq	80004000 <gpio_configure_pin+0xbc>
		gpio_port->odmers = 1 << (pin & 0x1F);
80003fe6:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003fea:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003fee:	30 19       	mov	r9,1
80003ff0:	f2 08 09 48 	lsl	r8,r9,r8
80003ff4:	10 99       	mov	r9,r8
80003ff6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003ffa:	f1 49 00 e4 	st.w	r8[228],r9
80003ffe:	c0 d8       	rjmp	80004018 <gpio_configure_pin+0xd4>
	} else {
		gpio_port->odmerc = 1 << (pin & 0x1F);
80004000:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004004:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004008:	30 19       	mov	r9,1
8000400a:	f2 08 09 48 	lsl	r8,r9,r8
8000400e:	10 99       	mov	r9,r8
80004010:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004014:	f1 49 00 e8 	st.w	r8[232],r9
#endif

#if defined(AVR32_GPIO_200_H_INCLUDED) || defined(AVR32_GPIO_210_H_INCLUDED) ||	\
	defined(AVR32_GPIO_212_H_INCLUDED)
	/* Select drive strength */
	if (flags & GPIO_DRIVE_LOW) {
80004018:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000401c:	e2 18 00 10 	andl	r8,0x10,COH
80004020:	c0 e0       	breq	8000403c <gpio_configure_pin+0xf8>
		gpio_port->odcr0s = 1 << (pin & 0x1F);
80004022:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004026:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000402a:	30 19       	mov	r9,1
8000402c:	f2 08 09 48 	lsl	r8,r9,r8
80004030:	10 99       	mov	r9,r8
80004032:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004036:	f1 49 01 04 	st.w	r8[260],r9
8000403a:	c0 d8       	rjmp	80004054 <gpio_configure_pin+0x110>
	} else {
		gpio_port->odcr0c = 1 << (pin & 0x1F);
8000403c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004040:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004044:	30 19       	mov	r9,1
80004046:	f2 08 09 48 	lsl	r8,r9,r8
8000404a:	10 99       	mov	r9,r8
8000404c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004050:	f1 49 01 08 	st.w	r8[264],r9
	}

	if (flags & GPIO_DRIVE_HIGH) {
80004054:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004058:	e2 18 00 20 	andl	r8,0x20,COH
8000405c:	c0 e0       	breq	80004078 <gpio_configure_pin+0x134>
		gpio_port->odcr1s = 1 << (pin & 0x1F);
8000405e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004062:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004066:	30 19       	mov	r9,1
80004068:	f2 08 09 48 	lsl	r8,r9,r8
8000406c:	10 99       	mov	r9,r8
8000406e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004072:	f1 49 01 14 	st.w	r8[276],r9
80004076:	c0 d8       	rjmp	80004090 <gpio_configure_pin+0x14c>
	} else {
		gpio_port->odcr1c = 1 << (pin & 0x1F);
80004078:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000407c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004080:	30 19       	mov	r9,1
80004082:	f2 08 09 48 	lsl	r8,r9,r8
80004086:	10 99       	mov	r9,r8
80004088:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000408c:	f1 49 01 18 	st.w	r8[280],r9
	}

#endif

	/* Select interrupt level for group */
	if (flags & GPIO_INTERRUPT) {
80004090:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004094:	e2 18 00 80 	andl	r8,0x80,COH
80004098:	c5 a0       	breq	8000414c <gpio_configure_pin+0x208>
		if (flags & GPIO_BOTHEDGES) {
8000409a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000409e:	e2 18 01 80 	andl	r8,0x180,COH
800040a2:	c1 a0       	breq	800040d6 <gpio_configure_pin+0x192>
			gpio_port->imr0c = 1 << (pin & 0x1F);
800040a4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800040a8:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800040ac:	30 19       	mov	r9,1
800040ae:	f2 08 09 48 	lsl	r8,r9,r8
800040b2:	10 99       	mov	r9,r8
800040b4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800040b8:	f1 49 00 a8 	st.w	r8[168],r9
			gpio_port->imr1c = 1 << (pin & 0x1F);
800040bc:	ee f8 ff f8 	ld.w	r8,r7[-8]
800040c0:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800040c4:	30 19       	mov	r9,1
800040c6:	f2 08 09 48 	lsl	r8,r9,r8
800040ca:	10 99       	mov	r9,r8
800040cc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800040d0:	f1 49 00 b8 	st.w	r8[184],r9
800040d4:	c3 c8       	rjmp	8000414c <gpio_configure_pin+0x208>
		} else if (flags & GPIO_RISING) {
800040d6:	ee f8 ff f4 	ld.w	r8,r7[-12]
800040da:	e2 18 02 80 	andl	r8,0x280,COH
800040de:	c1 a0       	breq	80004112 <gpio_configure_pin+0x1ce>
			gpio_port->imr0s = 1 << (pin & 0x1F);
800040e0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800040e4:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800040e8:	30 19       	mov	r9,1
800040ea:	f2 08 09 48 	lsl	r8,r9,r8
800040ee:	10 99       	mov	r9,r8
800040f0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800040f4:	f1 49 00 a4 	st.w	r8[164],r9
			gpio_port->imr1c = 1 << (pin & 0x1F);
800040f8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800040fc:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004100:	30 19       	mov	r9,1
80004102:	f2 08 09 48 	lsl	r8,r9,r8
80004106:	10 99       	mov	r9,r8
80004108:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000410c:	f1 49 00 b8 	st.w	r8[184],r9
80004110:	c1 e8       	rjmp	8000414c <gpio_configure_pin+0x208>
		} else if (flags & GPIO_FALLING) {
80004112:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004116:	e2 18 03 80 	andl	r8,0x380,COH
8000411a:	c1 90       	breq	8000414c <gpio_configure_pin+0x208>
			gpio_port->imr0c = 1 << (pin & 0x1F);
8000411c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004120:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004124:	30 19       	mov	r9,1
80004126:	f2 08 09 48 	lsl	r8,r9,r8
8000412a:	10 99       	mov	r9,r8
8000412c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004130:	f1 49 00 a8 	st.w	r8[168],r9
			gpio_port->imr1s = 1 << (pin & 0x1F);
80004134:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004138:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000413c:	30 19       	mov	r9,1
8000413e:	f2 08 09 48 	lsl	r8,r9,r8
80004142:	10 99       	mov	r9,r8
80004144:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004148:	f1 49 00 b4 	st.w	r8[180],r9
		}
	}

	/* Select direction and initial pin state */
	if (flags & GPIO_DIR_OUTPUT) {
8000414c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004150:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004154:	5c 58       	castu.b	r8
80004156:	c2 c0       	breq	800041ae <gpio_configure_pin+0x26a>
		if (flags & GPIO_INIT_HIGH) {
80004158:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000415c:	e2 18 00 02 	andl	r8,0x2,COH
80004160:	c0 e0       	breq	8000417c <gpio_configure_pin+0x238>
			gpio_port->ovrs = 1 << (pin & 0x1F);
80004162:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004166:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000416a:	30 19       	mov	r9,1
8000416c:	f2 08 09 48 	lsl	r8,r9,r8
80004170:	10 99       	mov	r9,r8
80004172:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004176:	f1 49 00 54 	st.w	r8[84],r9
8000417a:	c0 d8       	rjmp	80004194 <gpio_configure_pin+0x250>
		} else {
			gpio_port->ovrc = 1 << (pin & 0x1F);
8000417c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004180:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004184:	30 19       	mov	r9,1
80004186:	f2 08 09 48 	lsl	r8,r9,r8
8000418a:	10 99       	mov	r9,r8
8000418c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004190:	f1 49 00 58 	st.w	r8[88],r9
		}

		gpio_port->oders = 1 << (pin & 0x1F);
80004194:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004198:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000419c:	30 19       	mov	r9,1
8000419e:	f2 08 09 48 	lsl	r8,r9,r8
800041a2:	10 99       	mov	r9,r8
800041a4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800041a8:	f1 49 00 44 	st.w	r8[68],r9
800041ac:	c0 d8       	rjmp	800041c6 <gpio_configure_pin+0x282>
	} else {
		gpio_port->oderc = 1 << (pin & 0x1F);
800041ae:	ee f8 ff f8 	ld.w	r8,r7[-8]
800041b2:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800041b6:	30 19       	mov	r9,1
800041b8:	f2 08 09 48 	lsl	r8,r9,r8
800041bc:	10 99       	mov	r9,r8
800041be:	ee f8 ff fc 	ld.w	r8,r7[-4]
800041c2:	f1 49 00 48 	st.w	r8[72],r9
	}

	/* Enable GPIO */
	gpio_port->gpers = 1 << (pin & 0x1F);
800041c6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800041ca:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800041ce:	30 19       	mov	r9,1
800041d0:	f2 08 09 48 	lsl	r8,r9,r8
800041d4:	10 99       	mov	r9,r8
800041d6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800041da:	91 19       	st.w	r8[0x4],r9
}
800041dc:	2f dd       	sub	sp,-12
800041de:	e3 cd 80 80 	ldm	sp++,r7,pc

800041e2 <gpio_get_pin_value>:
 * \param pin The pin number.
 *
 * \return The pin value.
 */
bool gpio_get_pin_value(uint32_t pin)
{
800041e2:	eb cd 40 80 	pushm	r7,lr
800041e6:	1a 97       	mov	r7,sp
800041e8:	20 2d       	sub	sp,8
800041ea:	ef 4c ff f8 	st.w	r7[-8],r12
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800041ee:	ee f8 ff f8 	ld.w	r8,r7[-8]
800041f2:	a5 98       	lsr	r8,0x5
800041f4:	a9 78       	lsl	r8,0x9
800041f6:	e0 28 e0 00 	sub	r8,57344
800041fa:	ef 48 ff fc 	st.w	r7[-4],r8
	
	return (gpio_port->pvr >> (pin & 0x1F)) & 1;
800041fe:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004202:	71 89       	ld.w	r9,r8[0x60]
80004204:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004208:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000420c:	f2 08 0a 48 	lsr	r8,r9,r8
80004210:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004214:	5c 58       	castu.b	r8
}
80004216:	10 9c       	mov	r12,r8
80004218:	2f ed       	sub	sp,-8
8000421a:	e3 cd 80 80 	ldm	sp++,r7,pc

8000421e <gpio_set_pin_high>:
 * \param pin The pin number.
 *
 * \note The function \ref gpio_configure_pin must be called before.
 */
void gpio_set_pin_high(uint32_t pin)
{
8000421e:	eb cd 40 80 	pushm	r7,lr
80004222:	1a 97       	mov	r7,sp
80004224:	20 2d       	sub	sp,8
80004226:	ef 4c ff f8 	st.w	r7[-8],r12
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000422a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000422e:	a5 98       	lsr	r8,0x5
80004230:	a9 78       	lsl	r8,0x9
80004232:	e0 28 e0 00 	sub	r8,57344
80004236:	ef 48 ff fc 	st.w	r7[-4],r8
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
8000423a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000423e:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004242:	30 19       	mov	r9,1
80004244:	f2 08 09 48 	lsl	r8,r9,r8
80004248:	10 99       	mov	r9,r8
8000424a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000424e:	f1 49 00 54 	st.w	r8[84],r9
}
80004252:	2f ed       	sub	sp,-8
80004254:	e3 cd 80 80 	ldm	sp++,r7,pc

80004258 <gpio_set_pin_low>:
 * \param pin The pin number.
 *
 * \note The function \ref gpio_configure_pin must be called before.
 */
void gpio_set_pin_low(uint32_t pin)
{
80004258:	eb cd 40 80 	pushm	r7,lr
8000425c:	1a 97       	mov	r7,sp
8000425e:	20 2d       	sub	sp,8
80004260:	ef 4c ff f8 	st.w	r7[-8],r12
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80004264:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004268:	a5 98       	lsr	r8,0x5
8000426a:	a9 78       	lsl	r8,0x9
8000426c:	e0 28 e0 00 	sub	r8,57344
80004270:	ef 48 ff fc 	st.w	r7[-4],r8
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
80004274:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004278:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000427c:	30 19       	mov	r9,1
8000427e:	f2 08 09 48 	lsl	r8,r9,r8
80004282:	10 99       	mov	r9,r8
80004284:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004288:	f1 49 00 58 	st.w	r8[88],r9
}
8000428c:	2f ed       	sub	sp,-8
8000428e:	e3 cd 80 80 	ldm	sp++,r7,pc

80004292 <gpio_toggle_pin>:
 * \param pin The pin number.
 *
 * \note The function \ref gpio_configure_pin must be called before.
 */
void gpio_toggle_pin(uint32_t pin)
{
80004292:	eb cd 40 80 	pushm	r7,lr
80004296:	1a 97       	mov	r7,sp
80004298:	20 2d       	sub	sp,8
8000429a:	ef 4c ff f8 	st.w	r7[-8],r12
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000429e:	ee f8 ff f8 	ld.w	r8,r7[-8]
800042a2:	a5 98       	lsr	r8,0x5
800042a4:	a9 78       	lsl	r8,0x9
800042a6:	e0 28 e0 00 	sub	r8,57344
800042aa:	ef 48 ff fc 	st.w	r7[-4],r8
	
	/* Toggle the I/O line. */
	gpio_port->ovrt  = 1 << (pin & 0x1F);
800042ae:	ee f8 ff f8 	ld.w	r8,r7[-8]
800042b2:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800042b6:	30 19       	mov	r9,1
800042b8:	f2 08 09 48 	lsl	r8,r9,r8
800042bc:	10 99       	mov	r9,r8
800042be:	ee f8 ff fc 	ld.w	r8,r7[-4]
800042c2:	f1 49 00 5c 	st.w	r8[92],r9
}
800042c6:	2f ed       	sub	sp,-8
800042c8:	e3 cd 80 80 	ldm	sp++,r7,pc

800042cc <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
800042cc:	eb cd 40 80 	pushm	r7,lr
800042d0:	1a 97       	mov	r7,sp
	// Catch unregistered interrupts.
	while (true);
800042d2:	c0 08       	rjmp	800042d2 <_unhandled_interrupt+0x6>

800042d4 <_get_interrupt_handler>:
 *
 * \return Interrupt handler to execute.
 */
__int_handler _get_interrupt_handler(uint32_t int_level);
__int_handler _get_interrupt_handler(uint32_t int_level)
{
800042d4:	eb cd 40 80 	pushm	r7,lr
800042d8:	1a 97       	mov	r7,sp
800042da:	20 3d       	sub	sp,12
800042dc:	ef 4c ff f4 	st.w	r7[-12],r12
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
800042e0:	fe 78 00 00 	mov	r8,-65536
800042e4:	ee f9 ff f4 	ld.w	r9,r7[-12]
800042e8:	f2 09 11 03 	rsub	r9,r9,3
800042ec:	28 09       	sub	r9,-128
800042ee:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
800042f2:	ef 48 ff f8 	st.w	r7[-8],r8
	uint32_t int_req = AVR32_INTC.irr[int_grp];
800042f6:	fe 78 00 00 	mov	r8,-65536
800042fa:	ee f9 ff f8 	ld.w	r9,r7[-8]
800042fe:	2c 09       	sub	r9,-64
80004300:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80004304:	ef 48 ff fc 	st.w	r7[-4],r8
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80004308:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000430c:	58 08       	cp.w	r8,0
8000430e:	c1 30       	breq	80004334 <_get_interrupt_handler+0x60>
		? _int_handler_table[int_grp]._int_line_handler_table[32
80004310:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004314:	48 b8       	lddpc	r8,80004340 <_get_interrupt_handler+0x6c>
80004316:	a1 79       	lsl	r9,0x1
80004318:	2f f9       	sub	r9,-1
8000431a:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
8000431e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004322:	f0 08 12 00 	clz	r8,r8
80004326:	f0 08 11 1f 	rsub	r8,r8,31
			- clz(int_req) - 1]
8000432a:	a3 68       	lsl	r8,0x2
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
		? _int_handler_table[int_grp]._int_line_handler_table[32
8000432c:	f2 08 00 08 	add	r8,r9,r8
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80004330:	70 08       	ld.w	r8,r8[0x0]
80004332:	c0 28       	rjmp	80004336 <_get_interrupt_handler+0x62>
80004334:	30 08       	mov	r8,0
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80004336:	10 9c       	mov	r12,r8
80004338:	2f dd       	sub	sp,-12
8000433a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000433e:	00 00       	add	r0,r0
80004340:	80 00       	ld.sh	r0,r0[0x0]
80004342:	78 40       	ld.w	r0,r12[0x10]

80004344 <INTC_init_evba>:
 * \internal
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
80004344:	eb cd 40 80 	pushm	r7,lr
80004348:	1a 97       	mov	r7,sp
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
8000434a:	48 38       	lddpc	r8,80004354 <INTC_init_evba+0x10>
8000434c:	e3 b8 00 01 	mtsr	0x4,r8
}
80004350:	e3 cd 80 80 	ldm	sp++,r7,pc
80004354:	80 00       	ld.sh	r0,r0[0x0]
80004356:	76 00       	ld.w	r0,r11[0x0]

80004358 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80004358:	eb cd 40 80 	pushm	r7,lr
8000435c:	1a 97       	mov	r7,sp
8000435e:	20 2d       	sub	sp,8
	uint32_t int_grp, int_req;

	INTC_init_evba();
80004360:	f0 1f 00 20 	mcall	800043e0 <INTC_init_interrupts+0x88>

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80004364:	30 08       	mov	r8,0
80004366:	ef 48 ff f8 	st.w	r7[-8],r8
8000436a:	c3 18       	rjmp	800043cc <INTC_init_interrupts+0x74>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000436c:	30 08       	mov	r8,0
8000436e:	ef 48 ff fc 	st.w	r7[-4],r8
80004372:	c1 48       	rjmp	8000439a <INTC_init_interrupts+0x42>
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80004374:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004378:	49 b8       	lddpc	r8,800043e4 <INTC_init_interrupts+0x8c>
8000437a:	a1 79       	lsl	r9,0x1
8000437c:	2f f9       	sub	r9,-1
8000437e:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
80004382:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004386:	a3 68       	lsl	r8,0x2
80004388:	f2 08 00 08 	add	r8,r9,r8
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
8000438c:	49 79       	lddpc	r9,800043e8 <INTC_init_interrupts+0x90>
8000438e:	91 09       	st.w	r8[0x0],r9
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80004390:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004394:	2f f8       	sub	r8,-1
80004396:	ef 48 ff fc 	st.w	r7[-4],r8
	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
8000439a:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000439e:	49 28       	lddpc	r8,800043e4 <INTC_init_interrupts+0x8c>
800043a0:	f0 09 03 39 	ld.w	r9,r8[r9<<0x3]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800043a4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800043a8:	10 39       	cp.w	r9,r8
800043aa:	fe 9b ff e5 	brhi	80004374 <INTC_init_interrupts+0x1c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800043ae:	fe 78 00 00 	mov	r8,-65536
800043b2:	ee f9 ff f8 	ld.w	r9,r7[-8]
800043b6:	48 eb       	lddpc	r11,800043ec <INTC_init_interrupts+0x94>
800043b8:	48 ea       	lddpc	r10,800043f0 <INTC_init_interrupts+0x98>
800043ba:	f6 0a 01 0a 	sub	r10,r11,r10
800043be:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
800043c2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800043c6:	2f f8       	sub	r8,-1
800043c8:	ef 48 ff f8 	st.w	r7[-8],r8
800043cc:	ee f8 ff f8 	ld.w	r8,r7[-8]
800043d0:	e0 48 00 2e 	cp.w	r8,46
800043d4:	fe 98 ff cc 	brls	8000436c <INTC_init_interrupts+0x14>
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
	}
}
800043d8:	2f ed       	sub	sp,-8
800043da:	e3 cd 80 80 	ldm	sp++,r7,pc
800043de:	00 00       	add	r0,r0
800043e0:	80 00       	ld.sh	r0,r0[0x0]
800043e2:	43 44       	lddsp	r4,sp[0xd0]
800043e4:	80 00       	ld.sh	r0,r0[0x0]
800043e6:	78 40       	ld.w	r0,r12[0x10]
800043e8:	80 00       	ld.sh	r0,r0[0x0]
800043ea:	42 cc       	lddsp	r12,sp[0xb0]
800043ec:	80 00       	ld.sh	r0,r0[0x0]
800043ee:	77 04       	ld.w	r4,r11[0x40]
800043f0:	80 00       	ld.sh	r0,r0[0x0]
800043f2:	76 00       	ld.w	r0,r11[0x0]

800043f4 <INTC_register_interrupt>:
 *          be effective.
 *
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
800043f4:	eb cd 40 80 	pushm	r7,lr
800043f8:	1a 97       	mov	r7,sp
800043fa:	20 4d       	sub	sp,16
800043fc:	ef 4c ff f8 	st.w	r7[-8],r12
80004400:	ef 4b ff f4 	st.w	r7[-12],r11
80004404:	ef 4a ff f0 	st.w	r7[-16],r10
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80004408:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000440c:	a5 98       	lsr	r8,0x5
8000440e:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80004412:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004416:	4a 78       	lddpc	r8,800044b0 <INTC_register_interrupt+0xbc>
80004418:	a1 79       	lsl	r9,0x1
8000441a:	2f f9       	sub	r9,-1
8000441c:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
80004420:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004424:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004428:	a3 68       	lsl	r8,0x2
8000442a:	f2 08 00 08 	add	r8,r9,r8
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
8000442e:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004432:	91 09       	st.w	r8[0x0],r9
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80004434:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004438:	58 08       	cp.w	r8,0
8000443a:	c0 c1       	brne	80004452 <INTC_register_interrupt+0x5e>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
8000443c:	fe 78 00 00 	mov	r8,-65536
80004440:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004444:	49 cb       	lddpc	r11,800044b4 <INTC_register_interrupt+0xc0>
80004446:	49 da       	lddpc	r10,800044b8 <INTC_register_interrupt+0xc4>
80004448:	f6 0a 01 0a 	sub	r10,r11,r10
8000444c:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
80004450:	c2 d8       	rjmp	800044aa <INTC_register_interrupt+0xb6>
	} else if (int_level == AVR32_INTC_INT1) {
80004452:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004456:	58 18       	cp.w	r8,1
80004458:	c0 d1       	brne	80004472 <INTC_register_interrupt+0x7e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
8000445a:	fe 78 00 00 	mov	r8,-65536
8000445e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004462:	49 7b       	lddpc	r11,800044bc <INTC_register_interrupt+0xc8>
80004464:	49 5a       	lddpc	r10,800044b8 <INTC_register_interrupt+0xc4>
80004466:	f6 0a 01 0a 	sub	r10,r11,r10
8000446a:	bf aa       	sbr	r10,0x1e
8000446c:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
80004470:	c1 d8       	rjmp	800044aa <INTC_register_interrupt+0xb6>
	} else if (int_level == AVR32_INTC_INT2) {
80004472:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004476:	58 28       	cp.w	r8,2
80004478:	c0 d1       	brne	80004492 <INTC_register_interrupt+0x9e>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
8000447a:	fe 78 00 00 	mov	r8,-65536
8000447e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004482:	49 0b       	lddpc	r11,800044c0 <INTC_register_interrupt+0xcc>
80004484:	48 da       	lddpc	r10,800044b8 <INTC_register_interrupt+0xc4>
80004486:	f6 0a 01 0a 	sub	r10,r11,r10
8000448a:	bf ba       	sbr	r10,0x1f
8000448c:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
80004490:	c0 d8       	rjmp	800044aa <INTC_register_interrupt+0xb6>
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80004492:	fe 78 00 00 	mov	r8,-65536
80004496:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000449a:	48 bb       	lddpc	r11,800044c4 <INTC_register_interrupt+0xd0>
8000449c:	48 7a       	lddpc	r10,800044b8 <INTC_register_interrupt+0xc4>
8000449e:	f6 0a 01 0a 	sub	r10,r11,r10
800044a2:	ea 1a c0 00 	orh	r10,0xc000
800044a6:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
	}
}
800044aa:	2f cd       	sub	sp,-16
800044ac:	e3 cd 80 80 	ldm	sp++,r7,pc
800044b0:	80 00       	ld.sh	r0,r0[0x0]
800044b2:	78 40       	ld.w	r0,r12[0x10]
800044b4:	80 00       	ld.sh	r0,r0[0x0]
800044b6:	77 04       	ld.w	r4,r11[0x40]
800044b8:	80 00       	ld.sh	r0,r0[0x0]
800044ba:	76 00       	ld.w	r0,r11[0x0]
800044bc:	80 00       	ld.sh	r0,r0[0x0]
800044be:	77 12       	ld.w	r2,r11[0x44]
800044c0:	80 00       	ld.sh	r0,r0[0x0]
800044c2:	77 20       	ld.w	r0,r11[0x48]
800044c4:	80 00       	ld.sh	r0,r0[0x0]
800044c6:	77 2e       	ld.w	lr,r11[0x48]

800044c8 <cpu_irq_is_enabled_flags>:

	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
800044c8:	eb cd 40 80 	pushm	r7,lr
800044cc:	1a 97       	mov	r7,sp
800044ce:	20 1d       	sub	sp,4
800044d0:	ef 4c ff fc 	st.w	r7[-4],r12
	return !(flags & AVR32_SR_GM_MASK);
800044d4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800044d8:	e6 18 00 01 	andh	r8,0x1,COH
800044dc:	5f 08       	sreq	r8
800044de:	5c 58       	castu.b	r8
}
800044e0:	10 9c       	mov	r12,r8
800044e2:	2f fd       	sub	sp,-4
800044e4:	e3 cd 80 80 	ldm	sp++,r7,pc

800044e8 <pm_set_mclk_source>:
/**
 ** Clock Functions
 **/

long pm_set_mclk_source(pm_clk_src_t src)
{
800044e8:	eb cd 40 80 	pushm	r7,lr
800044ec:	1a 97       	mov	r7,sp
800044ee:	20 2d       	sub	sp,8
800044f0:	ef 4c ff f8 	st.w	r7[-8],r12
  // Unlock the write-protected MCCTRL register
  AVR32_ENTER_CRITICAL_REGION( );
800044f4:	e1 b8 00 00 	mfsr	r8,0x0
800044f8:	10 9c       	mov	r12,r8
800044fa:	f0 1f 00 0f 	mcall	80004534 <pm_set_mclk_source+0x4c>
800044fe:	18 98       	mov	r8,r12
80004500:	ef 68 ff ff 	st.b	r7[-1],r8
80004504:	d3 03       	ssrf	0x10
  PM_UNLOCK(AVR32_PM_MCCTRL);
80004506:	fe 78 04 00 	mov	r8,-64512
8000450a:	fc 19 aa 00 	movh	r9,0xaa00
8000450e:	f1 49 00 58 	st.w	r8[88],r9
  AVR32_PM.mcctrl = src;
80004512:	fe 78 04 00 	mov	r8,-64512
80004516:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000451a:	91 09       	st.w	r8[0x0],r9
  AVR32_LEAVE_CRITICAL_REGION( );
8000451c:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80004520:	30 08       	mov	r8,0
80004522:	f0 09 18 00 	cp.b	r9,r8
80004526:	c0 20       	breq	8000452a <pm_set_mclk_source+0x42>
80004528:	d5 03       	csrf	0x10

  return PASS;
8000452a:	30 08       	mov	r8,0
}
8000452c:	10 9c       	mov	r12,r8
8000452e:	2f ed       	sub	sp,-8
80004530:	e3 cd 80 80 	ldm	sp++,r7,pc
80004534:	80 00       	ld.sh	r0,r0[0x0]
80004536:	44 c8       	lddsp	r8,sp[0x130]

80004538 <cpu_irq_is_enabled_flags>:

	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
80004538:	eb cd 40 80 	pushm	r7,lr
8000453c:	1a 97       	mov	r7,sp
8000453e:	20 1d       	sub	sp,4
80004540:	ef 4c ff fc 	st.w	r7[-4],r12
	return !(flags & AVR32_SR_GM_MASK);
80004544:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004548:	e6 18 00 01 	andh	r8,0x1,COH
8000454c:	5f 08       	sreq	r8
8000454e:	5c 58       	castu.b	r8
}
80004550:	10 9c       	mov	r12,r8
80004552:	2f fd       	sub	sp,-4
80004554:	e3 cd 80 80 	ldm	sp++,r7,pc

80004558 <scif_start_rc8M>:
/**
 ** 8MHz RCosc Functions
 **/

void scif_start_rc8M(void)
{
80004558:	eb cd 40 80 	pushm	r7,lr
8000455c:	1a 97       	mov	r7,sp
8000455e:	20 3d       	sub	sp,12
  unsigned int* calibration_bits = (unsigned int*)0x80800200;
80004560:	e0 68 02 00 	mov	r8,512
80004564:	ea 18 80 80 	orh	r8,0x8080
80004568:	ef 48 ff f4 	st.w	r7[-12],r8
  unsigned long tmp1;
  
  AVR32_ENTER_CRITICAL_REGION( );
8000456c:	e1 b8 00 00 	mfsr	r8,0x0
80004570:	10 9c       	mov	r12,r8
80004572:	f0 1f 00 19 	mcall	800045d4 <scif_start_rc8M+0x7c>
80004576:	18 98       	mov	r8,r12
80004578:	ef 68 ff ff 	st.b	r7[-1],r8
8000457c:	d3 03       	ssrf	0x10
  // Unlock the write-protected RC8MCR register
  SCIF_UNLOCK(AVR32_SCIF_RCCR8);
8000457e:	fe 78 08 00 	mov	r8,-63488
80004582:	34 89       	mov	r9,72
80004584:	ea 19 aa 00 	orh	r9,0xaa00
80004588:	91 69       	st.w	r8[0x18],r9
   * NOTE: Datasheet says that LS byte is for 8MHz at 3.3V, and byte[2] is for 8MHz at 5V so that's the one we really want 7apr15
   */
  
//debug AVR32_SCIF.rccr8 = AVR32_SCIF_RCCR8_RCOSC8_EN_MASK | ((*calibration_bits)&AVR32_SCIF_RCCR8_CALIB_MASK);

  tmp1 = (*calibration_bits);				//read calibration info from flash
8000458a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000458e:	70 08       	ld.w	r8,r8[0x0]
80004590:	ef 48 ff f8 	st.w	r7[-8],r8
  tmp1 >>= 16;								//shift down by 16 to get byte[2] 7apr15
80004594:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004598:	b1 88       	lsr	r8,0x10
8000459a:	ef 48 ff f8 	st.w	r7[-8],r8
  tmp1 &= AVR32_SCIF_RCCR8_CALIB_MASK;		//7apr15
8000459e:	ee f8 ff f8 	ld.w	r8,r7[-8]
800045a2:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
800045a6:	ef 48 ff f8 	st.w	r7[-8],r8
  tmp1 |= AVR32_SCIF_RCCR8_RCOSC8_EN_MASK;  //7apr15
800045aa:	ee f8 ff f8 	ld.w	r8,r7[-8]
800045ae:	b9 a8       	sbr	r8,0x18
800045b0:	ef 48 ff f8 	st.w	r7[-8],r8
  
  AVR32_SCIF.rccr8 = tmp1;
800045b4:	fe 78 08 00 	mov	r8,-63488
800045b8:	ee f9 ff f8 	ld.w	r9,r7[-8]
800045bc:	f1 49 00 48 	st.w	r8[72],r9
  
  AVR32_LEAVE_CRITICAL_REGION( );
800045c0:	ef 39 ff ff 	ld.ub	r9,r7[-1]
800045c4:	30 08       	mov	r8,0
800045c6:	f0 09 18 00 	cp.b	r9,r8
800045ca:	c0 20       	breq	800045ce <scif_start_rc8M+0x76>
800045cc:	d5 03       	csrf	0x10
}
800045ce:	2f dd       	sub	sp,-12
800045d0:	e3 cd 80 80 	ldm	sp++,r7,pc
800045d4:	80 00       	ld.sh	r0,r0[0x0]
800045d6:	45 38       	lddsp	r8,sp[0x14c]

800045d8 <scif_start_gclk>:
/**
 ** Generic Clock Functions
 **/

long int scif_start_gclk(unsigned int gclk, const scif_gclk_opt_t *opt)
{
800045d8:	eb cd 40 80 	pushm	r7,lr
800045dc:	1a 97       	mov	r7,sp
800045de:	20 2d       	sub	sp,8
800045e0:	ef 4c ff fc 	st.w	r7[-4],r12
800045e4:	ef 4b ff f8 	st.w	r7[-8],r11
    return -1;
  }
#endif  // AVR32SFW_INPUT_CHECK

  // If the generic clock is already enabled, return an error.
  if(AVR32_SCIF.gcctrl[gclk] & AVR32_SCIF_GCCTRL_CEN_MASK)
800045e8:	fe 78 08 00 	mov	r8,-63488
800045ec:	ee f9 ff fc 	ld.w	r9,r7[-4]
800045f0:	2e 79       	sub	r9,-25
800045f2:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
800045f6:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800045fa:	5c 58       	castu.b	r8
800045fc:	c0 30       	breq	80004602 <scif_start_gclk+0x2a>
    return -1;
800045fe:	3f f8       	mov	r8,-1
80004600:	c2 08       	rjmp	80004640 <scif_start_gclk+0x68>

  // Configure & start the generic clock.
  AVR32_SCIF.gcctrl[gclk] = ((opt->divider << AVR32_SCIF_GCCTRL_DIV_OFFSET)&AVR32_SCIF_GCCTRL_DIV_MASK)
80004602:	fe 78 08 00 	mov	r8,-63488
80004606:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000460a:	ee fa ff f8 	ld.w	r10,r7[-8]
8000460e:	74 1a       	ld.w	r10,r10[0x4]
80004610:	b1 6a       	lsl	r10,0x10
80004612:	14 9b       	mov	r11,r10
80004614:	e6 1b 00 ff 	andh	r11,0xff,COH
                            |((opt->diven << AVR32_SCIF_GCCTRL_DIVEN_OFFSET)&AVR32_SCIF_GCCTRL_DIVEN_MASK)
80004618:	ee fa ff f8 	ld.w	r10,r7[-8]
8000461c:	74 2a       	ld.w	r10,r10[0x8]
8000461e:	a1 7a       	lsl	r10,0x1
80004620:	e2 1a 00 02 	andl	r10,0x2,COH
                            |((opt->clock_source << AVR32_SCIF_GCCTRL_OSCSEL_OFFSET)&AVR32_SCIF_GCCTRL_OSCSEL_MASK)
80004624:	14 4b       	or	r11,r10
80004626:	ee fa ff f8 	ld.w	r10,r7[-8]
8000462a:	74 0a       	ld.w	r10,r10[0x0]
8000462c:	a9 6a       	lsl	r10,0x8
8000462e:	e2 1a 0f 00 	andl	r10,0xf00,COH
                            |(AVR32_SCIF_GCCTRL_CEN_MASK);
80004632:	f7 ea 10 0a 	or	r10,r11,r10
  // If the generic clock is already enabled, return an error.
  if(AVR32_SCIF.gcctrl[gclk] & AVR32_SCIF_GCCTRL_CEN_MASK)
    return -1;

  // Configure & start the generic clock.
  AVR32_SCIF.gcctrl[gclk] = ((opt->divider << AVR32_SCIF_GCCTRL_DIV_OFFSET)&AVR32_SCIF_GCCTRL_DIV_MASK)
80004636:	a1 aa       	sbr	r10,0x0
80004638:	2e 79       	sub	r9,-25
8000463a:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
                            |((opt->diven << AVR32_SCIF_GCCTRL_DIVEN_OFFSET)&AVR32_SCIF_GCCTRL_DIVEN_MASK)
                            |((opt->clock_source << AVR32_SCIF_GCCTRL_OSCSEL_OFFSET)&AVR32_SCIF_GCCTRL_OSCSEL_MASK)
                            |(AVR32_SCIF_GCCTRL_CEN_MASK);

  return PASS;
8000463e:	30 08       	mov	r8,0
}
80004640:	10 9c       	mov	r12,r8
80004642:	2f ed       	sub	sp,-8
80004644:	e3 cd 80 80 	ldm	sp++,r7,pc

80004648 <cpu_irq_save>:
#endif

typedef uint32_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
80004648:	eb cd 40 80 	pushm	r7,lr
8000464c:	1a 97       	mov	r7,sp
8000464e:	20 1d       	sub	sp,4
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80004650:	e1 b8 00 00 	mfsr	r8,0x0
80004654:	ef 48 ff fc 	st.w	r7[-4],r8
	cpu_irq_disable();
80004658:	d3 03       	ssrf	0x10

	return flags;
8000465a:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
8000465e:	10 9c       	mov	r12,r8
80004660:	2f fd       	sub	sp,-4
80004662:	e3 cd 80 80 	ldm	sp++,r7,pc

80004666 <cpu_irq_is_enabled_flags>:

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
80004666:	eb cd 40 80 	pushm	r7,lr
8000466a:	1a 97       	mov	r7,sp
8000466c:	20 1d       	sub	sp,4
8000466e:	ef 4c ff fc 	st.w	r7[-4],r12
	return !(flags & AVR32_SR_GM_MASK);
80004672:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004676:	e6 18 00 01 	andh	r8,0x1,COH
8000467a:	5f 08       	sreq	r8
8000467c:	5c 58       	castu.b	r8
}
8000467e:	10 9c       	mov	r12,r8
80004680:	2f fd       	sub	sp,-4
80004682:	e3 cd 80 80 	ldm	sp++,r7,pc
80004686:	d7 03       	nop

80004688 <cpu_irq_restore>:

static inline void cpu_irq_restore(irqflags_t flags)
{
80004688:	eb cd 40 80 	pushm	r7,lr
8000468c:	1a 97       	mov	r7,sp
8000468e:	20 1d       	sub	sp,4
80004690:	ef 4c ff fc 	st.w	r7[-4],r12
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80004694:	ee fc ff fc 	ld.w	r12,r7[-4]
80004698:	f0 1f 00 05 	mcall	800046ac <cpu_irq_restore+0x24>
8000469c:	18 98       	mov	r8,r12
8000469e:	58 08       	cp.w	r8,0
800046a0:	c0 20       	breq	800046a4 <cpu_irq_restore+0x1c>
      cpu_irq_enable();
800046a2:	d5 03       	csrf	0x10
   }

	barrier();
}
800046a4:	2f fd       	sub	sp,-4
800046a6:	e3 cd 80 80 	ldm	sp++,r7,pc
800046aa:	00 00       	add	r0,r0
800046ac:	80 00       	ld.sh	r0,r0[0x0]
800046ae:	46 66       	lddsp	r6,sp[0x198]

800046b0 <twim_master_interrupt_handler>:
/**
 * \internal
 * \brief TWI interrupt handler.
 */
ISR(twim_master_interrupt_handler,CONF_TWIM_IRQ_GROUP,CONF_TWIM_IRQ_LEVEL)
{
800046b0:	eb cd 40 80 	pushm	r7,lr
800046b4:	1a 97       	mov	r7,sp
800046b6:	20 1d       	sub	sp,4
	// get masked status register value
	uint32_t status = twim_inst->sr & twim_it_mask;
800046b8:	4c 68       	lddpc	r8,800047d0 <twim_master_interrupt_handler+0x120>
800046ba:	70 08       	ld.w	r8,r8[0x0]
800046bc:	70 79       	ld.w	r9,r8[0x1c]
800046be:	4c 68       	lddpc	r8,800047d4 <twim_master_interrupt_handler+0x124>
800046c0:	70 08       	ld.w	r8,r8[0x0]
800046c2:	f3 e8 00 08 	and	r8,r9,r8
800046c6:	ef 48 ff fc 	st.w	r7[-4],r8
	// this is a NACK
	if (status & AVR32_TWIM_SR_STD_MASK) {
800046ca:	ee f8 ff fc 	ld.w	r8,r7[-4]
800046ce:	e2 18 07 00 	andl	r8,0x700,COH
800046d2:	c1 e0       	breq	8000470e <twim_master_interrupt_handler+0x5e>
		//if we get a nak, clear the valid bit in cmdr,
		//otherwise the command will be resent.
		transfer_status =(status & AVR32_TWIM_IER_NAK_MASK) ?
800046d4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800046d8:	e2 18 03 00 	andl	r8,0x300,COH
800046dc:	c0 30       	breq	800046e2 <twim_master_interrupt_handler+0x32>
800046de:	3f c8       	mov	r8,-4
800046e0:	c0 28       	rjmp	800046e4 <twim_master_interrupt_handler+0x34>
800046e2:	3f e8       	mov	r8,-2
800046e4:	4b d9       	lddpc	r9,800047d8 <twim_master_interrupt_handler+0x128>
800046e6:	93 08       	st.w	r9[0x0],r8
							TWI_RECEIVE_NACK : TWI_ARBITRATION_LOST;
		twim_inst->CMDR.valid = 0;
800046e8:	4b a8       	lddpc	r8,800047d0 <twim_master_interrupt_handler+0x120>
800046ea:	70 09       	ld.w	r9,r8[0x0]
800046ec:	72 38       	ld.w	r8,r9[0xc]
800046ee:	30 0a       	mov	r10,0
800046f0:	f1 da d1 e1 	bfins	r8,r10,0xf,0x1
800046f4:	93 38       	st.w	r9[0xc],r8
		twim_inst->scr = ~0UL;
800046f6:	4b 78       	lddpc	r8,800047d0 <twim_master_interrupt_handler+0x120>
800046f8:	70 08       	ld.w	r8,r8[0x0]
800046fa:	3f f9       	mov	r9,-1
800046fc:	91 b9       	st.w	r8[0x2c],r9
		twim_inst->idr = ~0UL;
800046fe:	4b 58       	lddpc	r8,800047d0 <twim_master_interrupt_handler+0x120>
80004700:	70 08       	ld.w	r8,r8[0x0]
80004702:	3f f9       	mov	r9,-1
80004704:	91 99       	st.w	r8[0x24],r9
		twim_next = false;
80004706:	4b 69       	lddpc	r9,800047dc <twim_master_interrupt_handler+0x12c>
80004708:	30 08       	mov	r8,0
8000470a:	b2 88       	st.b	r9[0x0],r8
8000470c:	c5 e8       	rjmp	800047c8 <twim_master_interrupt_handler+0x118>
	}
	// this is a RXRDY
	else if (status & AVR32_TWIM_SR_RXRDY_MASK) {
8000470e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004712:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004716:	5c 58       	castu.b	r8
80004718:	c2 00       	breq	80004758 <twim_master_interrupt_handler+0xa8>
		// get data from Receive Holding Register
		*twim_rx_data = twim_inst->rhr;
8000471a:	4b 28       	lddpc	r8,800047e0 <twim_master_interrupt_handler+0x130>
8000471c:	70 09       	ld.w	r9,r8[0x0]
8000471e:	4a d8       	lddpc	r8,800047d0 <twim_master_interrupt_handler+0x120>
80004720:	70 08       	ld.w	r8,r8[0x0]
80004722:	70 58       	ld.w	r8,r8[0x14]
80004724:	5c 58       	castu.b	r8
80004726:	b2 88       	st.b	r9[0x0],r8
		twim_rx_data++;
80004728:	4a e8       	lddpc	r8,800047e0 <twim_master_interrupt_handler+0x130>
8000472a:	70 08       	ld.w	r8,r8[0x0]
8000472c:	f0 c9 ff ff 	sub	r9,r8,-1
80004730:	4a c8       	lddpc	r8,800047e0 <twim_master_interrupt_handler+0x130>
80004732:	91 09       	st.w	r8[0x0],r9
		// decrease received bytes number
		twim_rx_nb_bytes--;
80004734:	4a c8       	lddpc	r8,800047e4 <twim_master_interrupt_handler+0x134>
80004736:	70 08       	ld.w	r8,r8[0x0]
80004738:	f0 c9 00 01 	sub	r9,r8,1
8000473c:	4a a8       	lddpc	r8,800047e4 <twim_master_interrupt_handler+0x134>
8000473e:	91 09       	st.w	r8[0x0],r9
		// receive complete
		if (twim_rx_nb_bytes == 0) {
80004740:	4a 98       	lddpc	r8,800047e4 <twim_master_interrupt_handler+0x134>
80004742:	70 08       	ld.w	r8,r8[0x0]
80004744:	58 08       	cp.w	r8,0
80004746:	c4 11       	brne	800047c8 <twim_master_interrupt_handler+0x118>
			// finish the receive operation
			twim_inst->idr = AVR32_TWIM_IDR_RXRDY_MASK;
80004748:	4a 28       	lddpc	r8,800047d0 <twim_master_interrupt_handler+0x120>
8000474a:	70 08       	ld.w	r8,r8[0x0]
8000474c:	30 19       	mov	r9,1
8000474e:	91 99       	st.w	r8[0x24],r9
			// set busy to false
			twim_next = false;
80004750:	4a 39       	lddpc	r9,800047dc <twim_master_interrupt_handler+0x12c>
80004752:	30 08       	mov	r8,0
80004754:	b2 88       	st.b	r9[0x0],r8
80004756:	c3 98       	rjmp	800047c8 <twim_master_interrupt_handler+0x118>
		}
	}
	// this is a TXRDY
	else if (status & AVR32_TWIM_SR_TXRDY_MASK) {
80004758:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000475c:	e2 18 00 02 	andl	r8,0x2,COH
80004760:	c3 40       	breq	800047c8 <twim_master_interrupt_handler+0x118>
		// no more bytes to transmit
		if (twim_tx_nb_bytes == 0) {
80004762:	4a 28       	lddpc	r8,800047e8 <twim_master_interrupt_handler+0x138>
80004764:	70 08       	ld.w	r8,r8[0x0]
80004766:	58 08       	cp.w	r8,0
80004768:	c0 91       	brne	8000477a <twim_master_interrupt_handler+0xca>
			// finish the receive operation
			twim_inst->idr = AVR32_TWIM_IDR_TXRDY_MASK;
8000476a:	49 a8       	lddpc	r8,800047d0 <twim_master_interrupt_handler+0x120>
8000476c:	70 08       	ld.w	r8,r8[0x0]
8000476e:	30 29       	mov	r9,2
80004770:	91 99       	st.w	r8[0x24],r9
			// set busy to false
			twim_next = false;
80004772:	49 b9       	lddpc	r9,800047dc <twim_master_interrupt_handler+0x12c>
80004774:	30 08       	mov	r8,0
80004776:	b2 88       	st.b	r9[0x0],r8
80004778:	c2 88       	rjmp	800047c8 <twim_master_interrupt_handler+0x118>
		} else {
			// put the byte in the Transmit Holding Register
			twim_inst->thr = *twim_tx_data++;
8000477a:	49 68       	lddpc	r8,800047d0 <twim_master_interrupt_handler+0x120>
8000477c:	70 0a       	ld.w	r10,r8[0x0]
8000477e:	49 c8       	lddpc	r8,800047ec <twim_master_interrupt_handler+0x13c>
80004780:	70 08       	ld.w	r8,r8[0x0]
80004782:	11 89       	ld.ub	r9,r8[0x0]
80004784:	5c 59       	castu.b	r9
80004786:	95 69       	st.w	r10[0x18],r9
80004788:	f0 c9 ff ff 	sub	r9,r8,-1
8000478c:	49 88       	lddpc	r8,800047ec <twim_master_interrupt_handler+0x13c>
8000478e:	91 09       	st.w	r8[0x0],r9
			// decrease transmitted bytes number
			twim_tx_nb_bytes--;
80004790:	49 68       	lddpc	r8,800047e8 <twim_master_interrupt_handler+0x138>
80004792:	70 08       	ld.w	r8,r8[0x0]
80004794:	f0 c9 00 01 	sub	r9,r8,1
80004798:	49 48       	lddpc	r8,800047e8 <twim_master_interrupt_handler+0x138>
8000479a:	91 09       	st.w	r8[0x0],r9
			if (twim_tx_nb_bytes == 0) {
8000479c:	49 38       	lddpc	r8,800047e8 <twim_master_interrupt_handler+0x138>
8000479e:	70 08       	ld.w	r8,r8[0x0]
800047a0:	58 08       	cp.w	r8,0
800047a2:	c1 31       	brne	800047c8 <twim_master_interrupt_handler+0x118>
				// Check for next transfer
				if(twim_next) {
800047a4:	48 e8       	lddpc	r8,800047dc <twim_master_interrupt_handler+0x12c>
800047a6:	11 88       	ld.ub	r8,r8[0x0]
800047a8:	5c 58       	castu.b	r8
800047aa:	c0 f0       	breq	800047c8 <twim_master_interrupt_handler+0x118>
					twim_next = false;
800047ac:	48 c9       	lddpc	r9,800047dc <twim_master_interrupt_handler+0x12c>
800047ae:	30 08       	mov	r8,0
800047b0:	b2 88       	st.b	r9[0x0],r8
					twim_tx_nb_bytes = twim_package->length;
800047b2:	49 08       	lddpc	r8,800047f0 <twim_master_interrupt_handler+0x140>
800047b4:	70 08       	ld.w	r8,r8[0x0]
800047b6:	70 39       	ld.w	r9,r8[0xc]
800047b8:	48 c8       	lddpc	r8,800047e8 <twim_master_interrupt_handler+0x138>
800047ba:	91 09       	st.w	r8[0x0],r9
					twim_tx_data = twim_package->buffer;
800047bc:	48 d8       	lddpc	r8,800047f0 <twim_master_interrupt_handler+0x140>
800047be:	70 08       	ld.w	r8,r8[0x0]
800047c0:	70 28       	ld.w	r8,r8[0x8]
800047c2:	10 99       	mov	r9,r8
800047c4:	48 a8       	lddpc	r8,800047ec <twim_master_interrupt_handler+0x13c>
800047c6:	91 09       	st.w	r8[0x0],r9
				}
			}
		}
	}
	return;
}
800047c8:	2f fd       	sub	sp,-4
800047ca:	e3 cd 40 80 	ldm	sp++,r7,lr
800047ce:	d6 03       	rete
800047d0:	00 00       	add	r0,r0
800047d2:	02 8c       	andn	r12,r1
800047d4:	00 00       	add	r0,r0
800047d6:	02 a4       	st.w	r1++,r4
800047d8:	00 00       	add	r0,r0
800047da:	02 98       	mov	r8,r1
800047dc:	00 00       	add	r0,r0
800047de:	02 ac       	st.w	r1++,r12
800047e0:	00 00       	add	r0,r0
800047e2:	02 94       	mov	r4,r1
800047e4:	00 00       	add	r0,r0
800047e6:	02 a0       	st.w	r1++,r0
800047e8:	00 00       	add	r0,r0
800047ea:	02 9c       	mov	r12,r1
800047ec:	00 00       	add	r0,r0
800047ee:	02 90       	mov	r0,r1
800047f0:	00 00       	add	r0,r0
800047f2:	02 a8       	st.w	r1++,r8

800047f4 <twim_set_speed>:
 * \retval STATUS_OK        Transaction is successful
 * \retval ERR_INVALID_ARG  Invalid arg resulting in wrong CWGR Exponential
 */
status_code_t twim_set_speed (volatile avr32_twim_t *twim, uint32_t speed,
		uint32_t pba_hz)
{
800047f4:	eb cd 40 80 	pushm	r7,lr
800047f8:	1a 97       	mov	r7,sp
800047fa:	20 5d       	sub	sp,20
800047fc:	ef 4c ff f4 	st.w	r7[-12],r12
80004800:	ef 4b ff f0 	st.w	r7[-16],r11
80004804:	ef 4a ff ec 	st.w	r7[-20],r10
	uint32_t f_prescaled;
	uint8_t cwgr_exp = 0;
80004808:	30 08       	mov	r8,0
8000480a:	ef 68 ff ff 	st.b	r7[-1],r8
	f_prescaled = (pba_hz / speed / 2);
8000480e:	ee f8 ff ec 	ld.w	r8,r7[-20]
80004812:	ee f9 ff f0 	ld.w	r9,r7[-16]
80004816:	f0 09 0d 08 	divu	r8,r8,r9
8000481a:	a1 98       	lsr	r8,0x1
8000481c:	ef 48 ff f8 	st.w	r7[-8],r8
	// f_prescaled must fit in 8 bits, cwgr_exp must fit in 3 bits
	while ((f_prescaled > 0xFF) && (cwgr_exp <= 0x7)) {
80004820:	c0 b8       	rjmp	80004836 <twim_set_speed+0x42>
		// increase clock divider
		cwgr_exp++;
80004822:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80004826:	2f f8       	sub	r8,-1
80004828:	ef 68 ff ff 	st.b	r7[-1],r8
		// divide f_prescaled value
		f_prescaled /= 2;
8000482c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004830:	a1 98       	lsr	r8,0x1
80004832:	ef 48 ff f8 	st.w	r7[-8],r8
{
	uint32_t f_prescaled;
	uint8_t cwgr_exp = 0;
	f_prescaled = (pba_hz / speed / 2);
	// f_prescaled must fit in 8 bits, cwgr_exp must fit in 3 bits
	while ((f_prescaled > 0xFF) && (cwgr_exp <= 0x7)) {
80004836:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000483a:	e0 48 00 ff 	cp.w	r8,255
8000483e:	e0 88 00 09 	brls	80004850 <twim_set_speed+0x5c>
80004842:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80004846:	30 78       	mov	r8,7
80004848:	f0 09 18 00 	cp.b	r9,r8
8000484c:	fe 98 ff eb 	brls	80004822 <twim_set_speed+0x2e>
		// increase clock divider
		cwgr_exp++;
		// divide f_prescaled value
		f_prescaled /= 2;
	}
	if (cwgr_exp > 0x7) {
80004850:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80004854:	30 78       	mov	r8,7
80004856:	f0 09 18 00 	cp.b	r9,r8
8000485a:	e0 88 00 04 	brls	80004862 <twim_set_speed+0x6e>
		return ERR_INVALID_ARG;
8000485e:	3f 88       	mov	r8,-8
80004860:	c1 a8       	rjmp	80004894 <twim_set_speed+0xa0>
	}
	// set clock waveform generator register
	twim->cwgr = ((f_prescaled/2) << AVR32_TWIM_CWGR_LOW_OFFSET)
80004862:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004866:	f0 09 16 01 	lsr	r9,r8,0x1
			| ((f_prescaled - f_prescaled/2) << AVR32_TWIM_CWGR_HIGH_OFFSET)
8000486a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000486e:	a1 98       	lsr	r8,0x1
80004870:	ee fa ff f8 	ld.w	r10,r7[-8]
80004874:	f4 08 01 08 	sub	r8,r10,r8
80004878:	a9 68       	lsl	r8,0x8
			| (cwgr_exp << AVR32_TWIM_CWGR_EXP_OFFSET)
8000487a:	10 49       	or	r9,r8
8000487c:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80004880:	bd 68       	lsl	r8,0x1c
			| (0     << AVR32_TWIM_CWGR_DATA_OFFSET)
			| (f_prescaled << AVR32_TWIM_CWGR_STASTO_OFFSET);
80004882:	10 49       	or	r9,r8
80004884:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004888:	b1 68       	lsl	r8,0x10
	}
	if (cwgr_exp > 0x7) {
		return ERR_INVALID_ARG;
	}
	// set clock waveform generator register
	twim->cwgr = ((f_prescaled/2) << AVR32_TWIM_CWGR_LOW_OFFSET)
8000488a:	10 49       	or	r9,r8
8000488c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004890:	91 19       	st.w	r8[0x4],r9
			| ((f_prescaled - f_prescaled/2) << AVR32_TWIM_CWGR_HIGH_OFFSET)
			| (cwgr_exp << AVR32_TWIM_CWGR_EXP_OFFSET)
			| (0     << AVR32_TWIM_CWGR_DATA_OFFSET)
			| (f_prescaled << AVR32_TWIM_CWGR_STASTO_OFFSET);
	return STATUS_OK;
80004892:	30 08       	mov	r8,0
}
80004894:	10 9c       	mov	r12,r8
80004896:	2f bd       	sub	sp,-20
80004898:	e3 cd 80 80 	ldm	sp++,r7,pc

8000489c <twim_master_init>:
 * \retval ERR_INVALID_ARG  Invalid arg resulting in wrong CWGR Exponential
 * \retval ERR_IO_ERROR     NACK is received or Bus Arbitration lost
 */
status_code_t twim_master_init (volatile avr32_twim_t *twim,
		const twim_options_t *opt)
{
8000489c:	eb cd 40 80 	pushm	r7,lr
800048a0:	1a 97       	mov	r7,sp
800048a2:	20 4d       	sub	sp,16
800048a4:	ef 4c ff f4 	st.w	r7[-12],r12
800048a8:	ef 4b ff f0 	st.w	r7[-16],r11
	bool global_interrupt_enabled = cpu_irq_is_enabled ();
800048ac:	e1 b8 00 00 	mfsr	r8,0x0
800048b0:	10 9c       	mov	r12,r8
800048b2:	f0 1f 00 37 	mcall	8000498c <twim_master_init+0xf0>
800048b6:	18 98       	mov	r8,r12
800048b8:	ef 68 ff fb 	st.b	r7[-5],r8
	// Initialize bus transfer status
	transfer_status = TWI_SUCCESS;
800048bc:	4b 58       	lddpc	r8,80004990 <twim_master_init+0xf4>
800048be:	30 09       	mov	r9,0
800048c0:	91 09       	st.w	r8[0x0],r9
	// Disable TWI interrupts
	if (global_interrupt_enabled) {
800048c2:	ef 39 ff fb 	ld.ub	r9,r7[-5]
800048c6:	30 08       	mov	r8,0
800048c8:	f0 09 18 00 	cp.b	r9,r8
800048cc:	c0 20       	breq	800048d0 <twim_master_init+0x34>
		cpu_irq_disable ();
800048ce:	d3 03       	ssrf	0x10
	}
	twim->idr = ~0UL;
800048d0:	ee f8 ff f4 	ld.w	r8,r7[-12]
800048d4:	3f f9       	mov	r9,-1
800048d6:	91 99       	st.w	r8[0x24],r9
	// Enable master transfer
	twim->cr = AVR32_TWIM_CR_MEN_MASK;
800048d8:	ee f8 ff f4 	ld.w	r8,r7[-12]
800048dc:	30 19       	mov	r9,1
800048de:	91 09       	st.w	r8[0x0],r9
	// Reset TWI
	twim->cr = AVR32_TWIM_CR_SWRST_MASK;
800048e0:	ee f8 ff f4 	ld.w	r8,r7[-12]
800048e4:	e0 69 00 80 	mov	r9,128
800048e8:	91 09       	st.w	r8[0x0],r9
	if (global_interrupt_enabled) {
800048ea:	ef 39 ff fb 	ld.ub	r9,r7[-5]
800048ee:	30 08       	mov	r8,0
800048f0:	f0 09 18 00 	cp.b	r9,r8
800048f4:	c0 20       	breq	800048f8 <twim_master_init+0x5c>
		cpu_irq_enable ();
800048f6:	d5 03       	csrf	0x10
	}
	// Clear SR
	twim->scr = ~0UL;
800048f8:	ee f8 ff f4 	ld.w	r8,r7[-12]
800048fc:	3f f9       	mov	r9,-1
800048fe:	91 b9       	st.w	r8[0x2c],r9

	// register Register twim_master_interrupt_handler interrupt on level CONF_TWIM_IRQ_LEVEL
	irqflags_t flags = cpu_irq_save();
80004900:	f0 1f 00 25 	mcall	80004994 <twim_master_init+0xf8>
80004904:	18 98       	mov	r8,r12
80004906:	ef 48 ff fc 	st.w	r7[-4],r8
	irq_register_handler(twim_master_interrupt_handler,
8000490a:	30 1a       	mov	r10,1
8000490c:	e0 6b 03 20 	mov	r11,800
80004910:	4a 2c       	lddpc	r12,80004998 <twim_master_init+0xfc>
80004912:	f0 1f 00 23 	mcall	8000499c <twim_master_init+0x100>
			CONF_TWIM_IRQ_LINE, CONF_TWIM_IRQ_LEVEL);
	cpu_irq_restore(flags);
80004916:	ee fc ff fc 	ld.w	r12,r7[-4]
8000491a:	f0 1f 00 22 	mcall	800049a0 <twim_master_init+0x104>

	if (opt->smbus) {
8000491e:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004922:	f1 38 00 0c 	ld.ub	r8,r8[12]
80004926:	58 08       	cp.w	r8,0
80004928:	c0 90       	breq	8000493a <twim_master_init+0x9e>
		// Enable SMBUS Transfer
		twim->cr = AVR32_TWIM_CR_SMEN_MASK;
8000492a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000492e:	31 09       	mov	r9,16
80004930:	91 09       	st.w	r8[0x0],r9
		twim->smbtr = (uint32_t) -1;
80004932:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004936:	3f f9       	mov	r9,-1
80004938:	91 29       	st.w	r8[0x8],r9
	}
	// Select the speed
	if (twim_set_speed (twim, opt->speed, opt->pba_hz) ==
8000493a:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000493e:	70 09       	ld.w	r9,r8[0x0]
80004940:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004944:	70 18       	ld.w	r8,r8[0x4]
80004946:	12 9a       	mov	r10,r9
80004948:	10 9b       	mov	r11,r8
8000494a:	ee fc ff f4 	ld.w	r12,r7[-12]
8000494e:	f0 1f 00 16 	mcall	800049a4 <twim_master_init+0x108>
80004952:	18 98       	mov	r8,r12
80004954:	5b 88       	cp.w	r8,-8
80004956:	c0 31       	brne	8000495c <twim_master_init+0xc0>
			ERR_INVALID_ARG) {
		return ERR_INVALID_ARG;
80004958:	3f 88       	mov	r8,-8
8000495a:	c1 48       	rjmp	80004982 <twim_master_init+0xe6>
	}
	// Probe the component
	twim_probe (twim, opt->chip);
8000495c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004960:	70 28       	ld.w	r8,r8[0x8]
80004962:	10 9b       	mov	r11,r8
80004964:	ee fc ff f4 	ld.w	r12,r7[-12]
80004968:	f0 1f 00 10 	mcall	800049a8 <twim_master_init+0x10c>
	//Check for nack and arbitration
	if (transfer_status == TWI_RECEIVE_NACK
			|| transfer_status == TWI_ARBITRATION_LOST) {
8000496c:	48 98       	lddpc	r8,80004990 <twim_master_init+0xf4>
8000496e:	70 08       	ld.w	r8,r8[0x0]
		return ERR_INVALID_ARG;
	}
	// Probe the component
	twim_probe (twim, opt->chip);
	//Check for nack and arbitration
	if (transfer_status == TWI_RECEIVE_NACK
80004970:	5b c8       	cp.w	r8,-4
80004972:	c0 50       	breq	8000497c <twim_master_init+0xe0>
			|| transfer_status == TWI_ARBITRATION_LOST) {
80004974:	48 78       	lddpc	r8,80004990 <twim_master_init+0xf4>
80004976:	70 08       	ld.w	r8,r8[0x0]
		return ERR_INVALID_ARG;
	}
	// Probe the component
	twim_probe (twim, opt->chip);
	//Check for nack and arbitration
	if (transfer_status == TWI_RECEIVE_NACK
80004978:	5b e8       	cp.w	r8,-2
8000497a:	c0 31       	brne	80004980 <twim_master_init+0xe4>
			|| transfer_status == TWI_ARBITRATION_LOST) {
		return ERR_IO_ERROR;
8000497c:	3f f8       	mov	r8,-1
8000497e:	c0 28       	rjmp	80004982 <twim_master_init+0xe6>
	}
	return STATUS_OK;
80004980:	30 08       	mov	r8,0
}
80004982:	10 9c       	mov	r12,r8
80004984:	2f cd       	sub	sp,-16
80004986:	e3 cd 80 80 	ldm	sp++,r7,pc
8000498a:	00 00       	add	r0,r0
8000498c:	80 00       	ld.sh	r0,r0[0x0]
8000498e:	46 66       	lddsp	r6,sp[0x198]
80004990:	00 00       	add	r0,r0
80004992:	02 98       	mov	r8,r1
80004994:	80 00       	ld.sh	r0,r0[0x0]
80004996:	46 48       	lddsp	r8,sp[0x190]
80004998:	80 00       	ld.sh	r0,r0[0x0]
8000499a:	46 b0       	lddsp	r0,sp[0x1ac]
8000499c:	80 00       	ld.sh	r0,r0[0x0]
8000499e:	43 f4       	lddsp	r4,sp[0xfc]
800049a0:	80 00       	ld.sh	r0,r0[0x0]
800049a2:	46 88       	lddsp	r8,sp[0x1a0]
800049a4:	80 00       	ld.sh	r0,r0[0x0]
800049a6:	47 f4       	lddsp	r4,sp[0x1fc]
800049a8:	80 00       	ld.sh	r0,r0[0x0]
800049aa:	49 f0       	lddpc	r0,80004a24 <twim_probe+0x34>

800049ac <twim_disable_interrupt>:
 * \brief Disable the TWI interrupts and clear its status register
 *
 * \param twim         Base address of the TWIM (i.e. &AVR32_TWI).
 */
void twim_disable_interrupt (volatile avr32_twim_t *twim)
{
800049ac:	eb cd 40 80 	pushm	r7,lr
800049b0:	1a 97       	mov	r7,sp
800049b2:	20 2d       	sub	sp,8
800049b4:	ef 4c ff f8 	st.w	r7[-8],r12
	bool global_interrupt_enabled = cpu_irq_is_enabled ();
800049b8:	e1 b8 00 00 	mfsr	r8,0x0
800049bc:	10 9c       	mov	r12,r8
800049be:	f0 1f 00 0c 	mcall	800049ec <twim_disable_interrupt+0x40>
800049c2:	18 98       	mov	r8,r12
800049c4:	ef 68 ff ff 	st.b	r7[-1],r8
	if (global_interrupt_enabled) {
800049c8:	ef 39 ff ff 	ld.ub	r9,r7[-1]
800049cc:	30 08       	mov	r8,0
800049ce:	f0 09 18 00 	cp.b	r9,r8
800049d2:	c0 20       	breq	800049d6 <twim_disable_interrupt+0x2a>
		cpu_irq_disable ();
800049d4:	d3 03       	ssrf	0x10
	}
	// Clear the interrupt flags
	twim->idr = ~0UL;
800049d6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800049da:	3f f9       	mov	r9,-1
800049dc:	91 99       	st.w	r8[0x24],r9
	// Clear the status flags
	twim->scr = ~0UL;
800049de:	ee f8 ff f8 	ld.w	r8,r7[-8]
800049e2:	3f f9       	mov	r9,-1
800049e4:	91 b9       	st.w	r8[0x2c],r9
}
800049e6:	2f ed       	sub	sp,-8
800049e8:	e3 cd 80 80 	ldm	sp++,r7,pc
800049ec:	80 00       	ld.sh	r0,r0[0x0]
800049ee:	46 66       	lddsp	r6,sp[0x198]

800049f0 <twim_probe>:
 * \param chip_addr       Address of the chip which is searched for
 * \retval STATUS_OK      Slave Found
 * \retval ERR_IO_ERROR   ANAK received or Bus Arbitration lost
 */
status_code_t twim_probe (volatile avr32_twim_t *twim, uint32_t chip_addr)
{
800049f0:	eb cd 40 80 	pushm	r7,lr
800049f4:	1a 97       	mov	r7,sp
800049f6:	20 3d       	sub	sp,12
800049f8:	ef 4c ff f8 	st.w	r7[-8],r12
800049fc:	ef 4b ff f4 	st.w	r7[-12],r11
	uint8_t data[1] = { 0 };
80004a00:	30 08       	mov	r8,0
80004a02:	ef 68 ff fc 	st.b	r7[-4],r8
	return (twim_write (twim,data,0,chip_addr,0));
80004a06:	ee cb 00 04 	sub	r11,r7,4
80004a0a:	30 08       	mov	r8,0
80004a0c:	ee f9 ff f4 	ld.w	r9,r7[-12]
80004a10:	30 0a       	mov	r10,0
80004a12:	ee fc ff f8 	ld.w	r12,r7[-8]
80004a16:	f0 1f 00 04 	mcall	80004a24 <twim_probe+0x34>
80004a1a:	18 98       	mov	r8,r12
}
80004a1c:	10 9c       	mov	r12,r8
80004a1e:	2f dd       	sub	sp,-12
80004a20:	e3 cd 80 80 	ldm	sp++,r7,pc
80004a24:	80 00       	ld.sh	r0,r0[0x0]
80004a26:	4c e0       	lddpc	r0,80004b5c <twim_read_packet+0x134>

80004a28 <twim_read_packet>:
 * \retval STATUS_OK      If all bytes were read successfully
 * \retval ERR_IO_ERROR   NACK received or Bus Arbitration lost
 */
status_code_t twim_read_packet (volatile avr32_twim_t *twim,
		const twim_package_t *package)
{
80004a28:	eb cd 40 80 	pushm	r7,lr
80004a2c:	1a 97       	mov	r7,sp
80004a2e:	20 2d       	sub	sp,8
80004a30:	ef 4c ff fc 	st.w	r7[-4],r12
80004a34:	ef 4b ff f8 	st.w	r7[-8],r11
	// Disable master transfer
	twim->cr = AVR32_TWIM_CR_MDIS_MASK;
80004a38:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a3c:	30 29       	mov	r9,2
80004a3e:	91 09       	st.w	r8[0x0],r9
	// Set pointer to TWIM instance for IT
	twim_inst = twim;
80004a40:	4c f8       	lddpc	r8,80004b7c <twim_read_packet+0x154>
80004a42:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004a46:	91 09       	st.w	r8[0x0],r9
	// Disable the TWIM interrupts
	twim_disable_interrupt (twim_inst);
80004a48:	4c d8       	lddpc	r8,80004b7c <twim_read_packet+0x154>
80004a4a:	70 08       	ld.w	r8,r8[0x0]
80004a4c:	10 9c       	mov	r12,r8
80004a4e:	f0 1f 00 4d 	mcall	80004b80 <twim_read_packet+0x158>
	// get a pointer to applicative data
	twim_rx_data = package->buffer;
80004a52:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004a56:	70 28       	ld.w	r8,r8[0x8]
80004a58:	10 99       	mov	r9,r8
80004a5a:	4c b8       	lddpc	r8,80004b84 <twim_read_packet+0x15c>
80004a5c:	91 09       	st.w	r8[0x0],r9
	// get a copy of nb bytes to read
	twim_rx_nb_bytes = package->length;
80004a5e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004a62:	70 39       	ld.w	r9,r8[0xc]
80004a64:	4c 98       	lddpc	r8,80004b88 <twim_read_packet+0x160>
80004a66:	91 09       	st.w	r8[0x0],r9
	// Set next write transfer to false
	twim_next = false;
80004a68:	4c 99       	lddpc	r9,80004b8c <twim_read_packet+0x164>
80004a6a:	30 08       	mov	r8,0
80004a6c:	b2 88       	st.b	r9[0x0],r8
	// Initialize bus transfer status
	transfer_status = TWI_SUCCESS;
80004a6e:	4c 98       	lddpc	r8,80004b90 <twim_read_packet+0x168>
80004a70:	30 09       	mov	r9,0
80004a72:	91 09       	st.w	r8[0x0],r9
	//check if internal address access is performed
	if (package->addr_length) {
80004a74:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004a78:	11 f8       	ld.ub	r8,r8[0x7]
80004a7a:	58 08       	cp.w	r8,0
80004a7c:	c3 f0       	breq	80004afa <twim_read_packet+0xd2>
		// Reset the TWIM module to clear the THR register
		twim_inst->cr = AVR32_TWIM_CR_MEN_MASK;
80004a7e:	4c 08       	lddpc	r8,80004b7c <twim_read_packet+0x154>
80004a80:	70 08       	ld.w	r8,r8[0x0]
80004a82:	30 19       	mov	r9,1
80004a84:	91 09       	st.w	r8[0x0],r9
		twim_inst->cr = AVR32_TWIM_CR_SWRST_MASK;
80004a86:	4b e8       	lddpc	r8,80004b7c <twim_read_packet+0x154>
80004a88:	70 08       	ld.w	r8,r8[0x0]
80004a8a:	e0 69 00 80 	mov	r9,128
80004a8e:	91 09       	st.w	r8[0x0],r9
		twim_inst->cr = AVR32_TWIM_CR_MDIS_MASK;
80004a90:	4b b8       	lddpc	r8,80004b7c <twim_read_packet+0x154>
80004a92:	70 08       	ld.w	r8,r8[0x0]
80004a94:	30 29       	mov	r9,2
80004a96:	91 09       	st.w	r8[0x0],r9
		// selection of first valid byte of the address
		twim_tx_data = package->addr;
80004a98:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004a9c:	2f c8       	sub	r8,-4
80004a9e:	10 99       	mov	r9,r8
80004aa0:	4b d8       	lddpc	r8,80004b94 <twim_read_packet+0x16c>
80004aa2:	91 09       	st.w	r8[0x0],r9
		// set the number of bytes to transmit
		twim_tx_nb_bytes = package->addr_length;
80004aa4:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004aa8:	11 f8       	ld.ub	r8,r8[0x7]
80004aaa:	10 99       	mov	r9,r8
80004aac:	4b b8       	lddpc	r8,80004b98 <twim_read_packet+0x170>
80004aae:	91 09       	st.w	r8[0x0],r9
		// mask NACK, TXRDY and RXRDY interrupts
		twim_it_mask = AVR32_TWIM_IER_STD_MASK |
80004ab0:	4b b8       	lddpc	r8,80004b9c <twim_read_packet+0x174>
80004ab2:	e0 69 07 03 	mov	r9,1795
80004ab6:	91 09       	st.w	r8[0x0],r9
				AVR32_TWIM_IER_TXRDY_MASK | AVR32_TWIM_IER_RXRDY_MASK;
		// Set the command register to initiate the transfer
		twim_inst->cmdr = (package->chip << AVR32_TWIM_CMDR_SADR_OFFSET)
80004ab8:	4b 18       	lddpc	r8,80004b7c <twim_read_packet+0x154>
80004aba:	70 08       	ld.w	r8,r8[0x0]
				| (package->addr_length << AVR32_TWIM_CMDR_NBYTES_OFFSET)
				| (AVR32_TWIM_CMDR_VALID_MASK)
80004abc:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004ac0:	72 09       	ld.w	r9,r9[0x0]
		twim_tx_nb_bytes = package->addr_length;
		// mask NACK, TXRDY and RXRDY interrupts
		twim_it_mask = AVR32_TWIM_IER_STD_MASK |
				AVR32_TWIM_IER_TXRDY_MASK | AVR32_TWIM_IER_RXRDY_MASK;
		// Set the command register to initiate the transfer
		twim_inst->cmdr = (package->chip << AVR32_TWIM_CMDR_SADR_OFFSET)
80004ac2:	f2 0a 15 01 	lsl	r10,r9,0x1
				| (package->addr_length << AVR32_TWIM_CMDR_NBYTES_OFFSET)
80004ac6:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004aca:	13 f9       	ld.ub	r9,r9[0x7]
80004acc:	b1 69       	lsl	r9,0x10
				| (AVR32_TWIM_CMDR_VALID_MASK)
80004ace:	f5 e9 10 09 	or	r9,r10,r9
		twim_tx_nb_bytes = package->addr_length;
		// mask NACK, TXRDY and RXRDY interrupts
		twim_it_mask = AVR32_TWIM_IER_STD_MASK |
				AVR32_TWIM_IER_TXRDY_MASK | AVR32_TWIM_IER_RXRDY_MASK;
		// Set the command register to initiate the transfer
		twim_inst->cmdr = (package->chip << AVR32_TWIM_CMDR_SADR_OFFSET)
80004ad2:	e8 19 a0 00 	orl	r9,0xa000
80004ad6:	91 39       	st.w	r8[0xc],r9
				| (package->addr_length << AVR32_TWIM_CMDR_NBYTES_OFFSET)
				| (AVR32_TWIM_CMDR_VALID_MASK)
				| (AVR32_TWIM_CMDR_START_MASK)
				| (0 << AVR32_TWIM_CMDR_READ_OFFSET);
		// set the next command register to followup with the previous command
		twim_inst->ncmdr = ((package->chip) << AVR32_TWIM_CMDR_SADR_OFFSET)
80004ad8:	4a 98       	lddpc	r8,80004b7c <twim_read_packet+0x154>
80004ada:	70 08       	ld.w	r8,r8[0x0]
80004adc:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004ae0:	72 09       	ld.w	r9,r9[0x0]
80004ae2:	f2 0a 15 01 	lsl	r10,r9,0x1
				| (package->length << AVR32_TWIM_CMDR_NBYTES_OFFSET)
				| (AVR32_TWIM_CMDR_VALID_MASK)
80004ae6:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004aea:	72 39       	ld.w	r9,r9[0xc]
				| (AVR32_TWIM_CMDR_VALID_MASK)
				| (AVR32_TWIM_CMDR_START_MASK)
				| (0 << AVR32_TWIM_CMDR_READ_OFFSET);
		// set the next command register to followup with the previous command
		twim_inst->ncmdr = ((package->chip) << AVR32_TWIM_CMDR_SADR_OFFSET)
				| (package->length << AVR32_TWIM_CMDR_NBYTES_OFFSET)
80004aec:	b1 69       	lsl	r9,0x10
				| (AVR32_TWIM_CMDR_VALID_MASK)
80004aee:	f5 e9 10 09 	or	r9,r10,r9
				| (package->addr_length << AVR32_TWIM_CMDR_NBYTES_OFFSET)
				| (AVR32_TWIM_CMDR_VALID_MASK)
				| (AVR32_TWIM_CMDR_START_MASK)
				| (0 << AVR32_TWIM_CMDR_READ_OFFSET);
		// set the next command register to followup with the previous command
		twim_inst->ncmdr = ((package->chip) << AVR32_TWIM_CMDR_SADR_OFFSET)
80004af2:	e8 19 e0 01 	orl	r9,0xe001
80004af6:	91 49       	st.w	r8[0x10],r9
80004af8:	c1 88       	rjmp	80004b28 <twim_read_packet+0x100>
				| (AVR32_TWIM_CMDR_VALID_MASK)
				| (AVR32_TWIM_CMDR_START_MASK)
				| (AVR32_TWIM_CMDR_STOP_MASK)
				| (AVR32_TWIM_CMDR_READ_MASK);
	} else {
		twim_tx_nb_bytes = 0;
80004afa:	4a 88       	lddpc	r8,80004b98 <twim_read_packet+0x170>
80004afc:	30 09       	mov	r9,0
80004afe:	91 09       	st.w	r8[0x0],r9
		// mask NACK and RXRDY interrupts
		twim_it_mask = AVR32_TWIM_IER_STD_MASK | AVR32_TWIM_IER_RXRDY_MASK;
80004b00:	4a 78       	lddpc	r8,80004b9c <twim_read_packet+0x174>
80004b02:	e0 69 07 01 	mov	r9,1793
80004b06:	91 09       	st.w	r8[0x0],r9
		// Set the command register to initiate the transfer
		twim_inst->cmdr = (package->chip << AVR32_TWIM_CMDR_SADR_OFFSET)
80004b08:	49 d8       	lddpc	r8,80004b7c <twim_read_packet+0x154>
80004b0a:	70 08       	ld.w	r8,r8[0x0]
				| (package->length << AVR32_TWIM_CMDR_NBYTES_OFFSET)
				| (AVR32_TWIM_CMDR_VALID_MASK)
80004b0c:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004b10:	72 09       	ld.w	r9,r9[0x0]
	} else {
		twim_tx_nb_bytes = 0;
		// mask NACK and RXRDY interrupts
		twim_it_mask = AVR32_TWIM_IER_STD_MASK | AVR32_TWIM_IER_RXRDY_MASK;
		// Set the command register to initiate the transfer
		twim_inst->cmdr = (package->chip << AVR32_TWIM_CMDR_SADR_OFFSET)
80004b12:	f2 0a 15 01 	lsl	r10,r9,0x1
				| (package->length << AVR32_TWIM_CMDR_NBYTES_OFFSET)
				| (AVR32_TWIM_CMDR_VALID_MASK)
80004b16:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004b1a:	72 39       	ld.w	r9,r9[0xc]
		twim_tx_nb_bytes = 0;
		// mask NACK and RXRDY interrupts
		twim_it_mask = AVR32_TWIM_IER_STD_MASK | AVR32_TWIM_IER_RXRDY_MASK;
		// Set the command register to initiate the transfer
		twim_inst->cmdr = (package->chip << AVR32_TWIM_CMDR_SADR_OFFSET)
				| (package->length << AVR32_TWIM_CMDR_NBYTES_OFFSET)
80004b1c:	b1 69       	lsl	r9,0x10
				| (AVR32_TWIM_CMDR_VALID_MASK)
80004b1e:	f5 e9 10 09 	or	r9,r10,r9
	} else {
		twim_tx_nb_bytes = 0;
		// mask NACK and RXRDY interrupts
		twim_it_mask = AVR32_TWIM_IER_STD_MASK | AVR32_TWIM_IER_RXRDY_MASK;
		// Set the command register to initiate the transfer
		twim_inst->cmdr = (package->chip << AVR32_TWIM_CMDR_SADR_OFFSET)
80004b22:	e8 19 e0 01 	orl	r9,0xe001
80004b26:	91 39       	st.w	r8[0xc],r9
				| (AVR32_TWIM_CMDR_START_MASK)
				| (AVR32_TWIM_CMDR_STOP_MASK)
				| (AVR32_TWIM_CMDR_READ_MASK);
	}
	// update IMR through IER
	twim_inst->ier = twim_it_mask;
80004b28:	49 58       	lddpc	r8,80004b7c <twim_read_packet+0x154>
80004b2a:	70 08       	ld.w	r8,r8[0x0]
80004b2c:	49 c9       	lddpc	r9,80004b9c <twim_read_packet+0x174>
80004b2e:	72 09       	ld.w	r9,r9[0x0]
80004b30:	91 89       	st.w	r8[0x20],r9
	// Enable master transfer
	twim->cr = AVR32_TWIM_CR_MEN_MASK;
80004b32:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004b36:	30 19       	mov	r9,1
80004b38:	91 09       	st.w	r8[0x0],r9
	// Enable all interrupts
	cpu_irq_enable ();
80004b3a:	d5 03       	csrf	0x10
	// get data
	while (!(transfer_status) && !(twim_status ())) {
80004b3c:	c0 38       	rjmp	80004b42 <twim_read_packet+0x11a>
		cpu_relax();
80004b3e:	fe cf ff fc 	sub	pc,pc,-4
	// Enable master transfer
	twim->cr = AVR32_TWIM_CR_MEN_MASK;
	// Enable all interrupts
	cpu_irq_enable ();
	// get data
	while (!(transfer_status) && !(twim_status ())) {
80004b42:	49 48       	lddpc	r8,80004b90 <twim_read_packet+0x168>
80004b44:	70 08       	ld.w	r8,r8[0x0]
80004b46:	58 08       	cp.w	r8,0
80004b48:	c0 61       	brne	80004b54 <twim_read_packet+0x12c>
80004b4a:	f0 1f 00 16 	mcall	80004ba0 <twim_read_packet+0x178>
80004b4e:	18 98       	mov	r8,r12
80004b50:	58 08       	cp.w	r8,0
80004b52:	cf 60       	breq	80004b3e <twim_read_packet+0x116>
		cpu_relax();
	}
	// Disable master transfer
	twim->cr = AVR32_TWIM_CR_MDIS_MASK;
80004b54:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004b58:	30 29       	mov	r9,2
80004b5a:	91 09       	st.w	r8[0x0],r9
	if (transfer_status == TWI_RECEIVE_NACK
			|| transfer_status == TWI_ARBITRATION_LOST) {
80004b5c:	48 d8       	lddpc	r8,80004b90 <twim_read_packet+0x168>
80004b5e:	70 08       	ld.w	r8,r8[0x0]
	while (!(transfer_status) && !(twim_status ())) {
		cpu_relax();
	}
	// Disable master transfer
	twim->cr = AVR32_TWIM_CR_MDIS_MASK;
	if (transfer_status == TWI_RECEIVE_NACK
80004b60:	5b c8       	cp.w	r8,-4
80004b62:	c0 50       	breq	80004b6c <twim_read_packet+0x144>
			|| transfer_status == TWI_ARBITRATION_LOST) {
80004b64:	48 b8       	lddpc	r8,80004b90 <twim_read_packet+0x168>
80004b66:	70 08       	ld.w	r8,r8[0x0]
	while (!(transfer_status) && !(twim_status ())) {
		cpu_relax();
	}
	// Disable master transfer
	twim->cr = AVR32_TWIM_CR_MDIS_MASK;
	if (transfer_status == TWI_RECEIVE_NACK
80004b68:	5b e8       	cp.w	r8,-2
80004b6a:	c0 31       	brne	80004b70 <twim_read_packet+0x148>
			|| transfer_status == TWI_ARBITRATION_LOST) {
		return ERR_IO_ERROR;
80004b6c:	3f f8       	mov	r8,-1
80004b6e:	c0 28       	rjmp	80004b72 <twim_read_packet+0x14a>
	}
	return STATUS_OK;
80004b70:	30 08       	mov	r8,0
}
80004b72:	10 9c       	mov	r12,r8
80004b74:	2f ed       	sub	sp,-8
80004b76:	e3 cd 80 80 	ldm	sp++,r7,pc
80004b7a:	00 00       	add	r0,r0
80004b7c:	00 00       	add	r0,r0
80004b7e:	02 8c       	andn	r12,r1
80004b80:	80 00       	ld.sh	r0,r0[0x0]
80004b82:	49 ac       	lddpc	r12,80004be8 <twim_write_packet+0x44>
80004b84:	00 00       	add	r0,r0
80004b86:	02 94       	mov	r4,r1
80004b88:	00 00       	add	r0,r0
80004b8a:	02 a0       	st.w	r1++,r0
80004b8c:	00 00       	add	r0,r0
80004b8e:	02 ac       	st.w	r1++,r12
80004b90:	00 00       	add	r0,r0
80004b92:	02 98       	mov	r8,r1
80004b94:	00 00       	add	r0,r0
80004b96:	02 90       	mov	r0,r1
80004b98:	00 00       	add	r0,r0
80004b9a:	02 9c       	mov	r12,r1
80004b9c:	00 00       	add	r0,r0
80004b9e:	02 a4       	st.w	r1++,r4
80004ba0:	80 00       	ld.sh	r0,r0[0x0]
80004ba2:	4d e4       	lddpc	r4,80004d18 <twim_write+0x38>

80004ba4 <twim_write_packet>:
 * \retval STATUS_OK      If all bytes were send successfully
 * \retval ERR_IO_ERROR   NACK received or Bus Arbitration lost
 */
status_code_t twim_write_packet (volatile avr32_twim_t *twim,
		const twim_package_t *package)
{
80004ba4:	eb cd 40 80 	pushm	r7,lr
80004ba8:	1a 97       	mov	r7,sp
80004baa:	20 2d       	sub	sp,8
80004bac:	ef 4c ff fc 	st.w	r7[-4],r12
80004bb0:	ef 4b ff f8 	st.w	r7[-8],r11
	// Reset the TWIM module to clear the THR register
	twim->cr = AVR32_TWIM_CR_MEN_MASK;
80004bb4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004bb8:	30 19       	mov	r9,1
80004bba:	91 09       	st.w	r8[0x0],r9
	twim->cr = AVR32_TWIM_CR_SWRST_MASK;
80004bbc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004bc0:	e0 69 00 80 	mov	r9,128
80004bc4:	91 09       	st.w	r8[0x0],r9
	twim->cr = AVR32_TWIM_CR_MDIS_MASK;
80004bc6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004bca:	30 29       	mov	r9,2
80004bcc:	91 09       	st.w	r8[0x0],r9
	// Set pointer to TWIM instance for IT
	twim_inst = twim;
80004bce:	4b c8       	lddpc	r8,80004cbc <twim_write_packet+0x118>
80004bd0:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004bd4:	91 09       	st.w	r8[0x0],r9
	// Disable the TWIM interrupts
	twim_disable_interrupt (twim_inst);
80004bd6:	4b a8       	lddpc	r8,80004cbc <twim_write_packet+0x118>
80004bd8:	70 08       	ld.w	r8,r8[0x0]
80004bda:	10 9c       	mov	r12,r8
80004bdc:	f0 1f 00 39 	mcall	80004cc0 <twim_write_packet+0x11c>
	// Initialize bus transfer status
	transfer_status = TWI_SUCCESS;
80004be0:	4b 98       	lddpc	r8,80004cc4 <twim_write_packet+0x120>
80004be2:	30 09       	mov	r9,0
80004be4:	91 09       	st.w	r8[0x0],r9
	// mask NACK and TXRDY interrupts
	twim_it_mask = AVR32_TWIM_IER_STD_MASK | AVR32_TWIM_IER_TXRDY_MASK;
80004be6:	4b 98       	lddpc	r8,80004cc8 <twim_write_packet+0x124>
80004be8:	e0 69 07 02 	mov	r9,1794
80004bec:	91 09       	st.w	r8[0x0],r9
	// Set next transfer to false
	twim_next = false;
80004bee:	4b 89       	lddpc	r9,80004ccc <twim_write_packet+0x128>
80004bf0:	30 08       	mov	r8,0
80004bf2:	b2 88       	st.b	r9[0x0],r8
	//check if internal address access is performed
	if (package->addr_length) {
80004bf4:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004bf8:	11 f8       	ld.ub	r8,r8[0x7]
80004bfa:	58 08       	cp.w	r8,0
80004bfc:	c1 50       	breq	80004c26 <twim_write_packet+0x82>
		// selection of first valid byte of the address
		twim_tx_data = package->addr;
80004bfe:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004c02:	2f c8       	sub	r8,-4
80004c04:	10 99       	mov	r9,r8
80004c06:	4b 38       	lddpc	r8,80004cd0 <twim_write_packet+0x12c>
80004c08:	91 09       	st.w	r8[0x0],r9
		// set the number of bytes to transmit
		twim_tx_nb_bytes = package->addr_length;
80004c0a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004c0e:	11 f8       	ld.ub	r8,r8[0x7]
80004c10:	10 99       	mov	r9,r8
80004c12:	4b 18       	lddpc	r8,80004cd4 <twim_write_packet+0x130>
80004c14:	91 09       	st.w	r8[0x0],r9
		// set next transfer to true
		twim_next = true;
80004c16:	4a e9       	lddpc	r9,80004ccc <twim_write_packet+0x128>
80004c18:	30 18       	mov	r8,1
80004c1a:	b2 88       	st.b	r9[0x0],r8
		// Set the number of bytes & address for next transfer
		twim_package = package;
80004c1c:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004c20:	4a e8       	lddpc	r8,80004cd8 <twim_write_packet+0x134>
80004c22:	91 09       	st.w	r8[0x0],r9
80004c24:	c0 c8       	rjmp	80004c3c <twim_write_packet+0x98>
	} else {
	// get a pointer to applicative data
	twim_tx_data = package->buffer;
80004c26:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004c2a:	70 28       	ld.w	r8,r8[0x8]
80004c2c:	10 99       	mov	r9,r8
80004c2e:	4a 98       	lddpc	r8,80004cd0 <twim_write_packet+0x12c>
80004c30:	91 09       	st.w	r8[0x0],r9
	// get a copy of nb bytes to write
	twim_tx_nb_bytes = package->length;
80004c32:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004c36:	70 39       	ld.w	r9,r8[0xc]
80004c38:	4a 78       	lddpc	r8,80004cd4 <twim_write_packet+0x130>
80004c3a:	91 09       	st.w	r8[0x0],r9
	}
	// initiate the transfer to send the data
	twim->cmdr = (package->chip << AVR32_TWIM_CMDR_SADR_OFFSET)
			| ((package->length + package->addr_length)
					<< AVR32_TWIM_CMDR_NBYTES_OFFSET)
			| (AVR32_TWIM_CMDR_VALID_MASK)
80004c3c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004c40:	70 08       	ld.w	r8,r8[0x0]
	twim_tx_data = package->buffer;
	// get a copy of nb bytes to write
	twim_tx_nb_bytes = package->length;
	}
	// initiate the transfer to send the data
	twim->cmdr = (package->chip << AVR32_TWIM_CMDR_SADR_OFFSET)
80004c42:	f0 09 15 01 	lsl	r9,r8,0x1
			| ((package->length + package->addr_length)
80004c46:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004c4a:	70 3a       	ld.w	r10,r8[0xc]
80004c4c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004c50:	11 f8       	ld.ub	r8,r8[0x7]
80004c52:	f4 08 00 08 	add	r8,r10,r8
80004c56:	b1 68       	lsl	r8,0x10
					<< AVR32_TWIM_CMDR_NBYTES_OFFSET)
			| (AVR32_TWIM_CMDR_VALID_MASK)
80004c58:	f3 e8 10 08 	or	r8,r9,r8
	twim_tx_data = package->buffer;
	// get a copy of nb bytes to write
	twim_tx_nb_bytes = package->length;
	}
	// initiate the transfer to send the data
	twim->cmdr = (package->chip << AVR32_TWIM_CMDR_SADR_OFFSET)
80004c5c:	10 99       	mov	r9,r8
80004c5e:	e8 19 e0 00 	orl	r9,0xe000
80004c62:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004c66:	91 39       	st.w	r8[0xc],r9
			| (AVR32_TWIM_CMDR_VALID_MASK)
			| (AVR32_TWIM_CMDR_START_MASK)
			| (AVR32_TWIM_CMDR_STOP_MASK)
			| (0 << AVR32_TWIM_CMDR_READ_OFFSET);
	// update IMR through IER
	twim_inst->ier = twim_it_mask;
80004c68:	49 58       	lddpc	r8,80004cbc <twim_write_packet+0x118>
80004c6a:	70 08       	ld.w	r8,r8[0x0]
80004c6c:	49 79       	lddpc	r9,80004cc8 <twim_write_packet+0x124>
80004c6e:	72 09       	ld.w	r9,r9[0x0]
80004c70:	91 89       	st.w	r8[0x20],r9
	// Enable master transfer
	twim_inst->cr = AVR32_TWIM_CR_MEN_MASK;
80004c72:	49 38       	lddpc	r8,80004cbc <twim_write_packet+0x118>
80004c74:	70 08       	ld.w	r8,r8[0x0]
80004c76:	30 19       	mov	r9,1
80004c78:	91 09       	st.w	r8[0x0],r9
	// Enable all interrupts
	cpu_irq_enable ();
80004c7a:	d5 03       	csrf	0x10
	// send data
	while (!(transfer_status) && !(twim_status ())) {
80004c7c:	c0 38       	rjmp	80004c82 <twim_write_packet+0xde>
		cpu_relax();
80004c7e:	fe cf ff fc 	sub	pc,pc,-4
	// Enable master transfer
	twim_inst->cr = AVR32_TWIM_CR_MEN_MASK;
	// Enable all interrupts
	cpu_irq_enable ();
	// send data
	while (!(transfer_status) && !(twim_status ())) {
80004c82:	49 18       	lddpc	r8,80004cc4 <twim_write_packet+0x120>
80004c84:	70 08       	ld.w	r8,r8[0x0]
80004c86:	58 08       	cp.w	r8,0
80004c88:	c0 61       	brne	80004c94 <twim_write_packet+0xf0>
80004c8a:	f0 1f 00 15 	mcall	80004cdc <twim_write_packet+0x138>
80004c8e:	18 98       	mov	r8,r12
80004c90:	58 08       	cp.w	r8,0
80004c92:	cf 60       	breq	80004c7e <twim_write_packet+0xda>
		cpu_relax();
	}
#if AVR32_TWIM_H_VERSION > 101	//Removed in twim100 module due to IC bug
	// Disable master transfer
	twim->cr = AVR32_TWIM_CR_MDIS_MASK;
80004c94:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004c98:	30 29       	mov	r9,2
80004c9a:	91 09       	st.w	r8[0x0],r9
#endif
	// Check for nack
	if (transfer_status == TWI_RECEIVE_NACK
			|| transfer_status == TWI_ARBITRATION_LOST) {
80004c9c:	48 a8       	lddpc	r8,80004cc4 <twim_write_packet+0x120>
80004c9e:	70 08       	ld.w	r8,r8[0x0]
#if AVR32_TWIM_H_VERSION > 101	//Removed in twim100 module due to IC bug
	// Disable master transfer
	twim->cr = AVR32_TWIM_CR_MDIS_MASK;
#endif
	// Check for nack
	if (transfer_status == TWI_RECEIVE_NACK
80004ca0:	5b c8       	cp.w	r8,-4
80004ca2:	c0 50       	breq	80004cac <twim_write_packet+0x108>
			|| transfer_status == TWI_ARBITRATION_LOST) {
80004ca4:	48 88       	lddpc	r8,80004cc4 <twim_write_packet+0x120>
80004ca6:	70 08       	ld.w	r8,r8[0x0]
#if AVR32_TWIM_H_VERSION > 101	//Removed in twim100 module due to IC bug
	// Disable master transfer
	twim->cr = AVR32_TWIM_CR_MDIS_MASK;
#endif
	// Check for nack
	if (transfer_status == TWI_RECEIVE_NACK
80004ca8:	5b e8       	cp.w	r8,-2
80004caa:	c0 31       	brne	80004cb0 <twim_write_packet+0x10c>
			|| transfer_status == TWI_ARBITRATION_LOST) {
		return ERR_IO_ERROR;
80004cac:	3f f8       	mov	r8,-1
80004cae:	c0 28       	rjmp	80004cb2 <twim_write_packet+0x10e>
	}
	return STATUS_OK;
80004cb0:	30 08       	mov	r8,0
}
80004cb2:	10 9c       	mov	r12,r8
80004cb4:	2f ed       	sub	sp,-8
80004cb6:	e3 cd 80 80 	ldm	sp++,r7,pc
80004cba:	00 00       	add	r0,r0
80004cbc:	00 00       	add	r0,r0
80004cbe:	02 8c       	andn	r12,r1
80004cc0:	80 00       	ld.sh	r0,r0[0x0]
80004cc2:	49 ac       	lddpc	r12,80004d28 <twim_write+0x48>
80004cc4:	00 00       	add	r0,r0
80004cc6:	02 98       	mov	r8,r1
80004cc8:	00 00       	add	r0,r0
80004cca:	02 a4       	st.w	r1++,r4
80004ccc:	00 00       	add	r0,r0
80004cce:	02 ac       	st.w	r1++,r12
80004cd0:	00 00       	add	r0,r0
80004cd2:	02 90       	mov	r0,r1
80004cd4:	00 00       	add	r0,r0
80004cd6:	02 9c       	mov	r12,r1
80004cd8:	00 00       	add	r0,r0
80004cda:	02 a8       	st.w	r1++,r8
80004cdc:	80 00       	ld.sh	r0,r0[0x0]
80004cde:	4d e4       	lddpc	r4,80004e54 <usart_set_async_baudrate+0x20>

80004ce0 <twim_write>:
 * \retval STATUS_OK      If all bytes were send successfully
 * \retval ERR_IO_ERROR   NACK received or Bus Arbitration lost
 */
status_code_t twim_write (volatile avr32_twim_t *twim, uint8_t const *buffer,
		uint32_t nbytes, uint32_t saddr, bool tenbit)
{
80004ce0:	eb cd 40 80 	pushm	r7,lr
80004ce4:	1a 97       	mov	r7,sp
80004ce6:	20 5d       	sub	sp,20
80004ce8:	ef 4c ff fc 	st.w	r7[-4],r12
80004cec:	ef 4b ff f8 	st.w	r7[-8],r11
80004cf0:	ef 4a ff f4 	st.w	r7[-12],r10
80004cf4:	ef 49 ff f0 	st.w	r7[-16],r9
80004cf8:	ef 68 ff ec 	st.b	r7[-20],r8
	// Reset the TWIM module to clear the THR register
	twim->cr = AVR32_TWIM_CR_MEN_MASK;
80004cfc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004d00:	30 19       	mov	r9,1
80004d02:	91 09       	st.w	r8[0x0],r9
	twim->cr = AVR32_TWIM_CR_SWRST_MASK;
80004d04:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004d08:	e0 69 00 80 	mov	r9,128
80004d0c:	91 09       	st.w	r8[0x0],r9
	twim->cr = AVR32_TWIM_CR_MDIS_MASK;
80004d0e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004d12:	30 29       	mov	r9,2
80004d14:	91 09       	st.w	r8[0x0],r9
	// Set pointer to TWIM instance for IT
	twim_inst = twim;
80004d16:	4a c8       	lddpc	r8,80004dc4 <twim_write+0xe4>
80004d18:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004d1c:	91 09       	st.w	r8[0x0],r9
	// Disable the TWIM interrupts
	twim_disable_interrupt (twim_inst);
80004d1e:	4a a8       	lddpc	r8,80004dc4 <twim_write+0xe4>
80004d20:	70 08       	ld.w	r8,r8[0x0]
80004d22:	10 9c       	mov	r12,r8
80004d24:	f0 1f 00 29 	mcall	80004dc8 <twim_write+0xe8>
	// get a pointer to applicative data
	twim_tx_data = buffer;
80004d28:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004d2c:	4a 88       	lddpc	r8,80004dcc <twim_write+0xec>
80004d2e:	91 09       	st.w	r8[0x0],r9
	// set the number of bytes to transmit
	twim_tx_nb_bytes = nbytes;
80004d30:	4a 88       	lddpc	r8,80004dd0 <twim_write+0xf0>
80004d32:	ee f9 ff f4 	ld.w	r9,r7[-12]
80004d36:	91 09       	st.w	r8[0x0],r9
	// Set next transfer to false
	twim_next = false;
80004d38:	4a 79       	lddpc	r9,80004dd4 <twim_write+0xf4>
80004d3a:	30 08       	mov	r8,0
80004d3c:	b2 88       	st.b	r9[0x0],r8
	// Initialize bus transfer status
	transfer_status = TWI_SUCCESS;
80004d3e:	4a 78       	lddpc	r8,80004dd8 <twim_write+0xf8>
80004d40:	30 09       	mov	r9,0
80004d42:	91 09       	st.w	r8[0x0],r9
	// set the command to start the transfer
	twim_inst->cmdr = (saddr << AVR32_TWIM_CMDR_SADR_OFFSET)
80004d44:	4a 08       	lddpc	r8,80004dc4 <twim_write+0xe4>
80004d46:	70 08       	ld.w	r8,r8[0x0]
80004d48:	ee f9 ff f0 	ld.w	r9,r7[-16]
80004d4c:	f2 0a 15 01 	lsl	r10,r9,0x1
			| (nbytes << AVR32_TWIM_CMDR_NBYTES_OFFSET)
80004d50:	ee f9 ff f4 	ld.w	r9,r7[-12]
80004d54:	b1 69       	lsl	r9,0x10
			| (AVR32_TWIM_CMDR_VALID_MASK)
80004d56:	12 4a       	or	r10,r9
			| (AVR32_TWIM_CMDR_START_MASK)
			| (AVR32_TWIM_CMDR_STOP_MASK)
			| ((tenbit ? 1 : 0) << AVR32_TWIM_CMDR_TENBIT_OFFSET)
80004d58:	ef 39 ff ec 	ld.ub	r9,r7[-20]
80004d5c:	ab 79       	lsl	r9,0xb
	// Set next transfer to false
	twim_next = false;
	// Initialize bus transfer status
	transfer_status = TWI_SUCCESS;
	// set the command to start the transfer
	twim_inst->cmdr = (saddr << AVR32_TWIM_CMDR_SADR_OFFSET)
80004d5e:	f5 e9 10 09 	or	r9,r10,r9
80004d62:	e8 19 e0 00 	orl	r9,0xe000
80004d66:	91 39       	st.w	r8[0xc],r9
			| (AVR32_TWIM_CMDR_START_MASK)
			| (AVR32_TWIM_CMDR_STOP_MASK)
			| ((tenbit ? 1 : 0) << AVR32_TWIM_CMDR_TENBIT_OFFSET)
			| (0 << AVR32_TWIM_CMDR_READ_OFFSET);
	// mask NACK and TXRDY interrupts
	twim_it_mask = AVR32_TWIM_IER_NAK_MASK | AVR32_TWIM_IER_TXRDY_MASK;
80004d68:	49 d8       	lddpc	r8,80004ddc <twim_write+0xfc>
80004d6a:	e0 69 03 02 	mov	r9,770
80004d6e:	91 09       	st.w	r8[0x0],r9
	// update IMR through IER
	twim_inst->ier = twim_it_mask;
80004d70:	49 58       	lddpc	r8,80004dc4 <twim_write+0xe4>
80004d72:	70 08       	ld.w	r8,r8[0x0]
80004d74:	49 a9       	lddpc	r9,80004ddc <twim_write+0xfc>
80004d76:	72 09       	ld.w	r9,r9[0x0]
80004d78:	91 89       	st.w	r8[0x20],r9
	// Enable master transfer
	twim_inst->cr = AVR32_TWIM_CR_MEN_MASK;
80004d7a:	49 38       	lddpc	r8,80004dc4 <twim_write+0xe4>
80004d7c:	70 08       	ld.w	r8,r8[0x0]
80004d7e:	30 19       	mov	r9,1
80004d80:	91 09       	st.w	r8[0x0],r9
	// Enable all interrupts
	cpu_irq_enable ();
80004d82:	d5 03       	csrf	0x10
	// send data
	while (!(transfer_status) && !(twim_status ())) {
80004d84:	c0 38       	rjmp	80004d8a <twim_write+0xaa>
		cpu_relax();
80004d86:	fe cf ff fc 	sub	pc,pc,-4
	// Enable master transfer
	twim_inst->cr = AVR32_TWIM_CR_MEN_MASK;
	// Enable all interrupts
	cpu_irq_enable ();
	// send data
	while (!(transfer_status) && !(twim_status ())) {
80004d8a:	49 48       	lddpc	r8,80004dd8 <twim_write+0xf8>
80004d8c:	70 08       	ld.w	r8,r8[0x0]
80004d8e:	58 08       	cp.w	r8,0
80004d90:	c0 61       	brne	80004d9c <twim_write+0xbc>
80004d92:	f0 1f 00 14 	mcall	80004de0 <twim_write+0x100>
80004d96:	18 98       	mov	r8,r12
80004d98:	58 08       	cp.w	r8,0
80004d9a:	cf 60       	breq	80004d86 <twim_write+0xa6>
		cpu_relax();
	}
#if AVR32_TWIM_H_VERSION > 101	// Removed in twim100 module due to IC bug
	// Disable master transfer
	twim->cr = AVR32_TWIM_CR_MDIS_MASK;
80004d9c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004da0:	30 29       	mov	r9,2
80004da2:	91 09       	st.w	r8[0x0],r9
#endif
	if (transfer_status == TWI_RECEIVE_NACK
			|| transfer_status == TWI_ARBITRATION_LOST) {
80004da4:	48 d8       	lddpc	r8,80004dd8 <twim_write+0xf8>
80004da6:	70 08       	ld.w	r8,r8[0x0]
	}
#if AVR32_TWIM_H_VERSION > 101	// Removed in twim100 module due to IC bug
	// Disable master transfer
	twim->cr = AVR32_TWIM_CR_MDIS_MASK;
#endif
	if (transfer_status == TWI_RECEIVE_NACK
80004da8:	5b c8       	cp.w	r8,-4
80004daa:	c0 50       	breq	80004db4 <twim_write+0xd4>
			|| transfer_status == TWI_ARBITRATION_LOST) {
80004dac:	48 b8       	lddpc	r8,80004dd8 <twim_write+0xf8>
80004dae:	70 08       	ld.w	r8,r8[0x0]
	}
#if AVR32_TWIM_H_VERSION > 101	// Removed in twim100 module due to IC bug
	// Disable master transfer
	twim->cr = AVR32_TWIM_CR_MDIS_MASK;
#endif
	if (transfer_status == TWI_RECEIVE_NACK
80004db0:	5b e8       	cp.w	r8,-2
80004db2:	c0 31       	brne	80004db8 <twim_write+0xd8>
			|| transfer_status == TWI_ARBITRATION_LOST) {
		return ERR_IO_ERROR;
80004db4:	3f f8       	mov	r8,-1
80004db6:	c0 28       	rjmp	80004dba <twim_write+0xda>
	}
	return STATUS_OK;
80004db8:	30 08       	mov	r8,0
}
80004dba:	10 9c       	mov	r12,r8
80004dbc:	2f bd       	sub	sp,-20
80004dbe:	e3 cd 80 80 	ldm	sp++,r7,pc
80004dc2:	00 00       	add	r0,r0
80004dc4:	00 00       	add	r0,r0
80004dc6:	02 8c       	andn	r12,r1
80004dc8:	80 00       	ld.sh	r0,r0[0x0]
80004dca:	49 ac       	lddpc	r12,80004e30 <cpu_irq_is_enabled_flags+0x1c>
80004dcc:	00 00       	add	r0,r0
80004dce:	02 90       	mov	r0,r1
80004dd0:	00 00       	add	r0,r0
80004dd2:	02 9c       	mov	r12,r1
80004dd4:	00 00       	add	r0,r0
80004dd6:	02 ac       	st.w	r1++,r12
80004dd8:	00 00       	add	r0,r0
80004dda:	02 98       	mov	r8,r1
80004ddc:	00 00       	add	r0,r0
80004dde:	02 a4       	st.w	r1++,r4
80004de0:	80 00       	ld.sh	r0,r0[0x0]
80004de2:	4d e4       	lddpc	r4,80004f58 <usart_reset+0x50>

80004de4 <twim_status>:

/**
 * \brief Information about the current status of the TWI Bus
 */
uint8_t twim_status ( void )
{
80004de4:	eb cd 40 80 	pushm	r7,lr
80004de8:	1a 97       	mov	r7,sp
80004dea:	20 1d       	sub	sp,4
	uint32_t status = twim_inst->sr;
80004dec:	48 98       	lddpc	r8,80004e10 <twim_status+0x2c>
80004dee:	70 08       	ld.w	r8,r8[0x0]
80004df0:	70 78       	ld.w	r8,r8[0x1c]
80004df2:	ef 48 ff fc 	st.w	r7[-4],r8
	if ((status & AVR32_TWIM_SR_IDLE_MASK)
80004df6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004dfa:	e2 18 00 10 	andl	r8,0x10,COH
80004dfe:	c0 30       	breq	80004e04 <twim_status+0x20>
#if AVR32_TWIM_H_VERSION > 101 ||(status&AVR32_TWIM_SR_BUSFREE_MASK)
#endif
		) {
		return 1;
80004e00:	30 18       	mov	r8,1
80004e02:	c0 28       	rjmp	80004e06 <twim_status+0x22>
	} else {
		return 0;
80004e04:	30 08       	mov	r8,0
	}
}
80004e06:	10 9c       	mov	r12,r8
80004e08:	2f fd       	sub	sp,-4
80004e0a:	e3 cd 80 80 	ldm	sp++,r7,pc
80004e0e:	00 00       	add	r0,r0
80004e10:	00 00       	add	r0,r0
80004e12:	02 8c       	andn	r12,r1

80004e14 <cpu_irq_is_enabled_flags>:

	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
80004e14:	eb cd 40 80 	pushm	r7,lr
80004e18:	1a 97       	mov	r7,sp
80004e1a:	20 1d       	sub	sp,4
80004e1c:	ef 4c ff fc 	st.w	r7[-4],r12
	return !(flags & AVR32_SR_GM_MASK);
80004e20:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004e24:	e6 18 00 01 	andh	r8,0x1,COH
80004e28:	5f 08       	sreq	r8
80004e2a:	5c 58       	castu.b	r8
}
80004e2c:	10 9c       	mov	r12,r8
80004e2e:	2f fd       	sub	sp,-4
80004e30:	e3 cd 80 80 	ldm	sp++,r7,pc

80004e34 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80004e34:	eb cd 40 80 	pushm	r7,lr
80004e38:	1a 97       	mov	r7,sp
80004e3a:	20 7d       	sub	sp,28
80004e3c:	ef 4c ff ec 	st.w	r7[-20],r12
80004e40:	ef 4b ff e8 	st.w	r7[-24],r11
80004e44:	ef 4a ff e4 	st.w	r7[-28],r10
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80004e48:	ee f8 ff e8 	ld.w	r8,r7[-24]
80004e4c:	f0 09 15 04 	lsl	r9,r8,0x4
80004e50:	ee f8 ff e4 	ld.w	r8,r7[-28]
80004e54:	10 39       	cp.w	r9,r8
80004e56:	e0 8b 00 04 	brhi	80004e5e <usart_set_async_baudrate+0x2a>
80004e5a:	31 08       	mov	r8,16
80004e5c:	c0 28       	rjmp	80004e60 <usart_set_async_baudrate+0x2c>
80004e5e:	30 88       	mov	r8,8
80004e60:	ef 48 ff f0 	st.w	r7[-16],r8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80004e64:	ee f8 ff e4 	ld.w	r8,r7[-28]
80004e68:	f0 09 15 03 	lsl	r9,r8,0x3
80004e6c:	ee fa ff f0 	ld.w	r10,r7[-16]
80004e70:	ee f8 ff e8 	ld.w	r8,r7[-24]
80004e74:	f4 08 02 48 	mul	r8,r10,r8
80004e78:	a1 98       	lsr	r8,0x1
80004e7a:	f2 08 00 08 	add	r8,r9,r8
80004e7e:	ee fa ff f0 	ld.w	r10,r7[-16]
80004e82:	ee f9 ff e8 	ld.w	r9,r7[-24]
80004e86:	f4 09 02 49 	mul	r9,r10,r9
80004e8a:	f0 09 0d 08 	divu	r8,r8,r9
80004e8e:	ef 48 ff f4 	st.w	r7[-12],r8
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80004e92:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004e96:	a3 98       	lsr	r8,0x3
80004e98:	ef 48 ff f8 	st.w	r7[-8],r8
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);
80004e9c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004ea0:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80004ea4:	ef 48 ff fc 	st.w	r7[-4],r8

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80004ea8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004eac:	58 08       	cp.w	r8,0
80004eae:	c0 70       	breq	80004ebc <usart_set_async_baudrate+0x88>
80004eb0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004eb4:	e0 48 ff ff 	cp.w	r8,65535
80004eb8:	e0 88 00 04 	brls	80004ec0 <usart_set_async_baudrate+0x8c>
    return USART_INVALID_INPUT;
80004ebc:	30 18       	mov	r8,1
80004ebe:	c2 08       	rjmp	80004efe <usart_set_async_baudrate+0xca>

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80004ec0:	ee f8 ff ec 	ld.w	r8,r7[-20]
80004ec4:	70 18       	ld.w	r8,r8[0x4]
80004ec6:	10 99       	mov	r9,r8
80004ec8:	e4 19 ff f7 	andh	r9,0xfff7
80004ecc:	e0 19 fe cf 	andl	r9,0xfecf
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80004ed0:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004ed4:	59 08       	cp.w	r8,16
80004ed6:	c0 40       	breq	80004ede <usart_set_async_baudrate+0xaa>
80004ed8:	e8 68 00 00 	mov	r8,524288
80004edc:	c0 28       	rjmp	80004ee0 <usart_set_async_baudrate+0xac>
80004ede:	30 08       	mov	r8,0
80004ee0:	10 49       	or	r9,r8
80004ee2:	ee f8 ff ec 	ld.w	r8,r7[-20]
80004ee6:	91 19       	st.w	r8[0x4],r9
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
                fp << AVR32_USART_BRGR_FP_OFFSET;
80004ee8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004eec:	f0 09 15 10 	lsl	r9,r8,0x10
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80004ef0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004ef4:	10 49       	or	r9,r8
80004ef6:	ee f8 ff ec 	ld.w	r8,r7[-20]
80004efa:	91 89       	st.w	r8[0x20],r9
                fp << AVR32_USART_BRGR_FP_OFFSET;

  return USART_SUCCESS;
80004efc:	30 08       	mov	r8,0
}
80004efe:	10 9c       	mov	r12,r8
80004f00:	2f 9d       	sub	sp,-28
80004f02:	e3 cd 80 80 	ldm	sp++,r7,pc
80004f06:	d7 03       	nop

80004f08 <usart_reset>:
 */
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
80004f08:	eb cd 40 80 	pushm	r7,lr
80004f0c:	1a 97       	mov	r7,sp
80004f0e:	20 2d       	sub	sp,8
80004f10:	ef 4c ff f8 	st.w	r7[-8],r12
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80004f14:	e1 b8 00 00 	mfsr	r8,0x0
80004f18:	10 9c       	mov	r12,r8
80004f1a:	f0 1f 00 18 	mcall	80004f78 <usart_reset+0x70>
80004f1e:	18 98       	mov	r8,r12
80004f20:	ef 68 ff ff 	st.b	r7[-1],r8

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80004f24:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80004f28:	30 08       	mov	r8,0
80004f2a:	f0 09 18 00 	cp.b	r9,r8
80004f2e:	c0 20       	breq	80004f32 <usart_reset+0x2a>
80004f30:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80004f32:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004f36:	3f f9       	mov	r9,-1
80004f38:	91 39       	st.w	r8[0xc],r9
  usart->csr;
80004f3a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004f3e:	70 58       	ld.w	r8,r8[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80004f40:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80004f44:	30 08       	mov	r8,0
80004f46:	f0 09 18 00 	cp.b	r9,r8
80004f4a:	c0 20       	breq	80004f4e <usart_reset+0x46>
80004f4c:	d5 03       	csrf	0x10

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80004f4e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004f52:	30 09       	mov	r9,0
80004f54:	91 19       	st.w	r8[0x4],r9
  usart->rtor = 0;
80004f56:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004f5a:	30 09       	mov	r9,0
80004f5c:	91 99       	st.w	r8[0x24],r9
  usart->ttgr = 0;
80004f5e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004f62:	30 09       	mov	r9,0
80004f64:	91 a9       	st.w	r8[0x28],r9

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80004f66:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004f6a:	ea 69 61 0c 	mov	r9,680204
80004f6e:	91 09       	st.w	r8[0x0],r9
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80004f70:	2f ed       	sub	sp,-8
80004f72:	e3 cd 80 80 	ldm	sp++,r7,pc
80004f76:	00 00       	add	r0,r0
80004f78:	80 00       	ld.sh	r0,r0[0x0]
80004f7a:	4e 14       	lddpc	r4,800050fc <usart_write_char+0x10>

80004f7c <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80004f7c:	eb cd 40 80 	pushm	r7,lr
80004f80:	1a 97       	mov	r7,sp
80004f82:	20 3d       	sub	sp,12
80004f84:	ef 4c ff fc 	st.w	r7[-4],r12
80004f88:	ef 4b ff f8 	st.w	r7[-8],r11
80004f8c:	ef 4a ff f4 	st.w	r7[-12],r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80004f90:	ee fc ff fc 	ld.w	r12,r7[-4]
80004f94:	f0 1f 00 54 	mcall	800050e4 <usart_init_rs232+0x168>

  // Check input values.
  if (!opt || // Null pointer.
80004f98:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004f9c:	58 08       	cp.w	r8,0
80004f9e:	c3 90       	breq	80005010 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
80004fa0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004fa4:	11 c9       	ld.ub	r9,r8[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80004fa6:	30 48       	mov	r8,4
80004fa8:	f0 09 18 00 	cp.b	r9,r8
80004fac:	e0 88 00 32 	brls	80005010 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
80004fb0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004fb4:	11 c9       	ld.ub	r9,r8[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80004fb6:	30 98       	mov	r8,9
80004fb8:	f0 09 18 00 	cp.b	r9,r8
80004fbc:	e0 8b 00 2a 	brhi	80005010 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80004fc0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004fc4:	11 d9       	ld.ub	r9,r8[0x5]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80004fc6:	30 78       	mov	r8,7
80004fc8:	f0 09 18 00 	cp.b	r9,r8
80004fcc:	e0 8b 00 22 	brhi	80005010 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
80004fd0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004fd4:	90 39       	ld.sh	r9,r8[0x6]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80004fd6:	e0 68 01 01 	mov	r8,257
80004fda:	f0 09 19 00 	cp.h	r9,r8
80004fde:	e0 8b 00 19 	brhi	80005010 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
80004fe2:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004fe6:	f1 39 00 08 	ld.ub	r9,r8[8]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80004fea:	30 38       	mov	r8,3
80004fec:	f0 09 18 00 	cp.b	r9,r8
80004ff0:	e0 8b 00 10 	brhi	80005010 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80004ff4:	ee f9 ff f4 	ld.w	r9,r7[-12]
80004ff8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004ffc:	70 08       	ld.w	r8,r8[0x0]
80004ffe:	12 9a       	mov	r10,r9
80005000:	10 9b       	mov	r11,r8
80005002:	ee fc ff fc 	ld.w	r12,r7[-4]
80005006:	f0 1f 00 39 	mcall	800050e8 <usart_init_rs232+0x16c>
8000500a:	18 98       	mov	r8,r12
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
8000500c:	58 18       	cp.w	r8,1
8000500e:	c0 31       	brne	80005014 <usart_init_rs232+0x98>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;
80005010:	30 18       	mov	r8,1
80005012:	c6 48       	rjmp	800050da <usart_init_rs232+0x15e>

  if (opt->charlength == 9)
80005014:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005018:	11 c9       	ld.ub	r9,r8[0x4]
8000501a:	30 98       	mov	r8,9
8000501c:	f0 09 18 00 	cp.b	r9,r8
80005020:	c0 a1       	brne	80005034 <usart_init_rs232+0xb8>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80005022:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005026:	70 18       	ld.w	r8,r8[0x4]
80005028:	10 99       	mov	r9,r8
8000502a:	b1 b9       	sbr	r9,0x11
8000502c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005030:	91 19       	st.w	r8[0x4],r9
80005032:	c0 d8       	rjmp	8000504c <usart_init_rs232+0xd0>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80005034:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005038:	70 19       	ld.w	r9,r8[0x4]
8000503a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000503e:	11 c8       	ld.ub	r8,r8[0x4]
80005040:	20 58       	sub	r8,5
80005042:	a7 68       	lsl	r8,0x6
80005044:	10 49       	or	r9,r8
80005046:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000504a:	91 19       	st.w	r8[0x4],r9
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
8000504c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005050:	70 19       	ld.w	r9,r8[0x4]
80005052:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005056:	11 d8       	ld.ub	r8,r8[0x5]
80005058:	f0 0a 15 09 	lsl	r10,r8,0x9
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;
8000505c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005060:	f1 38 00 08 	ld.ub	r8,r8[8]
80005064:	af 68       	lsl	r8,0xe
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80005066:	f5 e8 10 08 	or	r8,r10,r8
8000506a:	10 49       	or	r9,r8
8000506c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005070:	91 19       	st.w	r8[0x4],r9
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80005072:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005076:	90 39       	ld.sh	r9,r8[0x6]
80005078:	30 28       	mov	r8,2
8000507a:	f0 09 19 00 	cp.h	r9,r8
8000507e:	e0 88 00 14 	brls	800050a6 <usart_init_rs232+0x12a>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80005082:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005086:	70 18       	ld.w	r8,r8[0x4]
80005088:	10 99       	mov	r9,r8
8000508a:	ad b9       	sbr	r9,0xd
8000508c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005090:	91 19       	st.w	r8[0x4],r9
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80005092:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005096:	90 38       	ld.sh	r8,r8[0x6]
80005098:	5c 78       	castu.h	r8
8000509a:	20 28       	sub	r8,2
8000509c:	10 99       	mov	r9,r8
8000509e:	ee f8 ff fc 	ld.w	r8,r7[-4]
800050a2:	91 a9       	st.w	r8[0x28],r9
800050a4:	c0 d8       	rjmp	800050be <usart_init_rs232+0x142>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
800050a6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800050aa:	70 19       	ld.w	r9,r8[0x4]
800050ac:	ee f8 ff f8 	ld.w	r8,r7[-8]
800050b0:	90 38       	ld.sh	r8,r8[0x6]
800050b2:	5c 78       	castu.h	r8
800050b4:	ad 68       	lsl	r8,0xc
800050b6:	10 49       	or	r9,r8
800050b8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800050bc:	91 19       	st.w	r8[0x4],r9

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
800050be:	ee f8 ff fc 	ld.w	r8,r7[-4]
800050c2:	70 18       	ld.w	r8,r8[0x4]
800050c4:	10 99       	mov	r9,r8
800050c6:	e0 19 ff f0 	andl	r9,0xfff0
800050ca:	ee f8 ff fc 	ld.w	r8,r7[-4]
800050ce:	91 19       	st.w	r8[0x4],r9
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
800050d0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800050d4:	35 09       	mov	r9,80
800050d6:	91 09       	st.w	r8[0x0],r9
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
800050d8:	30 08       	mov	r8,0
}
800050da:	10 9c       	mov	r12,r8
800050dc:	2f dd       	sub	sp,-12
800050de:	e3 cd 80 80 	ldm	sp++,r7,pc
800050e2:	00 00       	add	r0,r0
800050e4:	80 00       	ld.sh	r0,r0[0x0]
800050e6:	4f 08       	lddpc	r8,800052a4 <PCA9952_write_reg+0x48>
800050e8:	80 00       	ld.sh	r0,r0[0x0]
800050ea:	4e 34       	lddpc	r4,80005274 <PCA9952_write_reg+0x18>

800050ec <usart_write_char>:
  return USART_SUCCESS;
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
800050ec:	eb cd 40 80 	pushm	r7,lr
800050f0:	1a 97       	mov	r7,sp
800050f2:	20 3d       	sub	sp,12
800050f4:	ef 4c ff f8 	st.w	r7[-8],r12
800050f8:	ef 4b ff f4 	st.w	r7[-12],r11
800050fc:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005100:	ef 48 ff fc 	st.w	r7[-4],r8
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80005104:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005108:	70 58       	ld.w	r8,r8[0x14]
8000510a:	e2 18 00 02 	andl	r8,0x2,COH
8000510e:	5f 18       	srne	r8
  if (usart_tx_ready(usart))
80005110:	58 08       	cp.w	r8,0
80005112:	c0 a0       	breq	80005126 <usart_write_char+0x3a>
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80005114:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005118:	f3 d8 c0 09 	bfextu	r9,r8,0x0,0x9
8000511c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005120:	91 79       	st.w	r8[0x1c],r9
    return USART_SUCCESS;
80005122:	30 08       	mov	r8,0
80005124:	c0 28       	rjmp	80005128 <usart_write_char+0x3c>
  }
  else
    return USART_TX_BUSY;
80005126:	30 28       	mov	r8,2
}
80005128:	10 9c       	mov	r12,r8
8000512a:	2f dd       	sub	sp,-12
8000512c:	e3 cd 80 80 	ldm	sp++,r7,pc

80005130 <usart_putchar>:


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80005130:	eb cd 40 80 	pushm	r7,lr
80005134:	1a 97       	mov	r7,sp
80005136:	20 3d       	sub	sp,12
80005138:	ef 4c ff f8 	st.w	r7[-8],r12
8000513c:	ef 4b ff f4 	st.w	r7[-12],r11
  int timeout = USART_DEFAULT_TIMEOUT;
80005140:	e0 68 27 10 	mov	r8,10000
80005144:	ef 48 ff fc 	st.w	r7[-4],r8

  do
  {
    if (!timeout--) return USART_FAILURE;
80005148:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000514c:	58 08       	cp.w	r8,0
8000514e:	5f 08       	sreq	r8
80005150:	5c 58       	castu.b	r8
80005152:	ee f9 ff fc 	ld.w	r9,r7[-4]
80005156:	20 19       	sub	r9,1
80005158:	ef 49 ff fc 	st.w	r7[-4],r9
8000515c:	58 08       	cp.w	r8,0
8000515e:	c0 30       	breq	80005164 <usart_putchar+0x34>
80005160:	3f f8       	mov	r8,-1
80005162:	c0 b8       	rjmp	80005178 <usart_putchar+0x48>
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80005164:	ee fb ff f4 	ld.w	r11,r7[-12]
80005168:	ee fc ff f8 	ld.w	r12,r7[-8]
8000516c:	f0 1f 00 05 	mcall	80005180 <usart_putchar+0x50>
80005170:	18 98       	mov	r8,r12
80005172:	58 08       	cp.w	r8,0
80005174:	ce a1       	brne	80005148 <usart_putchar+0x18>

  return USART_SUCCESS;
80005176:	30 08       	mov	r8,0
}
80005178:	10 9c       	mov	r12,r8
8000517a:	2f dd       	sub	sp,-12
8000517c:	e3 cd 80 80 	ldm	sp++,r7,pc
80005180:	80 00       	ld.sh	r0,r0[0x0]
80005182:	50 ec       	stdsp	sp[0x38],r12

80005184 <usart_write_line>:
  return c;
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80005184:	eb cd 40 80 	pushm	r7,lr
80005188:	1a 97       	mov	r7,sp
8000518a:	20 2d       	sub	sp,8
8000518c:	ef 4c ff fc 	st.w	r7[-4],r12
80005190:	ef 4b ff f8 	st.w	r7[-8],r11
  while (*string != '\0')
80005194:	c0 e8       	rjmp	800051b0 <usart_write_line+0x2c>
    usart_putchar(usart, *string++);
80005196:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000519a:	11 88       	ld.ub	r8,r8[0x0]
8000519c:	ee f9 ff f8 	ld.w	r9,r7[-8]
800051a0:	2f f9       	sub	r9,-1
800051a2:	ef 49 ff f8 	st.w	r7[-8],r9
800051a6:	10 9b       	mov	r11,r8
800051a8:	ee fc ff fc 	ld.w	r12,r7[-4]
800051ac:	f0 1f 00 05 	mcall	800051c0 <usart_write_line+0x3c>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
800051b0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800051b4:	11 88       	ld.ub	r8,r8[0x0]
800051b6:	58 08       	cp.w	r8,0
800051b8:	ce f1       	brne	80005196 <usart_write_line+0x12>
    usart_putchar(usart, *string++);
}
800051ba:	2f ed       	sub	sp,-8
800051bc:	e3 cd 80 80 	ldm	sp++,r7,pc
800051c0:	80 00       	ld.sh	r0,r0[0x0]
800051c2:	51 30       	stdsp	sp[0x4c],r0

800051c4 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
800051c4:	e0 7d 00 00 	mov	sp,65536

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
800051c8:	fe c0 db c8 	sub	r0,pc,-9272

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
800051cc:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
800051d0:	d5 53       	csrf	0x15
  cp      r0, r1
800051d2:	30 80       	mov	r0,8
  brhs    idata_load_loop_end
800051d4:	e0 61 00 c0 	mov	r1,192
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
800051d8:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
800051da:	c0 72       	brcc	800051e8 <idata_load_loop_end>
  cp      r0, r1
800051dc:	fe c2 d7 a4 	sub	r2,pc,-10332

800051e0 <idata_load_loop>:
  brlo    idata_load_loop
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
800051e0:	a5 05       	ld.d	r4,r2++
  lda.w   r1, _end
800051e2:	a1 24       	st.d	r0++,r4
  cp      r0, r1
800051e4:	02 30       	cp.w	r0,r1
  brhs    udata_clear_loop_end
800051e6:	cf d3       	brcs	800051e0 <idata_load_loop>

800051e8 <idata_load_loop_end>:
  mov     r2, 0
800051e8:	e0 60 00 c0 	mov	r0,192
  mov     r3, 0
udata_clear_loop:
  st.d    r0++, r2
800051ec:	e0 61 0b d8 	mov	r1,3032
  cp      r0, r1
  brlo    udata_clear_loop
800051f0:	02 30       	cp.w	r0,r1
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
800051f2:	c0 62       	brcc	800051fe <udata_clear_loop_end>
800051f4:	30 02       	mov	r2,0
800051f6:	30 03       	mov	r3,0

800051f8 <udata_clear_loop>:
800051f8:	a1 22       	st.d	r0++,r2
800051fa:	02 30       	cp.w	r0,r1
800051fc:	cf e3       	brcs	800051f8 <udata_clear_loop>

800051fe <udata_clear_loop_end>:
800051fe:	fe cf ed 52 	sub	pc,pc,-4782
80005202:	d7 03       	nop

80005204 <twi_master_read>:
 *                     (see \ref twim_package_t)
 * \return STATUS_OK   If all bytes were read, error code otherwise
 */
static inline status_code_t twi_master_read (volatile avr32_twi_t *twim,
		const twi_package_t *package)
{
80005204:	eb cd 40 80 	pushm	r7,lr
80005208:	1a 97       	mov	r7,sp
8000520a:	20 2d       	sub	sp,8
8000520c:	ef 4c ff fc 	st.w	r7[-4],r12
80005210:	ef 4b ff f8 	st.w	r7[-8],r11
	return (twim_read_packet (twim, package));
80005214:	ee fb ff f8 	ld.w	r11,r7[-8]
80005218:	ee fc ff fc 	ld.w	r12,r7[-4]
8000521c:	f0 1f 00 04 	mcall	8000522c <twi_master_read+0x28>
80005220:	18 98       	mov	r8,r12
}
80005222:	10 9c       	mov	r12,r8
80005224:	2f ed       	sub	sp,-8
80005226:	e3 cd 80 80 	ldm	sp++,r7,pc
8000522a:	00 00       	add	r0,r0
8000522c:	80 00       	ld.sh	r0,r0[0x0]
8000522e:	4a 28       	lddpc	r8,800052b4 <PCA9952_write_reg+0x58>

80005230 <twi_master_write>:
 *                     (see \ref twim_package_t)
 * \return STATUS_OK   if all bytes were written, error code otherwise
 */
static inline status_code_t twi_master_write (volatile avr32_twi_t *twim,
		const twi_package_t *package)
{
80005230:	eb cd 40 80 	pushm	r7,lr
80005234:	1a 97       	mov	r7,sp
80005236:	20 2d       	sub	sp,8
80005238:	ef 4c ff fc 	st.w	r7[-4],r12
8000523c:	ef 4b ff f8 	st.w	r7[-8],r11
	return (twim_write_packet (twim, package));
80005240:	ee fb ff f8 	ld.w	r11,r7[-8]
80005244:	ee fc ff fc 	ld.w	r12,r7[-4]
80005248:	f0 1f 00 04 	mcall	80005258 <twi_master_write+0x28>
8000524c:	18 98       	mov	r8,r12
}
8000524e:	10 9c       	mov	r12,r8
80005250:	2f ed       	sub	sp,-8
80005252:	e3 cd 80 80 	ldm	sp++,r7,pc
80005256:	00 00       	add	r0,r0
80005258:	80 00       	ld.sh	r0,r0[0x0]
8000525a:	4b a4       	lddpc	r4,80005340 <PCA9952_read_reg+0x60>

8000525c <PCA9952_write_reg>:
 *
 * \param reg_index Register address. Use macros as defined in the header file.
 * \param data Data that should be written to the device register.
 */
void PCA9952_write_reg(unsigned char topBotn, uint8_t reg_index, uint8_t data)
{
8000525c:	eb cd 40 80 	pushm	r7,lr
80005260:	1a 97       	mov	r7,sp
80005262:	20 9d       	sub	sp,36
80005264:	16 99       	mov	r9,r11
80005266:	14 98       	mov	r8,r10
80005268:	18 9a       	mov	r10,r12
8000526a:	ef 6a ff e4 	st.b	r7[-28],r10
8000526e:	ef 69 ff e0 	st.b	r7[-32],r9
80005272:	ef 68 ff dc 	st.b	r7[-36],r8
uint8_t pack[2];
twi_package_t twi_package;

	pack[0] = reg_index;
80005276:	ef 38 ff e0 	ld.ub	r8,r7[-32]
8000527a:	ef 68 ff fc 	st.b	r7[-4],r8
	pack[1] = data;
8000527e:	ef 38 ff dc 	ld.ub	r8,r7[-36]
80005282:	ef 68 ff fd 	st.b	r7[-3],r8

//7apr15	twi_package.chip = PCA9952_TWI_ADDRESS;

	if (topBotn == LED_TOP)
80005286:	ef 39 ff e4 	ld.ub	r9,r7[-28]
8000528a:	30 08       	mov	r8,0
8000528c:	f0 09 18 00 	cp.b	r9,r8
80005290:	c0 51       	brne	8000529a <PCA9952_write_reg+0x3e>
	{
		twi_package.chip = PCA9952_U7_TOPDRIVE_TWI_ADDRESS;
80005292:	36 08       	mov	r8,96
80005294:	ef 48 ff e8 	st.w	r7[-24],r8
80005298:	c0 a8       	rjmp	800052ac <PCA9952_write_reg+0x50>
	}
	else if (topBotn == LED_BOTTOM)
8000529a:	ef 39 ff e4 	ld.ub	r9,r7[-28]
8000529e:	30 18       	mov	r8,1
800052a0:	f0 09 18 00 	cp.b	r9,r8
800052a4:	c0 41       	brne	800052ac <PCA9952_write_reg+0x50>
	{
		twi_package.chip = PCA9952_U8_BOTDRIVE_TWI_ADDRESS;
800052a6:	36 18       	mov	r8,97
800052a8:	ef 48 ff e8 	st.w	r7[-24],r8
	}

	twi_package.addr_length = 0;
800052ac:	30 08       	mov	r8,0
800052ae:	ef 68 ff ef 	st.b	r7[-17],r8
	twi_package.buffer = &pack;
800052b2:	ee c8 00 04 	sub	r8,r7,4
800052b6:	ef 48 ff f0 	st.w	r7[-16],r8
	twi_package.length = sizeof(pack);
800052ba:	30 28       	mov	r8,2
800052bc:	ef 48 ff f4 	st.w	r7[-12],r8

	while(twi_master_write(PCA9952_TWI, &twi_package)!=TWI_SUCCESS);
800052c0:	ee c8 00 18 	sub	r8,r7,24
800052c4:	10 9b       	mov	r11,r8
800052c6:	fe 7c 38 00 	mov	r12,-51200
800052ca:	f0 1f 00 05 	mcall	800052dc <PCA9952_write_reg+0x80>
800052ce:	18 98       	mov	r8,r12
800052d0:	58 08       	cp.w	r8,0
800052d2:	cf 71       	brne	800052c0 <PCA9952_write_reg+0x64>

	return;
}
800052d4:	2f 7d       	sub	sp,-36
800052d6:	e3 cd 80 80 	ldm	sp++,r7,pc
800052da:	00 00       	add	r0,r0
800052dc:	80 00       	ld.sh	r0,r0[0x0]
800052de:	52 30       	stdsp	sp[0x8c],r0

800052e0 <PCA9952_read_reg>:
 *
 * \param reg_index Register address.
 * \returns Register content.
 */
uint8_t PCA9952_read_reg(unsigned char topBotn, uint8_t reg_index)
{
800052e0:	eb cd 40 8f 	pushm	r0-r3,r7,lr
800052e4:	1a 97       	mov	r7,sp
800052e6:	21 3d       	sub	sp,76
800052e8:	18 99       	mov	r9,r12
800052ea:	16 98       	mov	r8,r11
800052ec:	ef 69 ff b8 	st.b	r7[-72],r9
800052f0:	ef 68 ff b4 	st.b	r7[-76],r8
uint8_t data;
twi_package_t twi_package;

//7apr15	twi_package.chip = PCA9952_TWI_ADDRESS;

	if (topBotn == LED_TOP)
800052f4:	ef 39 ff b8 	ld.ub	r9,r7[-72]
800052f8:	30 08       	mov	r8,0
800052fa:	f0 09 18 00 	cp.b	r9,r8
800052fe:	c0 51       	brne	80005308 <PCA9952_read_reg+0x28>
	{
		twi_package.chip = PCA9952_U7_TOPDRIVE_TWI_ADDRESS;
80005300:	36 08       	mov	r8,96
80005302:	ef 48 ff c8 	st.w	r7[-56],r8
80005306:	c0 a8       	rjmp	8000531a <PCA9952_read_reg+0x3a>
	}
	else if (topBotn == LED_BOTTOM)
80005308:	ef 39 ff b8 	ld.ub	r9,r7[-72]
8000530c:	30 18       	mov	r8,1
8000530e:	f0 09 18 00 	cp.b	r9,r8
80005312:	c0 41       	brne	8000531a <PCA9952_read_reg+0x3a>
	{
		twi_package.chip = PCA9952_U8_BOTDRIVE_TWI_ADDRESS;
80005314:	36 18       	mov	r8,97
80005316:	ef 48 ff c8 	st.w	r7[-56],r8
	}

	twi_package.addr_length = 0;
8000531a:	30 08       	mov	r8,0
8000531c:	ef 68 ff cf 	st.b	r7[-49],r8
	twi_package.buffer = &reg_index;
80005320:	ee c8 00 4c 	sub	r8,r7,76
80005324:	ef 48 ff d0 	st.w	r7[-48],r8
	twi_package.length = 1;
80005328:	30 18       	mov	r8,1
8000532a:	ef 48 ff d4 	st.w	r7[-44],r8
	while(twi_master_write(PCA9952_TWI, &twi_package)!=TWI_SUCCESS);
8000532e:	ee c8 00 38 	sub	r8,r7,56
80005332:	10 9b       	mov	r11,r8
80005334:	fe 7c 38 00 	mov	r12,-51200
80005338:	f0 1f 00 5e 	mcall	800054b0 <PCA9952_read_reg+0x1d0>
8000533c:	18 98       	mov	r8,r12
8000533e:	58 08       	cp.w	r8,0
80005340:	cf 71       	brne	8000532e <PCA9952_read_reg+0x4e>
	* specified in the datasheet.
	* Also there seems to be a bug in the TWI module or the driver
	* since some delay here (code or real delay) adds about 500us
	* between the write and the next read cycle.
	*/
	cpu_delay_us(20, cpu_hz);
80005342:	4d d8       	lddpc	r8,800054b4 <PCA9952_read_reg+0x1d4>
80005344:	70 08       	ld.w	r8,r8[0x0]
80005346:	31 49       	mov	r9,20
80005348:	ef 49 ff e4 	st.w	r7[-28],r9
8000534c:	ef 48 ff e0 	st.w	r7[-32],r8
80005350:	ee f8 ff e4 	ld.w	r8,r7[-28]
80005354:	ef 48 ff ec 	st.w	r7[-20],r8
80005358:	ee f8 ff e0 	ld.w	r8,r7[-32]
8000535c:	ef 48 ff e8 	st.w	r7[-24],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_us_2_cy(unsigned long us, unsigned long fcpu_hz)
{
  return ((unsigned long long)us * fcpu_hz + 999999) / 1000000;
80005360:	ee f0 ff ec 	ld.w	r0,r7[-20]
80005364:	30 01       	mov	r1,0
80005366:	ee f2 ff e8 	ld.w	r2,r7[-24]
8000536a:	30 03       	mov	r3,0
8000536c:	e2 02 02 4a 	mul	r10,r1,r2
80005370:	e6 00 02 48 	mul	r8,r3,r0
80005374:	10 0a       	add	r10,r8
80005376:	e0 02 06 48 	mulu.d	r8,r0,r2
8000537a:	12 0a       	add	r10,r9
8000537c:	14 99       	mov	r9,r10
8000537e:	ee 7a 42 3f 	mov	r10,999999
80005382:	30 0b       	mov	r11,0
80005384:	f0 0a 00 0a 	add	r10,r8,r10
80005388:	f2 0b 00 4b 	adc	r11,r9,r11
8000538c:	ee 78 42 40 	mov	r8,1000000
80005390:	30 09       	mov	r9,0
80005392:	f0 1f 00 4a 	mcall	800054b8 <PCA9952_read_reg+0x1d8>
80005396:	14 98       	mov	r8,r10
80005398:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_us(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_us_2_cy(delay, fcpu_hz), &timer);
8000539a:	ef 48 ff f4 	st.w	r7[-12],r8
8000539e:	ee c8 00 44 	sub	r8,r7,68
800053a2:	ef 48 ff f0 	st.w	r7[-16],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800053a6:	e1 b8 00 42 	mfsr	r8,0x108
800053aa:	10 99       	mov	r9,r8
800053ac:	ee f8 ff f0 	ld.w	r8,r7[-16]
800053b0:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800053b2:	ee f8 ff f0 	ld.w	r8,r7[-16]
800053b6:	70 09       	ld.w	r9,r8[0x0]
800053b8:	ee f8 ff f4 	ld.w	r8,r7[-12]
800053bc:	10 09       	add	r9,r8
800053be:	ee f8 ff f0 	ld.w	r8,r7[-16]
800053c2:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
800053c4:	ee f9 ff f0 	ld.w	r9,r7[-16]
800053c8:	30 08       	mov	r8,0
800053ca:	f3 68 00 08 	st.b	r9[8],r8
800053ce:	ee c8 00 44 	sub	r8,r7,68
800053d2:	ef 48 ff f8 	st.w	r7[-8],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800053d6:	e1 b8 00 42 	mfsr	r8,0x108
800053da:	ef 48 ff fc 	st.w	r7[-4],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
800053de:	ee f8 ff f8 	ld.w	r8,r7[-8]
800053e2:	f1 39 00 08 	ld.ub	r9,r8[8]
800053e6:	30 28       	mov	r8,2
800053e8:	f0 09 18 00 	cp.b	r9,r8
800053ec:	c0 31       	brne	800053f2 <PCA9952_read_reg+0x112>
    return false;
800053ee:	30 08       	mov	r8,0
800053f0:	c4 38       	rjmp	80005476 <PCA9952_read_reg+0x196>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
800053f2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800053f6:	f1 39 00 08 	ld.ub	r9,r8[8]
800053fa:	30 18       	mov	r8,1
800053fc:	f0 09 18 00 	cp.b	r9,r8
80005400:	c0 31       	brne	80005406 <PCA9952_read_reg+0x126>
    return true;
80005402:	30 18       	mov	r8,1
80005404:	c3 98       	rjmp	80005476 <PCA9952_read_reg+0x196>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80005406:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000540a:	70 09       	ld.w	r9,r8[0x0]
8000540c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005410:	70 18       	ld.w	r8,r8[0x4]
80005412:	10 39       	cp.w	r9,r8
80005414:	e0 88 00 1a 	brls	80005448 <PCA9952_read_reg+0x168>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80005418:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000541c:	70 08       	ld.w	r8,r8[0x0]
8000541e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80005422:	10 39       	cp.w	r9,r8
80005424:	c1 02       	brcc	80005444 <PCA9952_read_reg+0x164>
80005426:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000542a:	70 18       	ld.w	r8,r8[0x4]
8000542c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80005430:	10 39       	cp.w	r9,r8
80005432:	e0 88 00 09 	brls	80005444 <PCA9952_read_reg+0x164>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80005436:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000543a:	30 18       	mov	r8,1
8000543c:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80005440:	30 18       	mov	r8,1
80005442:	c1 a8       	rjmp	80005476 <PCA9952_read_reg+0x196>
    }
    return false;
80005444:	30 08       	mov	r8,0
80005446:	c1 88       	rjmp	80005476 <PCA9952_read_reg+0x196>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80005448:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000544c:	70 08       	ld.w	r8,r8[0x0]
8000544e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80005452:	10 39       	cp.w	r9,r8
80005454:	c0 93       	brcs	80005466 <PCA9952_read_reg+0x186>
80005456:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000545a:	70 18       	ld.w	r8,r8[0x4]
8000545c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80005460:	10 39       	cp.w	r9,r8
80005462:	e0 88 00 09 	brls	80005474 <PCA9952_read_reg+0x194>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80005466:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000546a:	30 18       	mov	r8,1
8000546c:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80005470:	30 18       	mov	r8,1
80005472:	c0 28       	rjmp	80005476 <PCA9952_read_reg+0x196>
    }
    return false;
80005474:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_us(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_us_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
80005476:	58 08       	cp.w	r8,0
80005478:	ca b0       	breq	800053ce <PCA9952_read_reg+0xee>

//7apr15 this was set above, no need to reassign	twi_package.chip = PCA9952_TWI_ADDRESS;
	twi_package.addr_length = 0;
8000547a:	30 08       	mov	r8,0
8000547c:	ef 68 ff cf 	st.b	r7[-49],r8
	twi_package.buffer = &data;
80005480:	ee c8 00 21 	sub	r8,r7,33
80005484:	ef 48 ff d0 	st.w	r7[-48],r8
	twi_package.length = 1;
80005488:	30 18       	mov	r8,1
8000548a:	ef 48 ff d4 	st.w	r7[-44],r8
	while(twi_master_read(PCA9952_TWI, &twi_package)!=TWI_SUCCESS);
8000548e:	ee c8 00 38 	sub	r8,r7,56
80005492:	10 9b       	mov	r11,r8
80005494:	fe 7c 38 00 	mov	r12,-51200
80005498:	f0 1f 00 09 	mcall	800054bc <PCA9952_read_reg+0x1dc>
8000549c:	18 98       	mov	r8,r12
8000549e:	58 08       	cp.w	r8,0
800054a0:	cf 71       	brne	8000548e <PCA9952_read_reg+0x1ae>

	return data;
800054a2:	ef 38 ff df 	ld.ub	r8,r7[-33]
}
800054a6:	10 9c       	mov	r12,r8
800054a8:	2e dd       	sub	sp,-76
800054aa:	e3 cd 80 8f 	ldm	sp++,r0-r3,r7,pc
800054ae:	00 00       	add	r0,r0
800054b0:	80 00       	ld.sh	r0,r0[0x0]
800054b2:	52 30       	stdsp	sp[0x8c],r0
800054b4:	00 00       	add	r0,r0
800054b6:	02 b0       	st.h	r1++,r0
800054b8:	80 00       	ld.sh	r0,r0[0x0]
800054ba:	71 b0       	ld.w	r0,r8[0x6c]
800054bc:	80 00       	ld.sh	r0,r0[0x0]
800054be:	52 04       	stdsp	sp[0x80],r4

800054c0 <PCA9952_init>:


//7apr15 void PCA9952_init(int32_t fcpu) //TODO: maybe don't need fcpu, we'll see.
void PCA9952_init(void) //7apr15
{
800054c0:	eb cd 40 80 	pushm	r7,lr
800054c4:	1a 97       	mov	r7,sp
800054c6:	20 1d       	sub	sp,4
	/* Store cpu frequency locally*/
//7apr15	cpu_hz = fcpu;

	//Note output is off at the chip level before coming into this routine, LED_OEn set high before calling this function from main()

	PCA9952_write_reg(LED_TOP, PCA9952_MODE1, 0);		//No autoincrement, normal mode not sleep, does not respond to sub or allcall addresses
800054c8:	30 0a       	mov	r10,0
800054ca:	30 0b       	mov	r11,0
800054cc:	30 0c       	mov	r12,0
800054ce:	f0 1f 00 32 	mcall	80005594 <PCA9952_init+0xd4>
	PCA9952_write_reg(LED_TOP, PCA9952_MODE2, 0);		//Dimming not blinking, change on stop not ack (don't really care but have to pick something)
800054d2:	30 0a       	mov	r10,0
800054d4:	30 1b       	mov	r11,1
800054d6:	30 0c       	mov	r12,0
800054d8:	f0 1f 00 2f 	mcall	80005594 <PCA9952_init+0xd4>
	PCA9952_write_reg(LED_TOP, PCA9952_IREFALL, LED_DRIVER_CURRENT); //9apr15 drive at half current for now, power supply circuit needs modification
800054dc:	36 4a       	mov	r10,100
800054de:	34 3b       	mov	r11,67
800054e0:	30 0c       	mov	r12,0
800054e2:	f0 1f 00 2d 	mcall	80005594 <PCA9952_init+0xd4>
	PCA9952_write_reg(LED_TOP, PCA9952_LEDOUT0, 0);		//Setting all channels off for now
800054e6:	30 0a       	mov	r10,0
800054e8:	30 2b       	mov	r11,2
800054ea:	30 0c       	mov	r12,0
800054ec:	f0 1f 00 2a 	mcall	80005594 <PCA9952_init+0xd4>
	PCA9952_write_reg(LED_TOP, PCA9952_LEDOUT1, 0);
800054f0:	30 0a       	mov	r10,0
800054f2:	30 3b       	mov	r11,3
800054f4:	30 0c       	mov	r12,0
800054f6:	f0 1f 00 28 	mcall	80005594 <PCA9952_init+0xd4>
	PCA9952_write_reg(LED_TOP, PCA9952_LEDOUT2, 0);
800054fa:	30 0a       	mov	r10,0
800054fc:	30 4b       	mov	r11,4
800054fe:	30 0c       	mov	r12,0
80005500:	f0 1f 00 25 	mcall	80005594 <PCA9952_init+0xd4>
	PCA9952_write_reg(LED_TOP, PCA9952_LEDOUT3, 0);
80005504:	30 0a       	mov	r10,0
80005506:	30 5b       	mov	r11,5
80005508:	30 0c       	mov	r12,0
8000550a:	f0 1f 00 23 	mcall	80005594 <PCA9952_init+0xd4>

	tmp1 = PCA9952_read_reg(LED_TOP, PCA9952_EFLAG0);	//TODO: just see what we get, will need to weave error checking into this system later
8000550e:	34 4b       	mov	r11,68
80005510:	30 0c       	mov	r12,0
80005512:	f0 1f 00 22 	mcall	80005598 <PCA9952_init+0xd8>
80005516:	18 98       	mov	r8,r12
80005518:	ef 68 ff ff 	st.b	r7[-1],r8
	tmp2 = PCA9952_read_reg(LED_TOP, PCA9952_EFLAG1);
8000551c:	34 5b       	mov	r11,69
8000551e:	30 0c       	mov	r12,0
80005520:	f0 1f 00 1e 	mcall	80005598 <PCA9952_init+0xd8>
80005524:	18 98       	mov	r8,r12
80005526:	ef 68 ff fe 	st.b	r7[-2],r8

	PCA9952_write_reg(LED_BOTTOM, PCA9952_MODE1, 0);		//No autoincrement, normal mode not sleep, does not respond to sub or allcall addresses
8000552a:	30 0a       	mov	r10,0
8000552c:	30 0b       	mov	r11,0
8000552e:	30 1c       	mov	r12,1
80005530:	f0 1f 00 19 	mcall	80005594 <PCA9952_init+0xd4>
	PCA9952_write_reg(LED_BOTTOM, PCA9952_MODE2, 0);		//Dimming not blinking, change on stop not ack (don't really care but have to pick something)
80005534:	30 0a       	mov	r10,0
80005536:	30 1b       	mov	r11,1
80005538:	30 1c       	mov	r12,1
8000553a:	f0 1f 00 17 	mcall	80005594 <PCA9952_init+0xd4>
	PCA9952_write_reg(LED_BOTTOM, PCA9952_IREFALL, LED_DRIVER_CURRENT); //9apr15 drive at half current for now, power supply circuit needs modification
8000553e:	36 4a       	mov	r10,100
80005540:	34 3b       	mov	r11,67
80005542:	30 1c       	mov	r12,1
80005544:	f0 1f 00 14 	mcall	80005594 <PCA9952_init+0xd4>
	PCA9952_write_reg(LED_BOTTOM, PCA9952_LEDOUT0, 0);		//Setting all channels off for now
80005548:	30 0a       	mov	r10,0
8000554a:	30 2b       	mov	r11,2
8000554c:	30 1c       	mov	r12,1
8000554e:	f0 1f 00 12 	mcall	80005594 <PCA9952_init+0xd4>
	PCA9952_write_reg(LED_BOTTOM, PCA9952_LEDOUT1, 0);
80005552:	30 0a       	mov	r10,0
80005554:	30 3b       	mov	r11,3
80005556:	30 1c       	mov	r12,1
80005558:	f0 1f 00 0f 	mcall	80005594 <PCA9952_init+0xd4>
	PCA9952_write_reg(LED_BOTTOM, PCA9952_LEDOUT2, 0);
8000555c:	30 0a       	mov	r10,0
8000555e:	30 4b       	mov	r11,4
80005560:	30 1c       	mov	r12,1
80005562:	f0 1f 00 0d 	mcall	80005594 <PCA9952_init+0xd4>
	PCA9952_write_reg(LED_BOTTOM, PCA9952_LEDOUT3, 0);
80005566:	30 0a       	mov	r10,0
80005568:	30 5b       	mov	r11,5
8000556a:	30 1c       	mov	r12,1
8000556c:	f0 1f 00 0a 	mcall	80005594 <PCA9952_init+0xd4>

	tmp3 = PCA9952_read_reg(LED_BOTTOM, PCA9952_EFLAG0);	//TODO: just see what we get, will need to weave error checking into this system later
80005570:	34 4b       	mov	r11,68
80005572:	30 1c       	mov	r12,1
80005574:	f0 1f 00 09 	mcall	80005598 <PCA9952_init+0xd8>
80005578:	18 98       	mov	r8,r12
8000557a:	ef 68 ff fd 	st.b	r7[-3],r8
	tmp4 = PCA9952_read_reg(LED_BOTTOM, PCA9952_EFLAG1);
8000557e:	34 5b       	mov	r11,69
80005580:	30 1c       	mov	r12,1
80005582:	f0 1f 00 06 	mcall	80005598 <PCA9952_init+0xd8>
80005586:	18 98       	mov	r8,r12
80005588:	ef 68 ff fc 	st.b	r7[-4],r8

}
8000558c:	2f fd       	sub	sp,-4
8000558e:	e3 cd 80 80 	ldm	sp++,r7,pc
80005592:	00 00       	add	r0,r0
80005594:	80 00       	ld.sh	r0,r0[0x0]
80005596:	52 5c       	stdsp	sp[0x94],r12
80005598:	80 00       	ld.sh	r0,r0[0x0]
8000559a:	52 e0       	stdsp	sp[0xb8],r0

8000559c <PCA9952_channel>:



void PCA9952_channel(unsigned char topBotn, unsigned char channel, unsigned char onOffn)
{
8000559c:	eb cd 40 80 	pushm	r7,lr
800055a0:	1a 97       	mov	r7,sp
800055a2:	20 5d       	sub	sp,20
800055a4:	16 99       	mov	r9,r11
800055a6:	14 98       	mov	r8,r10
800055a8:	18 9a       	mov	r10,r12
800055aa:	ef 6a ff f4 	st.b	r7[-12],r10
800055ae:	ef 69 ff f0 	st.b	r7[-16],r9
800055b2:	ef 68 ff ec 	st.b	r7[-20],r8
	unsigned char regIdx, regPos, regShadow, maskVal, writeVal;
	
	regIdx = (channel / 4); //LEDOUT0 controls channels 0..3, LEDOUT1 controls channels 4..7 etc.
800055b6:	ef 38 ff f0 	ld.ub	r8,r7[-16]
800055ba:	a3 88       	lsr	r8,0x2
800055bc:	ef 68 ff fb 	st.b	r7[-5],r8
	regPos = (channel % 4);
800055c0:	ef 38 ff f0 	ld.ub	r8,r7[-16]
800055c4:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800055c8:	ef 68 ff fc 	st.b	r7[-4],r8
	
	switch(regIdx)
800055cc:	ef 38 ff fb 	ld.ub	r8,r7[-5]
800055d0:	58 18       	cp.w	r8,1
800055d2:	c1 50       	breq	800055fc <PCA9952_channel+0x60>
800055d4:	e0 89 00 05 	brgt	800055de <PCA9952_channel+0x42>
800055d8:	58 08       	cp.w	r8,0
800055da:	c0 70       	breq	800055e8 <PCA9952_channel+0x4c>
800055dc:	c2 d8       	rjmp	80005636 <PCA9952_channel+0x9a>
800055de:	58 28       	cp.w	r8,2
800055e0:	c1 80       	breq	80005610 <PCA9952_channel+0x74>
800055e2:	58 38       	cp.w	r8,3
800055e4:	c2 00       	breq	80005624 <PCA9952_channel+0x88>
800055e6:	c2 88       	rjmp	80005636 <PCA9952_channel+0x9a>
	{
		case 0:
			regShadow = PCA9952_read_reg(topBotn,PCA9952_LEDOUT0);
800055e8:	ef 38 ff f4 	ld.ub	r8,r7[-12]
800055ec:	30 2b       	mov	r11,2
800055ee:	10 9c       	mov	r12,r8
800055f0:	f0 1f 00 49 	mcall	80005714 <PCA9952_channel+0x178>
800055f4:	18 98       	mov	r8,r12
800055f6:	ef 68 ff fd 	st.b	r7[-3],r8
			break;
800055fa:	c1 e8       	rjmp	80005636 <PCA9952_channel+0x9a>
		case 1:
			regShadow = PCA9952_read_reg(topBotn,PCA9952_LEDOUT1);
800055fc:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80005600:	30 3b       	mov	r11,3
80005602:	10 9c       	mov	r12,r8
80005604:	f0 1f 00 44 	mcall	80005714 <PCA9952_channel+0x178>
80005608:	18 98       	mov	r8,r12
8000560a:	ef 68 ff fd 	st.b	r7[-3],r8
			break;
8000560e:	c1 48       	rjmp	80005636 <PCA9952_channel+0x9a>
		case 2:
			regShadow = PCA9952_read_reg(topBotn,PCA9952_LEDOUT2);
80005610:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80005614:	30 4b       	mov	r11,4
80005616:	10 9c       	mov	r12,r8
80005618:	f0 1f 00 3f 	mcall	80005714 <PCA9952_channel+0x178>
8000561c:	18 98       	mov	r8,r12
8000561e:	ef 68 ff fd 	st.b	r7[-3],r8
			break;
80005622:	c0 a8       	rjmp	80005636 <PCA9952_channel+0x9a>
		case 3:
			regShadow = PCA9952_read_reg(topBotn,PCA9952_LEDOUT3);
80005624:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80005628:	30 5b       	mov	r11,5
8000562a:	10 9c       	mov	r12,r8
8000562c:	f0 1f 00 3a 	mcall	80005714 <PCA9952_channel+0x178>
80005630:	18 98       	mov	r8,r12
80005632:	ef 68 ff fd 	st.b	r7[-3],r8
			break;		
	}

	maskVal = 0xFF << (regPos * 2);
80005636:	ef 38 ff fc 	ld.ub	r8,r7[-4]
8000563a:	a1 78       	lsl	r8,0x1
8000563c:	e0 69 00 ff 	mov	r9,255
80005640:	f2 08 09 48 	lsl	r8,r9,r8
80005644:	ef 68 ff fe 	st.b	r7[-2],r8
	maskVal = maskVal ^ 0xFF;
80005648:	ef 38 ff fe 	ld.ub	r8,r7[-2]
8000564c:	5c d8       	com	r8
8000564e:	ef 68 ff fe 	st.b	r7[-2],r8
	regShadow &= maskVal;
80005652:	ef 39 ff fd 	ld.ub	r9,r7[-3]
80005656:	ef 38 ff fe 	ld.ub	r8,r7[-2]
8000565a:	f3 e8 00 08 	and	r8,r9,r8
8000565e:	ef 68 ff fd 	st.b	r7[-3],r8

	if (onOffn == LED_ON)
80005662:	ef 39 ff ec 	ld.ub	r9,r7[-20]
80005666:	30 18       	mov	r8,1
80005668:	f0 09 18 00 	cp.b	r9,r8
8000566c:	c0 a1       	brne	80005680 <PCA9952_channel+0xe4>
	{
		writeVal = (0x01 << (regPos * 2));
8000566e:	ef 38 ff fc 	ld.ub	r8,r7[-4]
80005672:	a1 78       	lsl	r8,0x1
80005674:	30 19       	mov	r9,1
80005676:	f2 08 09 48 	lsl	r8,r9,r8
8000567a:	ef 68 ff ff 	st.b	r7[-1],r8
8000567e:	c0 a8       	rjmp	80005692 <PCA9952_channel+0xf6>
	}
	else if (onOffn == LED_OFF)
80005680:	ef 39 ff ec 	ld.ub	r9,r7[-20]
80005684:	30 08       	mov	r8,0
80005686:	f0 09 18 00 	cp.b	r9,r8
8000568a:	c0 41       	brne	80005692 <PCA9952_channel+0xf6>
	{
		writeVal = 0;
8000568c:	30 08       	mov	r8,0
8000568e:	ef 68 ff ff 	st.b	r7[-1],r8
	}
	
	regShadow |= writeVal;
80005692:	ef 39 ff fd 	ld.ub	r9,r7[-3]
80005696:	ef 38 ff ff 	ld.ub	r8,r7[-1]
8000569a:	f3 e8 10 08 	or	r8,r9,r8
8000569e:	ef 68 ff fd 	st.b	r7[-3],r8
	
	switch(regIdx)
800056a2:	ef 38 ff fb 	ld.ub	r8,r7[-5]
800056a6:	58 18       	cp.w	r8,1
800056a8:	c1 50       	breq	800056d2 <PCA9952_channel+0x136>
800056aa:	e0 89 00 05 	brgt	800056b4 <PCA9952_channel+0x118>
800056ae:	58 08       	cp.w	r8,0
800056b0:	c0 70       	breq	800056be <PCA9952_channel+0x122>
800056b2:	c2 d8       	rjmp	8000570c <PCA9952_channel+0x170>
800056b4:	58 28       	cp.w	r8,2
800056b6:	c1 80       	breq	800056e6 <PCA9952_channel+0x14a>
800056b8:	58 38       	cp.w	r8,3
800056ba:	c2 00       	breq	800056fa <PCA9952_channel+0x15e>
800056bc:	c2 88       	rjmp	8000570c <PCA9952_channel+0x170>
	{
		case 0:
			PCA9952_write_reg(topBotn,PCA9952_LEDOUT0, regShadow);
800056be:	ef 39 ff fd 	ld.ub	r9,r7[-3]
800056c2:	ef 38 ff f4 	ld.ub	r8,r7[-12]
800056c6:	12 9a       	mov	r10,r9
800056c8:	30 2b       	mov	r11,2
800056ca:	10 9c       	mov	r12,r8
800056cc:	f0 1f 00 13 	mcall	80005718 <PCA9952_channel+0x17c>
			break;
800056d0:	c1 e8       	rjmp	8000570c <PCA9952_channel+0x170>
		case 1:
			PCA9952_write_reg(topBotn,PCA9952_LEDOUT1, regShadow);
800056d2:	ef 39 ff fd 	ld.ub	r9,r7[-3]
800056d6:	ef 38 ff f4 	ld.ub	r8,r7[-12]
800056da:	12 9a       	mov	r10,r9
800056dc:	30 3b       	mov	r11,3
800056de:	10 9c       	mov	r12,r8
800056e0:	f0 1f 00 0e 	mcall	80005718 <PCA9952_channel+0x17c>
			break;
800056e4:	c1 48       	rjmp	8000570c <PCA9952_channel+0x170>
		case 2:
			PCA9952_write_reg(topBotn,PCA9952_LEDOUT2, regShadow);
800056e6:	ef 39 ff fd 	ld.ub	r9,r7[-3]
800056ea:	ef 38 ff f4 	ld.ub	r8,r7[-12]
800056ee:	12 9a       	mov	r10,r9
800056f0:	30 4b       	mov	r11,4
800056f2:	10 9c       	mov	r12,r8
800056f4:	f0 1f 00 09 	mcall	80005718 <PCA9952_channel+0x17c>
			break;
800056f8:	c0 a8       	rjmp	8000570c <PCA9952_channel+0x170>
		case 3:
			PCA9952_write_reg(topBotn,PCA9952_LEDOUT3, regShadow);
800056fa:	ef 39 ff fd 	ld.ub	r9,r7[-3]
800056fe:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80005702:	12 9a       	mov	r10,r9
80005704:	30 5b       	mov	r11,5
80005706:	10 9c       	mov	r12,r8
80005708:	f0 1f 00 04 	mcall	80005718 <PCA9952_channel+0x17c>
			break;
	}

}
8000570c:	2f bd       	sub	sp,-20
8000570e:	e3 cd 80 80 	ldm	sp++,r7,pc
80005712:	00 00       	add	r0,r0
80005714:	80 00       	ld.sh	r0,r0[0x0]
80005716:	52 e0       	stdsp	sp[0xb8],r0
80005718:	80 00       	ld.sh	r0,r0[0x0]
8000571a:	52 5c       	stdsp	sp[0x94],r12

8000571c <led_shelf>:

void led_shelf(unsigned char shelf, unsigned char onOffn)
{
8000571c:	eb cd 40 80 	pushm	r7,lr
80005720:	1a 97       	mov	r7,sp
80005722:	20 2d       	sub	sp,8
80005724:	18 99       	mov	r9,r12
80005726:	16 98       	mov	r8,r11
80005728:	ef 69 ff fc 	st.b	r7[-4],r9
8000572c:	ef 68 ff f8 	st.b	r7[-8],r8
	switch(shelf)
80005730:	ef 38 ff fc 	ld.ub	r8,r7[-4]
80005734:	58 18       	cp.w	r8,1
80005736:	c2 f0       	breq	80005794 <led_shelf+0x78>
80005738:	e0 89 00 05 	brgt	80005742 <led_shelf+0x26>
8000573c:	58 08       	cp.w	r8,0
8000573e:	c0 70       	breq	8000574c <led_shelf+0x30>
80005740:	c9 58       	rjmp	8000586a <led_shelf+0x14e>
80005742:	58 28       	cp.w	r8,2
80005744:	c4 c0       	breq	800057dc <led_shelf+0xc0>
80005746:	58 38       	cp.w	r8,3
80005748:	c6 e0       	breq	80005824 <led_shelf+0x108>
8000574a:	c9 08       	rjmp	8000586a <led_shelf+0x14e>
	{
		case 0: //bottom of LED board 0 which is the upper board in the shelf, and top of LED board 1 which is the lower board in the shelf
			PCA9952_channel(LED_BOTTOM, 0, onOffn);
8000574c:	ef 38 ff f8 	ld.ub	r8,r7[-8]
80005750:	10 9a       	mov	r10,r8
80005752:	30 0b       	mov	r11,0
80005754:	30 1c       	mov	r12,1
80005756:	f0 1f 00 47 	mcall	80005870 <led_shelf+0x154>
			PCA9952_channel(LED_BOTTOM, 1, onOffn);
8000575a:	ef 38 ff f8 	ld.ub	r8,r7[-8]
8000575e:	10 9a       	mov	r10,r8
80005760:	30 1b       	mov	r11,1
80005762:	30 1c       	mov	r12,1
80005764:	f0 1f 00 43 	mcall	80005870 <led_shelf+0x154>
			PCA9952_channel(LED_BOTTOM, 2, onOffn);
80005768:	ef 38 ff f8 	ld.ub	r8,r7[-8]
8000576c:	10 9a       	mov	r10,r8
8000576e:	30 2b       	mov	r11,2
80005770:	30 1c       	mov	r12,1
80005772:	f0 1f 00 40 	mcall	80005870 <led_shelf+0x154>
			PCA9952_channel(LED_TOP, 0, onOffn);
80005776:	ef 38 ff f8 	ld.ub	r8,r7[-8]
8000577a:	10 9a       	mov	r10,r8
8000577c:	30 0b       	mov	r11,0
8000577e:	30 0c       	mov	r12,0
80005780:	f0 1f 00 3c 	mcall	80005870 <led_shelf+0x154>
			PCA9952_channel(LED_TOP, 1, onOffn);
80005784:	ef 38 ff f8 	ld.ub	r8,r7[-8]
80005788:	10 9a       	mov	r10,r8
8000578a:	30 1b       	mov	r11,1
8000578c:	30 0c       	mov	r12,0
8000578e:	f0 1f 00 39 	mcall	80005870 <led_shelf+0x154>
			break;
80005792:	c6 c8       	rjmp	8000586a <led_shelf+0x14e>

		case 1: //bottom of LED board 1 which is the upper board in the shelf, and top of LED board 2 which is the lower board in the shelf
			PCA9952_channel(LED_BOTTOM, 3, onOffn);
80005794:	ef 38 ff f8 	ld.ub	r8,r7[-8]
80005798:	10 9a       	mov	r10,r8
8000579a:	30 3b       	mov	r11,3
8000579c:	30 1c       	mov	r12,1
8000579e:	f0 1f 00 35 	mcall	80005870 <led_shelf+0x154>
			PCA9952_channel(LED_BOTTOM, 4, onOffn);
800057a2:	ef 38 ff f8 	ld.ub	r8,r7[-8]
800057a6:	10 9a       	mov	r10,r8
800057a8:	30 4b       	mov	r11,4
800057aa:	30 1c       	mov	r12,1
800057ac:	f0 1f 00 31 	mcall	80005870 <led_shelf+0x154>
			PCA9952_channel(LED_BOTTOM, 5, onOffn);
800057b0:	ef 38 ff f8 	ld.ub	r8,r7[-8]
800057b4:	10 9a       	mov	r10,r8
800057b6:	30 5b       	mov	r11,5
800057b8:	30 1c       	mov	r12,1
800057ba:	f0 1f 00 2e 	mcall	80005870 <led_shelf+0x154>
			PCA9952_channel(LED_TOP, 2, onOffn);
800057be:	ef 38 ff f8 	ld.ub	r8,r7[-8]
800057c2:	10 9a       	mov	r10,r8
800057c4:	30 2b       	mov	r11,2
800057c6:	30 0c       	mov	r12,0
800057c8:	f0 1f 00 2a 	mcall	80005870 <led_shelf+0x154>
			PCA9952_channel(LED_TOP, 3, onOffn);
800057cc:	ef 38 ff f8 	ld.ub	r8,r7[-8]
800057d0:	10 9a       	mov	r10,r8
800057d2:	30 3b       	mov	r11,3
800057d4:	30 0c       	mov	r12,0
800057d6:	f0 1f 00 27 	mcall	80005870 <led_shelf+0x154>
			break;
800057da:	c4 88       	rjmp	8000586a <led_shelf+0x14e>

		case 2: //bottom of LED board 2 which is the upper board in the shelf, and top of LED board 3 which is the lower board in the shelf
			PCA9952_channel(LED_BOTTOM, 6, onOffn);
800057dc:	ef 38 ff f8 	ld.ub	r8,r7[-8]
800057e0:	10 9a       	mov	r10,r8
800057e2:	30 6b       	mov	r11,6
800057e4:	30 1c       	mov	r12,1
800057e6:	f0 1f 00 23 	mcall	80005870 <led_shelf+0x154>
			PCA9952_channel(LED_BOTTOM, 7, onOffn);
800057ea:	ef 38 ff f8 	ld.ub	r8,r7[-8]
800057ee:	10 9a       	mov	r10,r8
800057f0:	30 7b       	mov	r11,7
800057f2:	30 1c       	mov	r12,1
800057f4:	f0 1f 00 1f 	mcall	80005870 <led_shelf+0x154>
			PCA9952_channel(LED_BOTTOM, 8, onOffn);
800057f8:	ef 38 ff f8 	ld.ub	r8,r7[-8]
800057fc:	10 9a       	mov	r10,r8
800057fe:	30 8b       	mov	r11,8
80005800:	30 1c       	mov	r12,1
80005802:	f0 1f 00 1c 	mcall	80005870 <led_shelf+0x154>
			PCA9952_channel(LED_TOP, 4, onOffn);
80005806:	ef 38 ff f8 	ld.ub	r8,r7[-8]
8000580a:	10 9a       	mov	r10,r8
8000580c:	30 4b       	mov	r11,4
8000580e:	30 0c       	mov	r12,0
80005810:	f0 1f 00 18 	mcall	80005870 <led_shelf+0x154>
			PCA9952_channel(LED_TOP, 5, onOffn);
80005814:	ef 38 ff f8 	ld.ub	r8,r7[-8]
80005818:	10 9a       	mov	r10,r8
8000581a:	30 5b       	mov	r11,5
8000581c:	30 0c       	mov	r12,0
8000581e:	f0 1f 00 15 	mcall	80005870 <led_shelf+0x154>
			break;
80005822:	c2 48       	rjmp	8000586a <led_shelf+0x14e>

		case 3: //bottom of LED board 3 which is the upper board in the shelf, and top of LED board 4 which is the lower board in the shelf
			PCA9952_channel(LED_BOTTOM, 9, onOffn);
80005824:	ef 38 ff f8 	ld.ub	r8,r7[-8]
80005828:	10 9a       	mov	r10,r8
8000582a:	30 9b       	mov	r11,9
8000582c:	30 1c       	mov	r12,1
8000582e:	f0 1f 00 11 	mcall	80005870 <led_shelf+0x154>
			PCA9952_channel(LED_BOTTOM, 10, onOffn);
80005832:	ef 38 ff f8 	ld.ub	r8,r7[-8]
80005836:	10 9a       	mov	r10,r8
80005838:	30 ab       	mov	r11,10
8000583a:	30 1c       	mov	r12,1
8000583c:	f0 1f 00 0d 	mcall	80005870 <led_shelf+0x154>
			PCA9952_channel(LED_BOTTOM, 11, onOffn);
80005840:	ef 38 ff f8 	ld.ub	r8,r7[-8]
80005844:	10 9a       	mov	r10,r8
80005846:	30 bb       	mov	r11,11
80005848:	30 1c       	mov	r12,1
8000584a:	f0 1f 00 0a 	mcall	80005870 <led_shelf+0x154>
			PCA9952_channel(LED_TOP, 6, onOffn);
8000584e:	ef 38 ff f8 	ld.ub	r8,r7[-8]
80005852:	10 9a       	mov	r10,r8
80005854:	30 6b       	mov	r11,6
80005856:	30 0c       	mov	r12,0
80005858:	f0 1f 00 06 	mcall	80005870 <led_shelf+0x154>
			PCA9952_channel(LED_TOP, 7, onOffn);
8000585c:	ef 38 ff f8 	ld.ub	r8,r7[-8]
80005860:	10 9a       	mov	r10,r8
80005862:	30 7b       	mov	r11,7
80005864:	30 0c       	mov	r12,0
80005866:	f0 1f 00 03 	mcall	80005870 <led_shelf+0x154>
			break;
	}	
	
}
8000586a:	2f ed       	sub	sp,-8
8000586c:	e3 cd 80 80 	ldm	sp++,r7,pc
80005870:	80 00       	ld.sh	r0,r0[0x0]
80005872:	55 9c       	stdsp	sp[0x164],r12
80005874:	53 68       	stdsp	sp[0xd8],r8
80005876:	65 6c       	ld.w	r12,r2[0x58]
80005878:	66 20       	ld.w	r0,r3[0x8]
8000587a:	30 20       	mov	r0,2
8000587c:	61 63       	ld.w	r3,r0[0x58]
8000587e:	74 69       	ld.w	r9,r10[0x18]
80005880:	76 65       	ld.w	r5,r11[0x18]
80005882:	0d 0a       	ld.w	r10,r6++
80005884:	00 00       	add	r0,r0
80005886:	00 00       	add	r0,r0
80005888:	53 68       	stdsp	sp[0xd8],r8
8000588a:	65 6c       	ld.w	r12,r2[0x58]
8000588c:	66 20       	ld.w	r0,r3[0x8]
8000588e:	31 20       	mov	r0,18
80005890:	61 63       	ld.w	r3,r0[0x58]
80005892:	74 69       	ld.w	r9,r10[0x18]
80005894:	76 65       	ld.w	r5,r11[0x18]
80005896:	0d 0a       	ld.w	r10,r6++
80005898:	00 00       	add	r0,r0
8000589a:	00 00       	add	r0,r0
8000589c:	53 68       	stdsp	sp[0xd8],r8
8000589e:	65 6c       	ld.w	r12,r2[0x58]
800058a0:	66 20       	ld.w	r0,r3[0x8]
800058a2:	32 20       	mov	r0,34
800058a4:	61 63       	ld.w	r3,r0[0x58]
800058a6:	74 69       	ld.w	r9,r10[0x18]
800058a8:	76 65       	ld.w	r5,r11[0x18]
800058aa:	0d 0a       	ld.w	r10,r6++
800058ac:	00 00       	add	r0,r0
800058ae:	00 00       	add	r0,r0
800058b0:	53 68       	stdsp	sp[0xd8],r8
800058b2:	65 6c       	ld.w	r12,r2[0x58]
800058b4:	66 20       	ld.w	r0,r3[0x8]
800058b6:	33 20       	mov	r0,50
800058b8:	61 63       	ld.w	r3,r0[0x58]
800058ba:	74 69       	ld.w	r9,r10[0x18]
800058bc:	76 65       	ld.w	r5,r11[0x18]
800058be:	0d 0a       	ld.w	r10,r6++
800058c0:	00 00       	add	r0,r0
800058c2:	00 00       	add	r0,r0
800058c4:	53 45       	stdsp	sp[0xd0],r5
800058c6:	41 4c       	lddsp	r12,sp[0x50]
800058c8:	20 53       	sub	r3,5
800058ca:	48 49       	lddpc	r9,800058d8 <led_shelf+0x1bc>
800058cc:	45 4c       	lddsp	r12,sp[0x150]
800058ce:	44 20       	lddsp	r0,sp[0x108]
800058d0:	44 45       	lddsp	r5,sp[0x110]
800058d2:	4d 4f       	lddpc	pc,80005a20 <display_text+0x10>
800058d4:	20 0d       	sub	sp,0
800058d6:	0a 20       	rsub	r0,r5
800058d8:	43 6f       	lddsp	pc,sp[0xd8]
800058da:	70 79       	ld.w	r9,r8[0x1c]
800058dc:	72 69       	ld.w	r9,r9[0x18]
800058de:	67 68       	ld.w	r8,r3[0x58]
800058e0:	74 20       	ld.w	r0,r10[0x8]
800058e2:	28 63       	sub	r3,-122
800058e4:	29 20       	sub	r0,-110
800058e6:	32 30       	mov	r0,35
800058e8:	31 35       	mov	r5,19
800058ea:	20 54       	sub	r4,5
800058ec:	65 63       	ld.w	r3,r2[0x58]
800058ee:	68 6e       	ld.w	lr,r4[0x18]
800058f0:	69 63       	ld.w	r3,r4[0x58]
800058f2:	61 6c       	ld.w	r12,r0[0x58]
800058f4:	20 53       	sub	r3,5
800058f6:	6f 6c       	ld.w	r12,r7[0x58]
800058f8:	75 74       	ld.w	r4,r10[0x5c]
800058fa:	69 6f       	ld.w	pc,r4[0x58]
800058fc:	6e 73       	ld.w	r3,r7[0x1c]
800058fe:	20 47       	sub	r7,4
80005900:	72 6f       	ld.w	pc,r9[0x18]
80005902:	75 70       	ld.w	r0,r10[0x5c]
80005904:	2c 20       	sub	r0,-62
80005906:	49 6e       	lddpc	lr,8000595c <led_shelf+0x240>
80005908:	63 2e       	ld.w	lr,r1[0x48]
8000590a:	0d 0a       	ld.w	r10,r6++
8000590c:	00 00       	add	r0,r0
8000590e:	00 00       	add	r0,r0
80005910:	44 6f       	lddsp	pc,sp[0x118]
80005912:	6f 72       	ld.w	r2,r7[0x5c]
80005914:	20 6c       	sub	r12,6
80005916:	61 74       	ld.w	r4,r0[0x5c]
80005918:	63 68       	ld.w	r8,r1[0x58]
8000591a:	20 64       	sub	r4,6
8000591c:	65 74       	ld.w	r4,r2[0x5c]
8000591e:	65 63       	ld.w	r3,r2[0x58]
80005920:	74 65       	ld.w	r5,r10[0x18]
80005922:	64 0d       	ld.w	sp,r2[0x0]
80005924:	0a 00       	add	r0,r5
80005926:	00 00       	add	r0,r0
80005928:	41 63       	lddsp	r3,sp[0x58]
8000592a:	74 69       	ld.w	r9,r10[0x18]
8000592c:	6f 6e       	ld.w	lr,r7[0x58]
8000592e:	20 70       	sub	r0,7
80005930:	75 73       	ld.w	r3,r10[0x5c]
80005932:	68 20       	ld.w	r0,r4[0x8]
80005934:	62 75       	ld.w	r5,r1[0x1c]
80005936:	74 74       	ld.w	r4,r10[0x1c]
80005938:	6f 6e       	ld.w	lr,r7[0x58]
8000593a:	20 70       	sub	r0,7
8000593c:	72 65       	ld.w	r5,r9[0x18]
8000593e:	73 73       	ld.w	r3,r9[0x5c]
80005940:	20 64       	sub	r4,6
80005942:	65 74       	ld.w	r4,r2[0x5c]
80005944:	65 63       	ld.w	r3,r2[0x58]
80005946:	74 65       	ld.w	r5,r10[0x18]
80005948:	64 0d       	ld.w	sp,r2[0x0]
8000594a:	0a 00       	add	r0,r5
8000594c:	41 63       	lddsp	r3,sp[0x58]
8000594e:	74 69       	ld.w	r9,r10[0x18]
80005950:	6f 6e       	ld.w	lr,r7[0x58]
80005952:	20 70       	sub	r0,7
80005954:	75 73       	ld.w	r3,r10[0x5c]
80005956:	68 20       	ld.w	r0,r4[0x8]
80005958:	62 75       	ld.w	r5,r1[0x1c]
8000595a:	74 74       	ld.w	r4,r10[0x1c]
8000595c:	6f 6e       	ld.w	lr,r7[0x58]
8000595e:	20 72       	sub	r2,7
80005960:	65 6c       	ld.w	r12,r2[0x58]
80005962:	65 61       	ld.w	r1,r2[0x58]
80005964:	73 65       	ld.w	r5,r9[0x58]
80005966:	20 64       	sub	r4,6
80005968:	65 74       	ld.w	r4,r2[0x5c]
8000596a:	65 63       	ld.w	r3,r2[0x58]
8000596c:	74 65       	ld.w	r5,r10[0x18]
8000596e:	64 0d       	ld.w	sp,r2[0x0]
80005970:	0a 00       	add	r0,r5
80005972:	00 00       	add	r0,r0
80005974:	53 74       	stdsp	sp[0xdc],r4
80005976:	61 72       	ld.w	r2,r0[0x5c]
80005978:	74 20       	ld.w	r0,r10[0x8]
8000597a:	73 61       	ld.w	r1,r9[0x58]
8000597c:	6e 69       	ld.w	r9,r7[0x18]
8000597e:	74 69       	ld.w	r9,r10[0x18]
80005980:	7a 69       	ld.w	r9,sp[0x18]
80005982:	6e 67       	ld.w	r7,r7[0x18]
80005984:	0d 0a       	ld.w	r10,r6++
80005986:	00 00       	add	r0,r0
80005988:	45 69       	lddsp	r9,sp[0x158]
8000598a:	74 68       	ld.w	r8,r10[0x18]
8000598c:	65 72       	ld.w	r2,r2[0x5c]
8000598e:	20 6e       	sub	lr,6
80005990:	6f 20       	ld.w	r0,r7[0x48]
80005992:	64 65       	ld.w	r5,r2[0x18]
80005994:	76 69       	ld.w	r9,r11[0x18]
80005996:	63 65       	ld.w	r5,r1[0x58]
80005998:	73 20       	ld.w	r0,r9[0x48]
8000599a:	6f 72       	ld.w	r2,r7[0x5c]
8000599c:	20 73       	sub	r3,7
8000599e:	68 65       	ld.w	r5,r4[0x18]
800059a0:	6c 76       	ld.w	r6,r6[0x1c]
800059a2:	65 73       	ld.w	r3,r2[0x5c]
800059a4:	20 61       	sub	r1,6
800059a6:	72 65       	ld.w	r5,r9[0x18]
800059a8:	20 70       	sub	r0,7
800059aa:	61 73       	ld.w	r3,r0[0x5c]
800059ac:	74 20       	ld.w	r0,r10[0x8]
800059ae:	6c 69       	ld.w	r9,r6[0x18]
800059b0:	66 65       	ld.w	r5,r3[0x18]
800059b2:	74 69       	ld.w	r9,r10[0x18]
800059b4:	6d 65       	ld.w	r5,r6[0x58]
800059b6:	2c 20       	sub	r0,-62
800059b8:	63 68       	ld.w	r8,r1[0x58]
800059ba:	61 72       	ld.w	r2,r0[0x5c]
800059bc:	67 69       	ld.w	r9,r3[0x58]
800059be:	6e 67       	ld.w	r7,r7[0x18]
800059c0:	20 64       	sub	r4,6
800059c2:	65 76       	ld.w	r6,r2[0x5c]
800059c4:	69 63       	ld.w	r3,r4[0x58]
800059c6:	65 73       	ld.w	r3,r2[0x5c]
800059c8:	0d 0a       	ld.w	r10,r6++
800059ca:	00 00       	add	r0,r0
800059cc:	53 68       	stdsp	sp[0xd8],r8
800059ce:	65 6c       	ld.w	r12,r2[0x58]
800059d0:	66 20       	ld.w	r0,r3[0x8]
800059d2:	63 6c       	ld.w	r12,r1[0x58]
800059d4:	65 61       	ld.w	r1,r2[0x58]
800059d6:	6e 0d       	ld.w	sp,r7[0x0]
800059d8:	0a 00       	add	r0,r5
800059da:	00 00       	add	r0,r0
800059dc:	44 6f       	lddsp	pc,sp[0x118]
800059de:	6f 72       	ld.w	r2,r7[0x5c]
800059e0:	20 6c       	sub	r12,6
800059e2:	61 74       	ld.w	r4,r0[0x5c]
800059e4:	63 68       	ld.w	r8,r1[0x58]
800059e6:	20 6f       	sub	pc,6
800059e8:	70 65       	ld.w	r5,r8[0x18]
800059ea:	6e 65       	ld.w	r5,r7[0x18]
800059ec:	64 2c       	ld.w	r12,r2[0x8]
800059ee:	20 73       	sub	r3,7
800059f0:	68 75       	ld.w	r5,r4[0x1c]
800059f2:	74 74       	ld.w	r4,r10[0x1c]
800059f4:	69 6e       	ld.w	lr,r4[0x58]
800059f6:	67 20       	ld.w	r0,r3[0x48]
800059f8:	64 6f       	ld.w	pc,r2[0x18]
800059fa:	77 6e       	ld.w	lr,r11[0x58]
800059fc:	20 61       	sub	r1,6
800059fe:	6c 6c       	ld.w	r12,r6[0x18]
80005a00:	20 70       	sub	r0,7
80005a02:	72 6f       	ld.w	pc,r9[0x18]
80005a04:	63 65       	ld.w	r5,r1[0x58]
80005a06:	73 73       	ld.w	r3,r9[0x5c]
80005a08:	65 73       	ld.w	r3,r2[0x5c]
80005a0a:	0d 0a       	ld.w	r10,r6++
80005a0c:	00 00       	add	r0,r0
	...

80005a10 <display_text>:
unsigned char devicesPresentOnShelf[NUM_SHELVES];
unsigned char shelfActive[NUM_SHELVES];


void display_text(unsigned char idx)
{
80005a10:	eb cd 40 80 	pushm	r7,lr
80005a14:	1a 97       	mov	r7,sp
80005a16:	20 2d       	sub	sp,8
80005a18:	18 98       	mov	r8,r12
80005a1a:	ef 68 ff f8 	st.b	r7[-8],r8
	for (int i = 0; i<7; i++)
80005a1e:	30 08       	mov	r8,0
80005a20:	ef 48 ff fc 	st.w	r7[-4],r8
80005a24:	c1 58       	rjmp	80005a4e <display_text+0x3e>
	{
		usart_putchar(DISPLAY_USART, ((unsigned char) ((*(cmdPtrArray[idx]+i)))));
80005a26:	ef 39 ff f8 	ld.ub	r9,r7[-8]
80005a2a:	48 e8       	lddpc	r8,80005a60 <display_text+0x50>
80005a2c:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
80005a30:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005a34:	f2 08 00 08 	add	r8,r9,r8
80005a38:	11 88       	ld.ub	r8,r8[0x0]
80005a3a:	10 9b       	mov	r11,r8
80005a3c:	fc 7c 14 00 	mov	r12,-191488
80005a40:	f0 1f 00 09 	mcall	80005a64 <display_text+0x54>
unsigned char shelfActive[NUM_SHELVES];


void display_text(unsigned char idx)
{
	for (int i = 0; i<7; i++)
80005a44:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005a48:	2f f8       	sub	r8,-1
80005a4a:	ef 48 ff fc 	st.w	r7[-4],r8
80005a4e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005a52:	58 68       	cp.w	r8,6
80005a54:	fe 9a ff e9 	brle	80005a26 <display_text+0x16>
	{
		usart_putchar(DISPLAY_USART, ((unsigned char) ((*(cmdPtrArray[idx]+i)))));
	}
	
}
80005a58:	2f ed       	sub	sp,-8
80005a5a:	e3 cd 80 80 	ldm	sp++,r7,pc
80005a5e:	00 00       	add	r0,r0
80005a60:	00 00       	add	r0,r0
80005a62:	00 58       	eor	r8,r0
80005a64:	80 00       	ld.sh	r0,r0[0x0]
80005a66:	51 30       	stdsp	sp[0x4c],r0

80005a68 <init_io>:

void init_io(void)
{
80005a68:	eb cd 40 80 	pushm	r7,lr
80005a6c:	1a 97       	mov	r7,sp
80005a6e:	20 1d       	sub	sp,4
	uint32_t ioFlags;
	
	
	ioFlags = (GPIO_DIR_INPUT);
80005a70:	30 08       	mov	r8,0
80005a72:	ef 48 ff fc 	st.w	r7[-4],r8
	gpio_configure_pin(SEALSHIELD_DOOR_LATCH, ioFlags);
80005a76:	ee fb ff fc 	ld.w	r11,r7[-4]
80005a7a:	33 ec       	mov	r12,62
80005a7c:	f0 1f 00 2b 	mcall	80005b28 <init_io+0xc0>

	ioFlags = (GPIO_DIR_INPUT);
80005a80:	30 08       	mov	r8,0
80005a82:	ef 48 ff fc 	st.w	r7[-4],r8
	gpio_configure_pin(SEALSHIELD_ACTION_PB, ioFlags);
80005a86:	ee fb ff fc 	ld.w	r11,r7[-4]
80005a8a:	33 fc       	mov	r12,63
80005a8c:	f0 1f 00 27 	mcall	80005b28 <init_io+0xc0>

	ioFlags = (GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
80005a90:	30 38       	mov	r8,3
80005a92:	ef 48 ff fc 	st.w	r7[-4],r8
	gpio_configure_pin(SEALSHIELD_SERIAL_ID0, ioFlags);
80005a96:	ee fb ff fc 	ld.w	r11,r7[-4]
80005a9a:	33 3c       	mov	r12,51
80005a9c:	f0 1f 00 23 	mcall	80005b28 <init_io+0xc0>

	ioFlags = (GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
80005aa0:	30 38       	mov	r8,3
80005aa2:	ef 48 ff fc 	st.w	r7[-4],r8
	gpio_configure_pin(SEALSHIELD_SERIAL_ID1, ioFlags);
80005aa6:	ee fb ff fc 	ld.w	r11,r7[-4]
80005aaa:	33 4c       	mov	r12,52
80005aac:	f0 1f 00 1f 	mcall	80005b28 <init_io+0xc0>

	ioFlags = (GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
80005ab0:	30 38       	mov	r8,3
80005ab2:	ef 48 ff fc 	st.w	r7[-4],r8
	gpio_configure_pin(SEALSHIELD_SERIAL_ID2, ioFlags);
80005ab6:	ee fb ff fc 	ld.w	r11,r7[-4]
80005aba:	33 5c       	mov	r12,53
80005abc:	f0 1f 00 1b 	mcall	80005b28 <init_io+0xc0>

	ioFlags = (GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
80005ac0:	30 38       	mov	r8,3
80005ac2:	ef 48 ff fc 	st.w	r7[-4],r8
	gpio_configure_pin(SEALSHIELD_SERIAL_ID3, ioFlags);
80005ac6:	ee fb ff fc 	ld.w	r11,r7[-4]
80005aca:	33 6c       	mov	r12,54
80005acc:	f0 1f 00 17 	mcall	80005b28 <init_io+0xc0>

	ioFlags = (GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
80005ad0:	30 38       	mov	r8,3
80005ad2:	ef 48 ff fc 	st.w	r7[-4],r8
	gpio_configure_pin(SEALSHIELD_SERIAL_ID4, ioFlags);
80005ad6:	ee fb ff fc 	ld.w	r11,r7[-4]
80005ada:	33 7c       	mov	r12,55
80005adc:	f0 1f 00 13 	mcall	80005b28 <init_io+0xc0>

	ioFlags = (GPIO_DIR_OUTPUT | GPIO_INIT_LOW);
80005ae0:	30 18       	mov	r8,1
80005ae2:	ef 48 ff fc 	st.w	r7[-4],r8
	gpio_configure_pin(SEALSHIELD_DEBUG_LED, ioFlags);
80005ae6:	ee fb ff fc 	ld.w	r11,r7[-4]
80005aea:	37 cc       	mov	r12,124
80005aec:	f0 1f 00 0f 	mcall	80005b28 <init_io+0xc0>

	ioFlags = (GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
80005af0:	30 38       	mov	r8,3
80005af2:	ef 48 ff fc 	st.w	r7[-4],r8
	gpio_configure_pin(SEALSHIELD_PSUPPLY_ONn, ioFlags);
80005af6:	ee fb ff fc 	ld.w	r11,r7[-4]
80005afa:	31 7c       	mov	r12,23
80005afc:	f0 1f 00 0b 	mcall	80005b28 <init_io+0xc0>

	ioFlags = (GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
80005b00:	30 38       	mov	r8,3
80005b02:	ef 48 ff fc 	st.w	r7[-4],r8
	gpio_configure_pin(SEALSHIELD_LED_OEn, ioFlags);
80005b06:	ee fb ff fc 	ld.w	r11,r7[-4]
80005b0a:	31 6c       	mov	r12,22
80005b0c:	f0 1f 00 07 	mcall	80005b28 <init_io+0xc0>

	ioFlags = (GPIO_DIR_OUTPUT | GPIO_INIT_LOW); //high=1x multiplier, low=4x multiplier 10apr15
80005b10:	30 18       	mov	r8,1
80005b12:	ef 48 ff fc 	st.w	r7[-4],r8
	gpio_configure_pin(SEALSHIELD_MFP, ioFlags);
80005b16:	ee fb ff fc 	ld.w	r11,r7[-4]
80005b1a:	31 5c       	mov	r12,21
80005b1c:	f0 1f 00 03 	mcall	80005b28 <init_io+0xc0>

}
80005b20:	2f fd       	sub	sp,-4
80005b22:	e3 cd 80 80 	ldm	sp++,r7,pc
80005b26:	00 00       	add	r0,r0
80005b28:	80 00       	ld.sh	r0,r0[0x0]
80005b2a:	3f 44       	mov	r4,-12

80005b2c <read_serial_ids>:

int ledBoardPresent[NUM_LED_BOARDS];

/* One serial ID chip per board */
void read_serial_ids(void)
{
80005b2c:	eb cd 40 e0 	pushm	r5-r7,lr
80005b30:	1a 97       	mov	r7,sp
80005b32:	20 2d       	sub	sp,8
	/*
	 * Check for LED board presence by issuing a reset to the serial ID chip and checking for a response.
	 */
	
	SetSpeed(1); //1==standard speed, not overdrive
80005b34:	30 1c       	mov	r12,1
80005b36:	f0 1f 00 36 	mcall	80005c0c <read_serial_ids+0xe0>
	
	ledBoardPresent[0] = !OWTouchReset(0);
80005b3a:	30 0c       	mov	r12,0
80005b3c:	f0 1f 00 35 	mcall	80005c10 <read_serial_ids+0xe4>
80005b40:	18 98       	mov	r8,r12
80005b42:	58 08       	cp.w	r8,0
80005b44:	5f 09       	sreq	r9
80005b46:	4b 48       	lddpc	r8,80005c14 <read_serial_ids+0xe8>
80005b48:	91 09       	st.w	r8[0x0],r9
	ledBoardPresent[1] = !OWTouchReset(1);
80005b4a:	30 1c       	mov	r12,1
80005b4c:	f0 1f 00 31 	mcall	80005c10 <read_serial_ids+0xe4>
80005b50:	18 98       	mov	r8,r12
80005b52:	58 08       	cp.w	r8,0
80005b54:	5f 09       	sreq	r9
80005b56:	4b 08       	lddpc	r8,80005c14 <read_serial_ids+0xe8>
80005b58:	91 19       	st.w	r8[0x4],r9
	ledBoardPresent[2] = !OWTouchReset(2);
80005b5a:	30 2c       	mov	r12,2
80005b5c:	f0 1f 00 2d 	mcall	80005c10 <read_serial_ids+0xe4>
80005b60:	18 98       	mov	r8,r12
80005b62:	58 08       	cp.w	r8,0
80005b64:	5f 09       	sreq	r9
80005b66:	4a c8       	lddpc	r8,80005c14 <read_serial_ids+0xe8>
80005b68:	91 29       	st.w	r8[0x8],r9
	ledBoardPresent[3] = !OWTouchReset(3);
80005b6a:	30 3c       	mov	r12,3
80005b6c:	f0 1f 00 29 	mcall	80005c10 <read_serial_ids+0xe4>
80005b70:	18 98       	mov	r8,r12
80005b72:	58 08       	cp.w	r8,0
80005b74:	5f 09       	sreq	r9
80005b76:	4a 88       	lddpc	r8,80005c14 <read_serial_ids+0xe8>
80005b78:	91 39       	st.w	r8[0xc],r9
	ledBoardPresent[4] = !OWTouchReset(4);
80005b7a:	30 4c       	mov	r12,4
80005b7c:	f0 1f 00 25 	mcall	80005c10 <read_serial_ids+0xe4>
80005b80:	18 98       	mov	r8,r12
80005b82:	58 08       	cp.w	r8,0
80005b84:	5f 09       	sreq	r9
80005b86:	4a 48       	lddpc	r8,80005c14 <read_serial_ids+0xe8>
80005b88:	91 49       	st.w	r8[0x10],r9
	
	for (int i=0; i<NUM_LED_BOARDS; i++)
80005b8a:	30 08       	mov	r8,0
80005b8c:	ef 48 ff f8 	st.w	r7[-8],r8
80005b90:	c3 58       	rjmp	80005bfa <read_serial_ids+0xce>
	{
		if (ledBoardPresent[i])
80005b92:	ee f9 ff f8 	ld.w	r9,r7[-8]
80005b96:	4a 08       	lddpc	r8,80005c14 <read_serial_ids+0xe8>
80005b98:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80005b9c:	58 08       	cp.w	r8,0
80005b9e:	c2 90       	breq	80005bf0 <read_serial_ids+0xc4>
		{
			OWWriteByte(i, 0x33); //Read ID command
80005ba0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005ba4:	5c 58       	castu.b	r8
80005ba6:	33 3b       	mov	r11,51
80005ba8:	10 9c       	mov	r12,r8
80005baa:	f0 1f 00 1c 	mcall	80005c18 <read_serial_ids+0xec>
			
			for (int j=0; j<8; j++)
80005bae:	30 08       	mov	r8,0
80005bb0:	ef 48 ff fc 	st.w	r7[-4],r8
80005bb4:	c1 98       	rjmp	80005be6 <read_serial_ids+0xba>
			{
				ledBrdSerialID[i][j] = OWReadByte(i);
80005bb6:	ee f5 ff f8 	ld.w	r5,r7[-8]
80005bba:	ee f6 ff fc 	ld.w	r6,r7[-4]
80005bbe:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005bc2:	5c 58       	castu.b	r8
80005bc4:	10 9c       	mov	r12,r8
80005bc6:	f0 1f 00 16 	mcall	80005c1c <read_serial_ids+0xf0>
80005bca:	18 98       	mov	r8,r12
80005bcc:	5c 58       	castu.b	r8
80005bce:	49 5a       	lddpc	r10,80005c20 <read_serial_ids+0xf4>
80005bd0:	ea 09 15 03 	lsl	r9,r5,0x3
80005bd4:	0c 09       	add	r9,r6
80005bd6:	f4 09 00 09 	add	r9,r10,r9
80005bda:	b2 88       	st.b	r9[0x0],r8
	{
		if (ledBoardPresent[i])
		{
			OWWriteByte(i, 0x33); //Read ID command
			
			for (int j=0; j<8; j++)
80005bdc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005be0:	2f f8       	sub	r8,-1
80005be2:	ef 48 ff fc 	st.w	r7[-4],r8
80005be6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005bea:	58 78       	cp.w	r8,7
80005bec:	fe 9a ff e5 	brle	80005bb6 <read_serial_ids+0x8a>
	ledBoardPresent[1] = !OWTouchReset(1);
	ledBoardPresent[2] = !OWTouchReset(2);
	ledBoardPresent[3] = !OWTouchReset(3);
	ledBoardPresent[4] = !OWTouchReset(4);
	
	for (int i=0; i<NUM_LED_BOARDS; i++)
80005bf0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005bf4:	2f f8       	sub	r8,-1
80005bf6:	ef 48 ff f8 	st.w	r7[-8],r8
80005bfa:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005bfe:	58 48       	cp.w	r8,4
80005c00:	fe 9a ff c9 	brle	80005b92 <read_serial_ids+0x66>
			{
				ledBrdSerialID[i][j] = OWReadByte(i);
			}
		}
	}
}
80005c04:	2f ed       	sub	sp,-8
80005c06:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005c0a:	00 00       	add	r0,r0
80005c0c:	80 00       	ld.sh	r0,r0[0x0]
80005c0e:	21 34       	sub	r4,19
80005c10:	80 00       	ld.sh	r0,r0[0x0]
80005c12:	21 f4       	sub	r4,31
80005c14:	00 00       	add	r0,r0
80005c16:	07 0c       	ld.w	r12,r3++
80005c18:	80 00       	ld.sh	r0,r0[0x0]
80005c1a:	31 e4       	mov	r4,30
80005c1c:	80 00       	ld.sh	r0,r0[0x0]
80005c1e:	32 3c       	mov	r12,35
80005c20:	00 00       	add	r0,r0
80005c22:	0b a8       	ld.ub	r8,r5[0x2]

80005c24 <check_led_brd_side_lifetime>:
	LED_BOARD_SIDE_WITHIN_LIFETIME_LIMIT
};

/* Each side of an LED board will get different usage */
unsigned char check_led_brd_side_lifetime(unsigned char ledBrdPosition)
{
80005c24:	eb cd 40 80 	pushm	r7,lr
80005c28:	1a 97       	mov	r7,sp
80005c2a:	20 1d       	sub	sp,4
80005c2c:	18 98       	mov	r8,r12
80005c2e:	ef 68 ff fc 	st.b	r7[-4],r8
	 *			refurbished. This will require variable array storage. I could also create a linked
	 *			list to go with it to sort the IDs in numerial order to make them easier to find, otherwise
	 *			have to sort through the whole list every time, could get slow.
	 */
	
	return LED_BOARD_SIDE_WITHIN_LIFETIME_LIMIT;	//TODO: Every board is within limit for now. Perhaps hardcode one as out of spec
80005c32:	30 18       	mov	r8,1
													//		for demo purposes.
 	
}
80005c34:	10 9c       	mov	r12,r8
80005c36:	2f fd       	sub	sp,-4
80005c38:	e3 cd 80 80 	ldm	sp++,r7,pc

80005c3c <check_led_brd_side_lifetimes>:

/* Aggregate the information */
void check_led_brd_side_lifetimes(void)
{
80005c3c:	eb cd 40 c0 	pushm	r6-r7,lr
80005c40:	1a 97       	mov	r7,sp
80005c42:	20 1d       	sub	sp,4
	for (int i=0; i<NUM_LED_BOARD_SIDES; i++)
80005c44:	30 08       	mov	r8,0
80005c46:	ef 48 ff fc 	st.w	r7[-4],r8
80005c4a:	c1 28       	rjmp	80005c6e <check_led_brd_side_lifetimes+0x32>
	{
		brdSideWithinLifetimeLimit[i] = check_led_brd_side_lifetime(i);
80005c4c:	ee f6 ff fc 	ld.w	r6,r7[-4]
80005c50:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005c54:	5c 58       	castu.b	r8
80005c56:	10 9c       	mov	r12,r8
80005c58:	f0 1f 00 0a 	mcall	80005c80 <check_led_brd_side_lifetimes+0x44>
80005c5c:	18 98       	mov	r8,r12
80005c5e:	48 a9       	lddpc	r9,80005c84 <check_led_brd_side_lifetimes+0x48>
80005c60:	f2 06 0b 08 	st.b	r9[r6],r8
}

/* Aggregate the information */
void check_led_brd_side_lifetimes(void)
{
	for (int i=0; i<NUM_LED_BOARD_SIDES; i++)
80005c64:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005c68:	2f f8       	sub	r8,-1
80005c6a:	ef 48 ff fc 	st.w	r7[-4],r8
80005c6e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005c72:	58 78       	cp.w	r8,7
80005c74:	fe 9a ff ec 	brle	80005c4c <check_led_brd_side_lifetimes+0x10>
	{
		brdSideWithinLifetimeLimit[i] = check_led_brd_side_lifetime(i);
	}
}
80005c78:	2f fd       	sub	sp,-4
80005c7a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005c7e:	00 00       	add	r0,r0
80005c80:	80 00       	ld.sh	r0,r0[0x0]
80005c82:	5c 24       	cpc	r4
80005c84:	00 00       	add	r0,r0
80005c86:	09 84       	ld.ub	r4,r4[0x0]

80005c88 <adc_process_task>:
};

volatile avr32_adcifa_t *adcifa = &AVR32_ADCIFA; // ADCIFA IP registers address

int16_t adc_process_task(unsigned char shelfIdx)
{
80005c88:	eb cd 40 80 	pushm	r7,lr
80005c8c:	1a 97       	mov	r7,sp
80005c8e:	20 3d       	sub	sp,12
80005c90:	18 98       	mov	r8,r12
80005c92:	ef 68 ff f4 	st.b	r7[-12],r8
	int32_t i;

	volatile int16_t retVal;

	switch (shelfIdx)
80005c96:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80005c9a:	58 18       	cp.w	r8,1
80005c9c:	c5 30       	breq	80005d42 <adc_process_task+0xba>
80005c9e:	e0 89 00 05 	brgt	80005ca8 <adc_process_task+0x20>
80005ca2:	58 08       	cp.w	r8,0
80005ca4:	c0 90       	breq	80005cb6 <adc_process_task+0x2e>
80005ca6:	c0 f9       	rjmp	80005ec4 <adc_process_task+0x23c>
80005ca8:	58 28       	cp.w	r8,2
80005caa:	e0 80 00 8c 	breq	80005dc2 <adc_process_task+0x13a>
80005cae:	58 38       	cp.w	r8,3
80005cb0:	e0 80 00 c9 	breq	80005e42 <adc_process_task+0x1ba>
80005cb4:	c0 89       	rjmp	80005ec4 <adc_process_task+0x23c>
	{
		case 0:
			// Configure ADCIFA sequencer 0 shelf 1
			adcifa_configure_sequencer(adcifa, 0,
80005cb6:	fe f8 02 1e 	ld.w	r8,pc[542]
80005cba:	70 08       	ld.w	r8,r8[0x0]
80005cbc:	fe f9 02 1c 	ld.w	r9,pc[540]
80005cc0:	fe fa 02 1c 	ld.w	r10,pc[540]
80005cc4:	30 0b       	mov	r11,0
80005cc6:	10 9c       	mov	r12,r8
80005cc8:	f0 1f 00 86 	mcall	80005ee0 <adc_process_task+0x258>
			&adcifa_sequence_opt,
			adcifa_sequence_conversion_opt_seq0_shelf1);

			// Start ADCIFA sequencer 0
			adcifa_start_sequencer(adcifa, 0);
80005ccc:	fe f8 02 08 	ld.w	r8,pc[520]
80005cd0:	70 08       	ld.w	r8,r8[0x0]
80005cd2:	30 0b       	mov	r11,0
80005cd4:	10 9c       	mov	r12,r8
80005cd6:	f0 1f 00 84 	mcall	80005ee4 <adc_process_task+0x25c>

			// Get Values from sequencer 0
			if (adcifa_get_values_from_sequencer(adcifa,
80005cda:	4f f8       	lddpc	r8,80005ed4 <adc_process_task+0x24c>
80005cdc:	70 08       	ld.w	r8,r8[0x0]
80005cde:	fe f9 02 0a 	ld.w	r9,pc[522]
80005ce2:	4f fa       	lddpc	r10,80005edc <adc_process_task+0x254>
80005ce4:	30 0b       	mov	r11,0
80005ce6:	10 9c       	mov	r12,r8
80005ce8:	f0 1f 00 81 	mcall	80005eec <adc_process_task+0x264>
80005cec:	18 98       	mov	r8,r12
80005cee:	10 99       	mov	r9,r8
80005cf0:	30 28       	mov	r8,2
80005cf2:	f0 09 18 00 	cp.b	r9,r8
80005cf6:	e0 81 00 e6 	brne	80005ec2 <adc_process_task+0x23a>
			0,
			&adcifa_sequence_opt,
			adc_values_seq0) == ADCIFA_STATUS_COMPLETED) {
				for (i=BUFFER_LENGTH-1;i>=1;i--) {
80005cfa:	e0 68 00 ff 	mov	r8,255
80005cfe:	ef 48 ff fc 	st.w	r7[-4],r8
80005d02:	c1 28       	rjmp	80005d26 <adc_process_task+0x9e>
					bluesense0_buf[i] = bluesense0_buf[i-1];
80005d04:	ee fa ff fc 	ld.w	r10,r7[-4]
80005d08:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005d0c:	f0 c9 00 01 	sub	r9,r8,1
80005d10:	4f 88       	lddpc	r8,80005ef0 <adc_process_task+0x268>
80005d12:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
80005d16:	4f 79       	lddpc	r9,80005ef0 <adc_process_task+0x268>
80005d18:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
			// Get Values from sequencer 0
			if (adcifa_get_values_from_sequencer(adcifa,
			0,
			&adcifa_sequence_opt,
			adc_values_seq0) == ADCIFA_STATUS_COMPLETED) {
				for (i=BUFFER_LENGTH-1;i>=1;i--) {
80005d1c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005d20:	20 18       	sub	r8,1
80005d22:	ef 48 ff fc 	st.w	r7[-4],r8
80005d26:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005d2a:	58 08       	cp.w	r8,0
80005d2c:	fe 99 ff ec 	brgt	80005d04 <adc_process_task+0x7c>
					bluesense0_buf[i] = bluesense0_buf[i-1];
				}
				bluesense0_buf[0] = adc_values_seq0[0];
80005d30:	4e e8       	lddpc	r8,80005ee8 <adc_process_task+0x260>
80005d32:	90 08       	ld.sh	r8,r8[0x0]
80005d34:	4e f9       	lddpc	r9,80005ef0 <adc_process_task+0x268>
80005d36:	b2 08       	st.h	r9[0x0],r8
				retVal = bluesense0_buf[0];
80005d38:	4e e8       	lddpc	r8,80005ef0 <adc_process_task+0x268>
80005d3a:	90 08       	ld.sh	r8,r8[0x0]
80005d3c:	ef 58 ff fa 	st.h	r7[-6],r8
			}
			break;
80005d40:	cc 28       	rjmp	80005ec4 <adc_process_task+0x23c>
		
		case 1:
			// Configure ADCIFA sequencer 1 shelf 2
			adcifa_configure_sequencer(adcifa, 1,
80005d42:	4e 58       	lddpc	r8,80005ed4 <adc_process_task+0x24c>
80005d44:	70 08       	ld.w	r8,r8[0x0]
80005d46:	4e c9       	lddpc	r9,80005ef4 <adc_process_task+0x26c>
80005d48:	4e 5a       	lddpc	r10,80005edc <adc_process_task+0x254>
80005d4a:	30 1b       	mov	r11,1
80005d4c:	10 9c       	mov	r12,r8
80005d4e:	f0 1f 00 65 	mcall	80005ee0 <adc_process_task+0x258>
			&adcifa_sequence_opt,
			adcifa_sequence_conversion_opt_seq1_shelf2);

			// Start ADCIFA sequencer 1
			adcifa_start_sequencer(adcifa, 1);
80005d52:	4e 18       	lddpc	r8,80005ed4 <adc_process_task+0x24c>
80005d54:	70 08       	ld.w	r8,r8[0x0]
80005d56:	30 1b       	mov	r11,1
80005d58:	10 9c       	mov	r12,r8
80005d5a:	f0 1f 00 63 	mcall	80005ee4 <adc_process_task+0x25c>

			// Get Values from sequencer 1
			if (adcifa_get_values_from_sequencer(adcifa,
80005d5e:	4d e8       	lddpc	r8,80005ed4 <adc_process_task+0x24c>
80005d60:	70 08       	ld.w	r8,r8[0x0]
80005d62:	4e 69       	lddpc	r9,80005ef8 <adc_process_task+0x270>
80005d64:	4d ea       	lddpc	r10,80005edc <adc_process_task+0x254>
80005d66:	30 1b       	mov	r11,1
80005d68:	10 9c       	mov	r12,r8
80005d6a:	f0 1f 00 61 	mcall	80005eec <adc_process_task+0x264>
80005d6e:	18 98       	mov	r8,r12
80005d70:	10 99       	mov	r9,r8
80005d72:	30 28       	mov	r8,2
80005d74:	f0 09 18 00 	cp.b	r9,r8
80005d78:	c2 01       	brne	80005db8 <adc_process_task+0x130>
			1,
			&adcifa_sequence_opt,
			adc_values_seq1) == ADCIFA_STATUS_COMPLETED) {
				for (i=BUFFER_LENGTH-1;i>=1;i--) {
80005d7a:	e0 68 00 ff 	mov	r8,255
80005d7e:	ef 48 ff fc 	st.w	r7[-4],r8
80005d82:	c1 28       	rjmp	80005da6 <adc_process_task+0x11e>
					bluesense1_buf[i] = bluesense1_buf[i-1];
80005d84:	ee fa ff fc 	ld.w	r10,r7[-4]
80005d88:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005d8c:	f0 c9 00 01 	sub	r9,r8,1
80005d90:	4d b8       	lddpc	r8,80005efc <adc_process_task+0x274>
80005d92:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
80005d96:	4d a9       	lddpc	r9,80005efc <adc_process_task+0x274>
80005d98:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
			// Get Values from sequencer 1
			if (adcifa_get_values_from_sequencer(adcifa,
			1,
			&adcifa_sequence_opt,
			adc_values_seq1) == ADCIFA_STATUS_COMPLETED) {
				for (i=BUFFER_LENGTH-1;i>=1;i--) {
80005d9c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005da0:	20 18       	sub	r8,1
80005da2:	ef 48 ff fc 	st.w	r7[-4],r8
80005da6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005daa:	58 08       	cp.w	r8,0
80005dac:	fe 99 ff ec 	brgt	80005d84 <adc_process_task+0xfc>
					bluesense1_buf[i] = bluesense1_buf[i-1];
				}
				bluesense1_buf[0] = adc_values_seq1[0];
80005db0:	4d 28       	lddpc	r8,80005ef8 <adc_process_task+0x270>
80005db2:	90 08       	ld.sh	r8,r8[0x0]
80005db4:	4d 29       	lddpc	r9,80005efc <adc_process_task+0x274>
80005db6:	b2 08       	st.h	r9[0x0],r8
			}
			retVal = bluesense1_buf[0];
80005db8:	4d 18       	lddpc	r8,80005efc <adc_process_task+0x274>
80005dba:	90 08       	ld.sh	r8,r8[0x0]
80005dbc:	ef 58 ff fa 	st.h	r7[-6],r8
			break;
80005dc0:	c8 28       	rjmp	80005ec4 <adc_process_task+0x23c>
		
		case 2:
			// Configure ADCIFA sequencer 0 shelf 3
			adcifa_configure_sequencer(adcifa, 0,
80005dc2:	4c 58       	lddpc	r8,80005ed4 <adc_process_task+0x24c>
80005dc4:	70 08       	ld.w	r8,r8[0x0]
80005dc6:	4c f9       	lddpc	r9,80005f00 <adc_process_task+0x278>
80005dc8:	4c 5a       	lddpc	r10,80005edc <adc_process_task+0x254>
80005dca:	30 0b       	mov	r11,0
80005dcc:	10 9c       	mov	r12,r8
80005dce:	f0 1f 00 45 	mcall	80005ee0 <adc_process_task+0x258>
			&adcifa_sequence_opt,
			adcifa_sequence_conversion_opt_seq0_shelf3);

			// Start ADCIFA sequencer 0
			adcifa_start_sequencer(adcifa, 0);
80005dd2:	4c 18       	lddpc	r8,80005ed4 <adc_process_task+0x24c>
80005dd4:	70 08       	ld.w	r8,r8[0x0]
80005dd6:	30 0b       	mov	r11,0
80005dd8:	10 9c       	mov	r12,r8
80005dda:	f0 1f 00 43 	mcall	80005ee4 <adc_process_task+0x25c>

			// Get Values from sequencer 2
			if (adcifa_get_values_from_sequencer(adcifa,
80005dde:	4b e8       	lddpc	r8,80005ed4 <adc_process_task+0x24c>
80005de0:	70 08       	ld.w	r8,r8[0x0]
80005de2:	4c 29       	lddpc	r9,80005ee8 <adc_process_task+0x260>
80005de4:	4b ea       	lddpc	r10,80005edc <adc_process_task+0x254>
80005de6:	30 0b       	mov	r11,0
80005de8:	10 9c       	mov	r12,r8
80005dea:	f0 1f 00 41 	mcall	80005eec <adc_process_task+0x264>
80005dee:	18 98       	mov	r8,r12
80005df0:	10 99       	mov	r9,r8
80005df2:	30 28       	mov	r8,2
80005df4:	f0 09 18 00 	cp.b	r9,r8
80005df8:	c2 01       	brne	80005e38 <adc_process_task+0x1b0>
			0,
			&adcifa_sequence_opt,
			adc_values_seq0) == ADCIFA_STATUS_COMPLETED) {
				for (i=BUFFER_LENGTH-1;i>=1;i--) {
80005dfa:	e0 68 00 ff 	mov	r8,255
80005dfe:	ef 48 ff fc 	st.w	r7[-4],r8
80005e02:	c1 28       	rjmp	80005e26 <adc_process_task+0x19e>
					bluesense2_buf[i] = bluesense2_buf[i-1];
80005e04:	ee fa ff fc 	ld.w	r10,r7[-4]
80005e08:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005e0c:	f0 c9 00 01 	sub	r9,r8,1
80005e10:	4b d8       	lddpc	r8,80005f04 <adc_process_task+0x27c>
80005e12:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
80005e16:	4b c9       	lddpc	r9,80005f04 <adc_process_task+0x27c>
80005e18:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
			// Get Values from sequencer 2
			if (adcifa_get_values_from_sequencer(adcifa,
			0,
			&adcifa_sequence_opt,
			adc_values_seq0) == ADCIFA_STATUS_COMPLETED) {
				for (i=BUFFER_LENGTH-1;i>=1;i--) {
80005e1c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005e20:	20 18       	sub	r8,1
80005e22:	ef 48 ff fc 	st.w	r7[-4],r8
80005e26:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005e2a:	58 08       	cp.w	r8,0
80005e2c:	fe 99 ff ec 	brgt	80005e04 <adc_process_task+0x17c>
					bluesense2_buf[i] = bluesense2_buf[i-1];
				}
				bluesense2_buf[0] = adc_values_seq0[0];
80005e30:	4a e8       	lddpc	r8,80005ee8 <adc_process_task+0x260>
80005e32:	90 08       	ld.sh	r8,r8[0x0]
80005e34:	4b 49       	lddpc	r9,80005f04 <adc_process_task+0x27c>
80005e36:	b2 08       	st.h	r9[0x0],r8
			}
			retVal = bluesense2_buf[0];
80005e38:	4b 38       	lddpc	r8,80005f04 <adc_process_task+0x27c>
80005e3a:	90 08       	ld.sh	r8,r8[0x0]
80005e3c:	ef 58 ff fa 	st.h	r7[-6],r8
			break;
80005e40:	c4 28       	rjmp	80005ec4 <adc_process_task+0x23c>
		
		case 3:
			// Configure ADCIFA sequencer 1 shelf 4
			adcifa_configure_sequencer(adcifa, 1,
80005e42:	4a 58       	lddpc	r8,80005ed4 <adc_process_task+0x24c>
80005e44:	70 08       	ld.w	r8,r8[0x0]
80005e46:	4b 19       	lddpc	r9,80005f08 <adc_process_task+0x280>
80005e48:	4a 5a       	lddpc	r10,80005edc <adc_process_task+0x254>
80005e4a:	30 1b       	mov	r11,1
80005e4c:	10 9c       	mov	r12,r8
80005e4e:	f0 1f 00 25 	mcall	80005ee0 <adc_process_task+0x258>
			&adcifa_sequence_opt,
			adcifa_sequence_conversion_opt_seq1_shelf4);

			// Start ADCIFA sequencer 1
			adcifa_start_sequencer(adcifa, 1);
80005e52:	4a 18       	lddpc	r8,80005ed4 <adc_process_task+0x24c>
80005e54:	70 08       	ld.w	r8,r8[0x0]
80005e56:	30 1b       	mov	r11,1
80005e58:	10 9c       	mov	r12,r8
80005e5a:	f0 1f 00 23 	mcall	80005ee4 <adc_process_task+0x25c>

			// Get Values from sequencer 1
			if (adcifa_get_values_from_sequencer(adcifa,
80005e5e:	49 e8       	lddpc	r8,80005ed4 <adc_process_task+0x24c>
80005e60:	70 08       	ld.w	r8,r8[0x0]
80005e62:	4a 69       	lddpc	r9,80005ef8 <adc_process_task+0x270>
80005e64:	49 ea       	lddpc	r10,80005edc <adc_process_task+0x254>
80005e66:	30 1b       	mov	r11,1
80005e68:	10 9c       	mov	r12,r8
80005e6a:	f0 1f 00 21 	mcall	80005eec <adc_process_task+0x264>
80005e6e:	18 98       	mov	r8,r12
80005e70:	10 99       	mov	r9,r8
80005e72:	30 28       	mov	r8,2
80005e74:	f0 09 18 00 	cp.b	r9,r8
80005e78:	c2 01       	brne	80005eb8 <adc_process_task+0x230>
			1,
			&adcifa_sequence_opt,
			adc_values_seq1) == ADCIFA_STATUS_COMPLETED) {
				for (i=BUFFER_LENGTH-1;i>=1;i--) {
80005e7a:	e0 68 00 ff 	mov	r8,255
80005e7e:	ef 48 ff fc 	st.w	r7[-4],r8
80005e82:	c1 28       	rjmp	80005ea6 <adc_process_task+0x21e>
					bluesense3_buf[i] = bluesense3_buf[i-1];
80005e84:	ee fa ff fc 	ld.w	r10,r7[-4]
80005e88:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005e8c:	f0 c9 00 01 	sub	r9,r8,1
80005e90:	49 f8       	lddpc	r8,80005f0c <adc_process_task+0x284>
80005e92:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
80005e96:	49 e9       	lddpc	r9,80005f0c <adc_process_task+0x284>
80005e98:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
			// Get Values from sequencer 1
			if (adcifa_get_values_from_sequencer(adcifa,
			1,
			&adcifa_sequence_opt,
			adc_values_seq1) == ADCIFA_STATUS_COMPLETED) {
				for (i=BUFFER_LENGTH-1;i>=1;i--) {
80005e9c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005ea0:	20 18       	sub	r8,1
80005ea2:	ef 48 ff fc 	st.w	r7[-4],r8
80005ea6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005eaa:	58 08       	cp.w	r8,0
80005eac:	fe 99 ff ec 	brgt	80005e84 <adc_process_task+0x1fc>
					bluesense3_buf[i] = bluesense3_buf[i-1];
				}
				bluesense3_buf[0] = adc_values_seq1[0];
80005eb0:	49 28       	lddpc	r8,80005ef8 <adc_process_task+0x270>
80005eb2:	90 08       	ld.sh	r8,r8[0x0]
80005eb4:	49 69       	lddpc	r9,80005f0c <adc_process_task+0x284>
80005eb6:	b2 08       	st.h	r9[0x0],r8
			}
			retVal = bluesense3_buf[0];
80005eb8:	49 58       	lddpc	r8,80005f0c <adc_process_task+0x284>
80005eba:	90 08       	ld.sh	r8,r8[0x0]
80005ebc:	ef 58 ff fa 	st.h	r7[-6],r8
80005ec0:	c0 28       	rjmp	80005ec4 <adc_process_task+0x23c>
					bluesense0_buf[i] = bluesense0_buf[i-1];
				}
				bluesense0_buf[0] = adc_values_seq0[0];
				retVal = bluesense0_buf[0];
			}
			break;
80005ec2:	d7 03       	nop
			}
			retVal = bluesense3_buf[0];
			break;
	}
	
	return retVal;
80005ec4:	ef 08 ff fa 	ld.sh	r8,r7[-6]
80005ec8:	5c 88       	casts.h	r8

}
80005eca:	10 9c       	mov	r12,r8
80005ecc:	2f dd       	sub	sp,-12
80005ece:	e3 cd 80 80 	ldm	sp++,r7,pc
80005ed2:	00 00       	add	r0,r0
80005ed4:	00 00       	add	r0,r0
80005ed6:	00 a8       	st.w	r0++,r8
80005ed8:	00 00       	add	r0,r0
80005eda:	00 9b       	mov	r11,r0
80005edc:	00 00       	add	r0,r0
80005ede:	00 94       	mov	r4,r0
80005ee0:	80 00       	ld.sh	r0,r0[0x0]
80005ee2:	35 e4       	mov	r4,94
80005ee4:	80 00       	ld.sh	r0,r0[0x0]
80005ee6:	3a f4       	mov	r4,-81
80005ee8:	00 00       	add	r0,r0
80005eea:	03 08       	ld.w	r8,r1++
80005eec:	80 00       	ld.sh	r0,r0[0x0]
80005eee:	3b 80       	mov	r0,-72
80005ef0:	00 00       	add	r0,r0
80005ef2:	03 0c       	ld.w	r12,r1++
80005ef4:	00 00       	add	r0,r0
80005ef6:	00 9e       	mov	lr,r0
80005ef8:	00 00       	add	r0,r0
80005efa:	09 9c       	ld.ub	r12,r4[0x1]
80005efc:	00 00       	add	r0,r0
80005efe:	09 a8       	ld.ub	r8,r4[0x2]
80005f00:	00 00       	add	r0,r0
80005f02:	00 a1       	st.w	r0++,r1
80005f04:	00 00       	add	r0,r0
80005f06:	05 0c       	ld.w	r12,r2++
80005f08:	00 00       	add	r0,r0
80005f0a:	00 a4       	st.w	r0++,r4
80005f0c:	00 00       	add	r0,r0
80005f0e:	07 20       	ld.uh	r0,r3++

80005f10 <check_shelf_for_devices>:
	NO_DEVICES_PRESENT,
	DEVICES_PRESENT
};

unsigned char check_shelf_for_devices(unsigned char shelfPosition)
{
80005f10:	eb cd 40 8f 	pushm	r0-r3,r7,lr
80005f14:	1a 97       	mov	r7,sp
80005f16:	20 dd       	sub	sp,52
80005f18:	18 98       	mov	r8,r12
80005f1a:	ef 68 ff cc 	st.b	r7[-52],r8
	U16 bluesense;
	unsigned char retVal;
	
	led_shelf(shelfPosition, LED_ON); //TODO: do we finish this task fast enough to not check the door latch in here? Can't have LEDs on if the door opens
80005f1e:	ef 38 ff cc 	ld.ub	r8,r7[-52]
80005f22:	30 1b       	mov	r11,1
80005f24:	10 9c       	mov	r12,r8
80005f26:	f0 1f 00 7f 	mcall	80006120 <check_shelf_for_devices+0x210>
80005f2a:	33 28       	mov	r8,50
80005f2c:	ef 48 ff e4 	st.w	r7[-28],r8
80005f30:	e0 68 12 00 	mov	r8,4608
80005f34:	ea 18 00 7a 	orh	r8,0x7a
80005f38:	ef 48 ff e0 	st.w	r7[-32],r8
80005f3c:	ee f8 ff e4 	ld.w	r8,r7[-28]
80005f40:	ef 48 ff ec 	st.w	r7[-20],r8
80005f44:	ee f8 ff e0 	ld.w	r8,r7[-32]
80005f48:	ef 48 ff e8 	st.w	r7[-24],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80005f4c:	ee f0 ff ec 	ld.w	r0,r7[-20]
80005f50:	30 01       	mov	r1,0
80005f52:	ee f2 ff e8 	ld.w	r2,r7[-24]
80005f56:	30 03       	mov	r3,0
80005f58:	e2 02 02 4a 	mul	r10,r1,r2
80005f5c:	e6 00 02 48 	mul	r8,r3,r0
80005f60:	10 0a       	add	r10,r8
80005f62:	e0 02 06 48 	mulu.d	r8,r0,r2
80005f66:	12 0a       	add	r10,r9
80005f68:	14 99       	mov	r9,r10
80005f6a:	e0 6a 03 e7 	mov	r10,999
80005f6e:	30 0b       	mov	r11,0
80005f70:	f0 0a 00 0a 	add	r10,r8,r10
80005f74:	f2 0b 00 4b 	adc	r11,r9,r11
80005f78:	e0 68 03 e8 	mov	r8,1000
80005f7c:	30 09       	mov	r9,0
80005f7e:	f0 1f 00 6a 	mcall	80006124 <check_shelf_for_devices+0x214>
80005f82:	14 98       	mov	r8,r10
80005f84:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
80005f86:	ef 48 ff f4 	st.w	r7[-12],r8
80005f8a:	ee c8 00 30 	sub	r8,r7,48
80005f8e:	ef 48 ff f0 	st.w	r7[-16],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80005f92:	e1 b8 00 42 	mfsr	r8,0x108
80005f96:	10 99       	mov	r9,r8
80005f98:	ee f8 ff f0 	ld.w	r8,r7[-16]
80005f9c:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80005f9e:	ee f8 ff f0 	ld.w	r8,r7[-16]
80005fa2:	70 09       	ld.w	r9,r8[0x0]
80005fa4:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005fa8:	10 09       	add	r9,r8
80005faa:	ee f8 ff f0 	ld.w	r8,r7[-16]
80005fae:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
80005fb0:	ee f9 ff f0 	ld.w	r9,r7[-16]
80005fb4:	30 08       	mov	r8,0
80005fb6:	f3 68 00 08 	st.b	r9[8],r8
80005fba:	ee c8 00 30 	sub	r8,r7,48
80005fbe:	ef 48 ff f8 	st.w	r7[-8],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80005fc2:	e1 b8 00 42 	mfsr	r8,0x108
80005fc6:	ef 48 ff fc 	st.w	r7[-4],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
80005fca:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005fce:	f1 39 00 08 	ld.ub	r9,r8[8]
80005fd2:	30 28       	mov	r8,2
80005fd4:	f0 09 18 00 	cp.b	r9,r8
80005fd8:	c0 31       	brne	80005fde <check_shelf_for_devices+0xce>
    return false;
80005fda:	30 08       	mov	r8,0
80005fdc:	c4 38       	rjmp	80006062 <check_shelf_for_devices+0x152>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
80005fde:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005fe2:	f1 39 00 08 	ld.ub	r9,r8[8]
80005fe6:	30 18       	mov	r8,1
80005fe8:	f0 09 18 00 	cp.b	r9,r8
80005fec:	c0 31       	brne	80005ff2 <check_shelf_for_devices+0xe2>
    return true;
80005fee:	30 18       	mov	r8,1
80005ff0:	c3 98       	rjmp	80006062 <check_shelf_for_devices+0x152>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80005ff2:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005ff6:	70 09       	ld.w	r9,r8[0x0]
80005ff8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005ffc:	70 18       	ld.w	r8,r8[0x4]
80005ffe:	10 39       	cp.w	r9,r8
80006000:	e0 88 00 1a 	brls	80006034 <check_shelf_for_devices+0x124>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80006004:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006008:	70 08       	ld.w	r8,r8[0x0]
8000600a:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000600e:	10 39       	cp.w	r9,r8
80006010:	c1 02       	brcc	80006030 <check_shelf_for_devices+0x120>
80006012:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006016:	70 18       	ld.w	r8,r8[0x4]
80006018:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000601c:	10 39       	cp.w	r9,r8
8000601e:	e0 88 00 09 	brls	80006030 <check_shelf_for_devices+0x120>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80006022:	ee f9 ff f8 	ld.w	r9,r7[-8]
80006026:	30 18       	mov	r8,1
80006028:	f3 68 00 08 	st.b	r9[8],r8
      return true;
8000602c:	30 18       	mov	r8,1
8000602e:	c1 a8       	rjmp	80006062 <check_shelf_for_devices+0x152>
    }
    return false;
80006030:	30 08       	mov	r8,0
80006032:	c1 88       	rjmp	80006062 <check_shelf_for_devices+0x152>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80006034:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006038:	70 08       	ld.w	r8,r8[0x0]
8000603a:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000603e:	10 39       	cp.w	r9,r8
80006040:	c0 93       	brcs	80006052 <check_shelf_for_devices+0x142>
80006042:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006046:	70 18       	ld.w	r8,r8[0x4]
80006048:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000604c:	10 39       	cp.w	r9,r8
8000604e:	e0 88 00 09 	brls	80006060 <check_shelf_for_devices+0x150>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80006052:	ee f9 ff f8 	ld.w	r9,r7[-8]
80006056:	30 18       	mov	r8,1
80006058:	f3 68 00 08 	st.b	r9[8],r8
      return true;
8000605c:	30 18       	mov	r8,1
8000605e:	c0 28       	rjmp	80006062 <check_shelf_for_devices+0x152>
    }
    return false;
80006060:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
80006062:	58 08       	cp.w	r8,0
80006064:	ca b0       	breq	80005fba <check_shelf_for_devices+0xaa>
	
	cpu_delay_ms(50, 8000000);
		
	//Read bluesense for this shelf
	bluesense = 0;
80006066:	30 08       	mov	r8,0
80006068:	ef 58 ff dc 	st.h	r7[-36],r8
	bluesense = adc_process_task(shelfPosition);
8000606c:	ef 38 ff cc 	ld.ub	r8,r7[-52]
80006070:	10 9c       	mov	r12,r8
80006072:	f0 1f 00 2e 	mcall	80006128 <check_shelf_for_devices+0x218>
80006076:	18 98       	mov	r8,r12
80006078:	ef 58 ff dc 	st.h	r7[-36],r8

	led_shelf(shelfPosition, LED_OFF);
8000607c:	ef 38 ff cc 	ld.ub	r8,r7[-52]
80006080:	30 0b       	mov	r11,0
80006082:	10 9c       	mov	r12,r8
80006084:	f0 1f 00 27 	mcall	80006120 <check_shelf_for_devices+0x210>
	
	retVal = NO_DEVICES_PRESENT;
80006088:	30 08       	mov	r8,0
8000608a:	ef 68 ff df 	st.b	r7[-33],r8

	switch(shelfPosition)
8000608e:	ef 38 ff cc 	ld.ub	r8,r7[-52]
80006092:	58 18       	cp.w	r8,1
80006094:	c1 70       	breq	800060c2 <check_shelf_for_devices+0x1b2>
80006096:	e0 89 00 05 	brgt	800060a0 <check_shelf_for_devices+0x190>
8000609a:	58 08       	cp.w	r8,0
8000609c:	c0 70       	breq	800060aa <check_shelf_for_devices+0x19a>
8000609e:	c3 b8       	rjmp	80006114 <check_shelf_for_devices+0x204>
800060a0:	58 28       	cp.w	r8,2
800060a2:	c1 c0       	breq	800060da <check_shelf_for_devices+0x1ca>
800060a4:	58 38       	cp.w	r8,3
800060a6:	c2 60       	breq	800060f2 <check_shelf_for_devices+0x1e2>
800060a8:	c3 68       	rjmp	80006114 <check_shelf_for_devices+0x204>
	{
		case 0:
			if (bluesense > 0x800) {
800060aa:	ef 09 ff dc 	ld.sh	r9,r7[-36]
800060ae:	e0 68 08 00 	mov	r8,2048
800060b2:	f0 09 19 00 	cp.h	r9,r8
800060b6:	e0 88 00 2a 	brls	8000610a <check_shelf_for_devices+0x1fa>
				retVal = DEVICES_PRESENT;
800060ba:	30 18       	mov	r8,1
800060bc:	ef 68 ff df 	st.b	r7[-33],r8
			}
			break;
800060c0:	c2 a8       	rjmp	80006114 <check_shelf_for_devices+0x204>
		case 1:
			if (bluesense > 0x800) {
800060c2:	ef 09 ff dc 	ld.sh	r9,r7[-36]
800060c6:	e0 68 08 00 	mov	r8,2048
800060ca:	f0 09 19 00 	cp.h	r9,r8
800060ce:	e0 88 00 20 	brls	8000610e <check_shelf_for_devices+0x1fe>
				retVal = DEVICES_PRESENT;
800060d2:	30 18       	mov	r8,1
800060d4:	ef 68 ff df 	st.b	r7[-33],r8
			}
			break;
800060d8:	c1 e8       	rjmp	80006114 <check_shelf_for_devices+0x204>
		case 2:
			if (bluesense > 0x800) {
800060da:	ef 09 ff dc 	ld.sh	r9,r7[-36]
800060de:	e0 68 08 00 	mov	r8,2048
800060e2:	f0 09 19 00 	cp.h	r9,r8
800060e6:	e0 88 00 16 	brls	80006112 <check_shelf_for_devices+0x202>
				retVal = DEVICES_PRESENT;
800060ea:	30 18       	mov	r8,1
800060ec:	ef 68 ff df 	st.b	r7[-33],r8
			}
			break;
800060f0:	c1 28       	rjmp	80006114 <check_shelf_for_devices+0x204>
		case 3:
			if (bluesense > 0x800) {
800060f2:	ef 09 ff dc 	ld.sh	r9,r7[-36]
800060f6:	e0 68 08 00 	mov	r8,2048
800060fa:	f0 09 19 00 	cp.h	r9,r8
800060fe:	e0 88 00 0b 	brls	80006114 <check_shelf_for_devices+0x204>
				retVal = DEVICES_PRESENT;
80006102:	30 18       	mov	r8,1
80006104:	ef 68 ff df 	st.b	r7[-33],r8
80006108:	c0 68       	rjmp	80006114 <check_shelf_for_devices+0x204>
	{
		case 0:
			if (bluesense > 0x800) {
				retVal = DEVICES_PRESENT;
			}
			break;
8000610a:	d7 03       	nop
8000610c:	c0 48       	rjmp	80006114 <check_shelf_for_devices+0x204>
		case 1:
			if (bluesense > 0x800) {
				retVal = DEVICES_PRESENT;
			}
			break;
8000610e:	d7 03       	nop
80006110:	c0 28       	rjmp	80006114 <check_shelf_for_devices+0x204>
		case 2:
			if (bluesense > 0x800) {
				retVal = DEVICES_PRESENT;
			}
			break;
80006112:	d7 03       	nop
			}
			break;
	}
	

	return retVal;
80006114:	ef 38 ff df 	ld.ub	r8,r7[-33]
}
80006118:	10 9c       	mov	r12,r8
8000611a:	2f 3d       	sub	sp,-52
8000611c:	e3 cd 80 8f 	ldm	sp++,r0-r3,r7,pc
80006120:	80 00       	ld.sh	r0,r0[0x0]
80006122:	57 1c       	stdsp	sp[0x1c4],r12
80006124:	80 00       	ld.sh	r0,r0[0x0]
80006126:	71 b0       	ld.w	r0,r8[0x6c]
80006128:	80 00       	ld.sh	r0,r0[0x0]
8000612a:	5c 88       	casts.h	r8

8000612c <check_shelves_for_devices>:

void check_shelves_for_devices(void)
{
8000612c:	eb cd 40 c0 	pushm	r6-r7,lr
80006130:	1a 97       	mov	r7,sp
80006132:	20 1d       	sub	sp,4
	for (int i=0; i<NUM_SHELVES; i++)
80006134:	30 08       	mov	r8,0
80006136:	ef 48 ff fc 	st.w	r7[-4],r8
8000613a:	c1 28       	rjmp	8000615e <check_shelves_for_devices+0x32>
	{
		devicesPresentOnShelf[i] = check_shelf_for_devices(i);
8000613c:	ee f6 ff fc 	ld.w	r6,r7[-4]
80006140:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006144:	5c 58       	castu.b	r8
80006146:	10 9c       	mov	r12,r8
80006148:	f0 1f 00 0a 	mcall	80006170 <check_shelves_for_devices+0x44>
8000614c:	18 98       	mov	r8,r12
8000614e:	48 a9       	lddpc	r9,80006174 <check_shelves_for_devices+0x48>
80006150:	f2 06 0b 08 	st.b	r9[r6],r8
	return retVal;
}

void check_shelves_for_devices(void)
{
	for (int i=0; i<NUM_SHELVES; i++)
80006154:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006158:	2f f8       	sub	r8,-1
8000615a:	ef 48 ff fc 	st.w	r7[-4],r8
8000615e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006162:	58 38       	cp.w	r8,3
80006164:	fe 9a ff ec 	brle	8000613c <check_shelves_for_devices+0x10>
	{
		devicesPresentOnShelf[i] = check_shelf_for_devices(i);
	}
}
80006168:	2f fd       	sub	sp,-4
8000616a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000616e:	00 00       	add	r0,r0
80006170:	80 00       	ld.sh	r0,r0[0x0]
80006172:	5f 10       	srne	r0
80006174:	00 00       	add	r0,r0
80006176:	09 a0       	ld.ub	r0,r4[0x2]

80006178 <set_shelves_active_inactive>:


unsigned char topEflag0, topEflag1, botEflag0, botEflag1;

void set_shelves_active_inactive(void)
{
80006178:	eb cd 40 80 	pushm	r7,lr
8000617c:	1a 97       	mov	r7,sp
8000617e:	20 2d       	sub	sp,8
	numActiveShelves = 0;
80006180:	4c d9       	lddpc	r9,800062b4 <set_shelves_active_inactive+0x13c>
80006182:	30 08       	mov	r8,0
80006184:	b2 88       	st.b	r9[0x0],r8
	/*
	 * The rest of the evaluation
	 */
	
	
	for (int i=0; i<NUM_SHELVES; i++)
80006186:	30 08       	mov	r8,0
80006188:	ef 48 ff fc 	st.w	r7[-4],r8
8000618c:	c0 c8       	rjmp	800061a4 <set_shelves_active_inactive+0x2c>
	{
		shelfActive[i] = SHELF_INACTIVE;
8000618e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006192:	4c aa       	lddpc	r10,800062b8 <set_shelves_active_inactive+0x140>
80006194:	30 18       	mov	r8,1
80006196:	f4 09 0b 08 	st.b	r10[r9],r8
	/*
	 * The rest of the evaluation
	 */
	
	
	for (int i=0; i<NUM_SHELVES; i++)
8000619a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000619e:	2f f8       	sub	r8,-1
800061a0:	ef 48 ff fc 	st.w	r7[-4],r8
800061a4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800061a8:	58 38       	cp.w	r8,3
800061aa:	fe 9a ff f2 	brle	8000618e <set_shelves_active_inactive+0x16>
		shelfActive[i] = SHELF_INACTIVE;
		
	}
	
	/* check shelf 0 */
	if (ledBoardPresent[0] &&
800061ae:	4c 48       	lddpc	r8,800062bc <set_shelves_active_inactive+0x144>
800061b0:	70 08       	ld.w	r8,r8[0x0]
800061b2:	58 08       	cp.w	r8,0
800061b4:	c1 d0       	breq	800061ee <set_shelves_active_inactive+0x76>
		ledBoardPresent[1] &&
800061b6:	4c 28       	lddpc	r8,800062bc <set_shelves_active_inactive+0x144>
800061b8:	70 18       	ld.w	r8,r8[0x4]
		shelfActive[i] = SHELF_INACTIVE;
		
	}
	
	/* check shelf 0 */
	if (ledBoardPresent[0] &&
800061ba:	58 08       	cp.w	r8,0
800061bc:	c1 90       	breq	800061ee <set_shelves_active_inactive+0x76>
		ledBoardPresent[1] &&
		devicesPresentOnShelf[0] && 
800061be:	4c 18       	lddpc	r8,800062c0 <set_shelves_active_inactive+0x148>
800061c0:	11 88       	ld.ub	r8,r8[0x0]
		shelfActive[i] = SHELF_INACTIVE;
		
	}
	
	/* check shelf 0 */
	if (ledBoardPresent[0] &&
800061c2:	58 08       	cp.w	r8,0
800061c4:	c1 50       	breq	800061ee <set_shelves_active_inactive+0x76>
		ledBoardPresent[1] &&
		devicesPresentOnShelf[0] && 
		brdSideWithinLifetimeLimit[LED_BRD_0_BOT] &&
800061c6:	4c 08       	lddpc	r8,800062c4 <set_shelves_active_inactive+0x14c>
800061c8:	11 88       	ld.ub	r8,r8[0x0]
		shelfActive[i] = SHELF_INACTIVE;
		
	}
	
	/* check shelf 0 */
	if (ledBoardPresent[0] &&
800061ca:	58 08       	cp.w	r8,0
800061cc:	c1 10       	breq	800061ee <set_shelves_active_inactive+0x76>
		ledBoardPresent[1] &&
		devicesPresentOnShelf[0] && 
		brdSideWithinLifetimeLimit[LED_BRD_0_BOT] &&
		brdSideWithinLifetimeLimit[LED_BRD_1_TOP] )
800061ce:	4b e8       	lddpc	r8,800062c4 <set_shelves_active_inactive+0x14c>
800061d0:	11 98       	ld.ub	r8,r8[0x1]
		shelfActive[i] = SHELF_INACTIVE;
		
	}
	
	/* check shelf 0 */
	if (ledBoardPresent[0] &&
800061d2:	58 08       	cp.w	r8,0
800061d4:	c0 d0       	breq	800061ee <set_shelves_active_inactive+0x76>
		ledBoardPresent[1] &&
		devicesPresentOnShelf[0] && 
		brdSideWithinLifetimeLimit[LED_BRD_0_BOT] &&
		brdSideWithinLifetimeLimit[LED_BRD_1_TOP] )
	{
		shelfActive[0] = SHELF_ACTIVE;
800061d6:	4b 99       	lddpc	r9,800062b8 <set_shelves_active_inactive+0x140>
800061d8:	30 08       	mov	r8,0
800061da:	b2 88       	st.b	r9[0x0],r8
		numActiveShelves++;
800061dc:	4b 68       	lddpc	r8,800062b4 <set_shelves_active_inactive+0x13c>
800061de:	11 88       	ld.ub	r8,r8[0x0]
800061e0:	2f f8       	sub	r8,-1
800061e2:	5c 58       	castu.b	r8
800061e4:	4b 49       	lddpc	r9,800062b4 <set_shelves_active_inactive+0x13c>
800061e6:	b2 88       	st.b	r9[0x0],r8
		print_ssdbg("Shelf 0 active\r\n");
800061e8:	4b 8c       	lddpc	r12,800062c8 <set_shelves_active_inactive+0x150>
800061ea:	f0 1f 00 39 	mcall	800062cc <set_shelves_active_inactive+0x154>
	}
	
	/* check shelf 1 */
	
	if (ledBoardPresent[1] &&
800061ee:	4b 48       	lddpc	r8,800062bc <set_shelves_active_inactive+0x144>
800061f0:	70 18       	ld.w	r8,r8[0x4]
800061f2:	58 08       	cp.w	r8,0
800061f4:	c1 d0       	breq	8000622e <set_shelves_active_inactive+0xb6>
		ledBoardPresent[2] &&
800061f6:	4b 28       	lddpc	r8,800062bc <set_shelves_active_inactive+0x144>
800061f8:	70 28       	ld.w	r8,r8[0x8]
		print_ssdbg("Shelf 0 active\r\n");
	}
	
	/* check shelf 1 */
	
	if (ledBoardPresent[1] &&
800061fa:	58 08       	cp.w	r8,0
800061fc:	c1 90       	breq	8000622e <set_shelves_active_inactive+0xb6>
		ledBoardPresent[2] &&
	devicesPresentOnShelf[1] &&
800061fe:	4b 18       	lddpc	r8,800062c0 <set_shelves_active_inactive+0x148>
80006200:	11 98       	ld.ub	r8,r8[0x1]
		print_ssdbg("Shelf 0 active\r\n");
	}
	
	/* check shelf 1 */
	
	if (ledBoardPresent[1] &&
80006202:	58 08       	cp.w	r8,0
80006204:	c1 50       	breq	8000622e <set_shelves_active_inactive+0xb6>
		ledBoardPresent[2] &&
	devicesPresentOnShelf[1] &&
	brdSideWithinLifetimeLimit[LED_BRD_1_BOT] &&
80006206:	4b 08       	lddpc	r8,800062c4 <set_shelves_active_inactive+0x14c>
80006208:	11 a8       	ld.ub	r8,r8[0x2]
		print_ssdbg("Shelf 0 active\r\n");
	}
	
	/* check shelf 1 */
	
	if (ledBoardPresent[1] &&
8000620a:	58 08       	cp.w	r8,0
8000620c:	c1 10       	breq	8000622e <set_shelves_active_inactive+0xb6>
		ledBoardPresent[2] &&
	devicesPresentOnShelf[1] &&
	brdSideWithinLifetimeLimit[LED_BRD_1_BOT] &&
	brdSideWithinLifetimeLimit[LED_BRD_2_TOP] )
8000620e:	4a e8       	lddpc	r8,800062c4 <set_shelves_active_inactive+0x14c>
80006210:	11 b8       	ld.ub	r8,r8[0x3]
		print_ssdbg("Shelf 0 active\r\n");
	}
	
	/* check shelf 1 */
	
	if (ledBoardPresent[1] &&
80006212:	58 08       	cp.w	r8,0
80006214:	c0 d0       	breq	8000622e <set_shelves_active_inactive+0xb6>
		ledBoardPresent[2] &&
	devicesPresentOnShelf[1] &&
	brdSideWithinLifetimeLimit[LED_BRD_1_BOT] &&
	brdSideWithinLifetimeLimit[LED_BRD_2_TOP] )
	{
		shelfActive[1] = SHELF_ACTIVE;
80006216:	4a 99       	lddpc	r9,800062b8 <set_shelves_active_inactive+0x140>
80006218:	30 08       	mov	r8,0
8000621a:	b2 98       	st.b	r9[0x1],r8
		numActiveShelves++;
8000621c:	4a 68       	lddpc	r8,800062b4 <set_shelves_active_inactive+0x13c>
8000621e:	11 88       	ld.ub	r8,r8[0x0]
80006220:	2f f8       	sub	r8,-1
80006222:	5c 58       	castu.b	r8
80006224:	4a 49       	lddpc	r9,800062b4 <set_shelves_active_inactive+0x13c>
80006226:	b2 88       	st.b	r9[0x0],r8
		print_ssdbg("Shelf 1 active\r\n");
80006228:	4a ac       	lddpc	r12,800062d0 <set_shelves_active_inactive+0x158>
8000622a:	f0 1f 00 29 	mcall	800062cc <set_shelves_active_inactive+0x154>
	}
	
	/* check shelf 2 */
	
	if (ledBoardPresent[2] &&
8000622e:	4a 48       	lddpc	r8,800062bc <set_shelves_active_inactive+0x144>
80006230:	70 28       	ld.w	r8,r8[0x8]
80006232:	58 08       	cp.w	r8,0
80006234:	c1 d0       	breq	8000626e <set_shelves_active_inactive+0xf6>
		ledBoardPresent[3] &&
80006236:	4a 28       	lddpc	r8,800062bc <set_shelves_active_inactive+0x144>
80006238:	70 38       	ld.w	r8,r8[0xc]
		print_ssdbg("Shelf 1 active\r\n");
	}
	
	/* check shelf 2 */
	
	if (ledBoardPresent[2] &&
8000623a:	58 08       	cp.w	r8,0
8000623c:	c1 90       	breq	8000626e <set_shelves_active_inactive+0xf6>
		ledBoardPresent[3] &&
	devicesPresentOnShelf[2] &&
8000623e:	4a 18       	lddpc	r8,800062c0 <set_shelves_active_inactive+0x148>
80006240:	11 a8       	ld.ub	r8,r8[0x2]
		print_ssdbg("Shelf 1 active\r\n");
	}
	
	/* check shelf 2 */
	
	if (ledBoardPresent[2] &&
80006242:	58 08       	cp.w	r8,0
80006244:	c1 50       	breq	8000626e <set_shelves_active_inactive+0xf6>
		ledBoardPresent[3] &&
	devicesPresentOnShelf[2] &&
	brdSideWithinLifetimeLimit[LED_BRD_2_BOT] &&
80006246:	4a 08       	lddpc	r8,800062c4 <set_shelves_active_inactive+0x14c>
80006248:	11 c8       	ld.ub	r8,r8[0x4]
		print_ssdbg("Shelf 1 active\r\n");
	}
	
	/* check shelf 2 */
	
	if (ledBoardPresent[2] &&
8000624a:	58 08       	cp.w	r8,0
8000624c:	c1 10       	breq	8000626e <set_shelves_active_inactive+0xf6>
		ledBoardPresent[3] &&
	devicesPresentOnShelf[2] &&
	brdSideWithinLifetimeLimit[LED_BRD_2_BOT] &&
	brdSideWithinLifetimeLimit[LED_BRD_3_TOP] )
8000624e:	49 e8       	lddpc	r8,800062c4 <set_shelves_active_inactive+0x14c>
80006250:	11 d8       	ld.ub	r8,r8[0x5]
		print_ssdbg("Shelf 1 active\r\n");
	}
	
	/* check shelf 2 */
	
	if (ledBoardPresent[2] &&
80006252:	58 08       	cp.w	r8,0
80006254:	c0 d0       	breq	8000626e <set_shelves_active_inactive+0xf6>
		ledBoardPresent[3] &&
	devicesPresentOnShelf[2] &&
	brdSideWithinLifetimeLimit[LED_BRD_2_BOT] &&
	brdSideWithinLifetimeLimit[LED_BRD_3_TOP] )
	{
		shelfActive[2] = SHELF_ACTIVE;
80006256:	49 99       	lddpc	r9,800062b8 <set_shelves_active_inactive+0x140>
80006258:	30 08       	mov	r8,0
8000625a:	b2 a8       	st.b	r9[0x2],r8
		numActiveShelves++;
8000625c:	49 68       	lddpc	r8,800062b4 <set_shelves_active_inactive+0x13c>
8000625e:	11 88       	ld.ub	r8,r8[0x0]
80006260:	2f f8       	sub	r8,-1
80006262:	5c 58       	castu.b	r8
80006264:	49 49       	lddpc	r9,800062b4 <set_shelves_active_inactive+0x13c>
80006266:	b2 88       	st.b	r9[0x0],r8
		print_ssdbg("Shelf 2 active\r\n");
80006268:	49 bc       	lddpc	r12,800062d4 <set_shelves_active_inactive+0x15c>
8000626a:	f0 1f 00 19 	mcall	800062cc <set_shelves_active_inactive+0x154>
	}
	
	/* check shelf 3 */
	
	if (ledBoardPresent[3] &&
8000626e:	49 48       	lddpc	r8,800062bc <set_shelves_active_inactive+0x144>
80006270:	70 38       	ld.w	r8,r8[0xc]
80006272:	58 08       	cp.w	r8,0
80006274:	c1 d0       	breq	800062ae <set_shelves_active_inactive+0x136>
		ledBoardPresent[4] &&
80006276:	49 28       	lddpc	r8,800062bc <set_shelves_active_inactive+0x144>
80006278:	70 48       	ld.w	r8,r8[0x10]
		print_ssdbg("Shelf 2 active\r\n");
	}
	
	/* check shelf 3 */
	
	if (ledBoardPresent[3] &&
8000627a:	58 08       	cp.w	r8,0
8000627c:	c1 90       	breq	800062ae <set_shelves_active_inactive+0x136>
		ledBoardPresent[4] &&
	devicesPresentOnShelf[3] &&
8000627e:	49 18       	lddpc	r8,800062c0 <set_shelves_active_inactive+0x148>
80006280:	11 b8       	ld.ub	r8,r8[0x3]
		print_ssdbg("Shelf 2 active\r\n");
	}
	
	/* check shelf 3 */
	
	if (ledBoardPresent[3] &&
80006282:	58 08       	cp.w	r8,0
80006284:	c1 50       	breq	800062ae <set_shelves_active_inactive+0x136>
		ledBoardPresent[4] &&
	devicesPresentOnShelf[3] &&
	brdSideWithinLifetimeLimit[LED_BRD_3_BOT] &&
80006286:	49 08       	lddpc	r8,800062c4 <set_shelves_active_inactive+0x14c>
80006288:	11 e8       	ld.ub	r8,r8[0x6]
		print_ssdbg("Shelf 2 active\r\n");
	}
	
	/* check shelf 3 */
	
	if (ledBoardPresent[3] &&
8000628a:	58 08       	cp.w	r8,0
8000628c:	c1 10       	breq	800062ae <set_shelves_active_inactive+0x136>
		ledBoardPresent[4] &&
	devicesPresentOnShelf[3] &&
	brdSideWithinLifetimeLimit[LED_BRD_3_BOT] &&
	brdSideWithinLifetimeLimit[LED_BRD_4_TOP] )
8000628e:	48 e8       	lddpc	r8,800062c4 <set_shelves_active_inactive+0x14c>
80006290:	11 f8       	ld.ub	r8,r8[0x7]
		print_ssdbg("Shelf 2 active\r\n");
	}
	
	/* check shelf 3 */
	
	if (ledBoardPresent[3] &&
80006292:	58 08       	cp.w	r8,0
80006294:	c0 d0       	breq	800062ae <set_shelves_active_inactive+0x136>
		ledBoardPresent[4] &&
	devicesPresentOnShelf[3] &&
	brdSideWithinLifetimeLimit[LED_BRD_3_BOT] &&
	brdSideWithinLifetimeLimit[LED_BRD_4_TOP] )
	{
		shelfActive[3] = SHELF_ACTIVE;
80006296:	48 99       	lddpc	r9,800062b8 <set_shelves_active_inactive+0x140>
80006298:	30 08       	mov	r8,0
8000629a:	b2 b8       	st.b	r9[0x3],r8
		numActiveShelves++;
8000629c:	48 68       	lddpc	r8,800062b4 <set_shelves_active_inactive+0x13c>
8000629e:	11 88       	ld.ub	r8,r8[0x0]
800062a0:	2f f8       	sub	r8,-1
800062a2:	5c 58       	castu.b	r8
800062a4:	48 49       	lddpc	r9,800062b4 <set_shelves_active_inactive+0x13c>
800062a6:	b2 88       	st.b	r9[0x0],r8
		print_ssdbg("Shelf 3 active\r\n");
800062a8:	48 cc       	lddpc	r12,800062d8 <set_shelves_active_inactive+0x160>
800062aa:	f0 1f 00 09 	mcall	800062cc <set_shelves_active_inactive+0x154>
	}
}
800062ae:	2f ed       	sub	sp,-8
800062b0:	e3 cd 80 80 	ldm	sp++,r7,pc
800062b4:	00 00       	add	r0,r0
800062b6:	09 8c       	ld.ub	r12,r4[0x0]
800062b8:	00 00       	add	r0,r0
800062ba:	09 a4       	ld.ub	r4,r4[0x2]
800062bc:	00 00       	add	r0,r0
800062be:	07 0c       	ld.w	r12,r3++
800062c0:	00 00       	add	r0,r0
800062c2:	09 a0       	ld.ub	r0,r4[0x2]
800062c4:	00 00       	add	r0,r0
800062c6:	09 84       	ld.ub	r4,r4[0x0]
800062c8:	80 00       	ld.sh	r0,r0[0x0]
800062ca:	58 74       	cp.w	r4,7
800062cc:	80 00       	ld.sh	r0,r0[0x0]
800062ce:	33 a0       	mov	r0,58
800062d0:	80 00       	ld.sh	r0,r0[0x0]
800062d2:	58 88       	cp.w	r8,8
800062d4:	80 00       	ld.sh	r0,r0[0x0]
800062d6:	58 9c       	cp.w	r12,9
800062d8:	80 00       	ld.sh	r0,r0[0x0]
800062da:	58 b0       	cp.w	r0,11

800062dc <num_active_shelves>:

unsigned char num_active_shelves(void)
{
800062dc:	eb cd 40 80 	pushm	r7,lr
800062e0:	1a 97       	mov	r7,sp
	return numActiveShelves;
800062e2:	48 38       	lddpc	r8,800062ec <num_active_shelves+0x10>
800062e4:	11 88       	ld.ub	r8,r8[0x0]
}
800062e6:	10 9c       	mov	r12,r8
800062e8:	e3 cd 80 80 	ldm	sp++,r7,pc
800062ec:	00 00       	add	r0,r0
800062ee:	09 8c       	ld.ub	r12,r4[0x0]

800062f0 <init_sys_clocks>:

/*
 * Using RC8M (internal 8MHz)
 */
void init_sys_clocks(void)
{
800062f0:	eb cd 40 80 	pushm	r7,lr
800062f4:	1a 97       	mov	r7,sp
800062f6:	20 3d       	sub	sp,12
	scif_gclk_opt_t gclkOpt = {SCIF_GCCTRL_RC8M, 0,0};
800062f8:	30 28       	mov	r8,2
800062fa:	ef 48 ff f4 	st.w	r7[-12],r8
800062fe:	30 08       	mov	r8,0
80006300:	ef 48 ff f8 	st.w	r7[-8],r8
80006304:	30 08       	mov	r8,0
80006306:	ef 48 ff fc 	st.w	r7[-4],r8
	
	// Start the 8Mhz Oscillator
	scif_start_rc8M();
8000630a:	f0 1f 00 0a 	mcall	80006330 <init_sys_clocks+0x40>
	// Set the main clock source as being RC8MHz.
	pm_set_mclk_source(PM_CLK_SRC_RC8M);	
8000630e:	30 5c       	mov	r12,5
80006310:	f0 1f 00 09 	mcall	80006334 <init_sys_clocks+0x44>


	/* put the clock out on PC19 so we can check to make sure we set it up correctly */
	//Note this code comes from ASF example AVR32 SCIF example 3
	scif_start_gclk(AVR32_SCIF_GCLK_GCLK0PIN, &gclkOpt);
80006314:	ee c8 00 0c 	sub	r8,r7,12
80006318:	10 9b       	mov	r11,r8
8000631a:	30 9c       	mov	r12,9
8000631c:	f0 1f 00 07 	mcall	80006338 <init_sys_clocks+0x48>
	gpio_enable_module_pin(AVR32_SCIF_GCLK_0_1_PIN, AVR32_SCIF_GCLK_0_1_FUNCTION);
80006320:	30 1b       	mov	r11,1
80006322:	35 3c       	mov	r12,83
80006324:	f0 1f 00 06 	mcall	8000633c <init_sys_clocks+0x4c>
	
}
80006328:	2f dd       	sub	sp,-12
8000632a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000632e:	00 00       	add	r0,r0
80006330:	80 00       	ld.sh	r0,r0[0x0]
80006332:	45 58       	lddsp	r8,sp[0x154]
80006334:	80 00       	ld.sh	r0,r0[0x0]
80006336:	44 e8       	lddsp	r8,sp[0x138]
80006338:	80 00       	ld.sh	r0,r0[0x0]
8000633a:	45 d8       	lddsp	r8,sp[0x174]
8000633c:	80 00       	ld.sh	r0,r0[0x0]
8000633e:	3c c8       	mov	r8,-52

80006340 <adc_process_init>:
/*! \brief ADC Process Init
 *
 *
 */
void adc_process_init(void)
{
80006340:	eb cd 40 80 	pushm	r7,lr
80006344:	1a 97       	mov	r7,sp
		{INPUT3_ADC_PIN, INPUT3_ADC_FUNCTION},	//8apr15 TODO is this right??
		{INPUT4_ADC_PIN, INPUT4_ADC_FUNCTION}	//8apr15 TODO is this right??
	};

	// Assign and enable GPIO pins to the ADC function.
	gpio_enable_module(ADCIFA_GPIO_MAP,
80006346:	30 7b       	mov	r11,7
80006348:	48 bc       	lddpc	r12,80006374 <adc_process_init+0x34>
8000634a:	f0 1f 00 0c 	mcall	80006378 <adc_process_init+0x38>
			sizeof(ADCIFA_GPIO_MAP) / sizeof(ADCIFA_GPIO_MAP[0]));

	// Get ADCIFA Factory Configuration
	adcifa_get_calibration_data(adcifa, &adc_config_t);
8000634e:	48 c8       	lddpc	r8,8000637c <adc_process_init+0x3c>
80006350:	70 08       	ld.w	r8,r8[0x0]
80006352:	48 cb       	lddpc	r11,80006380 <adc_process_init+0x40>
80006354:	10 9c       	mov	r12,r8
80006356:	f0 1f 00 0c 	mcall	80006384 <adc_process_init+0x44>

	// Configure ADCIFA core
//debug 10apr15 	adcifa_configure(adcifa, &adc_config_t, FOSC0);
	adcifa_configure(adcifa, &adc_config_t, 8000000); //10apr15
8000635a:	48 98       	lddpc	r8,8000637c <adc_process_init+0x3c>
8000635c:	70 08       	ld.w	r8,r8[0x0]
8000635e:	e0 6a 12 00 	mov	r10,4608
80006362:	ea 1a 00 7a 	orh	r10,0x7a
80006366:	48 7b       	lddpc	r11,80006380 <adc_process_init+0x40>
80006368:	10 9c       	mov	r12,r8
8000636a:	f0 1f 00 08 	mcall	80006388 <adc_process_init+0x48>

}
8000636e:	e3 cd 80 80 	ldm	sp++,r7,pc
80006372:	00 00       	add	r0,r0
80006374:	80 00       	ld.sh	r0,r0[0x0]
80006376:	7a 00       	ld.w	r0,sp[0x0]
80006378:	80 00       	ld.sh	r0,r0[0x0]
8000637a:	3c 58       	mov	r8,-59
8000637c:	00 00       	add	r0,r0
8000637e:	00 a8       	st.w	r0++,r8
80006380:	00 00       	add	r0,r0
80006382:	00 80       	andn	r0,r0
80006384:	80 00       	ld.sh	r0,r0[0x0]
80006386:	33 ec       	mov	r12,62
80006388:	80 00       	ld.sh	r0,r0[0x0]
8000638a:	34 80       	mov	r0,72

8000638c <twi_init>:
/*! \brief TWI Initialization for QTouch Controller
 *
 *
 */
static void twi_init(void)
{
8000638c:	eb cd 40 80 	pushm	r7,lr
80006390:	1a 97       	mov	r7,sp
80006392:	20 8d       	sub	sp,32
	const gpio_map_t PCA9952_TWI_GPIO_MAP = {
		{PCA9952_TWI_SCL_PIN, PCA9952_TWI_SCL_FUNCTION},
		{PCA9952_TWI_SDA_PIN, PCA9952_TWI_SDA_FUNCTION}
	};
80006394:	49 a9       	lddpc	r9,800063fc <twi_init+0x70>
80006396:	ee c8 00 10 	sub	r8,r7,16
8000639a:	20 08       	sub	r8,0
8000639c:	20 09       	sub	r9,0
8000639e:	72 0a       	ld.w	r10,r9[0x0]
800063a0:	91 0a       	st.w	r8[0x0],r10
800063a2:	72 1a       	ld.w	r10,r9[0x4]
800063a4:	91 1a       	st.w	r8[0x4],r10
800063a6:	72 2a       	ld.w	r10,r9[0x8]
800063a8:	91 2a       	st.w	r8[0x8],r10
800063aa:	72 39       	ld.w	r9,r9[0xc]
800063ac:	91 39       	st.w	r8[0xc],r9
		.pba_hz = FPBA_HZ,
		.speed = PCA9952_TWI_MASTER_SPEED,
//7apr15		.chip = PCA9952_TWI_ADDRESS,
		.chip = PCA9952_U7_TOPDRIVE_TWI_ADDRESS, //7apr15
		.smbus        = false,
	};
800063ae:	49 59       	lddpc	r9,80006400 <twi_init+0x74>
800063b0:	ee c8 00 20 	sub	r8,r7,32
800063b4:	20 08       	sub	r8,0
800063b6:	20 09       	sub	r9,0
800063b8:	72 0a       	ld.w	r10,r9[0x0]
800063ba:	91 0a       	st.w	r8[0x0],r10
800063bc:	72 1a       	ld.w	r10,r9[0x4]
800063be:	91 1a       	st.w	r8[0x4],r10
800063c0:	72 2a       	ld.w	r10,r9[0x8]
800063c2:	91 2a       	st.w	r8[0x8],r10
800063c4:	72 39       	ld.w	r9,r9[0xc]
800063c6:	91 39       	st.w	r8[0xc],r9

	// Assign I/Os to TWI.
	gpio_enable_module(PCA9952_TWI_GPIO_MAP,
800063c8:	ee c8 00 10 	sub	r8,r7,16
800063cc:	30 2b       	mov	r11,2
800063ce:	10 9c       	mov	r12,r8
800063d0:	f0 1f 00 0d 	mcall	80006404 <twi_init+0x78>
	sizeof(PCA9952_TWI_GPIO_MAP) / sizeof(PCA9952_TWI_GPIO_MAP[0]));
	// Initialize as master.
	twi_master_init(PCA9952_TWI, &PCA9952_TWI_OPTIONS);
800063d4:	ee c8 00 20 	sub	r8,r7,32
800063d8:	10 9b       	mov	r11,r8
800063da:	fe 7c 38 00 	mov	r12,-51200
800063de:	f0 1f 00 0b 	mcall	80006408 <twi_init+0x7c>
	
	
	PCA9952_TWI_OPTIONS.chip = PCA9952_U8_BOTDRIVE_TWI_ADDRESS;
800063e2:	36 18       	mov	r8,97
800063e4:	ef 48 ff e8 	st.w	r7[-24],r8
	// Initialize as master.
	twi_master_init(PCA9952_TWI, &PCA9952_TWI_OPTIONS);
800063e8:	ee c8 00 20 	sub	r8,r7,32
800063ec:	10 9b       	mov	r11,r8
800063ee:	fe 7c 38 00 	mov	r12,-51200
800063f2:	f0 1f 00 06 	mcall	80006408 <twi_init+0x7c>
	
	
}
800063f6:	2f 8d       	sub	sp,-32
800063f8:	e3 cd 80 80 	ldm	sp++,r7,pc
800063fc:	80 00       	ld.sh	r0,r0[0x0]
800063fe:	79 e0       	ld.w	r0,r12[0x78]
80006400:	80 00       	ld.sh	r0,r0[0x0]
80006402:	79 f0       	ld.w	r0,r12[0x7c]
80006404:	80 00       	ld.sh	r0,r0[0x0]
80006406:	3c 58       	mov	r8,-59
80006408:	80 00       	ld.sh	r0,r0[0x0]
8000640a:	48 9c       	lddpc	r12,8000642c <calc_sanitize_time+0x20>

8000640c <calc_sanitize_time>:
	STATE_CLEAN,
	STATE_SHUTDOWN_PROCESSES
};

unsigned long calc_sanitize_time(unsigned char shelfIdx)
{
8000640c:	eb cd 40 80 	pushm	r7,lr
80006410:	1a 97       	mov	r7,sp
80006412:	20 4d       	sub	sp,16
80006414:	ef 6c ff f0 	st.b	r7[-16],r12
80006418:	e0 6c 03 e8 	mov	r12,1000
8000641c:	ef 4c ff fc 	st.w	r7[-4],r12
80006420:	e0 6c 12 00 	mov	r12,4608
80006424:	ea 1c 00 7a 	orh	r12,0x7a
80006428:	ef 4c ff f8 	st.w	r7[-8],r12
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
8000642c:	ee fa ff fc 	ld.w	r10,r7[-4]
80006430:	30 0b       	mov	r11,0
80006432:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006436:	30 09       	mov	r9,0
80006438:	f6 08 02 4c 	mul	r12,r11,r8
8000643c:	f2 0a 02 4e 	mul	lr,r9,r10
80006440:	1c 0c       	add	r12,lr
80006442:	f4 08 06 48 	mulu.d	r8,r10,r8
80006446:	12 0c       	add	r12,r9
80006448:	18 99       	mov	r9,r12
8000644a:	e0 6a 03 e7 	mov	r10,999
8000644e:	30 0b       	mov	r11,0
80006450:	f0 0a 00 0a 	add	r10,r8,r10
80006454:	f2 0b 00 4b 	adc	r11,r9,r11
80006458:	e0 68 03 e8 	mov	r8,1000
8000645c:	30 09       	mov	r9,0
8000645e:	f0 1f 00 07 	mcall	80006478 <calc_sanitize_time+0x6c>
80006462:	14 98       	mov	r8,r10
80006464:	16 99       	mov	r9,r11
	uint32_t cyclesPerSec;
	
	cyclesPerSec = cpu_ms_2_cy(1000, 8000000);
80006466:	ef 48 ff f4 	st.w	r7[-12],r8
	
	//TODO: put the real calculation here based on hours of usage
	
	return (8*cyclesPerSec); //fudge for now, show the string and let it wrap once, looks better for the show
8000646a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000646e:	a3 78       	lsl	r8,0x3
	
}
80006470:	10 9c       	mov	r12,r8
80006472:	2f cd       	sub	sp,-16
80006474:	e3 cd 80 80 	ldm	sp++,r7,pc
80006478:	80 00       	ld.sh	r0,r0[0x0]
8000647a:	71 b0       	ld.w	r0,r8[0x6c]

8000647c <door_latch_open_kill_all_shelves>:
unsigned char sealShieldState;
unsigned char anyShelvesStillSanitizing;


void door_latch_open_kill_all_shelves(void)
{
8000647c:	eb cd 40 80 	pushm	r7,lr
80006480:	1a 97       	mov	r7,sp
	led_shelf(0, LED_OFF);
80006482:	30 0b       	mov	r11,0
80006484:	30 0c       	mov	r12,0
80006486:	f0 1f 00 09 	mcall	800064a8 <door_latch_open_kill_all_shelves+0x2c>
	led_shelf(1, LED_OFF);
8000648a:	30 0b       	mov	r11,0
8000648c:	30 1c       	mov	r12,1
8000648e:	f0 1f 00 07 	mcall	800064a8 <door_latch_open_kill_all_shelves+0x2c>
	led_shelf(2, LED_OFF);
80006492:	30 0b       	mov	r11,0
80006494:	30 2c       	mov	r12,2
80006496:	f0 1f 00 05 	mcall	800064a8 <door_latch_open_kill_all_shelves+0x2c>
	led_shelf(3, LED_OFF);
8000649a:	30 0b       	mov	r11,0
8000649c:	30 3c       	mov	r12,3
8000649e:	f0 1f 00 03 	mcall	800064a8 <door_latch_open_kill_all_shelves+0x2c>
}
800064a2:	e3 cd 80 80 	ldm	sp++,r7,pc
800064a6:	00 00       	add	r0,r0
800064a8:	80 00       	ld.sh	r0,r0[0x0]
800064aa:	57 1c       	stdsp	sp[0x1c4],r12

800064ac <main>:
/*! \brief Main File Section:
 *          - Initialization (CPU, TWI, Usart,...)
 *          - Main loop with task management (CAN, LIN, ADC)
 */
int main(void)
{
800064ac:	eb cd 40 cf 	pushm	r0-r3,r6-r7,lr
800064b0:	1a 97       	mov	r7,sp
800064b2:	fa cd 01 28 	sub	sp,sp,296
	static unsigned char sanitizeIdx = 0;
	
	// Initialize System Clock
	init_sys_clocks();
800064b6:	f0 1f 03 13 	mcall	80007100 <main+0xc54>

	init_io();
800064ba:	f0 1f 03 13 	mcall	80007104 <main+0xc58>
	

	// Initialize USART
	init_ssdbg_rs232(FPBA_HZ);
800064be:	e0 6c 24 00 	mov	r12,9216
800064c2:	ea 1c 00 f4 	orh	r12,0xf4
800064c6:	f0 1f 03 11 	mcall	80007108 <main+0xc5c>
	init_display_rs232(FPBA_HZ);
800064ca:	e0 6c 24 00 	mov	r12,9216
800064ce:	ea 1c 00 f4 	orh	r12,0xf4
800064d2:	f0 1f 03 0f 	mcall	8000710c <main+0xc60>

	// Print Startup Message
	print_ssdbg("SEAL SHIELD DEMO \r\n Copyright (c) 2015 Technical Solutions Group, Inc.\r\n");
800064d6:	fe fc 0c 3a 	ld.w	r12,pc[3130]
800064da:	f0 1f 03 0f 	mcall	80007114 <main+0xc68>
	display_text(IDX_READY);
800064de:	30 0c       	mov	r12,0
800064e0:	f0 1f 03 0e 	mcall	80007118 <main+0xc6c>
	
	// Initialize ADC for bluesense channels which are used to see if there are any devices (phones, tablets, etc.) on the shelves
	adc_process_init();
800064e4:	f0 1f 03 0e 	mcall	8000711c <main+0xc70>

	
	// Initialize Interrupts
	irq_initialize_vectors(); //TODO: probably remove 5apr15
800064e8:	f0 1f 03 0e 	mcall	80007120 <main+0xc74>

	cpu_irq_enable();
800064ec:	d5 03       	csrf	0x10

	// Initialize TWI Interface
	twi_init();
800064ee:	f0 1f 03 0e 	mcall	80007124 <main+0xc78>

	gpio_set_pin_high(SEALSHIELD_LED_OEn); //make sure outputs are disabled at the chip level
800064f2:	31 6c       	mov	r12,22
800064f4:	f0 1f 03 0d 	mcall	80007128 <main+0xc7c>
	PCA9952_init();
800064f8:	f0 1f 03 0d 	mcall	8000712c <main+0xc80>
	controller_init(FCPU_HZ, FHSB_HZ, FPBA_HZ, FPBB_HZ);
	lin_task_init(); // Initialize LIN Interface
	can_task_init(); // Initialize CAN Interface
#endif

	sealShieldState = STATE_SS_IDLE;
800064fc:	fe f9 0c 34 	ld.w	r9,pc[3124]
80006500:	30 08       	mov	r8,0
80006502:	b2 88       	st.b	r9[0x0],r8
	
	//using this structure makes the timer IDs index-able
	shelfTimerPtr[0] = &timerShelf0;
80006504:	fe f9 0c 30 	ld.w	r9,pc[3120]
80006508:	fe f8 0c 30 	ld.w	r8,pc[3120]
8000650c:	93 08       	st.w	r9[0x0],r8
	shelfTimerPtr[1] = &timerShelf1;
8000650e:	fe f9 0c 26 	ld.w	r9,pc[3110]
80006512:	fe f8 0c 2a 	ld.w	r8,pc[3114]
80006516:	93 18       	st.w	r9[0x4],r8
	shelfTimerPtr[2] = &timerShelf2;
80006518:	fe f9 0c 1c 	ld.w	r9,pc[3100]
8000651c:	fe f8 0c 24 	ld.w	r8,pc[3108]
80006520:	93 28       	st.w	r9[0x8],r8
	shelfTimerPtr[3] = &timerShelf3;
80006522:	fe f9 0c 12 	ld.w	r9,pc[3090]
80006526:	fe f8 0c 1e 	ld.w	r8,pc[3102]
8000652a:	93 38       	st.w	r9[0xc],r8
	
	gpio_set_pin_low(SEALSHIELD_LED_OEn); //...and we are live!
8000652c:	31 6c       	mov	r12,22
8000652e:	f0 1f 03 07 	mcall	80007148 <main+0xc9c>
	gpio_set_pin_low(SEALSHIELD_PSUPPLY_ONn); //turn the leds on first and then the power supply
80006532:	31 7c       	mov	r12,23
80006534:	f0 1f 03 05 	mcall	80007148 <main+0xc9c>
80006538:	e0 68 09 00 	mov	r8,2304
8000653c:	ea 18 00 3d 	orh	r8,0x3d
80006540:	ef 48 ff 40 	st.w	r7[-192],r8
80006544:	fe f8 0c 08 	ld.w	r8,pc[3080]
80006548:	ef 48 ff 3c 	st.w	r7[-196],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000654c:	e1 b8 00 42 	mfsr	r8,0x108
80006550:	10 99       	mov	r9,r8
80006552:	ee f8 ff 3c 	ld.w	r8,r7[-196]
80006556:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80006558:	ee f8 ff 3c 	ld.w	r8,r7[-196]
8000655c:	70 09       	ld.w	r9,r8[0x0]
8000655e:	ee f8 ff 40 	ld.w	r8,r7[-192]
80006562:	10 09       	add	r9,r8
80006564:	ee f8 ff 3c 	ld.w	r8,r7[-196]
80006568:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
8000656a:	ee f9 ff 3c 	ld.w	r9,r7[-196]
8000656e:	30 08       	mov	r8,0
80006570:	f3 68 00 08 	st.b	r9[8],r8
80006574:	c0 28       	rjmp	80006578 <main+0xcc>
		{
			cpu_stop_timeout(&timerDebugLed);
			cpu_set_timeout((SS_ONE_SECOND/2), &timerDebugLed);
			gpio_toggle_pin(SEALSHIELD_DEBUG_LED);
		}
	} //while(true)
80006576:	d7 03       	nop
		{
			read_serial_ids();
		}
#endif

		switch(sealShieldState)
80006578:	fe f8 0b b8 	ld.w	r8,pc[3000]
8000657c:	11 88       	ld.ub	r8,r8[0x0]
8000657e:	10 99       	mov	r9,r8
80006580:	58 99       	cp.w	r9,9
80006582:	e0 8b 04 79 	brhi	80006e74 <main+0x9c8>
80006586:	fe f8 0b ca 	ld.w	r8,pc[3018]
8000658a:	f0 09 03 2f 	ld.w	pc,r8[r9<<0x2]
		{
			case STATE_SS_IDLE:
				if (SS_DOOR_LATCHED) {
8000658e:	33 ec       	mov	r12,62
80006590:	f0 1f 02 f1 	mcall	80007154 <main+0xca8>
80006594:	18 98       	mov	r8,r12
80006596:	ec 18 00 01 	eorl	r8,0x1
8000659a:	5c 58       	castu.b	r8
8000659c:	e0 80 04 61 	breq	80006e5e <main+0x9b2>
					gpio_set_pin_low(SEALSHIELD_DEBUG_LED);
800065a0:	37 cc       	mov	r12,124
800065a2:	f0 1f 02 ea 	mcall	80007148 <main+0xc9c>
					print_ssdbg("Door latch detected\r\n");
800065a6:	fe fc 0b b2 	ld.w	r12,pc[2994]
800065aa:	f0 1f 02 db 	mcall	80007114 <main+0xc68>
//					display_text(IDX_CLEAR);
					display_text(IDX_READY);
800065ae:	30 0c       	mov	r12,0
800065b0:	f0 1f 02 da 	mcall	80007118 <main+0xc6c>
					sealShieldState = STATE_DOOR_LATCHED;
800065b4:	fe f9 0b 7c 	ld.w	r9,pc[2940]
800065b8:	30 18       	mov	r8,1
800065ba:	b2 88       	st.b	r9[0x0],r8
					firstTimeThrough = 1;
800065bc:	fe f9 0b a0 	ld.w	r9,pc[2976]
800065c0:	30 18       	mov	r8,1
800065c2:	b2 88       	st.b	r9[0x0],r8
				}
				break;
800065c4:	e0 8f 04 58 	bral	80006e74 <main+0x9c8>
				
			case STATE_DOOR_LATCHED:
				if (!SS_ACTION_PB) {
800065c8:	33 fc       	mov	r12,63
800065ca:	f0 1f 02 e3 	mcall	80007154 <main+0xca8>
800065ce:	18 98       	mov	r8,r12
800065d0:	58 08       	cp.w	r8,0
800065d2:	e0 80 04 48 	breq	80006e62 <main+0x9b6>
					print_ssdbg("Action push button press detected\r\n");
800065d6:	fe fc 0b 8a 	ld.w	r12,pc[2954]
800065da:	f0 1f 02 cf 	mcall	80007114 <main+0xc68>
					sealShieldState = STATE_ACTION_PB_PRESSED;
800065de:	fe f9 0b 52 	ld.w	r9,pc[2898]
800065e2:	30 28       	mov	r8,2
800065e4:	b2 88       	st.b	r9[0x0],r8
					read_serial_ids();
800065e6:	f0 1f 02 e0 	mcall	80007164 <main+0xcb8>
				}
				break;
800065ea:	e0 8f 04 45 	bral	80006e74 <main+0x9c8>
				
			case STATE_ACTION_PB_PRESSED:
				if (SS_ACTION_PB)
800065ee:	33 fc       	mov	r12,63
800065f0:	f0 1f 02 d9 	mcall	80007154 <main+0xca8>
800065f4:	18 98       	mov	r8,r12
800065f6:	ec 18 00 01 	eorl	r8,0x1
800065fa:	5c 58       	castu.b	r8
800065fc:	e0 80 04 35 	breq	80006e66 <main+0x9ba>
				{
					print_ssdbg("Action push button release detected\r\n");
80006600:	fe fc 0b 68 	ld.w	r12,pc[2920]
80006604:	f0 1f 02 c4 	mcall	80007114 <main+0xc68>
					sealShieldState = STATE_ACTION_PB_RELEASED;	
80006608:	fe f9 0b 28 	ld.w	r9,pc[2856]
8000660c:	30 38       	mov	r8,3
8000660e:	b2 88       	st.b	r9[0x0],r8
					read_serial_ids();
80006610:	f0 1f 02 d5 	mcall	80007164 <main+0xcb8>
				}
				break;
80006614:	e0 8f 04 30 	bral	80006e74 <main+0x9c8>
				
			case STATE_ACTION_PB_RELEASED:
				read_serial_ids();
80006618:	f0 1f 02 d3 	mcall	80007164 <main+0xcb8>
				check_led_brd_side_lifetimes();
8000661c:	f0 1f 02 d4 	mcall	8000716c <main+0xcc0>
				check_shelves_for_devices();
80006620:	f0 1f 02 d4 	mcall	80007170 <main+0xcc4>
				set_shelves_active_inactive();
80006624:	f0 1f 02 d4 	mcall	80007174 <main+0xcc8>
				
				if (num_active_shelves() != 0) {
80006628:	f0 1f 02 d4 	mcall	80007178 <main+0xccc>
8000662c:	18 98       	mov	r8,r12
8000662e:	58 08       	cp.w	r8,0
80006630:	e0 80 01 72 	breq	80006914 <main+0x468>
					sealShieldState = STATE_START_SANITIZE;	
80006634:	fe f9 0a fc 	ld.w	r9,pc[2812]
80006638:	30 48       	mov	r8,4
8000663a:	b2 88       	st.b	r9[0x0],r8
					print_ssdbg("Start sanitizing\r\n");
8000663c:	fe fc 0b 40 	ld.w	r12,pc[2880]
80006640:	f0 1f 02 b5 	mcall	80007114 <main+0xc68>
					display_text(IDX_CLEAR);
80006644:	30 9c       	mov	r12,9
80006646:	f0 1f 02 b5 	mcall	80007118 <main+0xc6c>
8000664a:	e0 68 01 f4 	mov	r8,500
8000664e:	ef 48 ff 48 	st.w	r7[-184],r8
80006652:	e0 68 12 00 	mov	r8,4608
80006656:	ea 18 00 7a 	orh	r8,0x7a
8000665a:	ef 48 ff 44 	st.w	r7[-188],r8
8000665e:	ee f8 ff 48 	ld.w	r8,r7[-184]
80006662:	ef 48 ff 50 	st.w	r7[-176],r8
80006666:	ee f8 ff 44 	ld.w	r8,r7[-188]
8000666a:	ef 48 ff 4c 	st.w	r7[-180],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
8000666e:	ee fc ff 50 	ld.w	r12,r7[-176]
80006672:	ef 4c fe e4 	st.w	r7[-284],r12
80006676:	30 0a       	mov	r10,0
80006678:	ef 4a fe e0 	st.w	r7[-288],r10
8000667c:	ee f8 ff 4c 	ld.w	r8,r7[-180]
80006680:	ef 48 fe dc 	st.w	r7[-292],r8
80006684:	30 0c       	mov	r12,0
80006686:	ef 4c fe d8 	st.w	r7[-296],r12
8000668a:	ee f9 fe e0 	ld.w	r9,r7[-288]
8000668e:	ee fa fe dc 	ld.w	r10,r7[-292]
80006692:	b5 39       	mul	r9,r10
80006694:	ee f8 fe d8 	ld.w	r8,r7[-296]
80006698:	ee fc fe e4 	ld.w	r12,r7[-284]
8000669c:	b9 38       	mul	r8,r12
8000669e:	10 09       	add	r9,r8
800066a0:	ee f8 fe e4 	ld.w	r8,r7[-284]
800066a4:	ee fc fe dc 	ld.w	r12,r7[-292]
800066a8:	f0 0c 06 4a 	mulu.d	r10,r8,r12
800066ac:	16 09       	add	r9,r11
800066ae:	12 9b       	mov	r11,r9
800066b0:	e0 68 03 e7 	mov	r8,999
800066b4:	30 09       	mov	r9,0
800066b6:	10 0a       	add	r10,r8
800066b8:	f6 09 00 4b 	adc	r11,r11,r9
800066bc:	e0 68 03 e8 	mov	r8,1000
800066c0:	30 09       	mov	r9,0
800066c2:	f0 1f 02 b0 	mcall	80007180 <main+0xcd4>
800066c6:	14 98       	mov	r8,r10
800066c8:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
800066ca:	ef 48 ff 58 	st.w	r7[-168],r8
800066ce:	ee c8 00 f8 	sub	r8,r7,248
800066d2:	ef 48 ff 54 	st.w	r7[-172],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800066d6:	e1 b8 00 42 	mfsr	r8,0x108
800066da:	10 99       	mov	r9,r8
800066dc:	ee f8 ff 54 	ld.w	r8,r7[-172]
800066e0:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800066e2:	ee f8 ff 54 	ld.w	r8,r7[-172]
800066e6:	70 09       	ld.w	r9,r8[0x0]
800066e8:	ee f8 ff 58 	ld.w	r8,r7[-168]
800066ec:	10 09       	add	r9,r8
800066ee:	ee f8 ff 54 	ld.w	r8,r7[-172]
800066f2:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
800066f4:	ee f9 ff 54 	ld.w	r9,r7[-172]
800066f8:	30 08       	mov	r8,0
800066fa:	f3 68 00 08 	st.b	r9[8],r8
800066fe:	ee c8 00 f8 	sub	r8,r7,248
80006702:	ef 48 ff 5c 	st.w	r7[-164],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80006706:	e1 b8 00 42 	mfsr	r8,0x108
8000670a:	ef 48 ff 60 	st.w	r7[-160],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
8000670e:	ee f8 ff 5c 	ld.w	r8,r7[-164]
80006712:	f1 39 00 08 	ld.ub	r9,r8[8]
80006716:	30 28       	mov	r8,2
80006718:	f0 09 18 00 	cp.b	r9,r8
8000671c:	c0 31       	brne	80006722 <main+0x276>
    return false;
8000671e:	30 08       	mov	r8,0
80006720:	c4 38       	rjmp	800067a6 <main+0x2fa>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
80006722:	ee f8 ff 5c 	ld.w	r8,r7[-164]
80006726:	f1 39 00 08 	ld.ub	r9,r8[8]
8000672a:	30 18       	mov	r8,1
8000672c:	f0 09 18 00 	cp.b	r9,r8
80006730:	c0 31       	brne	80006736 <main+0x28a>
    return true;
80006732:	30 18       	mov	r8,1
80006734:	c3 98       	rjmp	800067a6 <main+0x2fa>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80006736:	ee f8 ff 5c 	ld.w	r8,r7[-164]
8000673a:	70 09       	ld.w	r9,r8[0x0]
8000673c:	ee f8 ff 5c 	ld.w	r8,r7[-164]
80006740:	70 18       	ld.w	r8,r8[0x4]
80006742:	10 39       	cp.w	r9,r8
80006744:	e0 88 00 1a 	brls	80006778 <main+0x2cc>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80006748:	ee f8 ff 5c 	ld.w	r8,r7[-164]
8000674c:	70 09       	ld.w	r9,r8[0x0]
8000674e:	ee f8 ff 60 	ld.w	r8,r7[-160]
80006752:	12 38       	cp.w	r8,r9
80006754:	c1 02       	brcc	80006774 <main+0x2c8>
80006756:	ee f8 ff 5c 	ld.w	r8,r7[-164]
8000675a:	70 19       	ld.w	r9,r8[0x4]
8000675c:	ee f8 ff 60 	ld.w	r8,r7[-160]
80006760:	12 38       	cp.w	r8,r9
80006762:	e0 88 00 09 	brls	80006774 <main+0x2c8>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80006766:	ee f9 ff 5c 	ld.w	r9,r7[-164]
8000676a:	30 18       	mov	r8,1
8000676c:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80006770:	30 18       	mov	r8,1
80006772:	c1 a8       	rjmp	800067a6 <main+0x2fa>
    }
    return false;
80006774:	30 08       	mov	r8,0
80006776:	c1 88       	rjmp	800067a6 <main+0x2fa>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80006778:	ee f8 ff 5c 	ld.w	r8,r7[-164]
8000677c:	70 09       	ld.w	r9,r8[0x0]
8000677e:	ee f8 ff 60 	ld.w	r8,r7[-160]
80006782:	12 38       	cp.w	r8,r9
80006784:	c0 93       	brcs	80006796 <main+0x2ea>
80006786:	ee f8 ff 5c 	ld.w	r8,r7[-164]
8000678a:	70 19       	ld.w	r9,r8[0x4]
8000678c:	ee f8 ff 60 	ld.w	r8,r7[-160]
80006790:	12 38       	cp.w	r8,r9
80006792:	e0 88 00 09 	brls	800067a4 <main+0x2f8>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80006796:	ee f9 ff 5c 	ld.w	r9,r7[-164]
8000679a:	30 18       	mov	r8,1
8000679c:	f3 68 00 08 	st.b	r9[8],r8
      return true;
800067a0:	30 18       	mov	r8,1
800067a2:	c0 28       	rjmp	800067a6 <main+0x2fa>
    }
    return false;
800067a4:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
800067a6:	58 08       	cp.w	r8,0
800067a8:	ca b0       	breq	800066fe <main+0x252>
					cpu_delay_ms(500, 8000000);
					display_text(IDX_CLEANING);
800067aa:	30 2c       	mov	r12,2
800067ac:	f0 1f 02 5b 	mcall	80007118 <main+0xc6c>
800067b0:	e0 68 0b b8 	mov	r8,3000
800067b4:	ef 48 ff 68 	st.w	r7[-152],r8
800067b8:	e0 68 12 00 	mov	r8,4608
800067bc:	ea 18 00 7a 	orh	r8,0x7a
800067c0:	ef 48 ff 64 	st.w	r7[-156],r8
800067c4:	ee f8 ff 68 	ld.w	r8,r7[-152]
800067c8:	ef 48 ff 70 	st.w	r7[-144],r8
800067cc:	ee f8 ff 64 	ld.w	r8,r7[-156]
800067d0:	ef 48 ff 6c 	st.w	r7[-148],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
800067d4:	ee fa ff 70 	ld.w	r10,r7[-144]
800067d8:	ef 4a fe f4 	st.w	r7[-268],r10
800067dc:	30 08       	mov	r8,0
800067de:	ef 48 fe f0 	st.w	r7[-272],r8
800067e2:	ee fc ff 6c 	ld.w	r12,r7[-148]
800067e6:	ef 4c fe ec 	st.w	r7[-276],r12
800067ea:	30 0a       	mov	r10,0
800067ec:	ef 4a fe e8 	st.w	r7[-280],r10
800067f0:	ee f9 fe f0 	ld.w	r9,r7[-272]
800067f4:	ee f8 fe ec 	ld.w	r8,r7[-276]
800067f8:	b1 39       	mul	r9,r8
800067fa:	ee f8 fe e8 	ld.w	r8,r7[-280]
800067fe:	ee fc fe f4 	ld.w	r12,r7[-268]
80006802:	b9 38       	mul	r8,r12
80006804:	10 09       	add	r9,r8
80006806:	ee f8 fe f4 	ld.w	r8,r7[-268]
8000680a:	ee fc fe ec 	ld.w	r12,r7[-276]
8000680e:	f0 0c 06 4a 	mulu.d	r10,r8,r12
80006812:	16 09       	add	r9,r11
80006814:	12 9b       	mov	r11,r9
80006816:	e0 68 03 e7 	mov	r8,999
8000681a:	30 09       	mov	r9,0
8000681c:	10 0a       	add	r10,r8
8000681e:	f6 09 00 4b 	adc	r11,r11,r9
80006822:	e0 68 03 e8 	mov	r8,1000
80006826:	30 09       	mov	r9,0
80006828:	f0 1f 02 56 	mcall	80007180 <main+0xcd4>
8000682c:	14 98       	mov	r8,r10
8000682e:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
80006830:	ef 48 ff 78 	st.w	r7[-136],r8
80006834:	ee c8 00 ec 	sub	r8,r7,236
80006838:	ef 48 ff 74 	st.w	r7[-140],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000683c:	e1 b8 00 42 	mfsr	r8,0x108
80006840:	10 99       	mov	r9,r8
80006842:	ee f8 ff 74 	ld.w	r8,r7[-140]
80006846:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80006848:	ee f8 ff 74 	ld.w	r8,r7[-140]
8000684c:	70 09       	ld.w	r9,r8[0x0]
8000684e:	ee f8 ff 78 	ld.w	r8,r7[-136]
80006852:	10 09       	add	r9,r8
80006854:	ee f8 ff 74 	ld.w	r8,r7[-140]
80006858:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
8000685a:	ee f9 ff 74 	ld.w	r9,r7[-140]
8000685e:	30 08       	mov	r8,0
80006860:	f3 68 00 08 	st.b	r9[8],r8
80006864:	ee c8 00 ec 	sub	r8,r7,236
80006868:	ef 48 ff 7c 	st.w	r7[-132],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000686c:	e1 b8 00 42 	mfsr	r8,0x108
80006870:	ef 48 ff 80 	st.w	r7[-128],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
80006874:	ee f8 ff 7c 	ld.w	r8,r7[-132]
80006878:	f1 39 00 08 	ld.ub	r9,r8[8]
8000687c:	30 28       	mov	r8,2
8000687e:	f0 09 18 00 	cp.b	r9,r8
80006882:	c0 31       	brne	80006888 <main+0x3dc>
    return false;
80006884:	30 08       	mov	r8,0
80006886:	c4 38       	rjmp	8000690c <main+0x460>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
80006888:	ee f8 ff 7c 	ld.w	r8,r7[-132]
8000688c:	f1 39 00 08 	ld.ub	r9,r8[8]
80006890:	30 18       	mov	r8,1
80006892:	f0 09 18 00 	cp.b	r9,r8
80006896:	c0 31       	brne	8000689c <main+0x3f0>
    return true;
80006898:	30 18       	mov	r8,1
8000689a:	c3 98       	rjmp	8000690c <main+0x460>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000689c:	ee f8 ff 7c 	ld.w	r8,r7[-132]
800068a0:	70 09       	ld.w	r9,r8[0x0]
800068a2:	ee f8 ff 7c 	ld.w	r8,r7[-132]
800068a6:	70 18       	ld.w	r8,r8[0x4]
800068a8:	10 39       	cp.w	r9,r8
800068aa:	e0 88 00 1a 	brls	800068de <main+0x432>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800068ae:	ee f8 ff 7c 	ld.w	r8,r7[-132]
800068b2:	70 09       	ld.w	r9,r8[0x0]
800068b4:	ee f8 ff 80 	ld.w	r8,r7[-128]
800068b8:	12 38       	cp.w	r8,r9
800068ba:	c1 02       	brcc	800068da <main+0x42e>
800068bc:	ee f8 ff 7c 	ld.w	r8,r7[-132]
800068c0:	70 19       	ld.w	r9,r8[0x4]
800068c2:	ee f8 ff 80 	ld.w	r8,r7[-128]
800068c6:	12 38       	cp.w	r8,r9
800068c8:	e0 88 00 09 	brls	800068da <main+0x42e>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
800068cc:	ee f9 ff 7c 	ld.w	r9,r7[-132]
800068d0:	30 18       	mov	r8,1
800068d2:	f3 68 00 08 	st.b	r9[8],r8
      return true;
800068d6:	30 18       	mov	r8,1
800068d8:	c1 a8       	rjmp	8000690c <main+0x460>
    }
    return false;
800068da:	30 08       	mov	r8,0
800068dc:	c1 88       	rjmp	8000690c <main+0x460>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800068de:	ee f8 ff 7c 	ld.w	r8,r7[-132]
800068e2:	70 09       	ld.w	r9,r8[0x0]
800068e4:	ee f8 ff 80 	ld.w	r8,r7[-128]
800068e8:	12 38       	cp.w	r8,r9
800068ea:	c0 93       	brcs	800068fc <main+0x450>
800068ec:	ee f8 ff 7c 	ld.w	r8,r7[-132]
800068f0:	70 19       	ld.w	r9,r8[0x4]
800068f2:	ee f8 ff 80 	ld.w	r8,r7[-128]
800068f6:	12 38       	cp.w	r8,r9
800068f8:	e0 88 00 09 	brls	8000690a <main+0x45e>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
800068fc:	ee f9 ff 7c 	ld.w	r9,r7[-132]
80006900:	30 18       	mov	r8,1
80006902:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80006906:	30 18       	mov	r8,1
80006908:	c0 28       	rjmp	8000690c <main+0x460>
    }
    return false;
8000690a:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
8000690c:	58 08       	cp.w	r8,0
8000690e:	ca b0       	breq	80006864 <main+0x3b8>
					sealShieldState = STATE_START_CLEAN;
					print_ssdbg("Either no devices or shelves are past lifetime, charging devices\r\n");
//					display_text(IDX_CLEAR);
					display_text(IDX_READY);
				}
				break;
80006910:	e0 8f 02 b2 	bral	80006e74 <main+0x9c8>
					cpu_delay_ms(500, 8000000);
					display_text(IDX_CLEANING);
					cpu_delay_ms(3000, 8000000); //give display time to update, scroll all the way across
				}
				else {
					sealShieldState = STATE_START_CLEAN;
80006914:	fe f9 08 1c 	ld.w	r9,pc[2076]
80006918:	30 78       	mov	r8,7
8000691a:	b2 88       	st.b	r9[0x0],r8
					print_ssdbg("Either no devices or shelves are past lifetime, charging devices\r\n");
8000691c:	fe fc 08 68 	ld.w	r12,pc[2152]
80006920:	f0 1f 01 fd 	mcall	80007114 <main+0xc68>
//					display_text(IDX_CLEAR);
					display_text(IDX_READY);
80006924:	30 0c       	mov	r12,0
80006926:	f0 1f 01 fd 	mcall	80007118 <main+0xc6c>
				}
				break;
8000692a:	e0 8f 02 a5 	bral	80006e74 <main+0x9c8>
				
			case STATE_START_SANITIZE:
				sanitizeIdx = 0xFF; //this means not assigned yet
8000692e:	fe f9 08 5a 	ld.w	r9,pc[2138]
80006932:	3f f8       	mov	r8,-1
80006934:	b2 88       	st.b	r9[0x0],r8
				for (int i = 0; i<NUM_SHELVES; i++) {
80006936:	30 08       	mov	r8,0
80006938:	ef 48 ff 38 	st.w	r7[-200],r8
8000693c:	c3 78       	rjmp	800069aa <main+0x4fe>
					if (shelfActive[i] == SHELF_ACTIVE) {
8000693e:	ee f9 ff 38 	ld.w	r9,r7[-200]
80006942:	fe f8 08 4a 	ld.w	r8,pc[2122]
80006946:	f0 09 07 08 	ld.ub	r8,r8[r9]
8000694a:	58 08       	cp.w	r8,0
8000694c:	c2 31       	brne	80006992 <main+0x4e6>
						shelfTimerInitSeconds[i] = calc_sanitize_time(i);
8000694e:	ee f6 ff 38 	ld.w	r6,r7[-200]
80006952:	ee f8 ff 38 	ld.w	r8,r7[-200]
80006956:	5c 58       	castu.b	r8
80006958:	10 9c       	mov	r12,r8
8000695a:	f0 1f 02 0e 	mcall	80007190 <main+0xce4>
8000695e:	18 99       	mov	r9,r12
80006960:	fe f8 08 34 	ld.w	r8,pc[2100]
80006964:	f0 06 09 29 	st.w	r8[r6<<0x2],r9
						
						led_shelf(i, LED_ON); //12apr15 turning the shelves on and leaving them on for the show. Use the timers I set up to cycle through the display text.
80006968:	ee f8 ff 38 	ld.w	r8,r7[-200]
8000696c:	5c 58       	castu.b	r8
8000696e:	30 1b       	mov	r11,1
80006970:	10 9c       	mov	r12,r8
80006972:	f0 1f 02 0a 	mcall	80007198 <main+0xcec>
						
						if (sanitizeIdx == 0xFF)
80006976:	fe f8 08 12 	ld.w	r8,pc[2066]
8000697a:	11 89       	ld.ub	r9,r8[0x0]
8000697c:	3f f8       	mov	r8,-1
8000697e:	f0 09 18 00 	cp.b	r9,r8
80006982:	c0 f1       	brne	800069a0 <main+0x4f4>
						{
							sanitizeIdx = i; //set this to the first active shelf
80006984:	ee f8 ff 38 	ld.w	r8,r7[-200]
80006988:	5c 58       	castu.b	r8
8000698a:	fe f9 07 fe 	ld.w	r9,pc[2046]
8000698e:	b2 88       	st.b	r9[0x0],r8
80006990:	c0 88       	rjmp	800069a0 <main+0x4f4>
						}
					}
					else {
						shelfTimerInitSeconds[i] = 0; //Don't run this shelf
80006992:	ee fa ff 38 	ld.w	r10,r7[-200]
80006996:	fe f9 07 fe 	ld.w	r9,pc[2046]
8000699a:	30 08       	mov	r8,0
8000699c:	f2 0a 09 28 	st.w	r9[r10<<0x2],r8
				}
				break;
				
			case STATE_START_SANITIZE:
				sanitizeIdx = 0xFF; //this means not assigned yet
				for (int i = 0; i<NUM_SHELVES; i++) {
800069a0:	ee f8 ff 38 	ld.w	r8,r7[-200]
800069a4:	2f f8       	sub	r8,-1
800069a6:	ef 48 ff 38 	st.w	r7[-200],r8
800069aa:	ee f8 ff 38 	ld.w	r8,r7[-200]
800069ae:	58 38       	cp.w	r8,3
800069b0:	fe 9a ff c7 	brle	8000693e <main+0x492>
					else {
						shelfTimerInitSeconds[i] = 0; //Don't run this shelf
					}
				}
				
				sealShieldState = STATE_SANITIZE_1;
800069b4:	fe f9 07 7c 	ld.w	r9,pc[1916]
800069b8:	30 58       	mov	r8,5
800069ba:	b2 88       	st.b	r9[0x0],r8
				break;
800069bc:	e0 8f 02 5c 	bral	80006e74 <main+0x9c8>
			case STATE_SANITIZE_1:
/*
 * Code specifically for the show, just turn on one shelf at a time, we need work on the power supply to get it up to full power (1A)
 */

				display_text(IDX_CLEAR);
800069c0:	30 9c       	mov	r12,9
800069c2:	f0 1f 01 d6 	mcall	80007118 <main+0xc6c>
800069c6:	e0 68 01 f4 	mov	r8,500
800069ca:	ef 48 ff 88 	st.w	r7[-120],r8
800069ce:	e0 68 12 00 	mov	r8,4608
800069d2:	ea 18 00 7a 	orh	r8,0x7a
800069d6:	ef 48 ff 84 	st.w	r7[-124],r8
800069da:	ee f8 ff 88 	ld.w	r8,r7[-120]
800069de:	ef 48 ff 90 	st.w	r7[-112],r8
800069e2:	ee f8 ff 84 	ld.w	r8,r7[-124]
800069e6:	ef 48 ff 8c 	st.w	r7[-116],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
800069ea:	ee fa ff 90 	ld.w	r10,r7[-112]
800069ee:	ef 4a ff 04 	st.w	r7[-252],r10
800069f2:	30 08       	mov	r8,0
800069f4:	ef 48 ff 00 	st.w	r7[-256],r8
800069f8:	ee fc ff 8c 	ld.w	r12,r7[-116]
800069fc:	ef 4c fe fc 	st.w	r7[-260],r12
80006a00:	30 0a       	mov	r10,0
80006a02:	ef 4a fe f8 	st.w	r7[-264],r10
80006a06:	ee f9 ff 00 	ld.w	r9,r7[-256]
80006a0a:	ee f8 fe fc 	ld.w	r8,r7[-260]
80006a0e:	b1 39       	mul	r9,r8
80006a10:	ee f8 fe f8 	ld.w	r8,r7[-264]
80006a14:	ee fc ff 04 	ld.w	r12,r7[-252]
80006a18:	b9 38       	mul	r8,r12
80006a1a:	10 09       	add	r9,r8
80006a1c:	ee f8 ff 04 	ld.w	r8,r7[-252]
80006a20:	ee fc fe fc 	ld.w	r12,r7[-260]
80006a24:	f0 0c 06 4a 	mulu.d	r10,r8,r12
80006a28:	16 09       	add	r9,r11
80006a2a:	12 9b       	mov	r11,r9
80006a2c:	e0 68 03 e7 	mov	r8,999
80006a30:	30 09       	mov	r9,0
80006a32:	10 0a       	add	r10,r8
80006a34:	f6 09 00 4b 	adc	r11,r11,r9
80006a38:	e0 68 03 e8 	mov	r8,1000
80006a3c:	30 09       	mov	r9,0
80006a3e:	f0 1f 01 d1 	mcall	80007180 <main+0xcd4>
80006a42:	14 98       	mov	r8,r10
80006a44:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
80006a46:	ef 48 ff 98 	st.w	r7[-104],r8
80006a4a:	ee c8 00 e0 	sub	r8,r7,224
80006a4e:	ef 48 ff 94 	st.w	r7[-108],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80006a52:	e1 b8 00 42 	mfsr	r8,0x108
80006a56:	10 99       	mov	r9,r8
80006a58:	ee f8 ff 94 	ld.w	r8,r7[-108]
80006a5c:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80006a5e:	ee f8 ff 94 	ld.w	r8,r7[-108]
80006a62:	70 09       	ld.w	r9,r8[0x0]
80006a64:	ee f8 ff 98 	ld.w	r8,r7[-104]
80006a68:	10 09       	add	r9,r8
80006a6a:	ee f8 ff 94 	ld.w	r8,r7[-108]
80006a6e:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
80006a70:	ee f9 ff 94 	ld.w	r9,r7[-108]
80006a74:	30 08       	mov	r8,0
80006a76:	f3 68 00 08 	st.b	r9[8],r8
80006a7a:	ee c8 00 e0 	sub	r8,r7,224
80006a7e:	ef 48 ff 9c 	st.w	r7[-100],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80006a82:	e1 b8 00 42 	mfsr	r8,0x108
80006a86:	ef 48 ff a0 	st.w	r7[-96],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
80006a8a:	ee f8 ff 9c 	ld.w	r8,r7[-100]
80006a8e:	f1 39 00 08 	ld.ub	r9,r8[8]
80006a92:	30 28       	mov	r8,2
80006a94:	f0 09 18 00 	cp.b	r9,r8
80006a98:	c0 31       	brne	80006a9e <main+0x5f2>
    return false;
80006a9a:	30 08       	mov	r8,0
80006a9c:	c4 38       	rjmp	80006b22 <main+0x676>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
80006a9e:	ee f8 ff 9c 	ld.w	r8,r7[-100]
80006aa2:	f1 39 00 08 	ld.ub	r9,r8[8]
80006aa6:	30 18       	mov	r8,1
80006aa8:	f0 09 18 00 	cp.b	r9,r8
80006aac:	c0 31       	brne	80006ab2 <main+0x606>
    return true;
80006aae:	30 18       	mov	r8,1
80006ab0:	c3 98       	rjmp	80006b22 <main+0x676>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80006ab2:	ee f8 ff 9c 	ld.w	r8,r7[-100]
80006ab6:	70 09       	ld.w	r9,r8[0x0]
80006ab8:	ee f8 ff 9c 	ld.w	r8,r7[-100]
80006abc:	70 18       	ld.w	r8,r8[0x4]
80006abe:	10 39       	cp.w	r9,r8
80006ac0:	e0 88 00 1a 	brls	80006af4 <main+0x648>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80006ac4:	ee f8 ff 9c 	ld.w	r8,r7[-100]
80006ac8:	70 09       	ld.w	r9,r8[0x0]
80006aca:	ee f8 ff a0 	ld.w	r8,r7[-96]
80006ace:	12 38       	cp.w	r8,r9
80006ad0:	c1 02       	brcc	80006af0 <main+0x644>
80006ad2:	ee f8 ff 9c 	ld.w	r8,r7[-100]
80006ad6:	70 19       	ld.w	r9,r8[0x4]
80006ad8:	ee f8 ff a0 	ld.w	r8,r7[-96]
80006adc:	12 38       	cp.w	r8,r9
80006ade:	e0 88 00 09 	brls	80006af0 <main+0x644>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80006ae2:	ee f9 ff 9c 	ld.w	r9,r7[-100]
80006ae6:	30 18       	mov	r8,1
80006ae8:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80006aec:	30 18       	mov	r8,1
80006aee:	c1 a8       	rjmp	80006b22 <main+0x676>
    }
    return false;
80006af0:	30 08       	mov	r8,0
80006af2:	c1 88       	rjmp	80006b22 <main+0x676>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80006af4:	ee f8 ff 9c 	ld.w	r8,r7[-100]
80006af8:	70 09       	ld.w	r9,r8[0x0]
80006afa:	ee f8 ff a0 	ld.w	r8,r7[-96]
80006afe:	12 38       	cp.w	r8,r9
80006b00:	c0 93       	brcs	80006b12 <main+0x666>
80006b02:	ee f8 ff 9c 	ld.w	r8,r7[-100]
80006b06:	70 19       	ld.w	r9,r8[0x4]
80006b08:	ee f8 ff a0 	ld.w	r8,r7[-96]
80006b0c:	12 38       	cp.w	r8,r9
80006b0e:	e0 88 00 09 	brls	80006b20 <main+0x674>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80006b12:	ee f9 ff 9c 	ld.w	r9,r7[-100]
80006b16:	30 18       	mov	r8,1
80006b18:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80006b1c:	30 18       	mov	r8,1
80006b1e:	c0 28       	rjmp	80006b22 <main+0x676>
    }
    return false;
80006b20:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
80006b22:	58 08       	cp.w	r8,0
80006b24:	ca b0       	breq	80006a7a <main+0x5ce>
				cpu_delay_ms(500, 8000000); //half second
				
				if (shelfTimerInitSeconds[sanitizeIdx] != 0)
80006b26:	fe f8 06 62 	ld.w	r8,pc[1634]
80006b2a:	11 88       	ld.ub	r8,r8[0x0]
80006b2c:	10 99       	mov	r9,r8
80006b2e:	fe f8 06 66 	ld.w	r8,pc[1638]
80006b32:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80006b36:	58 08       	cp.w	r8,0
80006b38:	c4 d0       	breq	80006bd2 <main+0x726>
				{
					cpu_set_timeout(shelfTimerInitSeconds[sanitizeIdx], shelfTimerPtr[sanitizeIdx]); //cpu cycle counts and the pointer to the timer variable for this particular shelf
80006b3a:	fe f8 06 4e 	ld.w	r8,pc[1614]
80006b3e:	11 88       	ld.ub	r8,r8[0x0]
80006b40:	10 99       	mov	r9,r8
80006b42:	fe f8 05 f2 	ld.w	r8,pc[1522]
80006b46:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
80006b4a:	fe f8 06 3e 	ld.w	r8,pc[1598]
80006b4e:	11 88       	ld.ub	r8,r8[0x0]
80006b50:	10 99       	mov	r9,r8
80006b52:	fe f8 06 42 	ld.w	r8,pc[1602]
80006b56:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80006b5a:	ef 48 ff a8 	st.w	r7[-88],r8
80006b5e:	ef 4a ff a4 	st.w	r7[-92],r10
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80006b62:	e1 b8 00 42 	mfsr	r8,0x108
80006b66:	10 99       	mov	r9,r8
80006b68:	ee f8 ff a4 	ld.w	r8,r7[-92]
80006b6c:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80006b6e:	ee f8 ff a4 	ld.w	r8,r7[-92]
80006b72:	70 09       	ld.w	r9,r8[0x0]
80006b74:	ee f8 ff a8 	ld.w	r8,r7[-88]
80006b78:	10 09       	add	r9,r8
80006b7a:	ee f8 ff a4 	ld.w	r8,r7[-92]
80006b7e:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
80006b80:	ee f9 ff a4 	ld.w	r9,r7[-92]
80006b84:	30 08       	mov	r8,0
80006b86:	f3 68 00 08 	st.b	r9[8],r8
					switch (sanitizeIdx)
80006b8a:	fe f8 05 fe 	ld.w	r8,pc[1534]
80006b8e:	11 88       	ld.ub	r8,r8[0x0]
80006b90:	58 18       	cp.w	r8,1
80006b92:	c0 f0       	breq	80006bb0 <main+0x704>
80006b94:	e0 89 00 05 	brgt	80006b9e <main+0x6f2>
80006b98:	58 08       	cp.w	r8,0
80006b9a:	c0 70       	breq	80006ba8 <main+0x6fc>
80006b9c:	c1 58       	rjmp	80006bc6 <main+0x71a>
80006b9e:	58 28       	cp.w	r8,2
80006ba0:	c0 c0       	breq	80006bb8 <main+0x70c>
80006ba2:	58 38       	cp.w	r8,3
80006ba4:	c0 e0       	breq	80006bc0 <main+0x714>
80006ba6:	c1 08       	rjmp	80006bc6 <main+0x71a>
					{
						case 0:
							//								display_text(IDX_CLEAR);
							display_text(IDX_SHELF1);
80006ba8:	30 5c       	mov	r12,5
80006baa:	f0 1f 01 5c 	mcall	80007118 <main+0xc6c>
							break;
80006bae:	c0 c8       	rjmp	80006bc6 <main+0x71a>
						case 1:
							//								display_text(IDX_CLEAR);
							display_text(IDX_SHELF2);
80006bb0:	30 6c       	mov	r12,6
80006bb2:	f0 1f 01 5a 	mcall	80007118 <main+0xc6c>
							break;
80006bb6:	c0 88       	rjmp	80006bc6 <main+0x71a>
						case 2:
							//								display_text(IDX_CLEAR);
							display_text(IDX_SHELF3);
80006bb8:	30 7c       	mov	r12,7
80006bba:	f0 1f 01 58 	mcall	80007118 <main+0xc6c>
							break;
80006bbe:	c0 48       	rjmp	80006bc6 <main+0x71a>
						case 3:
							//								display_text(IDX_CLEAR);
							display_text(IDX_SHELF4);
80006bc0:	30 8c       	mov	r12,8
80006bc2:	f0 1f 01 56 	mcall	80007118 <main+0xc6c>
					}

//12apr15 shelf st					led_shelf(sanitizeIdx, LED_ON);	//NOTE we need to be careful here, we need to be able to shut off the shelf LEDs the *instant* the door latch opens, this is important for safety
					//this means we need as little logic between turning the shelf on and turning it off so we can react as quickly as possible to the door latch
										
					sealShieldState = STATE_SANITIZE_2;
80006bc6:	fe f9 05 6a 	ld.w	r9,pc[1386]
80006bca:	30 68       	mov	r8,6
80006bcc:	b2 88       	st.b	r9[0x0],r8
//					display_text(IDX_CLEAR);
					display_text(IDX_CLEAN);

				}
#endif				
				break;
80006bce:	e0 8f 01 53 	bral	80006e74 <main+0x9c8>
					sealShieldState = STATE_SANITIZE_2;
				}
				else
				{
					//Nothing on that shelf, go to the next shelf
					if (++sanitizeIdx >= NUM_SHELVES)
80006bd2:	fe f8 05 b6 	ld.w	r8,pc[1462]
80006bd6:	11 88       	ld.ub	r8,r8[0x0]
80006bd8:	2f f8       	sub	r8,-1
80006bda:	5c 58       	castu.b	r8
80006bdc:	fe f9 05 ac 	ld.w	r9,pc[1452]
80006be0:	b2 88       	st.b	r9[0x0],r8
80006be2:	fe f8 05 a6 	ld.w	r8,pc[1446]
80006be6:	11 89       	ld.ub	r9,r8[0x0]
80006be8:	30 38       	mov	r8,3
80006bea:	f0 09 18 00 	cp.b	r9,r8
80006bee:	e0 88 01 3e 	brls	80006e6a <main+0x9be>
					{
						sanitizeIdx = 0; //12apr15 wrap around
80006bf2:	fe f9 05 96 	ld.w	r9,pc[1430]
80006bf6:	30 08       	mov	r8,0
80006bf8:	b2 88       	st.b	r9[0x0],r8
//					display_text(IDX_CLEAR);
					display_text(IDX_CLEAN);

				}
#endif				
				break;
80006bfa:	c3 d9       	rjmp	80006e74 <main+0x9c8>
				
			case STATE_SANITIZE_2:
				if (cpu_is_timeout(shelfTimerPtr[sanitizeIdx])) {
80006bfc:	fe f8 05 8c 	ld.w	r8,pc[1420]
80006c00:	11 88       	ld.ub	r8,r8[0x0]
80006c02:	10 99       	mov	r9,r8
80006c04:	fe f8 05 30 	ld.w	r8,pc[1328]
80006c08:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80006c0c:	ef 48 ff ac 	st.w	r7[-84],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80006c10:	e1 b8 00 42 	mfsr	r8,0x108
80006c14:	ef 48 ff b0 	st.w	r7[-80],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
80006c18:	ee f8 ff ac 	ld.w	r8,r7[-84]
80006c1c:	f1 39 00 08 	ld.ub	r9,r8[8]
80006c20:	30 28       	mov	r8,2
80006c22:	f0 09 18 00 	cp.b	r9,r8
80006c26:	c0 31       	brne	80006c2c <main+0x780>
    return false;
80006c28:	30 08       	mov	r8,0
80006c2a:	c4 38       	rjmp	80006cb0 <main+0x804>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
80006c2c:	ee f8 ff ac 	ld.w	r8,r7[-84]
80006c30:	f1 39 00 08 	ld.ub	r9,r8[8]
80006c34:	30 18       	mov	r8,1
80006c36:	f0 09 18 00 	cp.b	r9,r8
80006c3a:	c0 31       	brne	80006c40 <main+0x794>
    return true;
80006c3c:	30 18       	mov	r8,1
80006c3e:	c3 98       	rjmp	80006cb0 <main+0x804>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80006c40:	ee f8 ff ac 	ld.w	r8,r7[-84]
80006c44:	70 09       	ld.w	r9,r8[0x0]
80006c46:	ee f8 ff ac 	ld.w	r8,r7[-84]
80006c4a:	70 18       	ld.w	r8,r8[0x4]
80006c4c:	10 39       	cp.w	r9,r8
80006c4e:	e0 88 00 1a 	brls	80006c82 <main+0x7d6>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80006c52:	ee f8 ff ac 	ld.w	r8,r7[-84]
80006c56:	70 09       	ld.w	r9,r8[0x0]
80006c58:	ee f8 ff b0 	ld.w	r8,r7[-80]
80006c5c:	12 38       	cp.w	r8,r9
80006c5e:	c1 02       	brcc	80006c7e <main+0x7d2>
80006c60:	ee f8 ff ac 	ld.w	r8,r7[-84]
80006c64:	70 19       	ld.w	r9,r8[0x4]
80006c66:	ee f8 ff b0 	ld.w	r8,r7[-80]
80006c6a:	12 38       	cp.w	r8,r9
80006c6c:	e0 88 00 09 	brls	80006c7e <main+0x7d2>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80006c70:	ee f9 ff ac 	ld.w	r9,r7[-84]
80006c74:	30 18       	mov	r8,1
80006c76:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80006c7a:	30 18       	mov	r8,1
80006c7c:	c1 a8       	rjmp	80006cb0 <main+0x804>
    }
    return false;
80006c7e:	30 08       	mov	r8,0
80006c80:	c1 88       	rjmp	80006cb0 <main+0x804>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80006c82:	ee f8 ff ac 	ld.w	r8,r7[-84]
80006c86:	70 09       	ld.w	r9,r8[0x0]
80006c88:	ee f8 ff b0 	ld.w	r8,r7[-80]
80006c8c:	12 38       	cp.w	r8,r9
80006c8e:	c0 93       	brcs	80006ca0 <main+0x7f4>
80006c90:	ee f8 ff ac 	ld.w	r8,r7[-84]
80006c94:	70 19       	ld.w	r9,r8[0x4]
80006c96:	ee f8 ff b0 	ld.w	r8,r7[-80]
80006c9a:	12 38       	cp.w	r8,r9
80006c9c:	e0 88 00 09 	brls	80006cae <main+0x802>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80006ca0:	ee f9 ff ac 	ld.w	r9,r7[-84]
80006ca4:	30 18       	mov	r8,1
80006ca6:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80006caa:	30 18       	mov	r8,1
80006cac:	c0 28       	rjmp	80006cb0 <main+0x804>
    }
    return false;
80006cae:	30 08       	mov	r8,0
80006cb0:	58 08       	cp.w	r8,0
80006cb2:	e0 80 00 de 	breq	80006e6e <main+0x9c2>
//12apr15 leave shelves on indefinitely for the show					led_shelf(sanitizeIdx, LED_OFF);
					cpu_stop_timeout(shelfTimerPtr[sanitizeIdx]);
80006cb6:	fe f8 04 d2 	ld.w	r8,pc[1234]
80006cba:	11 88       	ld.ub	r8,r8[0x0]
80006cbc:	10 99       	mov	r9,r8
80006cbe:	fe f8 04 76 	ld.w	r8,pc[1142]
80006cc2:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80006cc6:	ef 48 ff b4 	st.w	r7[-76],r8
 *
 * \param  cpu_time:   (input) internal information used by the timer API.
 */
__always_inline static void cpu_stop_timeout(t_cpu_time *cpu_time)
{
  cpu_time->timer_state = CPU_TIMER_STATE_STOPPED;
80006cca:	ee f9 ff b4 	ld.w	r9,r7[-76]
80006cce:	30 28       	mov	r8,2
80006cd0:	f3 68 00 08 	st.b	r9[8],r8
					print_ssdbg("Shelf clean\r\n");
80006cd4:	fe fc 04 c8 	ld.w	r12,pc[1224]
80006cd8:	f0 1f 01 0f 	mcall	80007114 <main+0xc68>

					//All done, go to the next shelf
					if (++sanitizeIdx >= NUM_SHELVES)
80006cdc:	fe f8 04 ac 	ld.w	r8,pc[1196]
80006ce0:	11 88       	ld.ub	r8,r8[0x0]
80006ce2:	2f f8       	sub	r8,-1
80006ce4:	5c 58       	castu.b	r8
80006ce6:	fe f9 04 a2 	ld.w	r9,pc[1186]
80006cea:	b2 88       	st.b	r9[0x0],r8
80006cec:	fe f8 04 9c 	ld.w	r8,pc[1180]
80006cf0:	11 89       	ld.ub	r9,r8[0x0]
80006cf2:	30 38       	mov	r8,3
80006cf4:	f0 09 18 00 	cp.b	r9,r8
80006cf8:	e0 88 00 0b 	brls	80006d0e <main+0x862>
					{
						sanitizeIdx = 0;
80006cfc:	fe f9 04 8c 	ld.w	r9,pc[1164]
80006d00:	30 08       	mov	r8,0
80006d02:	b2 88       	st.b	r9[0x0],r8
						sealShieldState = STATE_SANITIZE_1; //that was the last shelf, get out of sanitizing
80006d04:	fe f9 04 2c 	ld.w	r9,pc[1068]
80006d08:	30 58       	mov	r8,5
80006d0a:	b2 88       	st.b	r9[0x0],r8
					else
					{
						sealShieldState = STATE_SANITIZE_1; //more shelves to clean possibly
					}
				}
				break;
80006d0c:	cb 48       	rjmp	80006e74 <main+0x9c8>
						sanitizeIdx = 0;
						sealShieldState = STATE_SANITIZE_1; //that was the last shelf, get out of sanitizing
					}
					else
					{
						sealShieldState = STATE_SANITIZE_1; //more shelves to clean possibly
80006d0e:	fe f9 04 22 	ld.w	r9,pc[1058]
80006d12:	30 58       	mov	r8,5
80006d14:	b2 88       	st.b	r9[0x0],r8
					}
				}
				break;
80006d16:	ca f8       	rjmp	80006e74 <main+0x9c8>
				
			case STATE_START_CLEAN:
				display_text(IDX_CLEAN);
80006d18:	30 1c       	mov	r12,1
80006d1a:	f0 1f 01 00 	mcall	80007118 <main+0xc6c>
				sealShieldState = STATE_CLEAN;
80006d1e:	fe f9 04 12 	ld.w	r9,pc[1042]
80006d22:	30 88       	mov	r8,8
80006d24:	b2 88       	st.b	r9[0x0],r8
80006d26:	e0 68 7e 00 	mov	r8,32256
80006d2a:	ea 18 03 56 	orh	r8,0x356
80006d2e:	ef 48 ff bc 	st.w	r7[-68],r8
80006d32:	fe f8 04 6e 	ld.w	r8,pc[1134]
80006d36:	ef 48 ff b8 	st.w	r7[-72],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80006d3a:	e1 b8 00 42 	mfsr	r8,0x108
80006d3e:	10 99       	mov	r9,r8
80006d40:	ee f8 ff b8 	ld.w	r8,r7[-72]
80006d44:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80006d46:	ee f8 ff b8 	ld.w	r8,r7[-72]
80006d4a:	70 09       	ld.w	r9,r8[0x0]
80006d4c:	ee f8 ff bc 	ld.w	r8,r7[-68]
80006d50:	10 09       	add	r9,r8
80006d52:	ee f8 ff b8 	ld.w	r8,r7[-72]
80006d56:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
80006d58:	ee f9 ff b8 	ld.w	r9,r7[-72]
80006d5c:	30 08       	mov	r8,0
80006d5e:	f3 68 00 08 	st.b	r9[8],r8
				cpu_set_timeout((7*SS_ONE_SECOND), &timerClean); //Fixed for now just to make the display look good, show the string and let it wrap once TODO: make this what it needs to be
				break;	
80006d62:	c8 98       	rjmp	80006e74 <main+0x9c8>
80006d64:	fe f8 04 3c 	ld.w	r8,pc[1084]
80006d68:	ef 48 ff c0 	st.w	r7[-64],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80006d6c:	e1 b8 00 42 	mfsr	r8,0x108
80006d70:	ef 48 ff c4 	st.w	r7[-60],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
80006d74:	ee f8 ff c0 	ld.w	r8,r7[-64]
80006d78:	f1 39 00 08 	ld.ub	r9,r8[8]
80006d7c:	30 28       	mov	r8,2
80006d7e:	f0 09 18 00 	cp.b	r9,r8
80006d82:	c0 31       	brne	80006d88 <main+0x8dc>
    return false;
80006d84:	30 08       	mov	r8,0
80006d86:	c4 38       	rjmp	80006e0c <main+0x960>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
80006d88:	ee f8 ff c0 	ld.w	r8,r7[-64]
80006d8c:	f1 39 00 08 	ld.ub	r9,r8[8]
80006d90:	30 18       	mov	r8,1
80006d92:	f0 09 18 00 	cp.b	r9,r8
80006d96:	c0 31       	brne	80006d9c <main+0x8f0>
    return true;
80006d98:	30 18       	mov	r8,1
80006d9a:	c3 98       	rjmp	80006e0c <main+0x960>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80006d9c:	ee f8 ff c0 	ld.w	r8,r7[-64]
80006da0:	70 09       	ld.w	r9,r8[0x0]
80006da2:	ee f8 ff c0 	ld.w	r8,r7[-64]
80006da6:	70 18       	ld.w	r8,r8[0x4]
80006da8:	10 39       	cp.w	r9,r8
80006daa:	e0 88 00 1a 	brls	80006dde <main+0x932>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80006dae:	ee f8 ff c0 	ld.w	r8,r7[-64]
80006db2:	70 09       	ld.w	r9,r8[0x0]
80006db4:	ee f8 ff c4 	ld.w	r8,r7[-60]
80006db8:	12 38       	cp.w	r8,r9
80006dba:	c1 02       	brcc	80006dda <main+0x92e>
80006dbc:	ee f8 ff c0 	ld.w	r8,r7[-64]
80006dc0:	70 19       	ld.w	r9,r8[0x4]
80006dc2:	ee f8 ff c4 	ld.w	r8,r7[-60]
80006dc6:	12 38       	cp.w	r8,r9
80006dc8:	e0 88 00 09 	brls	80006dda <main+0x92e>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80006dcc:	ee f9 ff c0 	ld.w	r9,r7[-64]
80006dd0:	30 18       	mov	r8,1
80006dd2:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80006dd6:	30 18       	mov	r8,1
80006dd8:	c1 a8       	rjmp	80006e0c <main+0x960>
    }
    return false;
80006dda:	30 08       	mov	r8,0
80006ddc:	c1 88       	rjmp	80006e0c <main+0x960>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80006dde:	ee f8 ff c0 	ld.w	r8,r7[-64]
80006de2:	70 09       	ld.w	r9,r8[0x0]
80006de4:	ee f8 ff c4 	ld.w	r8,r7[-60]
80006de8:	12 38       	cp.w	r8,r9
80006dea:	c0 93       	brcs	80006dfc <main+0x950>
80006dec:	ee f8 ff c0 	ld.w	r8,r7[-64]
80006df0:	70 19       	ld.w	r9,r8[0x4]
80006df2:	ee f8 ff c4 	ld.w	r8,r7[-60]
80006df6:	12 38       	cp.w	r8,r9
80006df8:	e0 88 00 09 	brls	80006e0a <main+0x95e>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80006dfc:	ee f9 ff c0 	ld.w	r9,r7[-64]
80006e00:	30 18       	mov	r8,1
80006e02:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80006e06:	30 18       	mov	r8,1
80006e08:	c0 28       	rjmp	80006e0c <main+0x960>
    }
    return false;
80006e0a:	30 08       	mov	r8,0
				
			case STATE_CLEAN:
				if (cpu_is_timeout(&timerClean)) {
80006e0c:	58 08       	cp.w	r8,0
80006e0e:	c3 20       	breq	80006e72 <main+0x9c6>
80006e10:	fe f8 03 90 	ld.w	r8,pc[912]
80006e14:	ef 48 ff c8 	st.w	r7[-56],r8
 *
 * \param  cpu_time:   (input) internal information used by the timer API.
 */
__always_inline static void cpu_stop_timeout(t_cpu_time *cpu_time)
{
  cpu_time->timer_state = CPU_TIMER_STATE_STOPPED;
80006e18:	ee f9 ff c8 	ld.w	r9,r7[-56]
80006e1c:	30 28       	mov	r8,2
80006e1e:	f3 68 00 08 	st.b	r9[8],r8
					cpu_stop_timeout(&timerClean);
					sealShieldState = STATE_ACTION_PB_RELEASED;	
80006e22:	fe f9 03 0e 	ld.w	r9,pc[782]
80006e26:	30 38       	mov	r8,3
80006e28:	b2 88       	st.b	r9[0x0],r8
					print_ssdbg("Start sanitizing\r\n");
80006e2a:	fe fc 03 52 	ld.w	r12,pc[850]
80006e2e:	f0 1f 00 ba 	mcall	80007114 <main+0xc68>

				}
				break;
80006e32:	c2 18       	rjmp	80006e74 <main+0x9c8>
				
			case STATE_SHUTDOWN_PROCESSES:
				//Shutdown all processes that could harm the user or equipment if the door is open
				led_shelf(0, LED_OFF);
80006e34:	30 0b       	mov	r11,0
80006e36:	30 0c       	mov	r12,0
80006e38:	f0 1f 00 d8 	mcall	80007198 <main+0xcec>
				led_shelf(1, LED_OFF);
80006e3c:	30 0b       	mov	r11,0
80006e3e:	30 1c       	mov	r12,1
80006e40:	f0 1f 00 d6 	mcall	80007198 <main+0xcec>
				led_shelf(2, LED_OFF);
80006e44:	30 0b       	mov	r11,0
80006e46:	30 2c       	mov	r12,2
80006e48:	f0 1f 00 d4 	mcall	80007198 <main+0xcec>
				led_shelf(3, LED_OFF);
80006e4c:	30 0b       	mov	r11,0
80006e4e:	30 3c       	mov	r12,3
80006e50:	f0 1f 00 d2 	mcall	80007198 <main+0xcec>
				sealShieldState = STATE_SS_IDLE;
80006e54:	fe f9 02 dc 	ld.w	r9,pc[732]
80006e58:	30 08       	mov	r8,0
80006e5a:	b2 88       	st.b	r9[0x0],r8
80006e5c:	c0 c8       	rjmp	80006e74 <main+0x9c8>
//					display_text(IDX_CLEAR);
					display_text(IDX_READY);
					sealShieldState = STATE_DOOR_LATCHED;
					firstTimeThrough = 1;
				}
				break;
80006e5e:	d7 03       	nop
80006e60:	c0 a8       	rjmp	80006e74 <main+0x9c8>
				if (!SS_ACTION_PB) {
					print_ssdbg("Action push button press detected\r\n");
					sealShieldState = STATE_ACTION_PB_PRESSED;
					read_serial_ids();
				}
				break;
80006e62:	d7 03       	nop
80006e64:	c0 88       	rjmp	80006e74 <main+0x9c8>
				{
					print_ssdbg("Action push button release detected\r\n");
					sealShieldState = STATE_ACTION_PB_RELEASED;	
					read_serial_ids();
				}
				break;
80006e66:	d7 03       	nop
80006e68:	c0 68       	rjmp	80006e74 <main+0x9c8>
//					display_text(IDX_CLEAR);
					display_text(IDX_CLEAN);

				}
#endif				
				break;
80006e6a:	d7 03       	nop
80006e6c:	c0 48       	rjmp	80006e74 <main+0x9c8>
					else
					{
						sealShieldState = STATE_SANITIZE_1; //more shelves to clean possibly
					}
				}
				break;
80006e6e:	d7 03       	nop
80006e70:	c0 28       	rjmp	80006e74 <main+0x9c8>
					cpu_stop_timeout(&timerClean);
					sealShieldState = STATE_ACTION_PB_RELEASED;	
					print_ssdbg("Start sanitizing\r\n");

				}
				break;
80006e72:	d7 03       	nop
		
		/*
		 * This check overrides everything going on in the state machine, if the user opens the door,
		 * shut down all processes for safety
		 */
		if (!SS_DOOR_LATCHED) {
80006e74:	33 ec       	mov	r12,62
80006e76:	f0 1f 00 b8 	mcall	80007154 <main+0xca8>
80006e7a:	18 98       	mov	r8,r12
80006e7c:	58 08       	cp.w	r8,0
80006e7e:	e0 80 00 c1 	breq	80007000 <main+0xb54>
		
			if (firstTimeThrough)
80006e82:	fe f8 02 da 	ld.w	r8,pc[730]
80006e86:	11 88       	ld.ub	r8,r8[0x0]
80006e88:	58 08       	cp.w	r8,0
80006e8a:	e0 80 00 bb 	breq	80007000 <main+0xb54>
			{
				door_latch_open_kill_all_shelves();
80006e8e:	f0 1f 00 c6 	mcall	800071a4 <main+0xcf8>

				display_text(IDX_CLEAR);
80006e92:	30 9c       	mov	r12,9
80006e94:	f0 1f 00 a1 	mcall	80007118 <main+0xc6c>
80006e98:	e0 68 01 f4 	mov	r8,500
80006e9c:	ef 48 ff d0 	st.w	r7[-48],r8
80006ea0:	e0 68 12 00 	mov	r8,4608
80006ea4:	ea 18 00 7a 	orh	r8,0x7a
80006ea8:	ef 48 ff cc 	st.w	r7[-52],r8
80006eac:	ee f8 ff d0 	ld.w	r8,r7[-48]
80006eb0:	ef 48 ff d8 	st.w	r7[-40],r8
80006eb4:	ee f8 ff cc 	ld.w	r8,r7[-52]
80006eb8:	ef 48 ff d4 	st.w	r7[-44],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80006ebc:	ee f2 ff d8 	ld.w	r2,r7[-40]
80006ec0:	30 03       	mov	r3,0
80006ec2:	ee f0 ff d4 	ld.w	r0,r7[-44]
80006ec6:	30 01       	mov	r1,0
80006ec8:	e6 00 02 49 	mul	r9,r3,r0
80006ecc:	e2 02 02 48 	mul	r8,r1,r2
80006ed0:	10 09       	add	r9,r8
80006ed2:	e4 00 06 4a 	mulu.d	r10,r2,r0
80006ed6:	16 09       	add	r9,r11
80006ed8:	12 9b       	mov	r11,r9
80006eda:	e0 68 03 e7 	mov	r8,999
80006ede:	30 09       	mov	r9,0
80006ee0:	10 0a       	add	r10,r8
80006ee2:	f6 09 00 4b 	adc	r11,r11,r9
80006ee6:	e0 68 03 e8 	mov	r8,1000
80006eea:	30 09       	mov	r9,0
80006eec:	f0 1f 00 a5 	mcall	80007180 <main+0xcd4>
80006ef0:	14 98       	mov	r8,r10
80006ef2:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
80006ef4:	ef 48 ff e0 	st.w	r7[-32],r8
80006ef8:	ee c8 00 d4 	sub	r8,r7,212
80006efc:	ef 48 ff dc 	st.w	r7[-36],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80006f00:	e1 b8 00 42 	mfsr	r8,0x108
80006f04:	10 99       	mov	r9,r8
80006f06:	ee f8 ff dc 	ld.w	r8,r7[-36]
80006f0a:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80006f0c:	ee f8 ff dc 	ld.w	r8,r7[-36]
80006f10:	70 09       	ld.w	r9,r8[0x0]
80006f12:	ee f8 ff e0 	ld.w	r8,r7[-32]
80006f16:	10 09       	add	r9,r8
80006f18:	ee f8 ff dc 	ld.w	r8,r7[-36]
80006f1c:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
80006f1e:	ee f9 ff dc 	ld.w	r9,r7[-36]
80006f22:	30 08       	mov	r8,0
80006f24:	f3 68 00 08 	st.b	r9[8],r8
80006f28:	ee c8 00 d4 	sub	r8,r7,212
80006f2c:	ef 48 ff e4 	st.w	r7[-28],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80006f30:	e1 b8 00 42 	mfsr	r8,0x108
80006f34:	ef 48 ff e8 	st.w	r7[-24],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
80006f38:	ee f8 ff e4 	ld.w	r8,r7[-28]
80006f3c:	f1 39 00 08 	ld.ub	r9,r8[8]
80006f40:	30 28       	mov	r8,2
80006f42:	f0 09 18 00 	cp.b	r9,r8
80006f46:	c0 31       	brne	80006f4c <main+0xaa0>
    return false;
80006f48:	30 08       	mov	r8,0
80006f4a:	c4 38       	rjmp	80006fd0 <main+0xb24>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
80006f4c:	ee f8 ff e4 	ld.w	r8,r7[-28]
80006f50:	f1 39 00 08 	ld.ub	r9,r8[8]
80006f54:	30 18       	mov	r8,1
80006f56:	f0 09 18 00 	cp.b	r9,r8
80006f5a:	c0 31       	brne	80006f60 <main+0xab4>
    return true;
80006f5c:	30 18       	mov	r8,1
80006f5e:	c3 98       	rjmp	80006fd0 <main+0xb24>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80006f60:	ee f8 ff e4 	ld.w	r8,r7[-28]
80006f64:	70 09       	ld.w	r9,r8[0x0]
80006f66:	ee f8 ff e4 	ld.w	r8,r7[-28]
80006f6a:	70 18       	ld.w	r8,r8[0x4]
80006f6c:	10 39       	cp.w	r9,r8
80006f6e:	e0 88 00 1a 	brls	80006fa2 <main+0xaf6>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80006f72:	ee f8 ff e4 	ld.w	r8,r7[-28]
80006f76:	70 09       	ld.w	r9,r8[0x0]
80006f78:	ee f8 ff e8 	ld.w	r8,r7[-24]
80006f7c:	12 38       	cp.w	r8,r9
80006f7e:	c1 02       	brcc	80006f9e <main+0xaf2>
80006f80:	ee f8 ff e4 	ld.w	r8,r7[-28]
80006f84:	70 19       	ld.w	r9,r8[0x4]
80006f86:	ee f8 ff e8 	ld.w	r8,r7[-24]
80006f8a:	12 38       	cp.w	r8,r9
80006f8c:	e0 88 00 09 	brls	80006f9e <main+0xaf2>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80006f90:	ee f9 ff e4 	ld.w	r9,r7[-28]
80006f94:	30 18       	mov	r8,1
80006f96:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80006f9a:	30 18       	mov	r8,1
80006f9c:	c1 a8       	rjmp	80006fd0 <main+0xb24>
    }
    return false;
80006f9e:	30 08       	mov	r8,0
80006fa0:	c1 88       	rjmp	80006fd0 <main+0xb24>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80006fa2:	ee f8 ff e4 	ld.w	r8,r7[-28]
80006fa6:	70 09       	ld.w	r9,r8[0x0]
80006fa8:	ee f8 ff e8 	ld.w	r8,r7[-24]
80006fac:	12 38       	cp.w	r8,r9
80006fae:	c0 93       	brcs	80006fc0 <main+0xb14>
80006fb0:	ee f8 ff e4 	ld.w	r8,r7[-28]
80006fb4:	70 19       	ld.w	r9,r8[0x4]
80006fb6:	ee f8 ff e8 	ld.w	r8,r7[-24]
80006fba:	12 38       	cp.w	r8,r9
80006fbc:	e0 88 00 09 	brls	80006fce <main+0xb22>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80006fc0:	ee f9 ff e4 	ld.w	r9,r7[-28]
80006fc4:	30 18       	mov	r8,1
80006fc6:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80006fca:	30 18       	mov	r8,1
80006fcc:	c0 28       	rjmp	80006fd0 <main+0xb24>
    }
    return false;
80006fce:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
80006fd0:	58 08       	cp.w	r8,0
80006fd2:	ca b0       	breq	80006f28 <main+0xa7c>
				cpu_delay_ms(500, 8000000);
				switch (sealShieldState)
80006fd4:	4d 78       	lddpc	r8,80007130 <main+0xc84>
80006fd6:	11 88       	ld.ub	r8,r8[0x0]
80006fd8:	20 58       	sub	r8,5
80006fda:	58 18       	cp.w	r8,1
80006fdc:	e0 8b 00 06 	brhi	80006fe8 <main+0xb3c>
				{
					case STATE_SANITIZE_1:
					case STATE_SANITIZE_2:
						display_text(IDX_DIRTY);
80006fe0:	30 3c       	mov	r12,3
80006fe2:	f0 1f 00 4e 	mcall	80007118 <main+0xc6c>
						break;
80006fe6:	c0 48       	rjmp	80006fee <main+0xb42>
					
					default:
						display_text(IDX_CLEAN);
80006fe8:	30 1c       	mov	r12,1
80006fea:	f0 1f 00 4c 	mcall	80007118 <main+0xc6c>
						break;
				}

				sealShieldState = STATE_SHUTDOWN_PROCESSES;
80006fee:	4d 19       	lddpc	r9,80007130 <main+0xc84>
80006ff0:	30 98       	mov	r8,9
80006ff2:	b2 88       	st.b	r9[0x0],r8
				print_ssdbg("Door latch opened, shutting down all processes\r\n");
80006ff4:	4e dc       	lddpc	r12,800071a8 <main+0xcfc>
80006ff6:	f0 1f 00 48 	mcall	80007114 <main+0xc68>
				firstTimeThrough = 0;
80006ffa:	4d 99       	lddpc	r9,8000715c <main+0xcb0>
80006ffc:	30 08       	mov	r8,0
80006ffe:	b2 88       	st.b	r9[0x0],r8
80007000:	4d 38       	lddpc	r8,8000714c <main+0xca0>
80007002:	ef 48 ff ec 	st.w	r7[-20],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80007006:	e1 b8 00 42 	mfsr	r8,0x108
8000700a:	ef 48 ff f0 	st.w	r7[-16],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
8000700e:	ee f8 ff ec 	ld.w	r8,r7[-20]
80007012:	f1 39 00 08 	ld.ub	r9,r8[8]
80007016:	30 28       	mov	r8,2
80007018:	f0 09 18 00 	cp.b	r9,r8
8000701c:	c0 31       	brne	80007022 <main+0xb76>
    return false;
8000701e:	30 08       	mov	r8,0
80007020:	c4 38       	rjmp	800070a6 <main+0xbfa>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
80007022:	ee f8 ff ec 	ld.w	r8,r7[-20]
80007026:	f1 39 00 08 	ld.ub	r9,r8[8]
8000702a:	30 18       	mov	r8,1
8000702c:	f0 09 18 00 	cp.b	r9,r8
80007030:	c0 31       	brne	80007036 <main+0xb8a>
    return true;
80007032:	30 18       	mov	r8,1
80007034:	c3 98       	rjmp	800070a6 <main+0xbfa>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80007036:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000703a:	70 09       	ld.w	r9,r8[0x0]
8000703c:	ee f8 ff ec 	ld.w	r8,r7[-20]
80007040:	70 18       	ld.w	r8,r8[0x4]
80007042:	10 39       	cp.w	r9,r8
80007044:	e0 88 00 1a 	brls	80007078 <main+0xbcc>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80007048:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000704c:	70 09       	ld.w	r9,r8[0x0]
8000704e:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007052:	12 38       	cp.w	r8,r9
80007054:	c1 02       	brcc	80007074 <main+0xbc8>
80007056:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000705a:	70 19       	ld.w	r9,r8[0x4]
8000705c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007060:	12 38       	cp.w	r8,r9
80007062:	e0 88 00 09 	brls	80007074 <main+0xbc8>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80007066:	ee f9 ff ec 	ld.w	r9,r7[-20]
8000706a:	30 18       	mov	r8,1
8000706c:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80007070:	30 18       	mov	r8,1
80007072:	c1 a8       	rjmp	800070a6 <main+0xbfa>
    }
    return false;
80007074:	30 08       	mov	r8,0
80007076:	c1 88       	rjmp	800070a6 <main+0xbfa>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80007078:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000707c:	70 09       	ld.w	r9,r8[0x0]
8000707e:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007082:	12 38       	cp.w	r8,r9
80007084:	c0 93       	brcs	80007096 <main+0xbea>
80007086:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000708a:	70 19       	ld.w	r9,r8[0x4]
8000708c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007090:	12 38       	cp.w	r8,r9
80007092:	e0 88 00 09 	brls	800070a4 <main+0xbf8>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80007096:	ee f9 ff ec 	ld.w	r9,r7[-20]
8000709a:	30 18       	mov	r8,1
8000709c:	f3 68 00 08 	st.b	r9[8],r8
      return true;
800070a0:	30 18       	mov	r8,1
800070a2:	c0 28       	rjmp	800070a6 <main+0xbfa>
    }
    return false;
800070a4:	30 08       	mov	r8,0
				
			}
		} //if (!SS_DOOR_LATCHED)
		
		if (cpu_is_timeout(&timerDebugLed))
800070a6:	58 08       	cp.w	r8,0
800070a8:	fe 90 fa 67 	breq	80006576 <main+0xca>
800070ac:	4a 88       	lddpc	r8,8000714c <main+0xca0>
800070ae:	ef 48 ff f4 	st.w	r7[-12],r8
 *
 * \param  cpu_time:   (input) internal information used by the timer API.
 */
__always_inline static void cpu_stop_timeout(t_cpu_time *cpu_time)
{
  cpu_time->timer_state = CPU_TIMER_STATE_STOPPED;
800070b2:	ee f9 ff f4 	ld.w	r9,r7[-12]
800070b6:	30 28       	mov	r8,2
800070b8:	f3 68 00 08 	st.b	r9[8],r8
800070bc:	e0 68 09 00 	mov	r8,2304
800070c0:	ea 18 00 3d 	orh	r8,0x3d
800070c4:	ef 48 ff fc 	st.w	r7[-4],r8
800070c8:	4a 18       	lddpc	r8,8000714c <main+0xca0>
800070ca:	ef 48 ff f8 	st.w	r7[-8],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800070ce:	e1 b8 00 42 	mfsr	r8,0x108
800070d2:	10 99       	mov	r9,r8
800070d4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800070d8:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800070da:	ee f8 ff f8 	ld.w	r8,r7[-8]
800070de:	70 09       	ld.w	r9,r8[0x0]
800070e0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800070e4:	10 09       	add	r9,r8
800070e6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800070ea:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
800070ec:	ee f9 ff f8 	ld.w	r9,r7[-8]
800070f0:	30 08       	mov	r8,0
800070f2:	f3 68 00 08 	st.b	r9[8],r8
		{
			cpu_stop_timeout(&timerDebugLed);
			cpu_set_timeout((SS_ONE_SECOND/2), &timerDebugLed);
			gpio_toggle_pin(SEALSHIELD_DEBUG_LED);
800070f6:	37 cc       	mov	r12,124
800070f8:	f0 1f 00 2d 	mcall	800071ac <main+0xd00>
		}
	} //while(true)
800070fc:	fe 9f fa 3e 	bral	80006578 <main+0xcc>
80007100:	80 00       	ld.sh	r0,r0[0x0]
80007102:	62 f0       	ld.w	r0,r1[0x3c]
80007104:	80 00       	ld.sh	r0,r0[0x0]
80007106:	5a 68       	cp.w	r8,-26
80007108:	80 00       	ld.sh	r0,r0[0x0]
8000710a:	32 a0       	mov	r0,42
8000710c:	80 00       	ld.sh	r0,r0[0x0]
8000710e:	32 c4       	mov	r4,44
80007110:	80 00       	ld.sh	r0,r0[0x0]
80007112:	58 c4       	cp.w	r4,12
80007114:	80 00       	ld.sh	r0,r0[0x0]
80007116:	33 a0       	mov	r0,58
80007118:	80 00       	ld.sh	r0,r0[0x0]
8000711a:	5a 10       	cp.w	r0,-31
8000711c:	80 00       	ld.sh	r0,r0[0x0]
8000711e:	63 40       	ld.w	r0,r1[0x50]
80007120:	80 00       	ld.sh	r0,r0[0x0]
80007122:	43 58       	lddsp	r8,sp[0xd4]
80007124:	80 00       	ld.sh	r0,r0[0x0]
80007126:	63 8c       	ld.w	r12,r1[0x60]
80007128:	80 00       	ld.sh	r0,r0[0x0]
8000712a:	42 1e       	lddsp	lr,sp[0x84]
8000712c:	80 00       	ld.sh	r0,r0[0x0]
8000712e:	54 c0       	stdsp	sp[0x130],r0
80007130:	00 00       	add	r0,r0
80007132:	03 0a       	ld.w	r10,r1++
80007134:	00 00       	add	r0,r0
80007136:	00 ac       	st.w	r0++,r12
80007138:	00 00       	add	r0,r0
8000713a:	09 78       	ld.ub	r8,--r4
8000713c:	00 00       	add	r0,r0
8000713e:	09 6c       	ld.uh	r12,--r4
80007140:	00 00       	add	r0,r0
80007142:	09 90       	ld.ub	r0,r4[0x1]
80007144:	00 00       	add	r0,r0
80007146:	09 20       	ld.uh	r0,r4++
80007148:	80 00       	ld.sh	r0,r0[0x0]
8000714a:	42 58       	lddsp	r8,sp[0x94]
8000714c:	00 00       	add	r0,r0
8000714e:	09 60       	ld.uh	r0,--r4
80007150:	80 00       	ld.sh	r0,r0[0x0]
80007152:	79 b8       	ld.w	r8,r12[0x6c]
80007154:	80 00       	ld.sh	r0,r0[0x0]
80007156:	41 e2       	lddsp	r2,sp[0x78]
80007158:	80 00       	ld.sh	r0,r0[0x0]
8000715a:	59 10       	cp.w	r0,17
8000715c:	00 00       	add	r0,r0
8000715e:	00 bc       	st.h	r0++,r12
80007160:	80 00       	ld.sh	r0,r0[0x0]
80007162:	59 28       	cp.w	r8,18
80007164:	80 00       	ld.sh	r0,r0[0x0]
80007166:	5b 2c       	cp.w	r12,-14
80007168:	80 00       	ld.sh	r0,r0[0x0]
8000716a:	59 4c       	cp.w	r12,20
8000716c:	80 00       	ld.sh	r0,r0[0x0]
8000716e:	5c 3c       	neg	r12
80007170:	80 00       	ld.sh	r0,r0[0x0]
80007172:	61 2c       	ld.w	r12,r0[0x48]
80007174:	80 00       	ld.sh	r0,r0[0x0]
80007176:	61 78       	ld.w	r8,r0[0x5c]
80007178:	80 00       	ld.sh	r0,r0[0x0]
8000717a:	62 dc       	ld.w	r12,r1[0x34]
8000717c:	80 00       	ld.sh	r0,r0[0x0]
8000717e:	59 74       	cp.w	r4,23
80007180:	80 00       	ld.sh	r0,r0[0x0]
80007182:	71 b0       	ld.w	r0,r8[0x6c]
80007184:	80 00       	ld.sh	r0,r0[0x0]
80007186:	59 88       	cp.w	r8,24
80007188:	00 00       	add	r0,r0
8000718a:	02 b4       	st.h	r1++,r4
8000718c:	00 00       	add	r0,r0
8000718e:	09 a4       	ld.ub	r4,r4[0x2]
80007190:	80 00       	ld.sh	r0,r0[0x0]
80007192:	64 0c       	ld.w	r12,r2[0x0]
80007194:	00 00       	add	r0,r0
80007196:	02 f8       	st.b	--r1,r8
80007198:	80 00       	ld.sh	r0,r0[0x0]
8000719a:	57 1c       	stdsp	sp[0x1c4],r12
8000719c:	80 00       	ld.sh	r0,r0[0x0]
8000719e:	59 cc       	cp.w	r12,28
800071a0:	00 00       	add	r0,r0
800071a2:	02 e8       	st.h	--r1,r8
800071a4:	80 00       	ld.sh	r0,r0[0x0]
800071a6:	64 7c       	ld.w	r12,r2[0x1c]
800071a8:	80 00       	ld.sh	r0,r0[0x0]
800071aa:	59 dc       	cp.w	r12,29
800071ac:	80 00       	ld.sh	r0,r0[0x0]
800071ae:	42 92       	lddsp	r2,sp[0xa4]

800071b0 <__avr32_udiv64>:
800071b0:	d4 31       	pushm	r0-r7,lr
800071b2:	1a 97       	mov	r7,sp
800071b4:	20 3d       	sub	sp,12
800071b6:	10 9c       	mov	r12,r8
800071b8:	12 9e       	mov	lr,r9
800071ba:	14 93       	mov	r3,r10
800071bc:	58 09       	cp.w	r9,0
800071be:	e0 81 00 bd 	brne	80007338 <__avr32_udiv64+0x188>
800071c2:	16 38       	cp.w	r8,r11
800071c4:	e0 88 00 40 	brls	80007244 <__avr32_udiv64+0x94>
800071c8:	f0 08 12 00 	clz	r8,r8
800071cc:	c0 d0       	breq	800071e6 <__avr32_udiv64+0x36>
800071ce:	f6 08 09 4b 	lsl	r11,r11,r8
800071d2:	f0 09 11 20 	rsub	r9,r8,32
800071d6:	f8 08 09 4c 	lsl	r12,r12,r8
800071da:	f4 09 0a 49 	lsr	r9,r10,r9
800071de:	f4 08 09 43 	lsl	r3,r10,r8
800071e2:	f3 eb 10 0b 	or	r11,r9,r11
800071e6:	f8 0e 16 10 	lsr	lr,r12,0x10
800071ea:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
800071ee:	f6 0e 0d 00 	divu	r0,r11,lr
800071f2:	e6 0b 16 10 	lsr	r11,r3,0x10
800071f6:	00 99       	mov	r9,r0
800071f8:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
800071fc:	e0 0a 02 48 	mul	r8,r0,r10
80007200:	10 3b       	cp.w	r11,r8
80007202:	c0 a2       	brcc	80007216 <__avr32_udiv64+0x66>
80007204:	20 19       	sub	r9,1
80007206:	18 0b       	add	r11,r12
80007208:	18 3b       	cp.w	r11,r12
8000720a:	c0 63       	brcs	80007216 <__avr32_udiv64+0x66>
8000720c:	10 3b       	cp.w	r11,r8
8000720e:	f7 b9 03 01 	sublo	r9,1
80007212:	f7 dc e3 0b 	addcs	r11,r11,r12
80007216:	f6 08 01 01 	sub	r1,r11,r8
8000721a:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000721e:	e2 0e 0d 00 	divu	r0,r1,lr
80007222:	e7 e1 11 03 	or	r3,r3,r1<<0x10
80007226:	00 98       	mov	r8,r0
80007228:	e0 0a 02 4a 	mul	r10,r0,r10
8000722c:	14 33       	cp.w	r3,r10
8000722e:	c0 82       	brcc	8000723e <__avr32_udiv64+0x8e>
80007230:	20 18       	sub	r8,1
80007232:	18 03       	add	r3,r12
80007234:	18 33       	cp.w	r3,r12
80007236:	c0 43       	brcs	8000723e <__avr32_udiv64+0x8e>
80007238:	14 33       	cp.w	r3,r10
8000723a:	f7 b8 03 01 	sublo	r8,1
8000723e:	f1 e9 11 08 	or	r8,r8,r9<<0x10
80007242:	cd f8       	rjmp	80007400 <__avr32_udiv64+0x250>
80007244:	58 08       	cp.w	r8,0
80007246:	c0 51       	brne	80007250 <__avr32_udiv64+0xa0>
80007248:	30 19       	mov	r9,1
8000724a:	f2 08 0d 08 	divu	r8,r9,r8
8000724e:	10 9c       	mov	r12,r8
80007250:	f8 06 12 00 	clz	r6,r12
80007254:	c0 41       	brne	8000725c <__avr32_udiv64+0xac>
80007256:	18 1b       	sub	r11,r12
80007258:	30 19       	mov	r9,1
8000725a:	c4 08       	rjmp	800072da <__avr32_udiv64+0x12a>
8000725c:	ec 01 11 20 	rsub	r1,r6,32
80007260:	f4 01 0a 49 	lsr	r9,r10,r1
80007264:	f8 06 09 4c 	lsl	r12,r12,r6
80007268:	f6 06 09 48 	lsl	r8,r11,r6
8000726c:	f6 01 0a 41 	lsr	r1,r11,r1
80007270:	f3 e8 10 08 	or	r8,r9,r8
80007274:	f8 03 16 10 	lsr	r3,r12,0x10
80007278:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000727c:	e2 03 0d 00 	divu	r0,r1,r3
80007280:	f0 0b 16 10 	lsr	r11,r8,0x10
80007284:	00 9e       	mov	lr,r0
80007286:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000728a:	e0 05 02 49 	mul	r9,r0,r5
8000728e:	12 3b       	cp.w	r11,r9
80007290:	c0 a2       	brcc	800072a4 <__avr32_udiv64+0xf4>
80007292:	20 1e       	sub	lr,1
80007294:	18 0b       	add	r11,r12
80007296:	18 3b       	cp.w	r11,r12
80007298:	c0 63       	brcs	800072a4 <__avr32_udiv64+0xf4>
8000729a:	12 3b       	cp.w	r11,r9
8000729c:	f7 be 03 01 	sublo	lr,1
800072a0:	f7 dc e3 0b 	addcs	r11,r11,r12
800072a4:	12 1b       	sub	r11,r9
800072a6:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
800072aa:	f6 03 0d 02 	divu	r2,r11,r3
800072ae:	f1 e3 11 08 	or	r8,r8,r3<<0x10
800072b2:	04 99       	mov	r9,r2
800072b4:	e4 05 02 4b 	mul	r11,r2,r5
800072b8:	16 38       	cp.w	r8,r11
800072ba:	c0 a2       	brcc	800072ce <__avr32_udiv64+0x11e>
800072bc:	20 19       	sub	r9,1
800072be:	18 08       	add	r8,r12
800072c0:	18 38       	cp.w	r8,r12
800072c2:	c0 63       	brcs	800072ce <__avr32_udiv64+0x11e>
800072c4:	16 38       	cp.w	r8,r11
800072c6:	f7 b9 03 01 	sublo	r9,1
800072ca:	f1 dc e3 08 	addcs	r8,r8,r12
800072ce:	f4 06 09 43 	lsl	r3,r10,r6
800072d2:	f0 0b 01 0b 	sub	r11,r8,r11
800072d6:	f3 ee 11 09 	or	r9,r9,lr<<0x10
800072da:	f8 06 16 10 	lsr	r6,r12,0x10
800072de:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
800072e2:	f6 06 0d 00 	divu	r0,r11,r6
800072e6:	e6 0b 16 10 	lsr	r11,r3,0x10
800072ea:	00 9a       	mov	r10,r0
800072ec:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
800072f0:	e0 0e 02 48 	mul	r8,r0,lr
800072f4:	10 3b       	cp.w	r11,r8
800072f6:	c0 a2       	brcc	8000730a <__avr32_udiv64+0x15a>
800072f8:	20 1a       	sub	r10,1
800072fa:	18 0b       	add	r11,r12
800072fc:	18 3b       	cp.w	r11,r12
800072fe:	c0 63       	brcs	8000730a <__avr32_udiv64+0x15a>
80007300:	10 3b       	cp.w	r11,r8
80007302:	f7 ba 03 01 	sublo	r10,1
80007306:	f7 dc e3 0b 	addcs	r11,r11,r12
8000730a:	f6 08 01 01 	sub	r1,r11,r8
8000730e:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
80007312:	e2 06 0d 00 	divu	r0,r1,r6
80007316:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000731a:	00 98       	mov	r8,r0
8000731c:	e0 0e 02 4b 	mul	r11,r0,lr
80007320:	16 33       	cp.w	r3,r11
80007322:	c0 82       	brcc	80007332 <__avr32_udiv64+0x182>
80007324:	20 18       	sub	r8,1
80007326:	18 03       	add	r3,r12
80007328:	18 33       	cp.w	r3,r12
8000732a:	c0 43       	brcs	80007332 <__avr32_udiv64+0x182>
8000732c:	16 33       	cp.w	r3,r11
8000732e:	f7 b8 03 01 	sublo	r8,1
80007332:	f1 ea 11 08 	or	r8,r8,r10<<0x10
80007336:	c6 98       	rjmp	80007408 <__avr32_udiv64+0x258>
80007338:	16 39       	cp.w	r9,r11
8000733a:	e0 8b 00 65 	brhi	80007404 <__avr32_udiv64+0x254>
8000733e:	f2 09 12 00 	clz	r9,r9
80007342:	c0 b1       	brne	80007358 <__avr32_udiv64+0x1a8>
80007344:	10 3a       	cp.w	r10,r8
80007346:	5f 2a       	srhs	r10
80007348:	1c 3b       	cp.w	r11,lr
8000734a:	5f b8       	srhi	r8
8000734c:	10 4a       	or	r10,r8
8000734e:	f2 0a 18 00 	cp.b	r10,r9
80007352:	c5 90       	breq	80007404 <__avr32_udiv64+0x254>
80007354:	30 18       	mov	r8,1
80007356:	c5 98       	rjmp	80007408 <__avr32_udiv64+0x258>
80007358:	f0 09 09 46 	lsl	r6,r8,r9
8000735c:	f2 03 11 20 	rsub	r3,r9,32
80007360:	fc 09 09 4e 	lsl	lr,lr,r9
80007364:	f0 03 0a 48 	lsr	r8,r8,r3
80007368:	f6 09 09 4c 	lsl	r12,r11,r9
8000736c:	f4 03 0a 42 	lsr	r2,r10,r3
80007370:	ef 46 ff f4 	st.w	r7[-12],r6
80007374:	f6 03 0a 43 	lsr	r3,r11,r3
80007378:	18 42       	or	r2,r12
8000737a:	f1 ee 10 0c 	or	r12,r8,lr
8000737e:	f8 01 16 10 	lsr	r1,r12,0x10
80007382:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
80007386:	e6 01 0d 04 	divu	r4,r3,r1
8000738a:	e4 03 16 10 	lsr	r3,r2,0x10
8000738e:	08 9e       	mov	lr,r4
80007390:	e7 e5 11 03 	or	r3,r3,r5<<0x10
80007394:	e8 06 02 48 	mul	r8,r4,r6
80007398:	10 33       	cp.w	r3,r8
8000739a:	c0 a2       	brcc	800073ae <__avr32_udiv64+0x1fe>
8000739c:	20 1e       	sub	lr,1
8000739e:	18 03       	add	r3,r12
800073a0:	18 33       	cp.w	r3,r12
800073a2:	c0 63       	brcs	800073ae <__avr32_udiv64+0x1fe>
800073a4:	10 33       	cp.w	r3,r8
800073a6:	f7 be 03 01 	sublo	lr,1
800073aa:	e7 dc e3 03 	addcs	r3,r3,r12
800073ae:	10 13       	sub	r3,r8
800073b0:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
800073b4:	e6 01 0d 00 	divu	r0,r3,r1
800073b8:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
800073bc:	00 98       	mov	r8,r0
800073be:	e0 06 02 46 	mul	r6,r0,r6
800073c2:	0c 3b       	cp.w	r11,r6
800073c4:	c0 a2       	brcc	800073d8 <__avr32_udiv64+0x228>
800073c6:	20 18       	sub	r8,1
800073c8:	18 0b       	add	r11,r12
800073ca:	18 3b       	cp.w	r11,r12
800073cc:	c0 63       	brcs	800073d8 <__avr32_udiv64+0x228>
800073ce:	0c 3b       	cp.w	r11,r6
800073d0:	f7 dc e3 0b 	addcs	r11,r11,r12
800073d4:	f7 b8 03 01 	sublo	r8,1
800073d8:	f1 ee 11 08 	or	r8,r8,lr<<0x10
800073dc:	ee f4 ff f4 	ld.w	r4,r7[-12]
800073e0:	0c 1b       	sub	r11,r6
800073e2:	f0 04 06 42 	mulu.d	r2,r8,r4
800073e6:	06 95       	mov	r5,r3
800073e8:	16 35       	cp.w	r5,r11
800073ea:	e0 8b 00 0a 	brhi	800073fe <__avr32_udiv64+0x24e>
800073ee:	5f 0b       	sreq	r11
800073f0:	f4 09 09 49 	lsl	r9,r10,r9
800073f4:	12 32       	cp.w	r2,r9
800073f6:	5f b9       	srhi	r9
800073f8:	f7 e9 00 09 	and	r9,r11,r9
800073fc:	c0 60       	breq	80007408 <__avr32_udiv64+0x258>
800073fe:	20 18       	sub	r8,1
80007400:	30 09       	mov	r9,0
80007402:	c0 38       	rjmp	80007408 <__avr32_udiv64+0x258>
80007404:	30 09       	mov	r9,0
80007406:	12 98       	mov	r8,r9
80007408:	10 9a       	mov	r10,r8
8000740a:	12 93       	mov	r3,r9
8000740c:	10 92       	mov	r2,r8
8000740e:	12 9b       	mov	r11,r9
80007410:	2f dd       	sub	sp,-12
80007412:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

80007600 <_evba>:
_evba:

	.org  0x000
	// Unrecoverable Exception.
_handle_Unrecoverable_Exception:
	rjmp $
80007600:	c0 08       	rjmp	80007600 <_evba>
	...

80007604 <_handle_TLB_Multiple_Hit>:

	.org  0x004
	// TLB Multiple Hit.
_handle_TLB_Multiple_Hit:
	rjmp $
80007604:	c0 08       	rjmp	80007604 <_handle_TLB_Multiple_Hit>
	...

80007608 <_handle_Bus_Error_Data_Fetch>:

	.org  0x008
	// Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
	rjmp $
80007608:	c0 08       	rjmp	80007608 <_handle_Bus_Error_Data_Fetch>
	...

8000760c <_handle_Bus_Error_Instruction_Fetch>:

	.org  0x00C
	// Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
	rjmp $
8000760c:	c0 08       	rjmp	8000760c <_handle_Bus_Error_Instruction_Fetch>
	...

80007610 <_handle_NMI>:

	.org  0x010
	// NMI.
_handle_NMI:
	rjmp $
80007610:	c0 08       	rjmp	80007610 <_handle_NMI>
	...

80007614 <_handle_Instruction_Address>:

	.org  0x014
	// Instruction Address.
_handle_Instruction_Address:
	rjmp $
80007614:	c0 08       	rjmp	80007614 <_handle_Instruction_Address>
	...

80007618 <_handle_ITLB_Protection>:

	.org  0x018
	// ITLB Protection.
_handle_ITLB_Protection:
	rjmp $
80007618:	c0 08       	rjmp	80007618 <_handle_ITLB_Protection>
	...

8000761c <_handle_Breakpoint>:

	.org  0x01C
	// Breakpoint.
_handle_Breakpoint:
	rjmp $
8000761c:	c0 08       	rjmp	8000761c <_handle_Breakpoint>
	...

80007620 <_handle_Illegal_Opcode>:

	.org  0x020
	// Illegal Opcode.
_handle_Illegal_Opcode:
	rjmp $
80007620:	c0 08       	rjmp	80007620 <_handle_Illegal_Opcode>
	...

80007624 <_handle_Unimplemented_Instruction>:

	.org  0x024
	// Unimplemented Instruction.
_handle_Unimplemented_Instruction:
	rjmp $
80007624:	c0 08       	rjmp	80007624 <_handle_Unimplemented_Instruction>
	...

80007628 <_handle_Privilege_Violation>:

	.org  0x028
	// Privilege Violation.
_handle_Privilege_Violation:
	rjmp $
80007628:	c0 08       	rjmp	80007628 <_handle_Privilege_Violation>
	...

8000762c <_handle_Floating_Point>:

	.org  0x02C
	// Floating-Point: UNUSED IN AVR32UC and AVR32AP.
_handle_Floating_Point:
	rjmp $
8000762c:	c0 08       	rjmp	8000762c <_handle_Floating_Point>
	...

80007630 <_handle_Coprocessor_Absent>:

	.org  0x030
	// Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
	rjmp $
80007630:	c0 08       	rjmp	80007630 <_handle_Coprocessor_Absent>
	...

80007634 <_handle_Data_Address_Read>:

	.org  0x034
	// Data Address (Read).
_handle_Data_Address_Read:
	rjmp $
80007634:	c0 08       	rjmp	80007634 <_handle_Data_Address_Read>
	...

80007638 <_handle_Data_Address_Write>:

	.org  0x038
	// Data Address (Write).
_handle_Data_Address_Write:
	rjmp $
80007638:	c0 08       	rjmp	80007638 <_handle_Data_Address_Write>
	...

8000763c <_handle_DTLB_Protection_Read>:

	.org  0x03C
	// DTLB Protection (Read).
_handle_DTLB_Protection_Read:
	rjmp $
8000763c:	c0 08       	rjmp	8000763c <_handle_DTLB_Protection_Read>
	...

80007640 <_handle_DTLB_Protection_Write>:

	.org  0x040
	// DTLB Protection (Write).
_handle_DTLB_Protection_Write:
	rjmp $
80007640:	c0 08       	rjmp	80007640 <_handle_DTLB_Protection_Write>
	...

80007644 <_handle_DTLB_Modified>:

	.org  0x044
	// DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
	rjmp $
80007644:	c0 08       	rjmp	80007644 <_handle_DTLB_Modified>
	...

80007650 <_handle_ITLB_Miss>:

	.org  0x050
	// ITLB Miss.
_handle_ITLB_Miss:
	rjmp $
80007650:	c0 08       	rjmp	80007650 <_handle_ITLB_Miss>
	...

80007660 <_handle_DTLB_Miss_Read>:

	.org  0x060
	// DTLB Miss (Read).
_handle_DTLB_Miss_Read:
	rjmp $
80007660:	c0 08       	rjmp	80007660 <_handle_DTLB_Miss_Read>
	...

80007670 <_handle_DTLB_Miss_Write>:

	.org  0x070
	// DTLB Miss (Write).
_handle_DTLB_Miss_Write:
	rjmp $
80007670:	c0 08       	rjmp	80007670 <_handle_DTLB_Miss_Write>
	...

80007700 <_handle_Supervisor_Call>:

	.org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	rjmp $
80007700:	c0 08       	rjmp	80007700 <_handle_Supervisor_Call>
80007702:	d7 03       	nop

80007704 <_int0>:
	 * RSR_INTx by the CPU upon interrupt entry. No other register is saved
	 * by hardware.
	 */
	pushm   r8-r12, lr
#endif
	// Pass the int_level parameter to the _get_interrupt_handler function.
80007704:	30 0c       	mov	r12,0
80007706:	fe b0 e5 e7 	rcall	800042d4 <_get_interrupt_handler>
8000770a:	58 0c       	cp.w	r12,0
8000770c:	f8 0f 17 10 	movne	pc,r12
	popm    r8-r12, lr
#endif
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
80007710:	d6 03       	rete

80007712 <_int1>:
	 * RSR_INTx by the CPU upon interrupt entry. No other register is saved
	 * by hardware.
	 */
	pushm   r8-r12, lr
#endif
	// Pass the int_level parameter to the _get_interrupt_handler function.
80007712:	30 1c       	mov	r12,1
80007714:	fe b0 e5 e0 	rcall	800042d4 <_get_interrupt_handler>
80007718:	58 0c       	cp.w	r12,0
8000771a:	f8 0f 17 10 	movne	pc,r12
	popm    r8-r12, lr
#endif
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
8000771e:	d6 03       	rete

80007720 <_int2>:
	 * RSR_INTx by the CPU upon interrupt entry. No other register is saved
	 * by hardware.
	 */
	pushm   r8-r12, lr
#endif
	// Pass the int_level parameter to the _get_interrupt_handler function.
80007720:	30 2c       	mov	r12,2
80007722:	fe b0 e5 d9 	rcall	800042d4 <_get_interrupt_handler>
80007726:	58 0c       	cp.w	r12,0
80007728:	f8 0f 17 10 	movne	pc,r12
	popm    r8-r12, lr
#endif
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
8000772c:	d6 03       	rete

8000772e <_int3>:
	 * RSR_INTx by the CPU upon interrupt entry. No other register is saved
	 * by hardware.
	 */
	pushm   r8-r12, lr
#endif
	// Pass the int_level parameter to the _get_interrupt_handler function.
8000772e:	30 3c       	mov	r12,3
80007730:	fe b0 e5 d2 	rcall	800042d4 <_get_interrupt_handler>
80007734:	58 0c       	cp.w	r12,0
80007736:	f8 0f 17 10 	movne	pc,r12
	popm    r8-r12, lr
#endif
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
8000773a:	d6 03       	rete
8000773c:	d7 03       	nop
8000773e:	d7 03       	nop
80007740:	d7 03       	nop
80007742:	d7 03       	nop
80007744:	d7 03       	nop
80007746:	d7 03       	nop
80007748:	d7 03       	nop
8000774a:	d7 03       	nop
8000774c:	d7 03       	nop
8000774e:	d7 03       	nop
80007750:	d7 03       	nop
80007752:	d7 03       	nop
80007754:	d7 03       	nop
80007756:	d7 03       	nop
80007758:	d7 03       	nop
8000775a:	d7 03       	nop
8000775c:	d7 03       	nop
8000775e:	d7 03       	nop
80007760:	d7 03       	nop
80007762:	d7 03       	nop
80007764:	d7 03       	nop
80007766:	d7 03       	nop
80007768:	d7 03       	nop
8000776a:	d7 03       	nop
8000776c:	d7 03       	nop
8000776e:	d7 03       	nop
80007770:	d7 03       	nop
80007772:	d7 03       	nop
80007774:	d7 03       	nop
80007776:	d7 03       	nop
80007778:	d7 03       	nop
8000777a:	d7 03       	nop
8000777c:	d7 03       	nop
8000777e:	d7 03       	nop
80007780:	d7 03       	nop
80007782:	d7 03       	nop
80007784:	d7 03       	nop
80007786:	d7 03       	nop
80007788:	d7 03       	nop
8000778a:	d7 03       	nop
8000778c:	d7 03       	nop
8000778e:	d7 03       	nop
80007790:	d7 03       	nop
80007792:	d7 03       	nop
80007794:	d7 03       	nop
80007796:	d7 03       	nop
80007798:	d7 03       	nop
8000779a:	d7 03       	nop
8000779c:	d7 03       	nop
8000779e:	d7 03       	nop
800077a0:	d7 03       	nop
800077a2:	d7 03       	nop
800077a4:	d7 03       	nop
800077a6:	d7 03       	nop
800077a8:	d7 03       	nop
800077aa:	d7 03       	nop
800077ac:	d7 03       	nop
800077ae:	d7 03       	nop
800077b0:	d7 03       	nop
800077b2:	d7 03       	nop
800077b4:	d7 03       	nop
800077b6:	d7 03       	nop
800077b8:	d7 03       	nop
800077ba:	d7 03       	nop
800077bc:	d7 03       	nop
800077be:	d7 03       	nop
800077c0:	d7 03       	nop
800077c2:	d7 03       	nop
800077c4:	d7 03       	nop
800077c6:	d7 03       	nop
800077c8:	d7 03       	nop
800077ca:	d7 03       	nop
800077cc:	d7 03       	nop
800077ce:	d7 03       	nop
800077d0:	d7 03       	nop
800077d2:	d7 03       	nop
800077d4:	d7 03       	nop
800077d6:	d7 03       	nop
800077d8:	d7 03       	nop
800077da:	d7 03       	nop
800077dc:	d7 03       	nop
800077de:	d7 03       	nop
800077e0:	d7 03       	nop
800077e2:	d7 03       	nop
800077e4:	d7 03       	nop
800077e6:	d7 03       	nop
800077e8:	d7 03       	nop
800077ea:	d7 03       	nop
800077ec:	d7 03       	nop
800077ee:	d7 03       	nop
800077f0:	d7 03       	nop
800077f2:	d7 03       	nop
800077f4:	d7 03       	nop
800077f6:	d7 03       	nop
800077f8:	d7 03       	nop
800077fa:	d7 03       	nop
800077fc:	d7 03       	nop
800077fe:	d7 03       	nop
