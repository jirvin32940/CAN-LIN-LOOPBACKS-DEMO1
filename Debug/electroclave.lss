
electroclave.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002010  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002010  80002010  00002410  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0001012c  80002010  80002010  00002410  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  80012200  80012200  00012600  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       000008e0  80012400  80012400  00012800  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  6 .data         000005b4  00000008  80012ce0  00013408  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .balign       00000004  000005bc  80013294  000139bc  2**0
                  ALLOC
  8 .bss          000007d8  000005c0  000005c0  00000000  2**2
                  ALLOC
  9 .heap         0000e268  00000d98  00000d98  00000000  2**0
                  ALLOC
 10 .comment      00000030  00000000  00000000  000139bc  2**0
                  CONTENTS, READONLY
 11 .debug_aranges 000011a8  00000000  00000000  000139f0  2**3
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_pubnames 000028e1  00000000  00000000  00014b98  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_info   0002e32d  00000000  00000000  00017479  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_abbrev 000056a4  00000000  00000000  000457a6  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   0001133d  00000000  00000000  0004ae4a  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  0000327c  00000000  00000000  0005c188  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_str    00006de1  00000000  00000000  0005f404  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_loc    0000ad8e  00000000  00000000  000661e5  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_macinfo 01032cd4  00000000  00000000  00070f73  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .stack        00001000  0000f000  0000f000  00000000  2**0
                  ALLOC
 21 .flash_nvram0 00000600  8007fa00  80013294  00013a00  2**2
                  ALLOC
 22 .flash_nvram1 00000300  8007f700  80080000  00013b00  2**2
                  ALLOC
 23 .flash_nvram2 00000200  8007f500  8007fa00  00013d00  2**2
                  ALLOC
 24 .flash_nvram3 00003a00  8007bb00  8007f700  00013b00  2**2
                  ALLOC
 25 .flash_nvram4 00000100  8007ba00  8007f500  00013a00  2**2
                  ALLOC
 26 .debug_ranges 00001228  00000000  00000000  010a3c48  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:

  .global _start
  .type _start, @function
_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80000000:	48 1f       	lddpc	pc,80000004 <_start+0x4>
80000002:	00 00       	add	r0,r0
80000004:	80 00       	ld.sh	r0,r0[0x0]
80000006:	59 7c       	cp.w	r12,23

80000008 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000008:	e0 8f 10 00 	bral	80002008 <program_start>
	...

80002008 <program_start>:

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002008:	48 1f       	lddpc	pc,8000200c <program_start+0x4>
8000200a:	00 00       	add	r0,r0
8000200c:	80 00       	ld.sh	r0,r0[0x0]
8000200e:	59 7c       	cp.w	r12,23

Disassembly of section .text:

80002010 <io_pin>:

#define EC_ONE_MICROSECOND 8

unsigned char io_pin(unsigned char idx);
unsigned char io_pin(unsigned char idx)
{
80002010:	eb cd 40 80 	pushm	r7,lr
80002014:	1a 97       	mov	r7,sp
80002016:	20 1d       	sub	sp,4
80002018:	18 98       	mov	r8,r12
8000201a:	ef 68 ff fc 	st.b	r7[-4],r8
	switch (idx)
8000201e:	ef 38 ff fc 	ld.ub	r8,r7[-4]
80002022:	58 28       	cp.w	r8,2
80002024:	c1 10       	breq	80002046 <io_pin+0x36>
80002026:	e0 89 00 07 	brgt	80002034 <io_pin+0x24>
8000202a:	58 08       	cp.w	r8,0
8000202c:	c0 90       	breq	8000203e <io_pin+0x2e>
8000202e:	58 18       	cp.w	r8,1
80002030:	c0 90       	breq	80002042 <io_pin+0x32>
80002032:	c1 08       	rjmp	80002052 <io_pin+0x42>
80002034:	58 38       	cp.w	r8,3
80002036:	c0 a0       	breq	8000204a <io_pin+0x3a>
80002038:	58 48       	cp.w	r8,4
8000203a:	c0 a0       	breq	8000204e <io_pin+0x3e>
8000203c:	c0 b8       	rjmp	80002052 <io_pin+0x42>
	{
		case 0:
			return ECLAVE_SERIAL_ID0;
8000203e:	33 38       	mov	r8,51
80002040:	c0 a8       	rjmp	80002054 <io_pin+0x44>
			break;
		case 1:
			return ECLAVE_SERIAL_ID1;
80002042:	33 48       	mov	r8,52
80002044:	c0 88       	rjmp	80002054 <io_pin+0x44>
			break;
		case 2:
			return ECLAVE_SERIAL_ID2;
80002046:	33 58       	mov	r8,53
80002048:	c0 68       	rjmp	80002054 <io_pin+0x44>
			break;
		case 3:
			return ECLAVE_SERIAL_ID3;
8000204a:	33 68       	mov	r8,54
8000204c:	c0 48       	rjmp	80002054 <io_pin+0x44>
			break;
		case 4:
			return ECLAVE_SERIAL_ID4;
8000204e:	33 78       	mov	r8,55
80002050:	c0 28       	rjmp	80002054 <io_pin+0x44>
			break;
		default: 
			return 0; //TODO: return a better error code here
80002052:	30 08       	mov	r8,0
			break;
	}
}
80002054:	10 9c       	mov	r12,r8
80002056:	2f fd       	sub	sp,-4
80002058:	e3 cd 80 80 	ldm	sp++,r7,pc

8000205c <drive_DQ_low>:

void drive_DQ_low(unsigned char idx);
void drive_DQ_low(unsigned char idx)
{
8000205c:	eb cd 40 80 	pushm	r7,lr
80002060:	1a 97       	mov	r7,sp
80002062:	20 3d       	sub	sp,12
80002064:	18 98       	mov	r8,r12
80002066:	ef 68 ff f4 	st.b	r7[-12],r8
	unsigned char ioPin;
	int32_t ioFlags;
	
	ioPin = io_pin(idx);
8000206a:	ef 38 ff f4 	ld.ub	r8,r7[-12]
8000206e:	10 9c       	mov	r12,r8
80002070:	f0 1f 00 0c 	mcall	800020a0 <drive_DQ_low+0x44>
80002074:	18 98       	mov	r8,r12
80002076:	ef 68 ff fb 	st.b	r7[-5],r8
	
	ioFlags = (GPIO_DIR_OUTPUT); //14may15 experiment
8000207a:	30 18       	mov	r8,1
8000207c:	ef 48 ff fc 	st.w	r7[-4],r8
	gpio_configure_pin(ioPin, ioFlags); //14may15 experiment
80002080:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002084:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80002088:	12 9b       	mov	r11,r9
8000208a:	10 9c       	mov	r12,r8
8000208c:	f0 1f 00 06 	mcall	800020a4 <drive_DQ_low+0x48>

	gpio_set_pin_low(ioPin);
80002090:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80002094:	10 9c       	mov	r12,r8
80002096:	f0 1f 00 05 	mcall	800020a8 <drive_DQ_low+0x4c>

}
8000209a:	2f dd       	sub	sp,-12
8000209c:	e3 cd 80 80 	ldm	sp++,r7,pc
800020a0:	80 00       	ld.sh	r0,r0[0x0]
800020a2:	20 10       	sub	r0,1
800020a4:	80 00       	ld.sh	r0,r0[0x0]
800020a6:	48 28       	lddpc	r8,800020ac <release_the_bus>
800020a8:	80 00       	ld.sh	r0,r0[0x0]
800020aa:	4b 3c       	lddpc	r12,80002174 <SetSpeed>

800020ac <release_the_bus>:

void release_the_bus(unsigned char idx);
void release_the_bus(unsigned char idx)
{
800020ac:	eb cd 40 80 	pushm	r7,lr
800020b0:	1a 97       	mov	r7,sp
800020b2:	20 3d       	sub	sp,12
800020b4:	18 98       	mov	r8,r12
800020b6:	ef 68 ff f4 	st.b	r7[-12],r8
	unsigned char ioPin;
	int32_t ioFlags;
	
	ioPin = io_pin(idx);
800020ba:	ef 38 ff f4 	ld.ub	r8,r7[-12]
800020be:	10 9c       	mov	r12,r8
800020c0:	f0 1f 00 0a 	mcall	800020e8 <release_the_bus+0x3c>
800020c4:	18 98       	mov	r8,r12
800020c6:	ef 68 ff fb 	st.b	r7[-5],r8
	
//14may15 experiment	gpio_set_pin_high(ioPin);
	
	ioFlags = (GPIO_DIR_INPUT); //14may15 experiment
800020ca:	30 08       	mov	r8,0
800020cc:	ef 48 ff fc 	st.w	r7[-4],r8
	gpio_configure_pin(ioPin, ioFlags); //14may15 experiment
800020d0:	ee f9 ff fc 	ld.w	r9,r7[-4]
800020d4:	ef 38 ff fb 	ld.ub	r8,r7[-5]
800020d8:	12 9b       	mov	r11,r9
800020da:	10 9c       	mov	r12,r8
800020dc:	f0 1f 00 04 	mcall	800020ec <release_the_bus+0x40>

}
800020e0:	2f dd       	sub	sp,-12
800020e2:	e3 cd 80 80 	ldm	sp++,r7,pc
800020e6:	00 00       	add	r0,r0
800020e8:	80 00       	ld.sh	r0,r0[0x0]
800020ea:	20 10       	sub	r0,1
800020ec:	80 00       	ld.sh	r0,r0[0x0]
800020ee:	48 28       	lddpc	r8,800020f4 <gpio_input+0x4>

800020f0 <gpio_input>:

void gpio_input(unsigned char idx) //14may15 experiment
{
800020f0:	eb cd 40 80 	pushm	r7,lr
800020f4:	1a 97       	mov	r7,sp
800020f6:	20 3d       	sub	sp,12
800020f8:	18 98       	mov	r8,r12
800020fa:	ef 68 ff f4 	st.b	r7[-12],r8
	uint32_t ioFlags;
	unsigned char ioPin;
		
	ioPin = io_pin(idx);
800020fe:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80002102:	10 9c       	mov	r12,r8
80002104:	f0 1f 00 09 	mcall	80002128 <gpio_input+0x38>
80002108:	18 98       	mov	r8,r12
8000210a:	ef 68 ff ff 	st.b	r7[-1],r8
		
	ioFlags = (GPIO_DIR_INPUT);
8000210e:	30 08       	mov	r8,0
80002110:	ef 48 ff f8 	st.w	r7[-8],r8
	gpio_configure_pin(ioPin, ioFlags);
80002114:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002118:	ee fb ff f8 	ld.w	r11,r7[-8]
8000211c:	10 9c       	mov	r12,r8
8000211e:	f0 1f 00 04 	mcall	8000212c <gpio_input+0x3c>

}
80002122:	2f dd       	sub	sp,-12
80002124:	e3 cd 80 80 	ldm	sp++,r7,pc
80002128:	80 00       	ld.sh	r0,r0[0x0]
8000212a:	20 10       	sub	r0,1
8000212c:	80 00       	ld.sh	r0,r0[0x0]
8000212e:	48 28       	lddpc	r8,80002134 <sample_line+0x4>

80002130 <sample_line>:

unsigned char sample_line(unsigned char idx);
unsigned char sample_line(unsigned char idx)
{
80002130:	eb cd 40 80 	pushm	r7,lr
80002134:	1a 97       	mov	r7,sp
80002136:	20 2d       	sub	sp,8
80002138:	18 98       	mov	r8,r12
8000213a:	ef 68 ff f8 	st.b	r7[-8],r8
//14may15 experiment		uint32_t ioFlags;
		unsigned char retVal, ioPin;
		
		ioPin = io_pin(idx);
8000213e:	ef 38 ff f8 	ld.ub	r8,r7[-8]
80002142:	10 9c       	mov	r12,r8
80002144:	f0 1f 00 0a 	mcall	8000216c <sample_line+0x3c>
80002148:	18 98       	mov	r8,r12
8000214a:	ef 68 ff ff 	st.b	r7[-1],r8
		
//14may15 experiment		ioFlags = (GPIO_DIR_INPUT);
//14may15 experiment		gpio_configure_pin(ioPin, ioFlags);

		retVal = gpio_get_pin_value(ioPin);
8000214e:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002152:	10 9c       	mov	r12,r8
80002154:	f0 1f 00 07 	mcall	80002170 <sample_line+0x40>
80002158:	18 98       	mov	r8,r12
8000215a:	ef 68 ff fe 	st.b	r7[-2],r8

//14may15 experiment		ioFlags = (GPIO_DIR_OUTPUT);
//14may15 experiment		gpio_configure_pin(ioPin, ioFlags);

		return retVal;
8000215e:	ef 38 ff fe 	ld.ub	r8,r7[-2]
}
80002162:	10 9c       	mov	r12,r8
80002164:	2f ed       	sub	sp,-8
80002166:	e3 cd 80 80 	ldm	sp++,r7,pc
8000216a:	00 00       	add	r0,r0
8000216c:	80 00       	ld.sh	r0,r0[0x0]
8000216e:	20 10       	sub	r0,1
80002170:	80 00       	ld.sh	r0,r0[0x0]
80002172:	4a c6       	lddpc	r6,80002220 <SetSpeed+0xac>

80002174 <SetSpeed>:

//-----------------------------------------------------------------------------
// Set the 1-Wire timing to 'standard' (standard=1) or 'overdrive' (standard=0).
//
void SetSpeed(int standard)
{
80002174:	eb cd 40 80 	pushm	r7,lr
80002178:	1a 97       	mov	r7,sp
8000217a:	20 1d       	sub	sp,4
8000217c:	ef 4c ff fc 	st.w	r7[-4],r12
		J = 410;
	}
	
#endif

	if (standard) //experiment 16may15 cut everything in half, some issue with using the PLL? and fudge the tight numbers at the low end
80002180:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002184:	58 08       	cp.w	r8,0
80002186:	c2 20       	breq	800021ca <SetSpeed+0x56>
	{
		// Standard Speed
		A = 0; //6;
80002188:	4a 18       	lddpc	r8,8000220c <SetSpeed+0x98>
8000218a:	30 09       	mov	r9,0
8000218c:	91 09       	st.w	r8[0x0],r9
		B = 32; //64;
8000218e:	4a 18       	lddpc	r8,80002210 <SetSpeed+0x9c>
80002190:	32 09       	mov	r9,32
80002192:	91 09       	st.w	r8[0x0],r9
		C = 30; //60;
80002194:	4a 08       	lddpc	r8,80002214 <SetSpeed+0xa0>
80002196:	31 e9       	mov	r9,30
80002198:	91 09       	st.w	r8[0x0],r9
		D = 2; //10;
8000219a:	4a 08       	lddpc	r8,80002218 <SetSpeed+0xa4>
8000219c:	30 29       	mov	r9,2
8000219e:	91 09       	st.w	r8[0x0],r9
		E = 2; //9;
800021a0:	49 f8       	lddpc	r8,8000221c <SetSpeed+0xa8>
800021a2:	30 29       	mov	r9,2
800021a4:	91 09       	st.w	r8[0x0],r9
		F = 27; //55;
800021a6:	49 f8       	lddpc	r8,80002220 <SetSpeed+0xac>
800021a8:	31 b9       	mov	r9,27
800021aa:	91 09       	st.w	r8[0x0],r9
		G = 0; //0;
800021ac:	49 e8       	lddpc	r8,80002224 <SetSpeed+0xb0>
800021ae:	30 09       	mov	r9,0
800021b0:	91 09       	st.w	r8[0x0],r9
		H = 240; //480;
800021b2:	49 e8       	lddpc	r8,80002228 <SetSpeed+0xb4>
800021b4:	e0 69 00 f0 	mov	r9,240
800021b8:	91 09       	st.w	r8[0x0],r9
		I = 35; //70;
800021ba:	49 d8       	lddpc	r8,8000222c <SetSpeed+0xb8>
800021bc:	32 39       	mov	r9,35
800021be:	91 09       	st.w	r8[0x0],r9
		J = 205; //410;
800021c0:	49 c8       	lddpc	r8,80002230 <SetSpeed+0xbc>
800021c2:	e0 69 00 cd 	mov	r9,205
800021c6:	91 09       	st.w	r8[0x0],r9
800021c8:	c1 f8       	rjmp	80002206 <SetSpeed+0x92>


	else
	{
		// Overdrive Speed
		A = 1.5;
800021ca:	49 18       	lddpc	r8,8000220c <SetSpeed+0x98>
800021cc:	30 19       	mov	r9,1
800021ce:	91 09       	st.w	r8[0x0],r9
		B = 7.5;
800021d0:	49 08       	lddpc	r8,80002210 <SetSpeed+0x9c>
800021d2:	30 79       	mov	r9,7
800021d4:	91 09       	st.w	r8[0x0],r9
		C = 7.5;
800021d6:	49 08       	lddpc	r8,80002214 <SetSpeed+0xa0>
800021d8:	30 79       	mov	r9,7
800021da:	91 09       	st.w	r8[0x0],r9
		D = 2.5;
800021dc:	48 f8       	lddpc	r8,80002218 <SetSpeed+0xa4>
800021de:	30 29       	mov	r9,2
800021e0:	91 09       	st.w	r8[0x0],r9
		E = 0.75;
800021e2:	48 f8       	lddpc	r8,8000221c <SetSpeed+0xa8>
800021e4:	30 09       	mov	r9,0
800021e6:	91 09       	st.w	r8[0x0],r9
		F = 7;
800021e8:	48 e8       	lddpc	r8,80002220 <SetSpeed+0xac>
800021ea:	30 79       	mov	r9,7
800021ec:	91 09       	st.w	r8[0x0],r9
		G = 2.5;
800021ee:	48 e8       	lddpc	r8,80002224 <SetSpeed+0xb0>
800021f0:	30 29       	mov	r9,2
800021f2:	91 09       	st.w	r8[0x0],r9
		H = 70;
800021f4:	48 d8       	lddpc	r8,80002228 <SetSpeed+0xb4>
800021f6:	34 69       	mov	r9,70
800021f8:	91 09       	st.w	r8[0x0],r9
		I = 8.5;
800021fa:	48 d8       	lddpc	r8,8000222c <SetSpeed+0xb8>
800021fc:	30 89       	mov	r9,8
800021fe:	91 09       	st.w	r8[0x0],r9
		J = 40;
80002200:	48 c8       	lddpc	r8,80002230 <SetSpeed+0xbc>
80002202:	32 89       	mov	r9,40
80002204:	91 09       	st.w	r8[0x0],r9
	}
}
80002206:	2f fd       	sub	sp,-4
80002208:	e3 cd 80 80 	ldm	sp++,r7,pc
8000220c:	00 00       	add	r0,r0
8000220e:	08 14       	sub	r4,r4
80002210:	00 00       	add	r0,r0
80002212:	08 18       	sub	r8,r4
80002214:	00 00       	add	r0,r0
80002216:	08 20       	rsub	r0,r4
80002218:	00 00       	add	r0,r0
8000221a:	08 10       	sub	r0,r4
8000221c:	00 00       	add	r0,r0
8000221e:	08 2c       	rsub	r12,r4
80002220:	00 00       	add	r0,r0
80002222:	08 34       	cp.w	r4,r4
80002224:	00 00       	add	r0,r0
80002226:	08 24       	rsub	r4,r4
80002228:	00 00       	add	r0,r0
8000222a:	08 28       	rsub	r8,r4
8000222c:	00 00       	add	r0,r0
8000222e:	08 30       	cp.w	r0,r4
80002230:	00 00       	add	r0,r0
80002232:	08 1c       	sub	r12,r4

80002234 <OWTouchReset>:
// Generate a 1-Wire reset, return 1 if no presence detect was found,
// return 0 otherwise.
// (NOTE: Does not handle alarm presence from DS2404/DS1994)
//
int OWTouchReset(unsigned char idx)
{
80002234:	eb cd 40 8f 	pushm	r0-r3,r7,lr
80002238:	1a 97       	mov	r7,sp
8000223a:	fa cd 00 e0 	sub	sp,sp,224
8000223e:	18 98       	mov	r8,r12
80002240:	ef 68 ff 48 	st.b	r7[-184],r8
	int result;

	cpu_delay_us(A, EC_CPU_CLOCK_100MHZ);
80002244:	fe f8 05 9c 	ld.w	r8,pc[1436]
80002248:	70 08       	ld.w	r8,r8[0x0]
8000224a:	ef 48 ff 84 	st.w	r7[-124],r8
8000224e:	e0 68 e1 00 	mov	r8,57600
80002252:	ea 18 05 f5 	orh	r8,0x5f5
80002256:	ef 48 ff 80 	st.w	r7[-128],r8
8000225a:	ee f8 ff 84 	ld.w	r8,r7[-124]
8000225e:	ef 48 ff 8c 	st.w	r7[-116],r8
80002262:	ee f8 ff 80 	ld.w	r8,r7[-128]
80002266:	ef 48 ff 88 	st.w	r7[-120],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_us_2_cy(unsigned long us, unsigned long fcpu_hz)
{
  return ((unsigned long long)us * fcpu_hz + 999999) / 1000000;
8000226a:	ee f2 ff 8c 	ld.w	r2,r7[-116]
8000226e:	30 03       	mov	r3,0
80002270:	ee fa ff 88 	ld.w	r10,r7[-120]
80002274:	30 0b       	mov	r11,0
80002276:	e6 0a 02 49 	mul	r9,r3,r10
8000227a:	f6 02 02 48 	mul	r8,r11,r2
8000227e:	10 09       	add	r9,r8
80002280:	e4 0a 06 4a 	mulu.d	r10,r2,r10
80002284:	16 09       	add	r9,r11
80002286:	12 9b       	mov	r11,r9
80002288:	ee 78 42 3f 	mov	r8,999999
8000228c:	30 09       	mov	r9,0
8000228e:	10 0a       	add	r10,r8
80002290:	f6 09 00 4b 	adc	r11,r11,r9
80002294:	ee 78 42 40 	mov	r8,1000000
80002298:	30 09       	mov	r9,0
8000229a:	f0 1f 01 53 	mcall	800027e4 <OWTouchReset+0x5b0>
8000229e:	14 98       	mov	r8,r10
800022a0:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_us(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_us_2_cy(delay, fcpu_hz), &timer);
800022a2:	ef 48 ff 94 	st.w	r7[-108],r8
800022a6:	ee c8 00 b4 	sub	r8,r7,180
800022aa:	ef 48 ff 90 	st.w	r7[-112],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800022ae:	e1 b8 00 42 	mfsr	r8,0x108
800022b2:	10 99       	mov	r9,r8
800022b4:	ee f8 ff 90 	ld.w	r8,r7[-112]
800022b8:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800022ba:	ee f8 ff 90 	ld.w	r8,r7[-112]
800022be:	70 09       	ld.w	r9,r8[0x0]
800022c0:	ee f8 ff 94 	ld.w	r8,r7[-108]
800022c4:	10 09       	add	r9,r8
800022c6:	ee f8 ff 90 	ld.w	r8,r7[-112]
800022ca:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
800022cc:	ee f9 ff 90 	ld.w	r9,r7[-112]
800022d0:	30 08       	mov	r8,0
800022d2:	f3 68 00 08 	st.b	r9[8],r8
800022d6:	ee c8 00 b4 	sub	r8,r7,180
800022da:	ef 48 ff 98 	st.w	r7[-104],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800022de:	e1 b8 00 42 	mfsr	r8,0x108
800022e2:	ef 48 ff 9c 	st.w	r7[-100],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
800022e6:	ee f8 ff 98 	ld.w	r8,r7[-104]
800022ea:	f1 39 00 08 	ld.ub	r9,r8[8]
800022ee:	30 28       	mov	r8,2
800022f0:	f0 09 18 00 	cp.b	r9,r8
800022f4:	c0 31       	brne	800022fa <OWTouchReset+0xc6>
    return false;
800022f6:	30 08       	mov	r8,0
800022f8:	c4 38       	rjmp	8000237e <OWTouchReset+0x14a>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
800022fa:	ee f8 ff 98 	ld.w	r8,r7[-104]
800022fe:	f1 39 00 08 	ld.ub	r9,r8[8]
80002302:	30 18       	mov	r8,1
80002304:	f0 09 18 00 	cp.b	r9,r8
80002308:	c0 31       	brne	8000230e <OWTouchReset+0xda>
    return true;
8000230a:	30 18       	mov	r8,1
8000230c:	c3 98       	rjmp	8000237e <OWTouchReset+0x14a>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000230e:	ee f8 ff 98 	ld.w	r8,r7[-104]
80002312:	70 09       	ld.w	r9,r8[0x0]
80002314:	ee f8 ff 98 	ld.w	r8,r7[-104]
80002318:	70 18       	ld.w	r8,r8[0x4]
8000231a:	10 39       	cp.w	r9,r8
8000231c:	e0 88 00 1a 	brls	80002350 <OWTouchReset+0x11c>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002320:	ee f8 ff 98 	ld.w	r8,r7[-104]
80002324:	70 08       	ld.w	r8,r8[0x0]
80002326:	ee f9 ff 9c 	ld.w	r9,r7[-100]
8000232a:	10 39       	cp.w	r9,r8
8000232c:	c1 02       	brcc	8000234c <OWTouchReset+0x118>
8000232e:	ee f8 ff 98 	ld.w	r8,r7[-104]
80002332:	70 18       	ld.w	r8,r8[0x4]
80002334:	ee f9 ff 9c 	ld.w	r9,r7[-100]
80002338:	10 39       	cp.w	r9,r8
8000233a:	e0 88 00 09 	brls	8000234c <OWTouchReset+0x118>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
8000233e:	ee f9 ff 98 	ld.w	r9,r7[-104]
80002342:	30 18       	mov	r8,1
80002344:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002348:	30 18       	mov	r8,1
8000234a:	c1 a8       	rjmp	8000237e <OWTouchReset+0x14a>
    }
    return false;
8000234c:	30 08       	mov	r8,0
8000234e:	c1 88       	rjmp	8000237e <OWTouchReset+0x14a>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002350:	ee f8 ff 98 	ld.w	r8,r7[-104]
80002354:	70 08       	ld.w	r8,r8[0x0]
80002356:	ee f9 ff 9c 	ld.w	r9,r7[-100]
8000235a:	10 39       	cp.w	r9,r8
8000235c:	c0 93       	brcs	8000236e <OWTouchReset+0x13a>
8000235e:	ee f8 ff 98 	ld.w	r8,r7[-104]
80002362:	70 18       	ld.w	r8,r8[0x4]
80002364:	ee f9 ff 9c 	ld.w	r9,r7[-100]
80002368:	10 39       	cp.w	r9,r8
8000236a:	e0 88 00 09 	brls	8000237c <OWTouchReset+0x148>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
8000236e:	ee f9 ff 98 	ld.w	r9,r7[-104]
80002372:	30 18       	mov	r8,1
80002374:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002378:	30 18       	mov	r8,1
8000237a:	c0 28       	rjmp	8000237e <OWTouchReset+0x14a>
    }
    return false;
8000237c:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_us(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_us_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
8000237e:	58 08       	cp.w	r8,0
80002380:	ca b0       	breq	800022d6 <OWTouchReset+0xa2>
	drive_DQ_low(idx);
80002382:	ef 38 ff 48 	ld.ub	r8,r7[-184]
80002386:	10 9c       	mov	r12,r8
80002388:	f0 1f 01 18 	mcall	800027e8 <OWTouchReset+0x5b4>
	cpu_delay_us(H, EC_CPU_CLOCK_100MHZ);	//tRSTL (reset low) 480-640us
8000238c:	fe f8 04 60 	ld.w	r8,pc[1120]
80002390:	70 08       	ld.w	r8,r8[0x0]
80002392:	ef 48 ff a4 	st.w	r7[-92],r8
80002396:	e0 68 e1 00 	mov	r8,57600
8000239a:	ea 18 05 f5 	orh	r8,0x5f5
8000239e:	ef 48 ff a0 	st.w	r7[-96],r8
800023a2:	ee f8 ff a4 	ld.w	r8,r7[-92]
800023a6:	ef 48 ff ac 	st.w	r7[-84],r8
800023aa:	ee f8 ff a0 	ld.w	r8,r7[-96]
800023ae:	ef 48 ff a8 	st.w	r7[-88],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_us_2_cy(unsigned long us, unsigned long fcpu_hz)
{
  return ((unsigned long long)us * fcpu_hz + 999999) / 1000000;
800023b2:	ee fc ff ac 	ld.w	r12,r7[-84]
800023b6:	ef 4c ff 2c 	st.w	r7[-212],r12
800023ba:	30 0b       	mov	r11,0
800023bc:	ef 4b ff 28 	st.w	r7[-216],r11
800023c0:	ee f9 ff a8 	ld.w	r9,r7[-88]
800023c4:	ef 49 ff 24 	st.w	r7[-220],r9
800023c8:	30 08       	mov	r8,0
800023ca:	ef 48 ff 20 	st.w	r7[-224],r8
800023ce:	ee fa ff 28 	ld.w	r10,r7[-216]
800023d2:	ee fc ff 24 	ld.w	r12,r7[-220]
800023d6:	b9 3a       	mul	r10,r12
800023d8:	ee f8 ff 20 	ld.w	r8,r7[-224]
800023dc:	ee fb ff 2c 	ld.w	r11,r7[-212]
800023e0:	b7 38       	mul	r8,r11
800023e2:	10 0a       	add	r10,r8
800023e4:	ee fc ff 2c 	ld.w	r12,r7[-212]
800023e8:	ee fb ff 24 	ld.w	r11,r7[-220]
800023ec:	f8 0b 06 48 	mulu.d	r8,r12,r11
800023f0:	12 0a       	add	r10,r9
800023f2:	14 99       	mov	r9,r10
800023f4:	ee 7a 42 3f 	mov	r10,999999
800023f8:	30 0b       	mov	r11,0
800023fa:	f0 0a 00 0a 	add	r10,r8,r10
800023fe:	f2 0b 00 4b 	adc	r11,r9,r11
80002402:	ee 78 42 40 	mov	r8,1000000
80002406:	30 09       	mov	r9,0
80002408:	f0 1f 00 f7 	mcall	800027e4 <OWTouchReset+0x5b0>
8000240c:	14 98       	mov	r8,r10
8000240e:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_us(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_us_2_cy(delay, fcpu_hz), &timer);
80002410:	ef 48 ff b4 	st.w	r7[-76],r8
80002414:	ee c8 00 a8 	sub	r8,r7,168
80002418:	ef 48 ff b0 	st.w	r7[-80],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000241c:	e1 b8 00 42 	mfsr	r8,0x108
80002420:	10 99       	mov	r9,r8
80002422:	ee f8 ff b0 	ld.w	r8,r7[-80]
80002426:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002428:	ee f8 ff b0 	ld.w	r8,r7[-80]
8000242c:	70 09       	ld.w	r9,r8[0x0]
8000242e:	ee f8 ff b4 	ld.w	r8,r7[-76]
80002432:	10 09       	add	r9,r8
80002434:	ee f8 ff b0 	ld.w	r8,r7[-80]
80002438:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
8000243a:	ee f9 ff b0 	ld.w	r9,r7[-80]
8000243e:	30 08       	mov	r8,0
80002440:	f3 68 00 08 	st.b	r9[8],r8
80002444:	ee c8 00 a8 	sub	r8,r7,168
80002448:	ef 48 ff b8 	st.w	r7[-72],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000244c:	e1 b8 00 42 	mfsr	r8,0x108
80002450:	ef 48 ff bc 	st.w	r7[-68],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
80002454:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002458:	f1 39 00 08 	ld.ub	r9,r8[8]
8000245c:	30 28       	mov	r8,2
8000245e:	f0 09 18 00 	cp.b	r9,r8
80002462:	c0 31       	brne	80002468 <OWTouchReset+0x234>
    return false;
80002464:	30 08       	mov	r8,0
80002466:	c4 38       	rjmp	800024ec <OWTouchReset+0x2b8>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
80002468:	ee f8 ff b8 	ld.w	r8,r7[-72]
8000246c:	f1 39 00 08 	ld.ub	r9,r8[8]
80002470:	30 18       	mov	r8,1
80002472:	f0 09 18 00 	cp.b	r9,r8
80002476:	c0 31       	brne	8000247c <OWTouchReset+0x248>
    return true;
80002478:	30 18       	mov	r8,1
8000247a:	c3 98       	rjmp	800024ec <OWTouchReset+0x2b8>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000247c:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002480:	70 09       	ld.w	r9,r8[0x0]
80002482:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002486:	70 18       	ld.w	r8,r8[0x4]
80002488:	10 39       	cp.w	r9,r8
8000248a:	e0 88 00 1a 	brls	800024be <OWTouchReset+0x28a>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000248e:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002492:	70 08       	ld.w	r8,r8[0x0]
80002494:	ee f9 ff bc 	ld.w	r9,r7[-68]
80002498:	10 39       	cp.w	r9,r8
8000249a:	c1 02       	brcc	800024ba <OWTouchReset+0x286>
8000249c:	ee f8 ff b8 	ld.w	r8,r7[-72]
800024a0:	70 18       	ld.w	r8,r8[0x4]
800024a2:	ee f9 ff bc 	ld.w	r9,r7[-68]
800024a6:	10 39       	cp.w	r9,r8
800024a8:	e0 88 00 09 	brls	800024ba <OWTouchReset+0x286>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
800024ac:	ee f9 ff b8 	ld.w	r9,r7[-72]
800024b0:	30 18       	mov	r8,1
800024b2:	f3 68 00 08 	st.b	r9[8],r8
      return true;
800024b6:	30 18       	mov	r8,1
800024b8:	c1 a8       	rjmp	800024ec <OWTouchReset+0x2b8>
    }
    return false;
800024ba:	30 08       	mov	r8,0
800024bc:	c1 88       	rjmp	800024ec <OWTouchReset+0x2b8>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800024be:	ee f8 ff b8 	ld.w	r8,r7[-72]
800024c2:	70 08       	ld.w	r8,r8[0x0]
800024c4:	ee f9 ff bc 	ld.w	r9,r7[-68]
800024c8:	10 39       	cp.w	r9,r8
800024ca:	c0 93       	brcs	800024dc <OWTouchReset+0x2a8>
800024cc:	ee f8 ff b8 	ld.w	r8,r7[-72]
800024d0:	70 18       	ld.w	r8,r8[0x4]
800024d2:	ee f9 ff bc 	ld.w	r9,r7[-68]
800024d6:	10 39       	cp.w	r9,r8
800024d8:	e0 88 00 09 	brls	800024ea <OWTouchReset+0x2b6>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
800024dc:	ee f9 ff b8 	ld.w	r9,r7[-72]
800024e0:	30 18       	mov	r8,1
800024e2:	f3 68 00 08 	st.b	r9[8],r8
      return true;
800024e6:	30 18       	mov	r8,1
800024e8:	c0 28       	rjmp	800024ec <OWTouchReset+0x2b8>
    }
    return false;
800024ea:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_us(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_us_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
800024ec:	58 08       	cp.w	r8,0
800024ee:	ca b0       	breq	80002444 <OWTouchReset+0x210>
	release_the_bus(idx);
800024f0:	ef 38 ff 48 	ld.ub	r8,r7[-184]
800024f4:	10 9c       	mov	r12,r8
800024f6:	f0 1f 00 bf 	mcall	800027f0 <OWTouchReset+0x5bc>
	
	gpio_input(idx); //14may15 experiment
800024fa:	ef 38 ff 48 	ld.ub	r8,r7[-184]
800024fe:	10 9c       	mov	r12,r8
80002500:	f0 1f 00 bd 	mcall	800027f4 <OWTouchReset+0x5c0>

	
	cpu_delay_us(I, EC_CPU_CLOCK_100MHZ);	//tMSP (presence detect sample) 60-75us
80002504:	fe f8 02 f4 	ld.w	r8,pc[756]
80002508:	70 08       	ld.w	r8,r8[0x0]
8000250a:	ef 48 ff c4 	st.w	r7[-60],r8
8000250e:	e0 68 e1 00 	mov	r8,57600
80002512:	ea 18 05 f5 	orh	r8,0x5f5
80002516:	ef 48 ff c0 	st.w	r7[-64],r8
8000251a:	ee f8 ff c4 	ld.w	r8,r7[-60]
8000251e:	ef 48 ff cc 	st.w	r7[-52],r8
80002522:	ee f8 ff c0 	ld.w	r8,r7[-64]
80002526:	ef 48 ff c8 	st.w	r7[-56],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_us_2_cy(unsigned long us, unsigned long fcpu_hz)
{
  return ((unsigned long long)us * fcpu_hz + 999999) / 1000000;
8000252a:	ee f9 ff cc 	ld.w	r9,r7[-52]
8000252e:	ef 49 ff 3c 	st.w	r7[-196],r9
80002532:	30 08       	mov	r8,0
80002534:	ef 48 ff 38 	st.w	r7[-200],r8
80002538:	ee fc ff c8 	ld.w	r12,r7[-56]
8000253c:	ef 4c ff 34 	st.w	r7[-204],r12
80002540:	30 0b       	mov	r11,0
80002542:	ef 4b ff 30 	st.w	r7[-208],r11
80002546:	ee fa ff 38 	ld.w	r10,r7[-200]
8000254a:	ee f9 ff 34 	ld.w	r9,r7[-204]
8000254e:	b3 3a       	mul	r10,r9
80002550:	ee f8 ff 30 	ld.w	r8,r7[-208]
80002554:	ee fc ff 3c 	ld.w	r12,r7[-196]
80002558:	b9 38       	mul	r8,r12
8000255a:	10 0a       	add	r10,r8
8000255c:	ee fb ff 3c 	ld.w	r11,r7[-196]
80002560:	ee fc ff 34 	ld.w	r12,r7[-204]
80002564:	f6 0c 06 48 	mulu.d	r8,r11,r12
80002568:	12 0a       	add	r10,r9
8000256a:	14 99       	mov	r9,r10
8000256c:	ee 7a 42 3f 	mov	r10,999999
80002570:	30 0b       	mov	r11,0
80002572:	f0 0a 00 0a 	add	r10,r8,r10
80002576:	f2 0b 00 4b 	adc	r11,r9,r11
8000257a:	ee 78 42 40 	mov	r8,1000000
8000257e:	30 09       	mov	r9,0
80002580:	f0 1f 00 99 	mcall	800027e4 <OWTouchReset+0x5b0>
80002584:	14 98       	mov	r8,r10
80002586:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_us(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_us_2_cy(delay, fcpu_hz), &timer);
80002588:	ef 48 ff d4 	st.w	r7[-44],r8
8000258c:	ee c8 00 9c 	sub	r8,r7,156
80002590:	ef 48 ff d0 	st.w	r7[-48],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002594:	e1 b8 00 42 	mfsr	r8,0x108
80002598:	10 99       	mov	r9,r8
8000259a:	ee f8 ff d0 	ld.w	r8,r7[-48]
8000259e:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800025a0:	ee f8 ff d0 	ld.w	r8,r7[-48]
800025a4:	70 09       	ld.w	r9,r8[0x0]
800025a6:	ee f8 ff d4 	ld.w	r8,r7[-44]
800025aa:	10 09       	add	r9,r8
800025ac:	ee f8 ff d0 	ld.w	r8,r7[-48]
800025b0:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
800025b2:	ee f9 ff d0 	ld.w	r9,r7[-48]
800025b6:	30 08       	mov	r8,0
800025b8:	f3 68 00 08 	st.b	r9[8],r8
800025bc:	ee c8 00 9c 	sub	r8,r7,156
800025c0:	ef 48 ff d8 	st.w	r7[-40],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800025c4:	e1 b8 00 42 	mfsr	r8,0x108
800025c8:	ef 48 ff dc 	st.w	r7[-36],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
800025cc:	ee f8 ff d8 	ld.w	r8,r7[-40]
800025d0:	f1 39 00 08 	ld.ub	r9,r8[8]
800025d4:	30 28       	mov	r8,2
800025d6:	f0 09 18 00 	cp.b	r9,r8
800025da:	c0 31       	brne	800025e0 <OWTouchReset+0x3ac>
    return false;
800025dc:	30 08       	mov	r8,0
800025de:	c4 38       	rjmp	80002664 <OWTouchReset+0x430>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
800025e0:	ee f8 ff d8 	ld.w	r8,r7[-40]
800025e4:	f1 39 00 08 	ld.ub	r9,r8[8]
800025e8:	30 18       	mov	r8,1
800025ea:	f0 09 18 00 	cp.b	r9,r8
800025ee:	c0 31       	brne	800025f4 <OWTouchReset+0x3c0>
    return true;
800025f0:	30 18       	mov	r8,1
800025f2:	c3 98       	rjmp	80002664 <OWTouchReset+0x430>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800025f4:	ee f8 ff d8 	ld.w	r8,r7[-40]
800025f8:	70 09       	ld.w	r9,r8[0x0]
800025fa:	ee f8 ff d8 	ld.w	r8,r7[-40]
800025fe:	70 18       	ld.w	r8,r8[0x4]
80002600:	10 39       	cp.w	r9,r8
80002602:	e0 88 00 1a 	brls	80002636 <OWTouchReset+0x402>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002606:	ee f8 ff d8 	ld.w	r8,r7[-40]
8000260a:	70 08       	ld.w	r8,r8[0x0]
8000260c:	ee f9 ff dc 	ld.w	r9,r7[-36]
80002610:	10 39       	cp.w	r9,r8
80002612:	c1 02       	brcc	80002632 <OWTouchReset+0x3fe>
80002614:	ee f8 ff d8 	ld.w	r8,r7[-40]
80002618:	70 18       	ld.w	r8,r8[0x4]
8000261a:	ee f9 ff dc 	ld.w	r9,r7[-36]
8000261e:	10 39       	cp.w	r9,r8
80002620:	e0 88 00 09 	brls	80002632 <OWTouchReset+0x3fe>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002624:	ee f9 ff d8 	ld.w	r9,r7[-40]
80002628:	30 18       	mov	r8,1
8000262a:	f3 68 00 08 	st.b	r9[8],r8
      return true;
8000262e:	30 18       	mov	r8,1
80002630:	c1 a8       	rjmp	80002664 <OWTouchReset+0x430>
    }
    return false;
80002632:	30 08       	mov	r8,0
80002634:	c1 88       	rjmp	80002664 <OWTouchReset+0x430>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002636:	ee f8 ff d8 	ld.w	r8,r7[-40]
8000263a:	70 08       	ld.w	r8,r8[0x0]
8000263c:	ee f9 ff dc 	ld.w	r9,r7[-36]
80002640:	10 39       	cp.w	r9,r8
80002642:	c0 93       	brcs	80002654 <OWTouchReset+0x420>
80002644:	ee f8 ff d8 	ld.w	r8,r7[-40]
80002648:	70 18       	ld.w	r8,r8[0x4]
8000264a:	ee f9 ff dc 	ld.w	r9,r7[-36]
8000264e:	10 39       	cp.w	r9,r8
80002650:	e0 88 00 09 	brls	80002662 <OWTouchReset+0x42e>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002654:	ee f9 ff d8 	ld.w	r9,r7[-40]
80002658:	30 18       	mov	r8,1
8000265a:	f3 68 00 08 	st.b	r9[8],r8
      return true;
8000265e:	30 18       	mov	r8,1
80002660:	c0 28       	rjmp	80002664 <OWTouchReset+0x430>
    }
    return false;
80002662:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_us(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_us_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
80002664:	58 08       	cp.w	r8,0
80002666:	ca b0       	breq	800025bc <OWTouchReset+0x388>
	result = sample_line(idx);
80002668:	ef 38 ff 48 	ld.ub	r8,r7[-184]
8000266c:	10 9c       	mov	r12,r8
8000266e:	f0 1f 00 64 	mcall	800027fc <OWTouchReset+0x5c8>
80002672:	18 98       	mov	r8,r12
80002674:	ef 48 ff 7c 	st.w	r7[-132],r8
	
	gpio_input(idx); //14may15 experiement
80002678:	ef 38 ff 48 	ld.ub	r8,r7[-184]
8000267c:	10 9c       	mov	r12,r8
8000267e:	f0 1f 00 5e 	mcall	800027f4 <OWTouchReset+0x5c0>

	cpu_delay_us(J, EC_CPU_CLOCK_100MHZ); // Complete the reset sequence recovery 5-??us (no max?)
80002682:	4e 08       	lddpc	r8,80002800 <OWTouchReset+0x5cc>
80002684:	70 08       	ld.w	r8,r8[0x0]
80002686:	ef 48 ff e4 	st.w	r7[-28],r8
8000268a:	e0 68 e1 00 	mov	r8,57600
8000268e:	ea 18 05 f5 	orh	r8,0x5f5
80002692:	ef 48 ff e0 	st.w	r7[-32],r8
80002696:	ee f8 ff e4 	ld.w	r8,r7[-28]
8000269a:	ef 48 ff ec 	st.w	r7[-20],r8
8000269e:	ee f8 ff e0 	ld.w	r8,r7[-32]
800026a2:	ef 48 ff e8 	st.w	r7[-24],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_us_2_cy(unsigned long us, unsigned long fcpu_hz)
{
  return ((unsigned long long)us * fcpu_hz + 999999) / 1000000;
800026a6:	ee fb ff ec 	ld.w	r11,r7[-20]
800026aa:	ef 4b ff 44 	st.w	r7[-188],r11
800026ae:	30 09       	mov	r9,0
800026b0:	ef 49 ff 40 	st.w	r7[-192],r9
800026b4:	ee f0 ff e8 	ld.w	r0,r7[-24]
800026b8:	30 01       	mov	r1,0
800026ba:	ee fa ff 40 	ld.w	r10,r7[-192]
800026be:	a1 3a       	mul	r10,r0
800026c0:	ee fc ff 44 	ld.w	r12,r7[-188]
800026c4:	e2 0c 02 48 	mul	r8,r1,r12
800026c8:	10 0a       	add	r10,r8
800026ca:	ee fb ff 44 	ld.w	r11,r7[-188]
800026ce:	f6 00 06 48 	mulu.d	r8,r11,r0
800026d2:	12 0a       	add	r10,r9
800026d4:	14 99       	mov	r9,r10
800026d6:	ee 7a 42 3f 	mov	r10,999999
800026da:	30 0b       	mov	r11,0
800026dc:	f0 0a 00 0a 	add	r10,r8,r10
800026e0:	f2 0b 00 4b 	adc	r11,r9,r11
800026e4:	ee 78 42 40 	mov	r8,1000000
800026e8:	30 09       	mov	r9,0
800026ea:	f0 1f 00 3f 	mcall	800027e4 <OWTouchReset+0x5b0>
800026ee:	14 98       	mov	r8,r10
800026f0:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_us(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_us_2_cy(delay, fcpu_hz), &timer);
800026f2:	ef 48 ff f4 	st.w	r7[-12],r8
800026f6:	ee c8 00 90 	sub	r8,r7,144
800026fa:	ef 48 ff f0 	st.w	r7[-16],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800026fe:	e1 b8 00 42 	mfsr	r8,0x108
80002702:	10 99       	mov	r9,r8
80002704:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002708:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000270a:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000270e:	70 09       	ld.w	r9,r8[0x0]
80002710:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002714:	10 09       	add	r9,r8
80002716:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000271a:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
8000271c:	ee f9 ff f0 	ld.w	r9,r7[-16]
80002720:	30 08       	mov	r8,0
80002722:	f3 68 00 08 	st.b	r9[8],r8
80002726:	ee c8 00 90 	sub	r8,r7,144
8000272a:	ef 48 ff f8 	st.w	r7[-8],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000272e:	e1 b8 00 42 	mfsr	r8,0x108
80002732:	ef 48 ff fc 	st.w	r7[-4],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
80002736:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000273a:	f1 39 00 08 	ld.ub	r9,r8[8]
8000273e:	30 28       	mov	r8,2
80002740:	f0 09 18 00 	cp.b	r9,r8
80002744:	c0 31       	brne	8000274a <OWTouchReset+0x516>
    return false;
80002746:	30 08       	mov	r8,0
80002748:	c4 38       	rjmp	800027ce <OWTouchReset+0x59a>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
8000274a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000274e:	f1 39 00 08 	ld.ub	r9,r8[8]
80002752:	30 18       	mov	r8,1
80002754:	f0 09 18 00 	cp.b	r9,r8
80002758:	c0 31       	brne	8000275e <OWTouchReset+0x52a>
    return true;
8000275a:	30 18       	mov	r8,1
8000275c:	c3 98       	rjmp	800027ce <OWTouchReset+0x59a>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000275e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002762:	70 09       	ld.w	r9,r8[0x0]
80002764:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002768:	70 18       	ld.w	r8,r8[0x4]
8000276a:	10 39       	cp.w	r9,r8
8000276c:	e0 88 00 1a 	brls	800027a0 <OWTouchReset+0x56c>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002770:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002774:	70 08       	ld.w	r8,r8[0x0]
80002776:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000277a:	10 39       	cp.w	r9,r8
8000277c:	c1 02       	brcc	8000279c <OWTouchReset+0x568>
8000277e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002782:	70 18       	ld.w	r8,r8[0x4]
80002784:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002788:	10 39       	cp.w	r9,r8
8000278a:	e0 88 00 09 	brls	8000279c <OWTouchReset+0x568>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
8000278e:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002792:	30 18       	mov	r8,1
80002794:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002798:	30 18       	mov	r8,1
8000279a:	c1 a8       	rjmp	800027ce <OWTouchReset+0x59a>
    }
    return false;
8000279c:	30 08       	mov	r8,0
8000279e:	c1 88       	rjmp	800027ce <OWTouchReset+0x59a>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800027a0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800027a4:	70 08       	ld.w	r8,r8[0x0]
800027a6:	ee f9 ff fc 	ld.w	r9,r7[-4]
800027aa:	10 39       	cp.w	r9,r8
800027ac:	c0 93       	brcs	800027be <OWTouchReset+0x58a>
800027ae:	ee f8 ff f8 	ld.w	r8,r7[-8]
800027b2:	70 18       	ld.w	r8,r8[0x4]
800027b4:	ee f9 ff fc 	ld.w	r9,r7[-4]
800027b8:	10 39       	cp.w	r9,r8
800027ba:	e0 88 00 09 	brls	800027cc <OWTouchReset+0x598>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
800027be:	ee f9 ff f8 	ld.w	r9,r7[-8]
800027c2:	30 18       	mov	r8,1
800027c4:	f3 68 00 08 	st.b	r9[8],r8
      return true;
800027c8:	30 18       	mov	r8,1
800027ca:	c0 28       	rjmp	800027ce <OWTouchReset+0x59a>
    }
    return false;
800027cc:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_us(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_us_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
800027ce:	58 08       	cp.w	r8,0
800027d0:	ca b0       	breq	80002726 <OWTouchReset+0x4f2>
	return result; // Return sample presence pulse result
800027d2:	ee f8 ff 7c 	ld.w	r8,r7[-132]
}
800027d6:	10 9c       	mov	r12,r8
800027d8:	2c 8d       	sub	sp,-224
800027da:	e3 cd 80 8f 	ldm	sp++,r0-r3,r7,pc
800027de:	00 00       	add	r0,r0
800027e0:	00 00       	add	r0,r0
800027e2:	08 14       	sub	r4,r4
800027e4:	80 00       	ld.sh	r0,r0[0x0]
800027e6:	ca 56       	brmi	80002730 <OWTouchReset+0x4fc>
800027e8:	80 00       	ld.sh	r0,r0[0x0]
800027ea:	20 5c       	sub	r12,5
800027ec:	00 00       	add	r0,r0
800027ee:	08 28       	rsub	r8,r4
800027f0:	80 00       	ld.sh	r0,r0[0x0]
800027f2:	20 ac       	sub	r12,10
800027f4:	80 00       	ld.sh	r0,r0[0x0]
800027f6:	20 f0       	sub	r0,15
800027f8:	00 00       	add	r0,r0
800027fa:	08 30       	cp.w	r0,r4
800027fc:	80 00       	ld.sh	r0,r0[0x0]
800027fe:	21 30       	sub	r0,19
80002800:	00 00       	add	r0,r0
80002802:	08 1c       	sub	r12,r4

80002804 <drive_DQ_low_and_release_the_bus>:

void drive_DQ_low_and_release_the_bus(unsigned char idx);
void drive_DQ_low_and_release_the_bus(unsigned char idx)
{
80002804:	eb cd 40 8f 	pushm	r0-r3,r7,lr
80002808:	1a 97       	mov	r7,sp
8000280a:	20 fd       	sub	sp,60
8000280c:	18 98       	mov	r8,r12
8000280e:	ef 68 ff c4 	st.b	r7[-60],r8
	unsigned char ioPin;
	int32_t ioFlagsOutput, ioFlagsInput;
	
	ioPin = io_pin(idx);
80002812:	ef 38 ff c4 	ld.ub	r8,r7[-60]
80002816:	10 9c       	mov	r12,r8
80002818:	f0 1f 00 61 	mcall	8000299c <drive_DQ_low_and_release_the_bus+0x198>
8000281c:	18 98       	mov	r8,r12
8000281e:	ef 68 ff d7 	st.b	r7[-41],r8
	
	ioFlagsInput = (GPIO_DIR_INPUT);
80002822:	30 08       	mov	r8,0
80002824:	ef 48 ff dc 	st.w	r7[-36],r8
	ioFlagsOutput = (GPIO_DIR_OUTPUT); //14may15 experiment
80002828:	30 18       	mov	r8,1
8000282a:	ef 48 ff d8 	st.w	r7[-40],r8

	gpio_configure_pin(ioPin, ioFlagsOutput); //14may15 experiment
8000282e:	ee f9 ff d8 	ld.w	r9,r7[-40]
80002832:	ef 38 ff d7 	ld.ub	r8,r7[-41]
80002836:	12 9b       	mov	r11,r9
80002838:	10 9c       	mov	r12,r8
8000283a:	f0 1f 00 5a 	mcall	800029a0 <drive_DQ_low_and_release_the_bus+0x19c>

	gpio_set_pin_low(ioPin);
8000283e:	ef 38 ff d7 	ld.ub	r8,r7[-41]
80002842:	10 9c       	mov	r12,r8
80002844:	f0 1f 00 58 	mcall	800029a4 <drive_DQ_low_and_release_the_bus+0x1a0>
	
	cpu_delay_us(A, EC_CPU_CLOCK_100MHZ);	//tW1L 5-15us
80002848:	4d 88       	lddpc	r8,800029a8 <drive_DQ_low_and_release_the_bus+0x1a4>
8000284a:	70 08       	ld.w	r8,r8[0x0]
8000284c:	ef 48 ff e4 	st.w	r7[-28],r8
80002850:	e0 68 e1 00 	mov	r8,57600
80002854:	ea 18 05 f5 	orh	r8,0x5f5
80002858:	ef 48 ff e0 	st.w	r7[-32],r8
8000285c:	ee f8 ff e4 	ld.w	r8,r7[-28]
80002860:	ef 48 ff ec 	st.w	r7[-20],r8
80002864:	ee f8 ff e0 	ld.w	r8,r7[-32]
80002868:	ef 48 ff e8 	st.w	r7[-24],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_us_2_cy(unsigned long us, unsigned long fcpu_hz)
{
  return ((unsigned long long)us * fcpu_hz + 999999) / 1000000;
8000286c:	ee f0 ff ec 	ld.w	r0,r7[-20]
80002870:	30 01       	mov	r1,0
80002872:	ee f2 ff e8 	ld.w	r2,r7[-24]
80002876:	30 03       	mov	r3,0
80002878:	e2 02 02 4a 	mul	r10,r1,r2
8000287c:	e6 00 02 48 	mul	r8,r3,r0
80002880:	10 0a       	add	r10,r8
80002882:	e0 02 06 48 	mulu.d	r8,r0,r2
80002886:	12 0a       	add	r10,r9
80002888:	14 99       	mov	r9,r10
8000288a:	ee 7a 42 3f 	mov	r10,999999
8000288e:	30 0b       	mov	r11,0
80002890:	f0 0a 00 0a 	add	r10,r8,r10
80002894:	f2 0b 00 4b 	adc	r11,r9,r11
80002898:	ee 78 42 40 	mov	r8,1000000
8000289c:	30 09       	mov	r9,0
8000289e:	f0 1f 00 44 	mcall	800029ac <drive_DQ_low_and_release_the_bus+0x1a8>
800028a2:	14 98       	mov	r8,r10
800028a4:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_us(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_us_2_cy(delay, fcpu_hz), &timer);
800028a6:	ef 48 ff f4 	st.w	r7[-12],r8
800028aa:	ee c8 00 38 	sub	r8,r7,56
800028ae:	ef 48 ff f0 	st.w	r7[-16],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800028b2:	e1 b8 00 42 	mfsr	r8,0x108
800028b6:	10 99       	mov	r9,r8
800028b8:	ee f8 ff f0 	ld.w	r8,r7[-16]
800028bc:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800028be:	ee f8 ff f0 	ld.w	r8,r7[-16]
800028c2:	70 09       	ld.w	r9,r8[0x0]
800028c4:	ee f8 ff f4 	ld.w	r8,r7[-12]
800028c8:	10 09       	add	r9,r8
800028ca:	ee f8 ff f0 	ld.w	r8,r7[-16]
800028ce:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
800028d0:	ee f9 ff f0 	ld.w	r9,r7[-16]
800028d4:	30 08       	mov	r8,0
800028d6:	f3 68 00 08 	st.b	r9[8],r8
800028da:	ee c8 00 38 	sub	r8,r7,56
800028de:	ef 48 ff f8 	st.w	r7[-8],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800028e2:	e1 b8 00 42 	mfsr	r8,0x108
800028e6:	ef 48 ff fc 	st.w	r7[-4],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
800028ea:	ee f8 ff f8 	ld.w	r8,r7[-8]
800028ee:	f1 39 00 08 	ld.ub	r9,r8[8]
800028f2:	30 28       	mov	r8,2
800028f4:	f0 09 18 00 	cp.b	r9,r8
800028f8:	c0 31       	brne	800028fe <drive_DQ_low_and_release_the_bus+0xfa>
    return false;
800028fa:	30 08       	mov	r8,0
800028fc:	c4 38       	rjmp	80002982 <drive_DQ_low_and_release_the_bus+0x17e>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
800028fe:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002902:	f1 39 00 08 	ld.ub	r9,r8[8]
80002906:	30 18       	mov	r8,1
80002908:	f0 09 18 00 	cp.b	r9,r8
8000290c:	c0 31       	brne	80002912 <drive_DQ_low_and_release_the_bus+0x10e>
    return true;
8000290e:	30 18       	mov	r8,1
80002910:	c3 98       	rjmp	80002982 <drive_DQ_low_and_release_the_bus+0x17e>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002912:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002916:	70 09       	ld.w	r9,r8[0x0]
80002918:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000291c:	70 18       	ld.w	r8,r8[0x4]
8000291e:	10 39       	cp.w	r9,r8
80002920:	e0 88 00 1a 	brls	80002954 <drive_DQ_low_and_release_the_bus+0x150>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002924:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002928:	70 08       	ld.w	r8,r8[0x0]
8000292a:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000292e:	10 39       	cp.w	r9,r8
80002930:	c1 02       	brcc	80002950 <drive_DQ_low_and_release_the_bus+0x14c>
80002932:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002936:	70 18       	ld.w	r8,r8[0x4]
80002938:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000293c:	10 39       	cp.w	r9,r8
8000293e:	e0 88 00 09 	brls	80002950 <drive_DQ_low_and_release_the_bus+0x14c>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002942:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002946:	30 18       	mov	r8,1
80002948:	f3 68 00 08 	st.b	r9[8],r8
      return true;
8000294c:	30 18       	mov	r8,1
8000294e:	c1 a8       	rjmp	80002982 <drive_DQ_low_and_release_the_bus+0x17e>
    }
    return false;
80002950:	30 08       	mov	r8,0
80002952:	c1 88       	rjmp	80002982 <drive_DQ_low_and_release_the_bus+0x17e>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002954:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002958:	70 08       	ld.w	r8,r8[0x0]
8000295a:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000295e:	10 39       	cp.w	r9,r8
80002960:	c0 93       	brcs	80002972 <drive_DQ_low_and_release_the_bus+0x16e>
80002962:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002966:	70 18       	ld.w	r8,r8[0x4]
80002968:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000296c:	10 39       	cp.w	r9,r8
8000296e:	e0 88 00 09 	brls	80002980 <drive_DQ_low_and_release_the_bus+0x17c>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002972:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002976:	30 18       	mov	r8,1
80002978:	f3 68 00 08 	st.b	r9[8],r8
      return true;
8000297c:	30 18       	mov	r8,1
8000297e:	c0 28       	rjmp	80002982 <drive_DQ_low_and_release_the_bus+0x17e>
    }
    return false;
80002980:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_us(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_us_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
80002982:	58 08       	cp.w	r8,0
80002984:	ca b0       	breq	800028da <drive_DQ_low_and_release_the_bus+0xd6>

	gpio_configure_pin(ioPin, ioFlagsInput); //14may15 experiment
80002986:	ee f9 ff dc 	ld.w	r9,r7[-36]
8000298a:	ef 38 ff d7 	ld.ub	r8,r7[-41]
8000298e:	12 9b       	mov	r11,r9
80002990:	10 9c       	mov	r12,r8
80002992:	f0 1f 00 04 	mcall	800029a0 <drive_DQ_low_and_release_the_bus+0x19c>
	
}
80002996:	2f 1d       	sub	sp,-60
80002998:	e3 cd 80 8f 	ldm	sp++,r0-r3,r7,pc
8000299c:	80 00       	ld.sh	r0,r0[0x0]
8000299e:	20 10       	sub	r0,1
800029a0:	80 00       	ld.sh	r0,r0[0x0]
800029a2:	48 28       	lddpc	r8,800029a8 <drive_DQ_low_and_release_the_bus+0x1a4>
800029a4:	80 00       	ld.sh	r0,r0[0x0]
800029a6:	4b 3c       	lddpc	r12,80002a70 <OWWriteBit+0xc0>
800029a8:	00 00       	add	r0,r0
800029aa:	08 14       	sub	r4,r4
800029ac:	80 00       	ld.sh	r0,r0[0x0]
800029ae:	ca 56       	brmi	800028f8 <drive_DQ_low_and_release_the_bus+0xf4>

800029b0 <OWWriteBit>:
//-----------------------------------------------------------------------------
// Send a 1-Wire write bit. Provide 10us recovery time.
//
void OWWriteBit(unsigned char idx, int bit);
void OWWriteBit(unsigned char idx, int bit)
{
800029b0:	eb cd 40 8f 	pushm	r0-r3,r7,lr
800029b4:	1a 97       	mov	r7,sp
800029b6:	fa cd 00 ac 	sub	sp,sp,172
800029ba:	18 98       	mov	r8,r12
800029bc:	ef 4b ff 74 	st.w	r7[-140],r11
800029c0:	ef 68 ff 78 	st.b	r7[-136],r8
	if (bit)
800029c4:	ee f8 ff 74 	ld.w	r8,r7[-140]
800029c8:	58 08       	cp.w	r8,0
800029ca:	e0 80 00 ba 	breq	80002b3e <OWWriteBit+0x18e>
	{
		// Write '1' bit
		drive_DQ_low_and_release_the_bus(idx);
800029ce:	ef 38 ff 78 	ld.ub	r8,r7[-136]
800029d2:	10 9c       	mov	r12,r8
800029d4:	f0 1f 01 0a 	mcall	80002dfc <OWWriteBit+0x44c>
#if 0
		drive_DQ_low(idx);
//14may15 take this out entirely, we can't seem to control this precisely enough		cpu_delay_us(A, EC_CPU_CLOCK_100MHZ	//tW1L 5-15us
		release_the_bus(idx);
#endif
		cpu_delay_us(B, EC_CPU_CLOCK_100MHZ);	// Complete the time slot and 10us recovery tSLOT 65-??us (no max)
800029d8:	fe f8 04 28 	ld.w	r8,pc[1064]
800029dc:	70 08       	ld.w	r8,r8[0x0]
800029de:	ef 48 ff a4 	st.w	r7[-92],r8
800029e2:	e0 68 e1 00 	mov	r8,57600
800029e6:	ea 18 05 f5 	orh	r8,0x5f5
800029ea:	ef 48 ff a0 	st.w	r7[-96],r8
800029ee:	ee f8 ff a4 	ld.w	r8,r7[-92]
800029f2:	ef 48 ff ac 	st.w	r7[-84],r8
800029f6:	ee f8 ff a0 	ld.w	r8,r7[-96]
800029fa:	ef 48 ff a8 	st.w	r7[-88],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_us_2_cy(unsigned long us, unsigned long fcpu_hz)
{
  return ((unsigned long long)us * fcpu_hz + 999999) / 1000000;
800029fe:	ee fc ff ac 	ld.w	r12,r7[-84]
80002a02:	ef 4c ff 60 	st.w	r7[-160],r12
80002a06:	30 0b       	mov	r11,0
80002a08:	ef 4b ff 5c 	st.w	r7[-164],r11
80002a0c:	ee f9 ff a8 	ld.w	r9,r7[-88]
80002a10:	ef 49 ff 58 	st.w	r7[-168],r9
80002a14:	30 08       	mov	r8,0
80002a16:	ef 48 ff 54 	st.w	r7[-172],r8
80002a1a:	ee fa ff 5c 	ld.w	r10,r7[-164]
80002a1e:	ee fc ff 58 	ld.w	r12,r7[-168]
80002a22:	b9 3a       	mul	r10,r12
80002a24:	ee f8 ff 54 	ld.w	r8,r7[-172]
80002a28:	ee fb ff 60 	ld.w	r11,r7[-160]
80002a2c:	b7 38       	mul	r8,r11
80002a2e:	10 0a       	add	r10,r8
80002a30:	ee fc ff 60 	ld.w	r12,r7[-160]
80002a34:	ee fb ff 58 	ld.w	r11,r7[-168]
80002a38:	f8 0b 06 48 	mulu.d	r8,r12,r11
80002a3c:	12 0a       	add	r10,r9
80002a3e:	14 99       	mov	r9,r10
80002a40:	ee 7a 42 3f 	mov	r10,999999
80002a44:	30 0b       	mov	r11,0
80002a46:	f0 0a 00 0a 	add	r10,r8,r10
80002a4a:	f2 0b 00 4b 	adc	r11,r9,r11
80002a4e:	ee 78 42 40 	mov	r8,1000000
80002a52:	30 09       	mov	r9,0
80002a54:	f0 1f 00 ec 	mcall	80002e04 <OWWriteBit+0x454>
80002a58:	14 98       	mov	r8,r10
80002a5a:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_us(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_us_2_cy(delay, fcpu_hz), &timer);
80002a5c:	ef 48 ff b4 	st.w	r7[-76],r8
80002a60:	ee c8 00 84 	sub	r8,r7,132
80002a64:	ef 48 ff b0 	st.w	r7[-80],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002a68:	e1 b8 00 42 	mfsr	r8,0x108
80002a6c:	10 99       	mov	r9,r8
80002a6e:	ee f8 ff b0 	ld.w	r8,r7[-80]
80002a72:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002a74:	ee f8 ff b0 	ld.w	r8,r7[-80]
80002a78:	70 09       	ld.w	r9,r8[0x0]
80002a7a:	ee f8 ff b4 	ld.w	r8,r7[-76]
80002a7e:	10 09       	add	r9,r8
80002a80:	ee f8 ff b0 	ld.w	r8,r7[-80]
80002a84:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
80002a86:	ee f9 ff b0 	ld.w	r9,r7[-80]
80002a8a:	30 08       	mov	r8,0
80002a8c:	f3 68 00 08 	st.b	r9[8],r8
80002a90:	ee c8 00 84 	sub	r8,r7,132
80002a94:	ef 48 ff b8 	st.w	r7[-72],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002a98:	e1 b8 00 42 	mfsr	r8,0x108
80002a9c:	ef 48 ff bc 	st.w	r7[-68],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
80002aa0:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002aa4:	f1 39 00 08 	ld.ub	r9,r8[8]
80002aa8:	30 28       	mov	r8,2
80002aaa:	f0 09 18 00 	cp.b	r9,r8
80002aae:	c0 31       	brne	80002ab4 <OWWriteBit+0x104>
    return false;
80002ab0:	30 08       	mov	r8,0
80002ab2:	c4 38       	rjmp	80002b38 <OWWriteBit+0x188>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
80002ab4:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002ab8:	f1 39 00 08 	ld.ub	r9,r8[8]
80002abc:	30 18       	mov	r8,1
80002abe:	f0 09 18 00 	cp.b	r9,r8
80002ac2:	c0 31       	brne	80002ac8 <OWWriteBit+0x118>
    return true;
80002ac4:	30 18       	mov	r8,1
80002ac6:	c3 98       	rjmp	80002b38 <OWWriteBit+0x188>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002ac8:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002acc:	70 09       	ld.w	r9,r8[0x0]
80002ace:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002ad2:	70 18       	ld.w	r8,r8[0x4]
80002ad4:	10 39       	cp.w	r9,r8
80002ad6:	e0 88 00 1a 	brls	80002b0a <OWWriteBit+0x15a>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002ada:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002ade:	70 08       	ld.w	r8,r8[0x0]
80002ae0:	ee f9 ff bc 	ld.w	r9,r7[-68]
80002ae4:	10 39       	cp.w	r9,r8
80002ae6:	c1 02       	brcc	80002b06 <OWWriteBit+0x156>
80002ae8:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002aec:	70 18       	ld.w	r8,r8[0x4]
80002aee:	ee f9 ff bc 	ld.w	r9,r7[-68]
80002af2:	10 39       	cp.w	r9,r8
80002af4:	e0 88 00 09 	brls	80002b06 <OWWriteBit+0x156>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002af8:	ee f9 ff b8 	ld.w	r9,r7[-72]
80002afc:	30 18       	mov	r8,1
80002afe:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002b02:	30 18       	mov	r8,1
80002b04:	c1 a8       	rjmp	80002b38 <OWWriteBit+0x188>
    }
    return false;
80002b06:	30 08       	mov	r8,0
80002b08:	c1 88       	rjmp	80002b38 <OWWriteBit+0x188>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002b0a:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002b0e:	70 08       	ld.w	r8,r8[0x0]
80002b10:	ee f9 ff bc 	ld.w	r9,r7[-68]
80002b14:	10 39       	cp.w	r9,r8
80002b16:	c0 93       	brcs	80002b28 <OWWriteBit+0x178>
80002b18:	ee f8 ff b8 	ld.w	r8,r7[-72]
80002b1c:	70 18       	ld.w	r8,r8[0x4]
80002b1e:	ee f9 ff bc 	ld.w	r9,r7[-68]
80002b22:	10 39       	cp.w	r9,r8
80002b24:	e0 88 00 09 	brls	80002b36 <OWWriteBit+0x186>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002b28:	ee f9 ff b8 	ld.w	r9,r7[-72]
80002b2c:	30 18       	mov	r8,1
80002b2e:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002b32:	30 18       	mov	r8,1
80002b34:	c0 28       	rjmp	80002b38 <OWWriteBit+0x188>
    }
    return false;
80002b36:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_us(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_us_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
80002b38:	58 08       	cp.w	r8,0
80002b3a:	ca b0       	breq	80002a90 <OWWriteBit+0xe0>
80002b3c:	c5 c9       	rjmp	80002df4 <OWWriteBit+0x444>
	}
	else
	{
		// Write '0' bit
		drive_DQ_low(idx);
80002b3e:	ef 38 ff 78 	ld.ub	r8,r7[-136]
80002b42:	10 9c       	mov	r12,r8
80002b44:	f0 1f 00 b1 	mcall	80002e08 <OWWriteBit+0x458>
		cpu_delay_us(C, EC_CPU_CLOCK_100MHZ);	//tW0L 60-120us
80002b48:	fe f8 02 c4 	ld.w	r8,pc[708]
80002b4c:	70 08       	ld.w	r8,r8[0x0]
80002b4e:	ef 48 ff c4 	st.w	r7[-60],r8
80002b52:	e0 68 e1 00 	mov	r8,57600
80002b56:	ea 18 05 f5 	orh	r8,0x5f5
80002b5a:	ef 48 ff c0 	st.w	r7[-64],r8
80002b5e:	ee f8 ff c4 	ld.w	r8,r7[-60]
80002b62:	ef 48 ff cc 	st.w	r7[-52],r8
80002b66:	ee f8 ff c0 	ld.w	r8,r7[-64]
80002b6a:	ef 48 ff c8 	st.w	r7[-56],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_us_2_cy(unsigned long us, unsigned long fcpu_hz)
{
  return ((unsigned long long)us * fcpu_hz + 999999) / 1000000;
80002b6e:	ee f9 ff cc 	ld.w	r9,r7[-52]
80002b72:	ef 49 ff 70 	st.w	r7[-144],r9
80002b76:	30 08       	mov	r8,0
80002b78:	ef 48 ff 6c 	st.w	r7[-148],r8
80002b7c:	ee fc ff c8 	ld.w	r12,r7[-56]
80002b80:	ef 4c ff 68 	st.w	r7[-152],r12
80002b84:	30 0b       	mov	r11,0
80002b86:	ef 4b ff 64 	st.w	r7[-156],r11
80002b8a:	ee fa ff 6c 	ld.w	r10,r7[-148]
80002b8e:	ee f9 ff 68 	ld.w	r9,r7[-152]
80002b92:	b3 3a       	mul	r10,r9
80002b94:	ee f8 ff 64 	ld.w	r8,r7[-156]
80002b98:	ee fc ff 70 	ld.w	r12,r7[-144]
80002b9c:	b9 38       	mul	r8,r12
80002b9e:	10 0a       	add	r10,r8
80002ba0:	ee fb ff 70 	ld.w	r11,r7[-144]
80002ba4:	ee fc ff 68 	ld.w	r12,r7[-152]
80002ba8:	f6 0c 06 48 	mulu.d	r8,r11,r12
80002bac:	12 0a       	add	r10,r9
80002bae:	14 99       	mov	r9,r10
80002bb0:	ee 7a 42 3f 	mov	r10,999999
80002bb4:	30 0b       	mov	r11,0
80002bb6:	f0 0a 00 0a 	add	r10,r8,r10
80002bba:	f2 0b 00 4b 	adc	r11,r9,r11
80002bbe:	ee 78 42 40 	mov	r8,1000000
80002bc2:	30 09       	mov	r9,0
80002bc4:	f0 1f 00 90 	mcall	80002e04 <OWWriteBit+0x454>
80002bc8:	14 98       	mov	r8,r10
80002bca:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_us(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_us_2_cy(delay, fcpu_hz), &timer);
80002bcc:	ef 48 ff d4 	st.w	r7[-44],r8
80002bd0:	ee c8 00 78 	sub	r8,r7,120
80002bd4:	ef 48 ff d0 	st.w	r7[-48],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002bd8:	e1 b8 00 42 	mfsr	r8,0x108
80002bdc:	10 99       	mov	r9,r8
80002bde:	ee f8 ff d0 	ld.w	r8,r7[-48]
80002be2:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002be4:	ee f8 ff d0 	ld.w	r8,r7[-48]
80002be8:	70 09       	ld.w	r9,r8[0x0]
80002bea:	ee f8 ff d4 	ld.w	r8,r7[-44]
80002bee:	10 09       	add	r9,r8
80002bf0:	ee f8 ff d0 	ld.w	r8,r7[-48]
80002bf4:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
80002bf6:	ee f9 ff d0 	ld.w	r9,r7[-48]
80002bfa:	30 08       	mov	r8,0
80002bfc:	f3 68 00 08 	st.b	r9[8],r8
80002c00:	ee c8 00 78 	sub	r8,r7,120
80002c04:	ef 48 ff d8 	st.w	r7[-40],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002c08:	e1 b8 00 42 	mfsr	r8,0x108
80002c0c:	ef 48 ff dc 	st.w	r7[-36],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
80002c10:	ee f8 ff d8 	ld.w	r8,r7[-40]
80002c14:	f1 39 00 08 	ld.ub	r9,r8[8]
80002c18:	30 28       	mov	r8,2
80002c1a:	f0 09 18 00 	cp.b	r9,r8
80002c1e:	c0 31       	brne	80002c24 <OWWriteBit+0x274>
    return false;
80002c20:	30 08       	mov	r8,0
80002c22:	c4 38       	rjmp	80002ca8 <OWWriteBit+0x2f8>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
80002c24:	ee f8 ff d8 	ld.w	r8,r7[-40]
80002c28:	f1 39 00 08 	ld.ub	r9,r8[8]
80002c2c:	30 18       	mov	r8,1
80002c2e:	f0 09 18 00 	cp.b	r9,r8
80002c32:	c0 31       	brne	80002c38 <OWWriteBit+0x288>
    return true;
80002c34:	30 18       	mov	r8,1
80002c36:	c3 98       	rjmp	80002ca8 <OWWriteBit+0x2f8>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002c38:	ee f8 ff d8 	ld.w	r8,r7[-40]
80002c3c:	70 09       	ld.w	r9,r8[0x0]
80002c3e:	ee f8 ff d8 	ld.w	r8,r7[-40]
80002c42:	70 18       	ld.w	r8,r8[0x4]
80002c44:	10 39       	cp.w	r9,r8
80002c46:	e0 88 00 1a 	brls	80002c7a <OWWriteBit+0x2ca>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002c4a:	ee f8 ff d8 	ld.w	r8,r7[-40]
80002c4e:	70 08       	ld.w	r8,r8[0x0]
80002c50:	ee f9 ff dc 	ld.w	r9,r7[-36]
80002c54:	10 39       	cp.w	r9,r8
80002c56:	c1 02       	brcc	80002c76 <OWWriteBit+0x2c6>
80002c58:	ee f8 ff d8 	ld.w	r8,r7[-40]
80002c5c:	70 18       	ld.w	r8,r8[0x4]
80002c5e:	ee f9 ff dc 	ld.w	r9,r7[-36]
80002c62:	10 39       	cp.w	r9,r8
80002c64:	e0 88 00 09 	brls	80002c76 <OWWriteBit+0x2c6>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002c68:	ee f9 ff d8 	ld.w	r9,r7[-40]
80002c6c:	30 18       	mov	r8,1
80002c6e:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002c72:	30 18       	mov	r8,1
80002c74:	c1 a8       	rjmp	80002ca8 <OWWriteBit+0x2f8>
    }
    return false;
80002c76:	30 08       	mov	r8,0
80002c78:	c1 88       	rjmp	80002ca8 <OWWriteBit+0x2f8>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002c7a:	ee f8 ff d8 	ld.w	r8,r7[-40]
80002c7e:	70 08       	ld.w	r8,r8[0x0]
80002c80:	ee f9 ff dc 	ld.w	r9,r7[-36]
80002c84:	10 39       	cp.w	r9,r8
80002c86:	c0 93       	brcs	80002c98 <OWWriteBit+0x2e8>
80002c88:	ee f8 ff d8 	ld.w	r8,r7[-40]
80002c8c:	70 18       	ld.w	r8,r8[0x4]
80002c8e:	ee f9 ff dc 	ld.w	r9,r7[-36]
80002c92:	10 39       	cp.w	r9,r8
80002c94:	e0 88 00 09 	brls	80002ca6 <OWWriteBit+0x2f6>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002c98:	ee f9 ff d8 	ld.w	r9,r7[-40]
80002c9c:	30 18       	mov	r8,1
80002c9e:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002ca2:	30 18       	mov	r8,1
80002ca4:	c0 28       	rjmp	80002ca8 <OWWriteBit+0x2f8>
    }
    return false;
80002ca6:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_us(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_us_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
80002ca8:	58 08       	cp.w	r8,0
80002caa:	ca b0       	breq	80002c00 <OWWriteBit+0x250>
		release_the_bus(idx);
80002cac:	ef 38 ff 78 	ld.ub	r8,r7[-136]
80002cb0:	10 9c       	mov	r12,r8
80002cb2:	f0 1f 00 58 	mcall	80002e10 <OWWriteBit+0x460>
		cpu_delay_us(D, EC_CPU_CLOCK_100MHZ);	//tREC 5-??us
80002cb6:	4d 88       	lddpc	r8,80002e14 <OWWriteBit+0x464>
80002cb8:	70 08       	ld.w	r8,r8[0x0]
80002cba:	ef 48 ff e4 	st.w	r7[-28],r8
80002cbe:	e0 68 e1 00 	mov	r8,57600
80002cc2:	ea 18 05 f5 	orh	r8,0x5f5
80002cc6:	ef 48 ff e0 	st.w	r7[-32],r8
80002cca:	ee f8 ff e4 	ld.w	r8,r7[-28]
80002cce:	ef 48 ff ec 	st.w	r7[-20],r8
80002cd2:	ee f8 ff e0 	ld.w	r8,r7[-32]
80002cd6:	ef 48 ff e8 	st.w	r7[-24],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_us_2_cy(unsigned long us, unsigned long fcpu_hz)
{
  return ((unsigned long long)us * fcpu_hz + 999999) / 1000000;
80002cda:	ee f0 ff ec 	ld.w	r0,r7[-20]
80002cde:	30 01       	mov	r1,0
80002ce0:	ee f2 ff e8 	ld.w	r2,r7[-24]
80002ce4:	30 03       	mov	r3,0
80002ce6:	e2 02 02 4a 	mul	r10,r1,r2
80002cea:	e6 00 02 48 	mul	r8,r3,r0
80002cee:	10 0a       	add	r10,r8
80002cf0:	e0 02 06 48 	mulu.d	r8,r0,r2
80002cf4:	12 0a       	add	r10,r9
80002cf6:	14 99       	mov	r9,r10
80002cf8:	ee 7a 42 3f 	mov	r10,999999
80002cfc:	30 0b       	mov	r11,0
80002cfe:	f0 0a 00 0a 	add	r10,r8,r10
80002d02:	f2 0b 00 4b 	adc	r11,r9,r11
80002d06:	ee 78 42 40 	mov	r8,1000000
80002d0a:	30 09       	mov	r9,0
80002d0c:	f0 1f 00 3e 	mcall	80002e04 <OWWriteBit+0x454>
80002d10:	14 98       	mov	r8,r10
80002d12:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_us(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_us_2_cy(delay, fcpu_hz), &timer);
80002d14:	ef 48 ff f4 	st.w	r7[-12],r8
80002d18:	ee c8 00 6c 	sub	r8,r7,108
80002d1c:	ef 48 ff f0 	st.w	r7[-16],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002d20:	e1 b8 00 42 	mfsr	r8,0x108
80002d24:	10 99       	mov	r9,r8
80002d26:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002d2a:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002d2c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002d30:	70 09       	ld.w	r9,r8[0x0]
80002d32:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002d36:	10 09       	add	r9,r8
80002d38:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002d3c:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
80002d3e:	ee f9 ff f0 	ld.w	r9,r7[-16]
80002d42:	30 08       	mov	r8,0
80002d44:	f3 68 00 08 	st.b	r9[8],r8
80002d48:	ee c8 00 6c 	sub	r8,r7,108
80002d4c:	ef 48 ff f8 	st.w	r7[-8],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002d50:	e1 b8 00 42 	mfsr	r8,0x108
80002d54:	ef 48 ff fc 	st.w	r7[-4],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
80002d58:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d5c:	f1 39 00 08 	ld.ub	r9,r8[8]
80002d60:	30 28       	mov	r8,2
80002d62:	f0 09 18 00 	cp.b	r9,r8
80002d66:	c0 31       	brne	80002d6c <OWWriteBit+0x3bc>
    return false;
80002d68:	30 08       	mov	r8,0
80002d6a:	c4 38       	rjmp	80002df0 <OWWriteBit+0x440>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
80002d6c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d70:	f1 39 00 08 	ld.ub	r9,r8[8]
80002d74:	30 18       	mov	r8,1
80002d76:	f0 09 18 00 	cp.b	r9,r8
80002d7a:	c0 31       	brne	80002d80 <OWWriteBit+0x3d0>
    return true;
80002d7c:	30 18       	mov	r8,1
80002d7e:	c3 98       	rjmp	80002df0 <OWWriteBit+0x440>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002d80:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d84:	70 09       	ld.w	r9,r8[0x0]
80002d86:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d8a:	70 18       	ld.w	r8,r8[0x4]
80002d8c:	10 39       	cp.w	r9,r8
80002d8e:	e0 88 00 1a 	brls	80002dc2 <OWWriteBit+0x412>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002d92:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d96:	70 08       	ld.w	r8,r8[0x0]
80002d98:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002d9c:	10 39       	cp.w	r9,r8
80002d9e:	c1 02       	brcc	80002dbe <OWWriteBit+0x40e>
80002da0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002da4:	70 18       	ld.w	r8,r8[0x4]
80002da6:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002daa:	10 39       	cp.w	r9,r8
80002dac:	e0 88 00 09 	brls	80002dbe <OWWriteBit+0x40e>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002db0:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002db4:	30 18       	mov	r8,1
80002db6:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002dba:	30 18       	mov	r8,1
80002dbc:	c1 a8       	rjmp	80002df0 <OWWriteBit+0x440>
    }
    return false;
80002dbe:	30 08       	mov	r8,0
80002dc0:	c1 88       	rjmp	80002df0 <OWWriteBit+0x440>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002dc2:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002dc6:	70 08       	ld.w	r8,r8[0x0]
80002dc8:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002dcc:	10 39       	cp.w	r9,r8
80002dce:	c0 93       	brcs	80002de0 <OWWriteBit+0x430>
80002dd0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002dd4:	70 18       	ld.w	r8,r8[0x4]
80002dd6:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002dda:	10 39       	cp.w	r9,r8
80002ddc:	e0 88 00 09 	brls	80002dee <OWWriteBit+0x43e>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002de0:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002de4:	30 18       	mov	r8,1
80002de6:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002dea:	30 18       	mov	r8,1
80002dec:	c0 28       	rjmp	80002df0 <OWWriteBit+0x440>
    }
    return false;
80002dee:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_us(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_us_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
80002df0:	58 08       	cp.w	r8,0
80002df2:	ca b0       	breq	80002d48 <OWWriteBit+0x398>
	}
}
80002df4:	2d 5d       	sub	sp,-172
80002df6:	e3 cd 80 8f 	ldm	sp++,r0-r3,r7,pc
80002dfa:	00 00       	add	r0,r0
80002dfc:	80 00       	ld.sh	r0,r0[0x0]
80002dfe:	28 04       	sub	r4,-128
80002e00:	00 00       	add	r0,r0
80002e02:	08 18       	sub	r8,r4
80002e04:	80 00       	ld.sh	r0,r0[0x0]
80002e06:	ca 56       	brmi	80002d50 <OWWriteBit+0x3a0>
80002e08:	80 00       	ld.sh	r0,r0[0x0]
80002e0a:	20 5c       	sub	r12,5
80002e0c:	00 00       	add	r0,r0
80002e0e:	08 20       	rsub	r0,r4
80002e10:	80 00       	ld.sh	r0,r0[0x0]
80002e12:	20 ac       	sub	r12,10
80002e14:	00 00       	add	r0,r0
80002e16:	08 10       	sub	r0,r4

80002e18 <OWReadBit>:
//-----------------------------------------------------------------------------
// Read a bit from the 1-Wire bus and return it. Provide 10us recovery time.
//
int OWReadBit(unsigned char idx);
int OWReadBit(unsigned char idx)
{
80002e18:	eb cd 40 8f 	pushm	r0-r3,r7,lr
80002e1c:	1a 97       	mov	r7,sp
80002e1e:	21 cd       	sub	sp,112
80002e20:	18 98       	mov	r8,r12
80002e22:	ef 68 ff a0 	st.b	r7[-96],r8
#if 0
	drive_DQ_low(idx);
//14may15 take this out entirely, we can't seem to control this precisely enough	cpu_delay_us(A, EC_CPU_CLOCK_100MHZ	//tRL 5-15us
	release_the_bus(idx);
#endif
	drive_DQ_low_and_release_the_bus(idx);
80002e26:	ef 38 ff a0 	ld.ub	r8,r7[-96]
80002e2a:	10 9c       	mov	r12,r8
80002e2c:	f0 1f 00 b1 	mcall	800030f0 <OWReadBit+0x2d8>
	
	cpu_delay_us(E, EC_CPU_CLOCK_100MHZ);	//tMSR 5-15us
80002e30:	fe f8 02 c4 	ld.w	r8,pc[708]
80002e34:	70 08       	ld.w	r8,r8[0x0]
80002e36:	ef 48 ff c4 	st.w	r7[-60],r8
80002e3a:	e0 68 e1 00 	mov	r8,57600
80002e3e:	ea 18 05 f5 	orh	r8,0x5f5
80002e42:	ef 48 ff c0 	st.w	r7[-64],r8
80002e46:	ee f8 ff c4 	ld.w	r8,r7[-60]
80002e4a:	ef 48 ff cc 	st.w	r7[-52],r8
80002e4e:	ee f8 ff c0 	ld.w	r8,r7[-64]
80002e52:	ef 48 ff c8 	st.w	r7[-56],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_us_2_cy(unsigned long us, unsigned long fcpu_hz)
{
  return ((unsigned long long)us * fcpu_hz + 999999) / 1000000;
80002e56:	ee fc ff cc 	ld.w	r12,r7[-52]
80002e5a:	ef 4c ff 9c 	st.w	r7[-100],r12
80002e5e:	30 0b       	mov	r11,0
80002e60:	ef 4b ff 98 	st.w	r7[-104],r11
80002e64:	ee f9 ff c8 	ld.w	r9,r7[-56]
80002e68:	ef 49 ff 94 	st.w	r7[-108],r9
80002e6c:	30 08       	mov	r8,0
80002e6e:	ef 48 ff 90 	st.w	r7[-112],r8
80002e72:	ee fa ff 98 	ld.w	r10,r7[-104]
80002e76:	ee fc ff 94 	ld.w	r12,r7[-108]
80002e7a:	b9 3a       	mul	r10,r12
80002e7c:	ee f8 ff 90 	ld.w	r8,r7[-112]
80002e80:	ee fb ff 9c 	ld.w	r11,r7[-100]
80002e84:	b7 38       	mul	r8,r11
80002e86:	10 0a       	add	r10,r8
80002e88:	ee fc ff 9c 	ld.w	r12,r7[-100]
80002e8c:	ee fb ff 94 	ld.w	r11,r7[-108]
80002e90:	f8 0b 06 48 	mulu.d	r8,r12,r11
80002e94:	12 0a       	add	r10,r9
80002e96:	14 99       	mov	r9,r10
80002e98:	ee 7a 42 3f 	mov	r10,999999
80002e9c:	30 0b       	mov	r11,0
80002e9e:	f0 0a 00 0a 	add	r10,r8,r10
80002ea2:	f2 0b 00 4b 	adc	r11,r9,r11
80002ea6:	ee 78 42 40 	mov	r8,1000000
80002eaa:	30 09       	mov	r9,0
80002eac:	f0 1f 00 93 	mcall	800030f8 <OWReadBit+0x2e0>
80002eb0:	14 98       	mov	r8,r10
80002eb2:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_us(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_us_2_cy(delay, fcpu_hz), &timer);
80002eb4:	ef 48 ff d4 	st.w	r7[-44],r8
80002eb8:	ee c8 00 5c 	sub	r8,r7,92
80002ebc:	ef 48 ff d0 	st.w	r7[-48],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002ec0:	e1 b8 00 42 	mfsr	r8,0x108
80002ec4:	10 99       	mov	r9,r8
80002ec6:	ee f8 ff d0 	ld.w	r8,r7[-48]
80002eca:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002ecc:	ee f8 ff d0 	ld.w	r8,r7[-48]
80002ed0:	70 09       	ld.w	r9,r8[0x0]
80002ed2:	ee f8 ff d4 	ld.w	r8,r7[-44]
80002ed6:	10 09       	add	r9,r8
80002ed8:	ee f8 ff d0 	ld.w	r8,r7[-48]
80002edc:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
80002ede:	ee f9 ff d0 	ld.w	r9,r7[-48]
80002ee2:	30 08       	mov	r8,0
80002ee4:	f3 68 00 08 	st.b	r9[8],r8
80002ee8:	ee c8 00 5c 	sub	r8,r7,92
80002eec:	ef 48 ff d8 	st.w	r7[-40],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002ef0:	e1 b8 00 42 	mfsr	r8,0x108
80002ef4:	ef 48 ff dc 	st.w	r7[-36],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
80002ef8:	ee f8 ff d8 	ld.w	r8,r7[-40]
80002efc:	f1 39 00 08 	ld.ub	r9,r8[8]
80002f00:	30 28       	mov	r8,2
80002f02:	f0 09 18 00 	cp.b	r9,r8
80002f06:	c0 31       	brne	80002f0c <OWReadBit+0xf4>
    return false;
80002f08:	30 08       	mov	r8,0
80002f0a:	c4 38       	rjmp	80002f90 <OWReadBit+0x178>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
80002f0c:	ee f8 ff d8 	ld.w	r8,r7[-40]
80002f10:	f1 39 00 08 	ld.ub	r9,r8[8]
80002f14:	30 18       	mov	r8,1
80002f16:	f0 09 18 00 	cp.b	r9,r8
80002f1a:	c0 31       	brne	80002f20 <OWReadBit+0x108>
    return true;
80002f1c:	30 18       	mov	r8,1
80002f1e:	c3 98       	rjmp	80002f90 <OWReadBit+0x178>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002f20:	ee f8 ff d8 	ld.w	r8,r7[-40]
80002f24:	70 09       	ld.w	r9,r8[0x0]
80002f26:	ee f8 ff d8 	ld.w	r8,r7[-40]
80002f2a:	70 18       	ld.w	r8,r8[0x4]
80002f2c:	10 39       	cp.w	r9,r8
80002f2e:	e0 88 00 1a 	brls	80002f62 <OWReadBit+0x14a>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002f32:	ee f8 ff d8 	ld.w	r8,r7[-40]
80002f36:	70 08       	ld.w	r8,r8[0x0]
80002f38:	ee f9 ff dc 	ld.w	r9,r7[-36]
80002f3c:	10 39       	cp.w	r9,r8
80002f3e:	c1 02       	brcc	80002f5e <OWReadBit+0x146>
80002f40:	ee f8 ff d8 	ld.w	r8,r7[-40]
80002f44:	70 18       	ld.w	r8,r8[0x4]
80002f46:	ee f9 ff dc 	ld.w	r9,r7[-36]
80002f4a:	10 39       	cp.w	r9,r8
80002f4c:	e0 88 00 09 	brls	80002f5e <OWReadBit+0x146>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002f50:	ee f9 ff d8 	ld.w	r9,r7[-40]
80002f54:	30 18       	mov	r8,1
80002f56:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002f5a:	30 18       	mov	r8,1
80002f5c:	c1 a8       	rjmp	80002f90 <OWReadBit+0x178>
    }
    return false;
80002f5e:	30 08       	mov	r8,0
80002f60:	c1 88       	rjmp	80002f90 <OWReadBit+0x178>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002f62:	ee f8 ff d8 	ld.w	r8,r7[-40]
80002f66:	70 08       	ld.w	r8,r8[0x0]
80002f68:	ee f9 ff dc 	ld.w	r9,r7[-36]
80002f6c:	10 39       	cp.w	r9,r8
80002f6e:	c0 93       	brcs	80002f80 <OWReadBit+0x168>
80002f70:	ee f8 ff d8 	ld.w	r8,r7[-40]
80002f74:	70 18       	ld.w	r8,r8[0x4]
80002f76:	ee f9 ff dc 	ld.w	r9,r7[-36]
80002f7a:	10 39       	cp.w	r9,r8
80002f7c:	e0 88 00 09 	brls	80002f8e <OWReadBit+0x176>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80002f80:	ee f9 ff d8 	ld.w	r9,r7[-40]
80002f84:	30 18       	mov	r8,1
80002f86:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80002f8a:	30 18       	mov	r8,1
80002f8c:	c0 28       	rjmp	80002f90 <OWReadBit+0x178>
    }
    return false;
80002f8e:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_us(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_us_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
80002f90:	58 08       	cp.w	r8,0
80002f92:	ca b0       	breq	80002ee8 <OWReadBit+0xd0>
	result = sample_line(idx);
80002f94:	ef 38 ff a0 	ld.ub	r8,r7[-96]
80002f98:	10 9c       	mov	r12,r8
80002f9a:	f0 1f 00 59 	mcall	800030fc <OWReadBit+0x2e4>
80002f9e:	18 98       	mov	r8,r12
80002fa0:	ef 48 ff bc 	st.w	r7[-68],r8
	cpu_delay_us(F, EC_CPU_CLOCK_100MHZ); // Complete the time slot and 10us recovery tREC 5+us
80002fa4:	4d 78       	lddpc	r8,80003100 <OWReadBit+0x2e8>
80002fa6:	70 08       	ld.w	r8,r8[0x0]
80002fa8:	ef 48 ff e4 	st.w	r7[-28],r8
80002fac:	e0 68 e1 00 	mov	r8,57600
80002fb0:	ea 18 05 f5 	orh	r8,0x5f5
80002fb4:	ef 48 ff e0 	st.w	r7[-32],r8
80002fb8:	ee f8 ff e4 	ld.w	r8,r7[-28]
80002fbc:	ef 48 ff ec 	st.w	r7[-20],r8
80002fc0:	ee f8 ff e0 	ld.w	r8,r7[-32]
80002fc4:	ef 48 ff e8 	st.w	r7[-24],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_us_2_cy(unsigned long us, unsigned long fcpu_hz)
{
  return ((unsigned long long)us * fcpu_hz + 999999) / 1000000;
80002fc8:	ee f0 ff ec 	ld.w	r0,r7[-20]
80002fcc:	30 01       	mov	r1,0
80002fce:	ee f2 ff e8 	ld.w	r2,r7[-24]
80002fd2:	30 03       	mov	r3,0
80002fd4:	e2 02 02 4a 	mul	r10,r1,r2
80002fd8:	e6 00 02 48 	mul	r8,r3,r0
80002fdc:	10 0a       	add	r10,r8
80002fde:	e0 02 06 48 	mulu.d	r8,r0,r2
80002fe2:	12 0a       	add	r10,r9
80002fe4:	14 99       	mov	r9,r10
80002fe6:	ee 7a 42 3f 	mov	r10,999999
80002fea:	30 0b       	mov	r11,0
80002fec:	f0 0a 00 0a 	add	r10,r8,r10
80002ff0:	f2 0b 00 4b 	adc	r11,r9,r11
80002ff4:	ee 78 42 40 	mov	r8,1000000
80002ff8:	30 09       	mov	r9,0
80002ffa:	f0 1f 00 40 	mcall	800030f8 <OWReadBit+0x2e0>
80002ffe:	14 98       	mov	r8,r10
80003000:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_us(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_us_2_cy(delay, fcpu_hz), &timer);
80003002:	ef 48 ff f4 	st.w	r7[-12],r8
80003006:	ee c8 00 50 	sub	r8,r7,80
8000300a:	ef 48 ff f0 	st.w	r7[-16],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000300e:	e1 b8 00 42 	mfsr	r8,0x108
80003012:	10 99       	mov	r9,r8
80003014:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003018:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000301a:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000301e:	70 09       	ld.w	r9,r8[0x0]
80003020:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003024:	10 09       	add	r9,r8
80003026:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000302a:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
8000302c:	ee f9 ff f0 	ld.w	r9,r7[-16]
80003030:	30 08       	mov	r8,0
80003032:	f3 68 00 08 	st.b	r9[8],r8
80003036:	ee c8 00 50 	sub	r8,r7,80
8000303a:	ef 48 ff f8 	st.w	r7[-8],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000303e:	e1 b8 00 42 	mfsr	r8,0x108
80003042:	ef 48 ff fc 	st.w	r7[-4],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
80003046:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000304a:	f1 39 00 08 	ld.ub	r9,r8[8]
8000304e:	30 28       	mov	r8,2
80003050:	f0 09 18 00 	cp.b	r9,r8
80003054:	c0 31       	brne	8000305a <OWReadBit+0x242>
    return false;
80003056:	30 08       	mov	r8,0
80003058:	c4 38       	rjmp	800030de <OWReadBit+0x2c6>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
8000305a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000305e:	f1 39 00 08 	ld.ub	r9,r8[8]
80003062:	30 18       	mov	r8,1
80003064:	f0 09 18 00 	cp.b	r9,r8
80003068:	c0 31       	brne	8000306e <OWReadBit+0x256>
    return true;
8000306a:	30 18       	mov	r8,1
8000306c:	c3 98       	rjmp	800030de <OWReadBit+0x2c6>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000306e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003072:	70 09       	ld.w	r9,r8[0x0]
80003074:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003078:	70 18       	ld.w	r8,r8[0x4]
8000307a:	10 39       	cp.w	r9,r8
8000307c:	e0 88 00 1a 	brls	800030b0 <OWReadBit+0x298>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80003080:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003084:	70 08       	ld.w	r8,r8[0x0]
80003086:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000308a:	10 39       	cp.w	r9,r8
8000308c:	c1 02       	brcc	800030ac <OWReadBit+0x294>
8000308e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003092:	70 18       	ld.w	r8,r8[0x4]
80003094:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003098:	10 39       	cp.w	r9,r8
8000309a:	e0 88 00 09 	brls	800030ac <OWReadBit+0x294>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
8000309e:	ee f9 ff f8 	ld.w	r9,r7[-8]
800030a2:	30 18       	mov	r8,1
800030a4:	f3 68 00 08 	st.b	r9[8],r8
      return true;
800030a8:	30 18       	mov	r8,1
800030aa:	c1 a8       	rjmp	800030de <OWReadBit+0x2c6>
    }
    return false;
800030ac:	30 08       	mov	r8,0
800030ae:	c1 88       	rjmp	800030de <OWReadBit+0x2c6>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800030b0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800030b4:	70 08       	ld.w	r8,r8[0x0]
800030b6:	ee f9 ff fc 	ld.w	r9,r7[-4]
800030ba:	10 39       	cp.w	r9,r8
800030bc:	c0 93       	brcs	800030ce <OWReadBit+0x2b6>
800030be:	ee f8 ff f8 	ld.w	r8,r7[-8]
800030c2:	70 18       	ld.w	r8,r8[0x4]
800030c4:	ee f9 ff fc 	ld.w	r9,r7[-4]
800030c8:	10 39       	cp.w	r9,r8
800030ca:	e0 88 00 09 	brls	800030dc <OWReadBit+0x2c4>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
800030ce:	ee f9 ff f8 	ld.w	r9,r7[-8]
800030d2:	30 18       	mov	r8,1
800030d4:	f3 68 00 08 	st.b	r9[8],r8
      return true;
800030d8:	30 18       	mov	r8,1
800030da:	c0 28       	rjmp	800030de <OWReadBit+0x2c6>
    }
    return false;
800030dc:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_us(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_us_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
800030de:	58 08       	cp.w	r8,0
800030e0:	ca b0       	breq	80003036 <OWReadBit+0x21e>

	return result;
800030e2:	ee f8 ff bc 	ld.w	r8,r7[-68]
}
800030e6:	10 9c       	mov	r12,r8
800030e8:	2e 4d       	sub	sp,-112
800030ea:	e3 cd 80 8f 	ldm	sp++,r0-r3,r7,pc
800030ee:	00 00       	add	r0,r0
800030f0:	80 00       	ld.sh	r0,r0[0x0]
800030f2:	28 04       	sub	r4,-128
800030f4:	00 00       	add	r0,r0
800030f6:	08 2c       	rsub	r12,r4
800030f8:	80 00       	ld.sh	r0,r0[0x0]
800030fa:	ca 56       	brmi	80003044 <OWReadBit+0x22c>
800030fc:	80 00       	ld.sh	r0,r0[0x0]
800030fe:	21 30       	sub	r0,19
80003100:	00 00       	add	r0,r0
80003102:	08 34       	cp.w	r4,r4

80003104 <OWWriteByte>:

//-----------------------------------------------------------------------------
// Write 1-Wire data byte
//
void OWWriteByte(unsigned char idx, int data)
{
80003104:	eb cd 40 80 	pushm	r7,lr
80003108:	1a 97       	mov	r7,sp
8000310a:	20 3d       	sub	sp,12
8000310c:	18 98       	mov	r8,r12
8000310e:	ef 4b ff f4 	st.w	r7[-12],r11
80003112:	ef 68 ff f8 	st.b	r7[-8],r8
	int loop;

	// Loop to write each bit in the byte, LS-bit first
	for (loop = 0; loop < 8; loop++)
80003116:	30 08       	mov	r8,0
80003118:	ef 48 ff fc 	st.w	r7[-4],r8
8000311c:	c1 58       	rjmp	80003146 <OWWriteByte+0x42>
	{
		OWWriteBit(idx, data & 0x01);
8000311e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003122:	f3 d8 c0 01 	bfextu	r9,r8,0x0,0x1
80003126:	ef 38 ff f8 	ld.ub	r8,r7[-8]
8000312a:	12 9b       	mov	r11,r9
8000312c:	10 9c       	mov	r12,r8
8000312e:	f0 1f 00 0b 	mcall	80003158 <OWWriteByte+0x54>

		// shift the data byte for the next bit
		data >>= 1;
80003132:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003136:	a1 58       	asr	r8,0x1
80003138:	ef 48 ff f4 	st.w	r7[-12],r8
void OWWriteByte(unsigned char idx, int data)
{
	int loop;

	// Loop to write each bit in the byte, LS-bit first
	for (loop = 0; loop < 8; loop++)
8000313c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003140:	2f f8       	sub	r8,-1
80003142:	ef 48 ff fc 	st.w	r7[-4],r8
80003146:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000314a:	58 78       	cp.w	r8,7
8000314c:	fe 9a ff e9 	brle	8000311e <OWWriteByte+0x1a>
		OWWriteBit(idx, data & 0x01);

		// shift the data byte for the next bit
		data >>= 1;
	}
}
80003150:	2f dd       	sub	sp,-12
80003152:	e3 cd 80 80 	ldm	sp++,r7,pc
80003156:	00 00       	add	r0,r0
80003158:	80 00       	ld.sh	r0,r0[0x0]
8000315a:	29 b0       	sub	r0,-101

8000315c <OWReadByte>:

//-----------------------------------------------------------------------------
// Read 1-Wire data byte and return it
//
int OWReadByte(unsigned char idx)
{
8000315c:	eb cd 40 80 	pushm	r7,lr
80003160:	1a 97       	mov	r7,sp
80003162:	20 3d       	sub	sp,12
80003164:	18 98       	mov	r8,r12
80003166:	ef 68 ff f4 	st.b	r7[-12],r8
	int loop, result=0;
8000316a:	30 08       	mov	r8,0
8000316c:	ef 48 ff fc 	st.w	r7[-4],r8

	for (loop = 0; loop < 8; loop++)
80003170:	30 08       	mov	r8,0
80003172:	ef 48 ff f8 	st.w	r7[-8],r8
80003176:	c1 88       	rjmp	800031a6 <OWReadByte+0x4a>
	{
		// shift the result to get it ready for the next bit
		result >>= 1;
80003178:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000317c:	a1 58       	asr	r8,0x1
8000317e:	ef 48 ff fc 	st.w	r7[-4],r8

		// if result is one, then set MS bit
		if (OWReadBit(idx))
80003182:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80003186:	10 9c       	mov	r12,r8
80003188:	f0 1f 00 0d 	mcall	800031bc <OWReadByte+0x60>
8000318c:	18 98       	mov	r8,r12
8000318e:	58 08       	cp.w	r8,0
80003190:	c0 60       	breq	8000319c <OWReadByte+0x40>
		result |= 0x80;
80003192:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003196:	a7 b8       	sbr	r8,0x7
80003198:	ef 48 ff fc 	st.w	r7[-4],r8
//
int OWReadByte(unsigned char idx)
{
	int loop, result=0;

	for (loop = 0; loop < 8; loop++)
8000319c:	ee f8 ff f8 	ld.w	r8,r7[-8]
800031a0:	2f f8       	sub	r8,-1
800031a2:	ef 48 ff f8 	st.w	r7[-8],r8
800031a6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800031aa:	58 78       	cp.w	r8,7
800031ac:	fe 9a ff e6 	brle	80003178 <OWReadByte+0x1c>

		// if result is one, then set MS bit
		if (OWReadBit(idx))
		result |= 0x80;
	}
	return result;
800031b0:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
800031b4:	10 9c       	mov	r12,r8
800031b6:	2f dd       	sub	sp,-12
800031b8:	e3 cd 80 80 	ldm	sp++,r7,pc
800031bc:	80 00       	ld.sh	r0,r0[0x0]
800031be:	2e 18       	sub	r8,-31

800031c0 <crc8_add>:
	return OWTouchReset(idx);
}

/* Polynomial ^8 + ^5 + ^4 + 1 */
unsigned char crc8_add(unsigned char acc, unsigned char byte)
{
800031c0:	eb cd 40 80 	pushm	r7,lr
800031c4:	1a 97       	mov	r7,sp
800031c6:	20 3d       	sub	sp,12
800031c8:	18 99       	mov	r9,r12
800031ca:	16 98       	mov	r8,r11
800031cc:	ef 69 ff f8 	st.b	r7[-8],r9
800031d0:	ef 68 ff f4 	st.b	r7[-12],r8
   int i;
   acc ^= byte;
800031d4:	ef 39 ff f8 	ld.ub	r9,r7[-8]
800031d8:	ef 38 ff f4 	ld.ub	r8,r7[-12]
800031dc:	f3 e8 20 08 	eor	r8,r9,r8
800031e0:	ef 68 ff f8 	st.b	r7[-8],r8
   for(i = 0; i < 8; i++) 
800031e4:	30 08       	mov	r8,0
800031e6:	ef 48 ff fc 	st.w	r7[-4],r8
800031ea:	c1 c8       	rjmp	80003222 <crc8_add+0x62>
   {
		if(acc & 1) 
800031ec:	ef 38 ff f8 	ld.ub	r8,r7[-8]
800031f0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800031f4:	5c 58       	castu.b	r8
800031f6:	c0 c0       	breq	8000320e <crc8_add+0x4e>
		{
			acc = (acc >> 1) ^ 0x8c;
800031f8:	ef 38 ff f8 	ld.ub	r8,r7[-8]
800031fc:	a1 98       	lsr	r8,0x1
800031fe:	5c 58       	castu.b	r8
80003200:	ee 18 ff ff 	eorh	r8,0xffff
80003204:	ec 18 ff 8c 	eorl	r8,0xff8c
80003208:	ef 68 ff f8 	st.b	r7[-8],r8
8000320c:	c0 68       	rjmp	80003218 <crc8_add+0x58>
		} 
		else 
		{
			acc >>= 1;
8000320e:	ef 38 ff f8 	ld.ub	r8,r7[-8]
80003212:	a1 98       	lsr	r8,0x1
80003214:	ef 68 ff f8 	st.b	r7[-8],r8
/* Polynomial ^8 + ^5 + ^4 + 1 */
unsigned char crc8_add(unsigned char acc, unsigned char byte)
{
   int i;
   acc ^= byte;
   for(i = 0; i < 8; i++) 
80003218:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000321c:	2f f8       	sub	r8,-1
8000321e:	ef 48 ff fc 	st.w	r7[-4],r8
80003222:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003226:	58 78       	cp.w	r8,7
80003228:	fe 9a ff e2 	brle	800031ec <crc8_add+0x2c>
		else 
		{
			acc >>= 1;
	    }
   }
   return acc;
8000322c:	ef 38 ff f8 	ld.ub	r8,r7[-8]
}
80003230:	10 9c       	mov	r12,r8
80003232:	2f dd       	sub	sp,-12
80003234:	e3 cd 80 80 	ldm	sp++,r7,pc

80003238 <init_ecdbg_rs232>:
//! ASCII representation of hexadecimal digits.
static const char HEX_DIGITS[16] = "0123456789ABCDEF";


void init_ecdbg_rs232(long pba_hz)
{
80003238:	eb cd 40 80 	pushm	r7,lr
8000323c:	1a 97       	mov	r7,sp
8000323e:	20 1d       	sub	sp,4
80003240:	ef 4c ff fc 	st.w	r7[-4],r12
  init_ecdbg_rs232_ex(ECDBG_USART_BAUDRATE, pba_hz);
80003244:	ee fb ff fc 	ld.w	r11,r7[-4]
80003248:	e0 7c c2 00 	mov	r12,115200
8000324c:	f0 1f 00 03 	mcall	80003258 <init_ecdbg_rs232+0x20>
}
80003250:	2f fd       	sub	sp,-4
80003252:	e3 cd 80 80 	ldm	sp++,r7,pc
80003256:	00 00       	add	r0,r0
80003258:	80 00       	ld.sh	r0,r0[0x0]
8000325a:	32 80       	mov	r0,40

8000325c <init_display_rs232>:

void init_display_rs232(long pba_hz)
{
8000325c:	eb cd 40 80 	pushm	r7,lr
80003260:	1a 97       	mov	r7,sp
80003262:	20 1d       	sub	sp,4
80003264:	ef 4c ff fc 	st.w	r7[-4],r12
	init_display_rs232_ex(DISPLAY_USART_BAUDRATE, pba_hz);
80003268:	ee fb ff fc 	ld.w	r11,r7[-4]
8000326c:	e0 6c 12 c0 	mov	r12,4800
80003270:	f0 1f 00 03 	mcall	8000327c <init_display_rs232+0x20>
}
80003274:	2f fd       	sub	sp,-4
80003276:	e3 cd 80 80 	ldm	sp++,r7,pc
8000327a:	00 00       	add	r0,r0
8000327c:	80 00       	ld.sh	r0,r0[0x0]
8000327e:	32 dc       	mov	r12,45

80003280 <init_ecdbg_rs232_ex>:


void init_ecdbg_rs232_ex(unsigned long baudrate, long pba_hz)
{
80003280:	eb cd 40 80 	pushm	r7,lr
80003284:	1a 97       	mov	r7,sp
80003286:	20 5d       	sub	sp,20
80003288:	ef 4c ff f0 	st.w	r7[-16],r12
8000328c:	ef 4b ff ec 	st.w	r7[-20],r11
    .baudrate = baudrate,
    .charlength = 8,
    .paritytype = USART_NO_PARITY,
    .stopbits = USART_1_STOPBIT,
    .channelmode = USART_NORMAL_CHMODE
  };
80003290:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003294:	ef 48 ff f4 	st.w	r7[-12],r8
80003298:	30 88       	mov	r8,8
8000329a:	ef 68 ff f8 	st.b	r7[-8],r8
8000329e:	30 48       	mov	r8,4
800032a0:	ef 68 ff f9 	st.b	r7[-7],r8
800032a4:	30 08       	mov	r8,0
800032a6:	ef 58 ff fa 	st.h	r7[-6],r8
800032aa:	30 08       	mov	r8,0
800032ac:	ef 68 ff fc 	st.b	r7[-4],r8

  // Setup GPIO for debug USART.
  gpio_enable_module(ECDBG_USART_GPIO_MAP,
800032b0:	30 2b       	mov	r11,2
800032b2:	48 8c       	lddpc	r12,800032d0 <init_ecdbg_rs232_ex+0x50>
800032b4:	f0 1f 00 08 	mcall	800032d4 <init_ecdbg_rs232_ex+0x54>
                     sizeof(ECDBG_USART_GPIO_MAP) / sizeof(ECDBG_USART_GPIO_MAP[0]));

  // Initialize it in RS232 mode.
  usart_init_rs232(ECDBG_USART, &ecdbg_usart_options, pba_hz);
800032b8:	ee c8 00 0c 	sub	r8,r7,12
800032bc:	ee fa ff ec 	ld.w	r10,r7[-20]
800032c0:	10 9b       	mov	r11,r8
800032c2:	fe 7c 28 00 	mov	r12,-55296
800032c6:	f0 1f 00 05 	mcall	800032d8 <init_ecdbg_rs232_ex+0x58>
}
800032ca:	2f bd       	sub	sp,-20
800032cc:	e3 cd 80 80 	ldm	sp++,r7,pc
800032d0:	80 01       	ld.sh	r1,r0[0x0]
800032d2:	24 10       	sub	r0,65
800032d4:	80 00       	ld.sh	r0,r0[0x0]
800032d6:	45 3c       	lddsp	r12,sp[0x14c]
800032d8:	80 00       	ld.sh	r0,r0[0x0]
800032da:	56 e0       	stdsp	sp[0x1b8],r0

800032dc <init_display_rs232_ex>:

void init_display_rs232_ex(unsigned long baudrate, long pba_hz)
{
800032dc:	eb cd 40 80 	pushm	r7,lr
800032e0:	1a 97       	mov	r7,sp
800032e2:	20 5d       	sub	sp,20
800032e4:	ef 4c ff f0 	st.w	r7[-16],r12
800032e8:	ef 4b ff ec 	st.w	r7[-20],r11
		.baudrate = baudrate,
		.charlength = 8,
		.paritytype = USART_NO_PARITY,
		.stopbits = USART_1_STOPBIT,
		.channelmode = USART_NORMAL_CHMODE
	};
800032ec:	ee f8 ff f0 	ld.w	r8,r7[-16]
800032f0:	ef 48 ff f4 	st.w	r7[-12],r8
800032f4:	30 88       	mov	r8,8
800032f6:	ef 68 ff f8 	st.b	r7[-8],r8
800032fa:	30 48       	mov	r8,4
800032fc:	ef 68 ff f9 	st.b	r7[-7],r8
80003300:	30 08       	mov	r8,0
80003302:	ef 58 ff fa 	st.h	r7[-6],r8
80003306:	30 08       	mov	r8,0
80003308:	ef 68 ff fc 	st.b	r7[-4],r8

	// Setup GPIO for debug USART.
	gpio_enable_module(DISPLAY_USART_GPIO_MAP,
8000330c:	30 2b       	mov	r11,2
8000330e:	48 8c       	lddpc	r12,8000332c <init_display_rs232_ex+0x50>
80003310:	f0 1f 00 08 	mcall	80003330 <init_display_rs232_ex+0x54>
	sizeof(DISPLAY_USART_GPIO_MAP) / sizeof(DISPLAY_USART_GPIO_MAP[0]));

	// Initialize it in RS232 mode.
	usart_init_rs232(DISPLAY_USART, &display_usart_options, pba_hz);
80003314:	ee c8 00 0c 	sub	r8,r7,12
80003318:	ee fa ff ec 	ld.w	r10,r7[-20]
8000331c:	10 9b       	mov	r11,r8
8000331e:	fc 7c 14 00 	mov	r12,-191488
80003322:	f0 1f 00 05 	mcall	80003334 <init_display_rs232_ex+0x58>
}
80003326:	2f bd       	sub	sp,-20
80003328:	e3 cd 80 80 	ldm	sp++,r7,pc
8000332c:	80 01       	ld.sh	r1,r0[0x0]
8000332e:	24 00       	sub	r0,64
80003330:	80 00       	ld.sh	r0,r0[0x0]
80003332:	45 3c       	lddsp	r12,sp[0x14c]
80003334:	80 00       	ld.sh	r0,r0[0x0]
80003336:	56 e0       	stdsp	sp[0x1b8],r0

80003338 <print_ecdbg>:


void print_ecdbg(const char *str)
{
80003338:	eb cd 40 80 	pushm	r7,lr
8000333c:	1a 97       	mov	r7,sp
8000333e:	20 1d       	sub	sp,4
80003340:	ef 4c ff fc 	st.w	r7[-4],r12
  // Redirection to the debug USART.
  print(ECDBG_USART, str);
80003344:	ee fb ff fc 	ld.w	r11,r7[-4]
80003348:	fe 7c 28 00 	mov	r12,-55296
8000334c:	f0 1f 00 03 	mcall	80003358 <print_ecdbg+0x20>
}
80003350:	2f fd       	sub	sp,-4
80003352:	e3 cd 80 80 	ldm	sp++,r7,pc
80003356:	00 00       	add	r0,r0
80003358:	80 00       	ld.sh	r0,r0[0x0]
8000335a:	33 5c       	mov	r12,53

8000335c <print>:
	print_hex(DISPLAY_USART, n);
}


void print(volatile avr32_usart_t *usart, const char *str)
{
8000335c:	eb cd 40 80 	pushm	r7,lr
80003360:	1a 97       	mov	r7,sp
80003362:	20 2d       	sub	sp,8
80003364:	ef 4c ff fc 	st.w	r7[-4],r12
80003368:	ef 4b ff f8 	st.w	r7[-8],r11
  // Invoke the USART driver to transmit the input string with the given USART.
  usart_write_line(usart, str);
8000336c:	ee fb ff f8 	ld.w	r11,r7[-8]
80003370:	ee fc ff fc 	ld.w	r12,r7[-4]
80003374:	f0 1f 00 03 	mcall	80003380 <print+0x24>
}
80003378:	2f ed       	sub	sp,-8
8000337a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000337e:	00 00       	add	r0,r0
80003380:	80 00       	ld.sh	r0,r0[0x0]
80003382:	59 3c       	cp.w	r12,19

80003384 <adcifa_get_calibration_data>:
 * \param adcifa       Base address of the ADCIFA
 * \param p_adcifa_opt Structure for the ADCIFA core configuration
 */
void adcifa_get_calibration_data(volatile avr32_adcifa_t *adcifa,
		adcifa_opt_t *p_adcifa_opt)
{
80003384:	eb cd 40 80 	pushm	r7,lr
80003388:	1a 97       	mov	r7,sp
8000338a:	20 6d       	sub	sp,24
8000338c:	ef 4c ff ec 	st.w	r7[-20],r12
80003390:	ef 4b ff e8 	st.w	r7[-24],r11
	/* Get Offset Calibration */
	int32_t adc_ocal
		= ((*(volatile signed int *)(AVR32_FLASHC_FACTORY_PAGE_ADDRESS
80003394:	e0 68 02 04 	mov	r8,516
80003398:	ea 18 80 80 	orh	r8,0x8080
8000339c:	70 08       	ld.w	r8,r8[0x0]
8000339e:	e6 18 3f 00 	andh	r8,0x3f00,COH
			+ AVR32_FLASHC_FROW_OCAL_WORD)) &
			AVR32_FLASHC_FROW_OCAL_MASK) >>
			AVR32_FLASHC_FROW_OCAL_OFFSET;
800033a2:	b9 48       	asr	r8,0x18
800033a4:	ef 48 ff f0 	st.w	r7[-16],r8
	/* Get Gain Calibration */
	int32_t adc_gcal
		= ((*(volatile signed int *)(AVR32_FLASHC_FACTORY_PAGE_ADDRESS
			+ AVR32_FLASHC_FROW_GCAL_WORD)) &
			AVR32_FLASHC_FROW_GCAL_MASK) >>
			AVR32_FLASHC_FROW_GCAL_OFFSET;
800033a8:	e0 68 02 04 	mov	r8,516
800033ac:	ea 18 80 80 	orh	r8,0x8080
			AVR32_FLASHC_FROW_OCAL_MASK) >>
			AVR32_FLASHC_FROW_OCAL_OFFSET;

	/* Get Gain Calibration */
	int32_t adc_gcal
		= ((*(volatile signed int *)(AVR32_FLASHC_FACTORY_PAGE_ADDRESS
800033b0:	70 08       	ld.w	r8,r8[0x0]
			+ AVR32_FLASHC_FROW_GCAL_WORD)) &
			AVR32_FLASHC_FROW_GCAL_MASK) >>
			AVR32_FLASHC_FROW_GCAL_OFFSET;
800033b2:	f1 d8 c0 0f 	bfextu	r8,r8,0x0,0xf
800033b6:	ef 48 ff f4 	st.w	r7[-12],r8
	/*  Get S/H Calibration */
	int32_t adc_gain0
		= ((*(volatile signed int *)(AVR32_FLASHC_FACTORY_PAGE_ADDRESS
			+ AVR32_FLASHC_FROW_GAIN0_WORD)) &
			AVR32_FLASHC_FROW_GAIN0_MASK) >>
			AVR32_FLASHC_FROW_GAIN0_OFFSET;
800033ba:	e0 68 02 08 	mov	r8,520
800033be:	ea 18 80 80 	orh	r8,0x8080
			AVR32_FLASHC_FROW_GCAL_MASK) >>
			AVR32_FLASHC_FROW_GCAL_OFFSET;

	/*  Get S/H Calibration */
	int32_t adc_gain0
		= ((*(volatile signed int *)(AVR32_FLASHC_FACTORY_PAGE_ADDRESS
800033c2:	70 08       	ld.w	r8,r8[0x0]
			+ AVR32_FLASHC_FROW_GAIN0_WORD)) &
			AVR32_FLASHC_FROW_GAIN0_MASK) >>
			AVR32_FLASHC_FROW_GAIN0_OFFSET;
800033c4:	f1 d8 c0 0a 	bfextu	r8,r8,0x0,0xa
800033c8:	ef 48 ff f8 	st.w	r7[-8],r8

	int32_t adc_gain1
		= ((*(volatile signed int *)(AVR32_FLASHC_FACTORY_PAGE_ADDRESS
800033cc:	e0 68 02 08 	mov	r8,520
800033d0:	ea 18 80 80 	orh	r8,0x8080
800033d4:	70 08       	ld.w	r8,r8[0x0]
800033d6:	e6 18 03 ff 	andh	r8,0x3ff,COH
			+ AVR32_FLASHC_FROW_GAIN1_WORD)) &
			AVR32_FLASHC_FROW_GAIN1_MASK) >>
			AVR32_FLASHC_FROW_GAIN1_OFFSET;
800033da:	b1 48       	asr	r8,0x10
800033dc:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Get ADC Offset Calibration */
	p_adcifa_opt->offset_calibration_value = adc_ocal;
800033e0:	ee f8 ff f0 	ld.w	r8,r7[-16]
800033e4:	5c 88       	casts.h	r8
800033e6:	ee f9 ff e8 	ld.w	r9,r7[-24]
800033ea:	b2 68       	st.h	r9[0xc],r8

	/* Get ADC Gain Calibration */
	p_adcifa_opt->gain_calibration_value = adc_gcal;
800033ec:	ee f8 ff f4 	ld.w	r8,r7[-12]
800033f0:	5c 88       	casts.h	r8
800033f2:	ee f9 ff e8 	ld.w	r9,r7[-24]
800033f6:	b2 58       	st.h	r9[0xa],r8

	/* Get Sample & Hold Gain Calibration for Seq 0 */
	p_adcifa_opt->sh0_calibration_value = adc_gain0;
800033f8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800033fc:	5c 88       	casts.h	r8
800033fe:	ee f9 ff e8 	ld.w	r9,r7[-24]
80003402:	b2 78       	st.h	r9[0xe],r8

	/* Get Sample & Hold Gain Calibration for Seq 1 */
	p_adcifa_opt->sh1_calibration_value = adc_gain1;
80003404:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003408:	5c 88       	casts.h	r8
8000340a:	ee f9 ff e8 	ld.w	r9,r7[-24]
8000340e:	f3 58 00 10 	st.h	r9[16],r8
}
80003412:	2f ad       	sub	sp,-24
80003414:	e3 cd 80 80 	ldm	sp++,r7,pc

80003418 <adcifa_configure>:
 * \return ADCIFA_CONFIGURATION_REFUSED or ADCIFA_CONFIGURATION_ACCEPTED
 */
uint8_t adcifa_configure(volatile avr32_adcifa_t *adcifa,
		adcifa_opt_t *p_adcifa_opt,
		uint32_t pb_hz)
{
80003418:	eb cd 40 80 	pushm	r7,lr
8000341c:	1a 97       	mov	r7,sp
8000341e:	20 3d       	sub	sp,12
80003420:	ef 4c ff fc 	st.w	r7[-4],r12
80003424:	ef 4b ff f8 	st.w	r7[-8],r11
80003428:	ef 4a ff f4 	st.w	r7[-12],r10
	/* Sanity Check */
	Assert(adcifa != NULL);

	/* Set the ADC configuration */
	AVR32_ADCIFA.cfg
8000342c:	fc 7a 24 00 	mov	r10,-187392
		= (p_adcifa_opt->sleep_mode_enable <<
80003430:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003434:	f1 38 00 08 	ld.ub	r8,r8[8]
80003438:	f0 09 15 02 	lsl	r9,r8,0x2
			AVR32_ADCIFA_CFG_SLEEP)
			| (p_adcifa_opt->single_sequencer_mode <<
8000343c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003440:	11 e8       	ld.ub	r8,r8[0x6]
80003442:	a3 78       	lsl	r8,0x3
			AVR32_ADCIFA_CFG_SSMQ)
			| (p_adcifa_opt->free_running_mode_enable <<
80003444:	10 49       	or	r9,r8
80003446:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000344a:	11 f8       	ld.ub	r8,r8[0x7]
8000344c:	a5 68       	lsl	r8,0x4
			AVR32_ADCIFA_CFG_FRM)
			| (p_adcifa_opt->reference_source <<
8000344e:	10 49       	or	r9,r8
80003450:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003454:	11 c8       	ld.ub	r8,r8[0x4]
80003456:	a5 78       	lsl	r8,0x5
			AVR32_ADCIFA_CFG_RS)
			| (p_adcifa_opt->sample_and_hold_disable <<
80003458:	10 49       	or	r9,r8
8000345a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000345e:	11 d8       	ld.ub	r8,r8[0x5]
80003460:	a7 78       	lsl	r8,0x7
			AVR32_ADCIFA_CFG_SHD)
			| (p_adcifa_opt->mux_settle_more_time <<
80003462:	10 49       	or	r9,r8
80003464:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003468:	f1 38 00 09 	ld.ub	r8,r8[9]
8000346c:	ab 68       	lsl	r8,0xa
			AVR32_ADCIFA_CFG_MUXSET)
			| (((ADCIFA_START_UP_TIME *
8000346e:	f3 e8 10 08 	or	r8,r9,r8
	/* Sanity Check */
	Assert(adcifa != NULL);

	/* Set the ADC configuration */
	AVR32_ADCIFA.cfg
		= (p_adcifa_opt->sleep_mode_enable <<
80003472:	10 9b       	mov	r11,r8
			| (p_adcifa_opt->sample_and_hold_disable <<
			AVR32_ADCIFA_CFG_SHD)
			| (p_adcifa_opt->mux_settle_more_time <<
			AVR32_ADCIFA_CFG_MUXSET)
			| (((ADCIFA_START_UP_TIME *
			(p_adcifa_opt->frequency /
80003474:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003478:	70 09       	ld.w	r9,r8[0x0]
8000347a:	e0 68 4d d3 	mov	r8,19923
8000347e:	ea 18 10 62 	orh	r8,0x1062
80003482:	f2 08 06 48 	mulu.d	r8,r9,r8
80003486:	a7 89       	lsr	r9,0x6
			AVR32_ADCIFA_CFG_RS)
			| (p_adcifa_opt->sample_and_hold_disable <<
			AVR32_ADCIFA_CFG_SHD)
			| (p_adcifa_opt->mux_settle_more_time <<
			AVR32_ADCIFA_CFG_MUXSET)
			| (((ADCIFA_START_UP_TIME *
80003488:	e0 68 03 e8 	mov	r8,1000
8000348c:	b1 39       	mul	r9,r8
8000348e:	e0 68 4d d3 	mov	r8,19923
80003492:	ea 18 10 62 	orh	r8,0x1062
80003496:	f2 08 06 48 	mulu.d	r8,r9,r8
8000349a:	f2 08 16 0b 	lsr	r8,r9,0xb
8000349e:	b1 68       	lsl	r8,0x10
	/* Sanity Check */
	Assert(adcifa != NULL);

	/* Set the ADC configuration */
	AVR32_ADCIFA.cfg
		= (p_adcifa_opt->sleep_mode_enable <<
800034a0:	f7 e8 10 08 	or	r8,r11,r8
{
	/* Sanity Check */
	Assert(adcifa != NULL);

	/* Set the ADC configuration */
	AVR32_ADCIFA.cfg
800034a4:	95 18       	st.w	r10[0x4],r8
			1000)) / 32000) << AVR32_ADCIFA_CFG_SUT);

	/* Configure Clock  (rounded up) */
	adcifa->ckdiv
		= (((pb_hz /
			(2 * p_adcifa_opt->frequency)) - 1) <<
800034a6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800034aa:	70 08       	ld.w	r8,r8[0x0]
800034ac:	f0 09 15 01 	lsl	r9,r8,0x1
			(p_adcifa_opt->frequency /
			1000)) / 32000) << AVR32_ADCIFA_CFG_SUT);

	/* Configure Clock  (rounded up) */
	adcifa->ckdiv
		= (((pb_hz /
800034b0:	ee f8 ff f4 	ld.w	r8,r7[-12]
800034b4:	f0 09 0d 08 	divu	r8,r8,r9
800034b8:	20 18       	sub	r8,1
800034ba:	f3 d8 c0 09 	bfextu	r9,r8,0x0,0x9
			| (((ADCIFA_START_UP_TIME *
			(p_adcifa_opt->frequency /
			1000)) / 32000) << AVR32_ADCIFA_CFG_SUT);

	/* Configure Clock  (rounded up) */
	adcifa->ckdiv
800034be:	ee f8 ff fc 	ld.w	r8,r7[-4]
800034c2:	f1 49 00 44 	st.w	r8[68],r9
			(2 * p_adcifa_opt->frequency)) - 1) <<
			AVR32_ADCIFA_CKDIV_CNT_OFFSET) &
			AVR32_ADCIFA_CKDIV_CNT_MASK;

	/* Set ADC Offset Calibration */
	ADCIFA_set_offset_calibration(p_adcifa_opt->offset_calibration_value);
800034c6:	fc 78 24 00 	mov	r8,-187392
800034ca:	fc 79 24 00 	mov	r9,-187392
800034ce:	73 a9       	ld.w	r9,r9[0x68]
800034d0:	12 9a       	mov	r10,r9
800034d2:	e4 1a c0 ff 	andh	r10,0xc0ff
800034d6:	ee f9 ff f8 	ld.w	r9,r7[-8]
800034da:	92 69       	ld.sh	r9,r9[0xc]
800034dc:	b9 69       	lsl	r9,0x18
800034de:	e6 19 3f 00 	andh	r9,0x3f00,COH
800034e2:	f5 e9 10 09 	or	r9,r10,r9
800034e6:	f1 49 00 68 	st.w	r8[104],r9

	/* Set ADC Gain Calibration */
	ADCIFA_set_gain_calibration(p_adcifa_opt->gain_calibration_value);
800034ea:	fc 78 24 00 	mov	r8,-187392
800034ee:	fc 79 24 00 	mov	r9,-187392
800034f2:	73 a9       	ld.w	r9,r9[0x68]
800034f4:	12 9a       	mov	r10,r9
800034f6:	e0 1a 80 00 	andl	r10,0x8000
800034fa:	ee f9 ff f8 	ld.w	r9,r7[-8]
800034fe:	92 59       	ld.sh	r9,r9[0xa]
80003500:	f3 d9 c0 0f 	bfextu	r9,r9,0x0,0xf
80003504:	f5 e9 10 09 	or	r9,r10,r9
80003508:	f1 49 00 68 	st.w	r8[104],r9

	/* Set Sample & Hold Gain Calibration for seq 0 */
	ADCIFA_set_sh0_gain_calibration(p_adcifa_opt->sh0_calibration_value);
8000350c:	fc 78 24 00 	mov	r8,-187392
80003510:	fc 79 24 00 	mov	r9,-187392
80003514:	73 b9       	ld.w	r9,r9[0x6c]
80003516:	12 9a       	mov	r10,r9
80003518:	e0 1a fc 00 	andl	r10,0xfc00
8000351c:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003520:	92 79       	ld.sh	r9,r9[0xe]
80003522:	f3 d9 c0 0a 	bfextu	r9,r9,0x0,0xa
80003526:	f5 e9 10 09 	or	r9,r10,r9
8000352a:	f1 49 00 6c 	st.w	r8[108],r9

	/* Set Sample & Hold Gain Calibration for seq 1 */
	ADCIFA_set_sh1_gain_calibration(p_adcifa_opt->sh1_calibration_value);
8000352e:	fc 78 24 00 	mov	r8,-187392
80003532:	fc 79 24 00 	mov	r9,-187392
80003536:	73 b9       	ld.w	r9,r9[0x6c]
80003538:	12 9a       	mov	r10,r9
8000353a:	e4 1a fc 00 	andh	r10,0xfc00
8000353e:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003542:	f3 09 00 10 	ld.sh	r9,r9[16]
80003546:	b1 69       	lsl	r9,0x10
80003548:	e6 19 03 ff 	andh	r9,0x3ff,COH
8000354c:	f5 e9 10 09 	or	r9,r10,r9
80003550:	f1 49 00 6c 	st.w	r8[108],r9

	/* Enable ADCIFA */
	ADCIFA_enable();
80003554:	fc 78 24 00 	mov	r8,-187392
80003558:	fc 79 24 00 	mov	r9,-187392
8000355c:	72 19       	ld.w	r9,r9[0x4]
8000355e:	a1 a9       	sbr	r9,0x0
80003560:	91 19       	st.w	r8[0x4],r9
80003562:	c0 28       	rjmp	80003566 <adcifa_configure+0x14e>
	/* Wait Startup Time */
	while (1) {
		if (ADCIFA_is_startup_time()) {
			break;
		}
	}
80003564:	d7 03       	nop
	/* Enable ADCIFA */
	ADCIFA_enable();

	/* Wait Startup Time */
	while (1) {
		if (ADCIFA_is_startup_time()) {
80003566:	fc 78 24 00 	mov	r8,-187392
8000356a:	70 28       	ld.w	r8,r8[0x8]
8000356c:	e2 18 40 00 	andl	r8,0x4000,COH
80003570:	cf a0       	breq	80003564 <adcifa_configure+0x14c>
			break;
		}
	}

	return ADCIFA_CONFIGURATION_ACCEPTED;
80003572:	30 18       	mov	r8,1
}
80003574:	10 9c       	mov	r12,r8
80003576:	2f dd       	sub	sp,-12
80003578:	e3 cd 80 80 	ldm	sp++,r7,pc

8000357c <adcifa_configure_sequencer>:
 */
uint8_t adcifa_configure_sequencer(volatile avr32_adcifa_t *adcifa,
		uint8_t sequencer,
		adcifa_sequencer_opt_t *p_adcifa_sequencer_opt,
		adcifa_sequencer_conversion_opt_t *p_adcifa_sequencer_conversion_opt)
{
8000357c:	eb cd 40 80 	pushm	r7,lr
80003580:	1a 97       	mov	r7,sp
80003582:	21 1d       	sub	sp,68
80003584:	ef 4c ff c8 	st.w	r7[-56],r12
80003588:	16 98       	mov	r8,r11
8000358a:	ef 4a ff c0 	st.w	r7[-64],r10
8000358e:	ef 49 ff bc 	st.w	r7[-68],r9
80003592:	ef 68 ff c4 	st.b	r7[-60],r8
	uint8_t g[16] = {0};
80003596:	30 08       	mov	r8,0
80003598:	30 09       	mov	r9,0
8000359a:	ee e9 ff ec 	st.d	r7[-20],r8
8000359e:	30 08       	mov	r8,0
800035a0:	30 09       	mov	r9,0
800035a2:	ee e9 ff f4 	st.d	r7[-12],r8
	uint8_t mp[16] = {0};
800035a6:	30 08       	mov	r8,0
800035a8:	30 09       	mov	r9,0
800035aa:	ee e9 ff dc 	st.d	r7[-36],r8
800035ae:	30 08       	mov	r8,0
800035b0:	30 09       	mov	r9,0
800035b2:	ee e9 ff e4 	st.d	r7[-28],r8
	uint8_t mn[16] = {0};
800035b6:	30 08       	mov	r8,0
800035b8:	30 09       	mov	r9,0
800035ba:	ee e9 ff cc 	st.d	r7[-52],r8
800035be:	30 08       	mov	r8,0
800035c0:	30 09       	mov	r9,0
800035c2:	ee e9 ff d4 	st.d	r7[-44],r8

	/* Sanity Check */
	Assert( adcifa != NULL );

	/* Switch case with sequencer */
	switch (sequencer) {
800035c6:	ef 38 ff c4 	ld.ub	r8,r7[-60]
800035ca:	58 08       	cp.w	r8,0
800035cc:	c0 60       	breq	800035d8 <adcifa_configure_sequencer+0x5c>
800035ce:	58 18       	cp.w	r8,1
800035d0:	e0 80 01 65 	breq	8000389a <adcifa_configure_sequencer+0x31e>
800035d4:	e0 8f 02 54 	bral	80003a7c <adcifa_configure_sequencer+0x500>
	/* Sequencer 0 */
	case 0:
		/* Configure Sequencer 0 */
		ADCIFA_configure_sequencer_0(
800035d8:	fc 78 24 00 	mov	r8,-187392
800035dc:	ee f9 ff c0 	ld.w	r9,r7[-64]
800035e0:	13 89       	ld.ub	r9,r9[0x0]
800035e2:	20 19       	sub	r9,1
800035e4:	f2 0a 15 10 	lsl	r10,r9,0x10
800035e8:	ee f9 ff c0 	ld.w	r9,r7[-64]
800035ec:	13 99       	ld.ub	r9,r9[0x1]
800035ee:	ad 69       	lsl	r9,0xc
800035f0:	12 4a       	or	r10,r9
800035f2:	ee f9 ff c0 	ld.w	r9,r7[-64]
800035f6:	13 a9       	ld.ub	r9,r9[0x2]
800035f8:	a9 69       	lsl	r9,0x8
800035fa:	12 4a       	or	r10,r9
800035fc:	ee f9 ff c0 	ld.w	r9,r7[-64]
80003600:	13 b9       	ld.ub	r9,r9[0x3]
80003602:	a3 69       	lsl	r9,0x2
80003604:	12 4a       	or	r10,r9
80003606:	ee f9 ff c0 	ld.w	r9,r7[-64]
8000360a:	13 c9       	ld.ub	r9,r9[0x4]
8000360c:	a3 79       	lsl	r9,0x3
8000360e:	12 4a       	or	r10,r9
80003610:	ee f9 ff c0 	ld.w	r9,r7[-64]
80003614:	13 d9       	ld.ub	r9,r9[0x5]
80003616:	a1 79       	lsl	r9,0x1
80003618:	12 4a       	or	r10,r9
8000361a:	ee f9 ff c0 	ld.w	r9,r7[-64]
8000361e:	13 e9       	ld.ub	r9,r9[0x6]
80003620:	f5 e9 10 09 	or	r9,r10,r9
80003624:	91 59       	st.w	r8[0x14],r9
				(p_adcifa_sequencer_opt->sh_mode),
#endif
				(p_adcifa_sequencer_opt->half_word_adjustment),
				(p_adcifa_sequencer_opt->software_acknowledge));
		/* Configure Gain for Sequencer 0 */
		for (i = 0; i < p_adcifa_sequencer_opt->convnb; i++) {
80003626:	30 08       	mov	r8,0
80003628:	ef 68 ff ff 	st.b	r7[-1],r8
8000362c:	c1 68       	rjmp	80003658 <adcifa_configure_sequencer+0xdc>
			g[i] = p_adcifa_sequencer_conversion_opt[i].gain;
8000362e:	ef 3a ff ff 	ld.ub	r10,r7[-1]
80003632:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80003636:	12 98       	mov	r8,r9
80003638:	a1 78       	lsl	r8,0x1
8000363a:	12 08       	add	r8,r9
8000363c:	ee f9 ff bc 	ld.w	r9,r7[-68]
80003640:	f2 08 00 08 	add	r8,r9,r8
80003644:	11 a8       	ld.ub	r8,r8[0x2]
80003646:	ee 0a 00 09 	add	r9,r7,r10
8000364a:	f3 68 ff ec 	st.b	r9[-20],r8
				(p_adcifa_sequencer_opt->sh_mode),
#endif
				(p_adcifa_sequencer_opt->half_word_adjustment),
				(p_adcifa_sequencer_opt->software_acknowledge));
		/* Configure Gain for Sequencer 0 */
		for (i = 0; i < p_adcifa_sequencer_opt->convnb; i++) {
8000364e:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80003652:	2f f8       	sub	r8,-1
80003654:	ef 68 ff ff 	st.b	r7[-1],r8
80003658:	ee f8 ff c0 	ld.w	r8,r7[-64]
8000365c:	11 88       	ld.ub	r8,r8[0x0]
8000365e:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80003662:	f0 09 18 00 	cp.b	r9,r8
80003666:	ce 43       	brcs	8000362e <adcifa_configure_sequencer+0xb2>
			g[i] = p_adcifa_sequencer_conversion_opt[i].gain;
		}
		ADCIFA_configure_sh0gain(g[7], g[6], g[5], g[4], g[3], g[2],
80003668:	fc 78 24 00 	mov	r8,-187392
8000366c:	ef 39 ff f3 	ld.ub	r9,r7[-13]
80003670:	f2 0a 15 1c 	lsl	r10,r9,0x1c
80003674:	ef 39 ff f2 	ld.ub	r9,r7[-14]
80003678:	b9 69       	lsl	r9,0x18
8000367a:	12 4a       	or	r10,r9
8000367c:	ef 39 ff f1 	ld.ub	r9,r7[-15]
80003680:	b5 69       	lsl	r9,0x14
80003682:	12 4a       	or	r10,r9
80003684:	ef 39 ff f0 	ld.ub	r9,r7[-16]
80003688:	b1 69       	lsl	r9,0x10
8000368a:	12 4a       	or	r10,r9
8000368c:	ef 39 ff ef 	ld.ub	r9,r7[-17]
80003690:	ad 69       	lsl	r9,0xc
80003692:	12 4a       	or	r10,r9
80003694:	ef 39 ff ee 	ld.ub	r9,r7[-18]
80003698:	a9 69       	lsl	r9,0x8
8000369a:	12 4a       	or	r10,r9
8000369c:	ef 39 ff ed 	ld.ub	r9,r7[-19]
800036a0:	a5 69       	lsl	r9,0x4
800036a2:	12 4a       	or	r10,r9
800036a4:	ef 39 ff ec 	ld.ub	r9,r7[-20]
800036a8:	f5 e9 10 09 	or	r9,r10,r9
800036ac:	91 79       	st.w	r8[0x1c],r9
				g[1], g[0]);

		/* Configure Mux for Sequencer 0 */
		for (i = 0; i < p_adcifa_sequencer_opt->convnb; i++) {
800036ae:	30 08       	mov	r8,0
800036b0:	ef 68 ff ff 	st.b	r7[-1],r8
800036b4:	c2 68       	rjmp	80003700 <adcifa_configure_sequencer+0x184>
			mp[i] = p_adcifa_sequencer_conversion_opt[i].channel_p;
800036b6:	ef 3a ff ff 	ld.ub	r10,r7[-1]
800036ba:	ef 39 ff ff 	ld.ub	r9,r7[-1]
800036be:	12 98       	mov	r8,r9
800036c0:	a1 78       	lsl	r8,0x1
800036c2:	12 08       	add	r8,r9
800036c4:	ee f9 ff bc 	ld.w	r9,r7[-68]
800036c8:	f2 08 00 08 	add	r8,r9,r8
800036cc:	11 88       	ld.ub	r8,r8[0x0]
800036ce:	ee 0a 00 09 	add	r9,r7,r10
800036d2:	f3 68 ff dc 	st.b	r9[-36],r8
			mn[i] = p_adcifa_sequencer_conversion_opt[i].channel_n;
800036d6:	ef 3a ff ff 	ld.ub	r10,r7[-1]
800036da:	ef 39 ff ff 	ld.ub	r9,r7[-1]
800036de:	12 98       	mov	r8,r9
800036e0:	a1 78       	lsl	r8,0x1
800036e2:	12 08       	add	r8,r9
800036e4:	ee f9 ff bc 	ld.w	r9,r7[-68]
800036e8:	f2 08 00 08 	add	r8,r9,r8
800036ec:	11 98       	ld.ub	r8,r8[0x1]
800036ee:	ee 0a 00 09 	add	r9,r7,r10
800036f2:	f3 68 ff cc 	st.b	r9[-52],r8
		}
		ADCIFA_configure_sh0gain(g[7], g[6], g[5], g[4], g[3], g[2],
				g[1], g[0]);

		/* Configure Mux for Sequencer 0 */
		for (i = 0; i < p_adcifa_sequencer_opt->convnb; i++) {
800036f6:	ef 38 ff ff 	ld.ub	r8,r7[-1]
800036fa:	2f f8       	sub	r8,-1
800036fc:	ef 68 ff ff 	st.b	r7[-1],r8
80003700:	ee f8 ff c0 	ld.w	r8,r7[-64]
80003704:	11 88       	ld.ub	r8,r8[0x0]
80003706:	ef 39 ff ff 	ld.ub	r9,r7[-1]
8000370a:	f0 09 18 00 	cp.b	r9,r8
8000370e:	cd 43       	brcs	800036b6 <adcifa_configure_sequencer+0x13a>
			mp[i] = p_adcifa_sequencer_conversion_opt[i].channel_p;
			mn[i] = p_adcifa_sequencer_conversion_opt[i].channel_n;
		}
		ADCIFA_configure_muxsel0p(mp[7], mp[6], mp[5], mp[4], mp[3],
80003710:	fc 78 24 00 	mov	r8,-187392
80003714:	ef 39 ff e3 	ld.ub	r9,r7[-29]
80003718:	f2 0a 15 18 	lsl	r10,r9,0x18
8000371c:	ef 39 ff e2 	ld.ub	r9,r7[-30]
80003720:	b1 69       	lsl	r9,0x10
80003722:	12 4a       	or	r10,r9
80003724:	ef 39 ff e1 	ld.ub	r9,r7[-31]
80003728:	a9 69       	lsl	r9,0x8
8000372a:	12 4a       	or	r10,r9
8000372c:	ef 39 ff e0 	ld.ub	r9,r7[-32]
80003730:	f5 e9 10 09 	or	r9,r10,r9
80003734:	91 b9       	st.w	r8[0x2c],r9
80003736:	fc 78 24 00 	mov	r8,-187392
8000373a:	ef 39 ff df 	ld.ub	r9,r7[-33]
8000373e:	f2 0a 15 18 	lsl	r10,r9,0x18
80003742:	ef 39 ff de 	ld.ub	r9,r7[-34]
80003746:	b1 69       	lsl	r9,0x10
80003748:	12 4a       	or	r10,r9
8000374a:	ef 39 ff dd 	ld.ub	r9,r7[-35]
8000374e:	a9 69       	lsl	r9,0x8
80003750:	12 4a       	or	r10,r9
80003752:	ef 39 ff dc 	ld.ub	r9,r7[-36]
80003756:	f5 e9 10 09 	or	r9,r10,r9
8000375a:	91 99       	st.w	r8[0x24],r9
				mp[2], mp[1], mp[0]);
		ADCIFA_configure_muxsel0n(mn[7], mn[6], mn[5], mn[4], mn[3],
8000375c:	fc 78 24 00 	mov	r8,-187392
80003760:	ef 39 ff d3 	ld.ub	r9,r7[-45]
80003764:	f2 0a 15 18 	lsl	r10,r9,0x18
80003768:	ef 39 ff d2 	ld.ub	r9,r7[-46]
8000376c:	b1 69       	lsl	r9,0x10
8000376e:	12 4a       	or	r10,r9
80003770:	ef 39 ff d1 	ld.ub	r9,r7[-47]
80003774:	a9 69       	lsl	r9,0x8
80003776:	12 4a       	or	r10,r9
80003778:	ef 39 ff d0 	ld.ub	r9,r7[-48]
8000377c:	f5 e9 10 09 	or	r9,r10,r9
80003780:	91 f9       	st.w	r8[0x3c],r9
80003782:	fc 78 24 00 	mov	r8,-187392
80003786:	ef 39 ff cf 	ld.ub	r9,r7[-49]
8000378a:	f2 0a 15 18 	lsl	r10,r9,0x18
8000378e:	ef 39 ff ce 	ld.ub	r9,r7[-50]
80003792:	b1 69       	lsl	r9,0x10
80003794:	12 4a       	or	r10,r9
80003796:	ef 39 ff cd 	ld.ub	r9,r7[-51]
8000379a:	a9 69       	lsl	r9,0x8
8000379c:	12 4a       	or	r10,r9
8000379e:	ef 39 ff cc 	ld.ub	r9,r7[-52]
800037a2:	f5 e9 10 09 	or	r9,r10,r9
800037a6:	91 d9       	st.w	r8[0x34],r9
		 * This adcifa_seq1_configured variable check if muxsel1p,muxsel1n 
		 * registers are already configured. This may happen if this function is
		 * called first with sequencer 1 as argument and then called with 
		 * sequencer 0 as argument in case dual mode is used.
		 */
		if(!adcifa_seq1_configured)
800037a8:	fe f8 02 e0 	ld.w	r8,pc[736]
800037ac:	11 88       	ld.ub	r8,r8[0x0]
800037ae:	ec 18 00 01 	eorl	r8,0x1
800037b2:	5c 58       	castu.b	r8
800037b4:	e0 80 01 63 	breq	80003a7a <adcifa_configure_sequencer+0x4fe>
		{
			/*
			 * Configure gain for sequencer 0 (in single sequencer mode for 
			 * conversions 9 to 16)
			 */ 
			ADCIFA_configure_sh1gain(g[15], g[14], g[13], g[12], g[11], g[10], 
800037b8:	fc 78 24 00 	mov	r8,-187392
800037bc:	ef 39 ff fb 	ld.ub	r9,r7[-5]
800037c0:	f2 0a 15 1c 	lsl	r10,r9,0x1c
800037c4:	ef 39 ff fa 	ld.ub	r9,r7[-6]
800037c8:	b9 69       	lsl	r9,0x18
800037ca:	12 4a       	or	r10,r9
800037cc:	ef 39 ff f9 	ld.ub	r9,r7[-7]
800037d0:	b5 69       	lsl	r9,0x14
800037d2:	12 4a       	or	r10,r9
800037d4:	ef 39 ff f8 	ld.ub	r9,r7[-8]
800037d8:	b1 69       	lsl	r9,0x10
800037da:	12 4a       	or	r10,r9
800037dc:	ef 39 ff f7 	ld.ub	r9,r7[-9]
800037e0:	ad 69       	lsl	r9,0xc
800037e2:	12 4a       	or	r10,r9
800037e4:	ef 39 ff f6 	ld.ub	r9,r7[-10]
800037e8:	a9 69       	lsl	r9,0x8
800037ea:	12 4a       	or	r10,r9
800037ec:	ef 39 ff f5 	ld.ub	r9,r7[-11]
800037f0:	a5 69       	lsl	r9,0x4
800037f2:	12 4a       	or	r10,r9
800037f4:	ef 39 ff f4 	ld.ub	r9,r7[-12]
800037f8:	f5 e9 10 09 	or	r9,r10,r9
800037fc:	91 89       	st.w	r8[0x20],r9

			/*
			 * Configure Mux for sequencer 0 (in single sequencer mode for 
			 * conversions 9 to 16)
			 */
			ADCIFA_configure_muxsel1p(mp[15], mp[14], mp[13], mp[12], mp[11], 
800037fe:	fc 78 24 00 	mov	r8,-187392
80003802:	ef 39 ff eb 	ld.ub	r9,r7[-21]
80003806:	f2 0a 15 18 	lsl	r10,r9,0x18
8000380a:	ef 39 ff ea 	ld.ub	r9,r7[-22]
8000380e:	b1 69       	lsl	r9,0x10
80003810:	12 4a       	or	r10,r9
80003812:	ef 39 ff e9 	ld.ub	r9,r7[-23]
80003816:	a9 69       	lsl	r9,0x8
80003818:	12 4a       	or	r10,r9
8000381a:	ef 39 ff e8 	ld.ub	r9,r7[-24]
8000381e:	f5 e9 10 09 	or	r9,r10,r9
80003822:	91 c9       	st.w	r8[0x30],r9
80003824:	fc 78 24 00 	mov	r8,-187392
80003828:	ef 39 ff e7 	ld.ub	r9,r7[-25]
8000382c:	f2 0a 15 18 	lsl	r10,r9,0x18
80003830:	ef 39 ff e6 	ld.ub	r9,r7[-26]
80003834:	b1 69       	lsl	r9,0x10
80003836:	12 4a       	or	r10,r9
80003838:	ef 39 ff e5 	ld.ub	r9,r7[-27]
8000383c:	a9 69       	lsl	r9,0x8
8000383e:	12 4a       	or	r10,r9
80003840:	ef 39 ff e4 	ld.ub	r9,r7[-28]
80003844:	f5 e9 10 09 	or	r9,r10,r9
80003848:	91 a9       	st.w	r8[0x28],r9
				mp[10], mp[9], mp[8]);
			ADCIFA_configure_muxsel1n(mn[15], mn[14], mn[13], mn[12], mn[11], 
8000384a:	fc 78 24 00 	mov	r8,-187392
8000384e:	ef 39 ff db 	ld.ub	r9,r7[-37]
80003852:	f2 0a 15 18 	lsl	r10,r9,0x18
80003856:	ef 39 ff da 	ld.ub	r9,r7[-38]
8000385a:	b1 69       	lsl	r9,0x10
8000385c:	12 4a       	or	r10,r9
8000385e:	ef 39 ff d9 	ld.ub	r9,r7[-39]
80003862:	a9 69       	lsl	r9,0x8
80003864:	12 4a       	or	r10,r9
80003866:	ef 39 ff d8 	ld.ub	r9,r7[-40]
8000386a:	f5 e9 10 09 	or	r9,r10,r9
8000386e:	f1 49 00 40 	st.w	r8[64],r9
80003872:	fc 78 24 00 	mov	r8,-187392
80003876:	ef 39 ff d7 	ld.ub	r9,r7[-41]
8000387a:	f2 0a 15 18 	lsl	r10,r9,0x18
8000387e:	ef 39 ff d6 	ld.ub	r9,r7[-42]
80003882:	b1 69       	lsl	r9,0x10
80003884:	12 4a       	or	r10,r9
80003886:	ef 39 ff d5 	ld.ub	r9,r7[-43]
8000388a:	a9 69       	lsl	r9,0x8
8000388c:	12 4a       	or	r10,r9
8000388e:	ef 39 ff d4 	ld.ub	r9,r7[-44]
80003892:	f5 e9 10 09 	or	r9,r10,r9
80003896:	91 e9       	st.w	r8[0x38],r9
				mn[10], mn[9], mn[8]);

		}

		break;
80003898:	cf 28       	rjmp	80003a7c <adcifa_configure_sequencer+0x500>

	/* Sequencer 1 */
	case 1:
		/* Configure Sequencer 1 */
		ADCIFA_configure_sequencer_1(
8000389a:	fc 78 24 00 	mov	r8,-187392
8000389e:	ee f9 ff c0 	ld.w	r9,r7[-64]
800038a2:	13 89       	ld.ub	r9,r9[0x0]
800038a4:	20 19       	sub	r9,1
800038a6:	f2 0a 15 10 	lsl	r10,r9,0x10
800038aa:	ee f9 ff c0 	ld.w	r9,r7[-64]
800038ae:	13 99       	ld.ub	r9,r9[0x1]
800038b0:	ad 69       	lsl	r9,0xc
800038b2:	12 4a       	or	r10,r9
800038b4:	ee f9 ff c0 	ld.w	r9,r7[-64]
800038b8:	13 a9       	ld.ub	r9,r9[0x2]
800038ba:	a9 69       	lsl	r9,0x8
800038bc:	12 4a       	or	r10,r9
800038be:	ee f9 ff c0 	ld.w	r9,r7[-64]
800038c2:	13 b9       	ld.ub	r9,r9[0x3]
800038c4:	a3 69       	lsl	r9,0x2
800038c6:	12 4a       	or	r10,r9
800038c8:	ee f9 ff c0 	ld.w	r9,r7[-64]
800038cc:	13 c9       	ld.ub	r9,r9[0x4]
800038ce:	a3 79       	lsl	r9,0x3
800038d0:	12 4a       	or	r10,r9
800038d2:	ee f9 ff c0 	ld.w	r9,r7[-64]
800038d6:	13 d9       	ld.ub	r9,r9[0x5]
800038d8:	a1 79       	lsl	r9,0x1
800038da:	f5 e9 10 09 	or	r9,r10,r9
800038de:	12 9a       	mov	r10,r9
800038e0:	a5 aa       	sbr	r10,0x4
800038e2:	ee f9 ff c0 	ld.w	r9,r7[-64]
800038e6:	13 e9       	ld.ub	r9,r9[0x6]
800038e8:	f5 e9 10 09 	or	r9,r10,r9
800038ec:	91 69       	st.w	r8[0x18],r9
#endif
				(p_adcifa_sequencer_opt->half_word_adjustment),
				(p_adcifa_sequencer_opt->software_acknowledge));

		/* Configure Gain for Sequencer 1 */
		for (i = 0; i < p_adcifa_sequencer_opt->convnb; i++) {
800038ee:	30 08       	mov	r8,0
800038f0:	ef 68 ff ff 	st.b	r7[-1],r8
800038f4:	c1 68       	rjmp	80003920 <adcifa_configure_sequencer+0x3a4>
			g[i] = p_adcifa_sequencer_conversion_opt[i].gain;
800038f6:	ef 3a ff ff 	ld.ub	r10,r7[-1]
800038fa:	ef 39 ff ff 	ld.ub	r9,r7[-1]
800038fe:	12 98       	mov	r8,r9
80003900:	a1 78       	lsl	r8,0x1
80003902:	12 08       	add	r8,r9
80003904:	ee f9 ff bc 	ld.w	r9,r7[-68]
80003908:	f2 08 00 08 	add	r8,r9,r8
8000390c:	11 a8       	ld.ub	r8,r8[0x2]
8000390e:	ee 0a 00 09 	add	r9,r7,r10
80003912:	f3 68 ff ec 	st.b	r9[-20],r8
#endif
				(p_adcifa_sequencer_opt->half_word_adjustment),
				(p_adcifa_sequencer_opt->software_acknowledge));

		/* Configure Gain for Sequencer 1 */
		for (i = 0; i < p_adcifa_sequencer_opt->convnb; i++) {
80003916:	ef 38 ff ff 	ld.ub	r8,r7[-1]
8000391a:	2f f8       	sub	r8,-1
8000391c:	ef 68 ff ff 	st.b	r7[-1],r8
80003920:	ee f8 ff c0 	ld.w	r8,r7[-64]
80003924:	11 88       	ld.ub	r8,r8[0x0]
80003926:	ef 39 ff ff 	ld.ub	r9,r7[-1]
8000392a:	f0 09 18 00 	cp.b	r9,r8
8000392e:	ce 43       	brcs	800038f6 <adcifa_configure_sequencer+0x37a>
			g[i] = p_adcifa_sequencer_conversion_opt[i].gain;
		}
		ADCIFA_configure_sh1gain(g[7], g[6], g[5], g[4], g[3], g[2],
80003930:	fc 78 24 00 	mov	r8,-187392
80003934:	ef 39 ff f3 	ld.ub	r9,r7[-13]
80003938:	f2 0a 15 1c 	lsl	r10,r9,0x1c
8000393c:	ef 39 ff f2 	ld.ub	r9,r7[-14]
80003940:	b9 69       	lsl	r9,0x18
80003942:	12 4a       	or	r10,r9
80003944:	ef 39 ff f1 	ld.ub	r9,r7[-15]
80003948:	b5 69       	lsl	r9,0x14
8000394a:	12 4a       	or	r10,r9
8000394c:	ef 39 ff f0 	ld.ub	r9,r7[-16]
80003950:	b1 69       	lsl	r9,0x10
80003952:	12 4a       	or	r10,r9
80003954:	ef 39 ff ef 	ld.ub	r9,r7[-17]
80003958:	ad 69       	lsl	r9,0xc
8000395a:	12 4a       	or	r10,r9
8000395c:	ef 39 ff ee 	ld.ub	r9,r7[-18]
80003960:	a9 69       	lsl	r9,0x8
80003962:	12 4a       	or	r10,r9
80003964:	ef 39 ff ed 	ld.ub	r9,r7[-19]
80003968:	a5 69       	lsl	r9,0x4
8000396a:	12 4a       	or	r10,r9
8000396c:	ef 39 ff ec 	ld.ub	r9,r7[-20]
80003970:	f5 e9 10 09 	or	r9,r10,r9
80003974:	91 89       	st.w	r8[0x20],r9
				g[1], g[0]);

		/* Configure Mux for Sequencer 1 */
		for (i = 0; i < p_adcifa_sequencer_opt->convnb; i++) {
80003976:	30 08       	mov	r8,0
80003978:	ef 68 ff ff 	st.b	r7[-1],r8
8000397c:	c2 68       	rjmp	800039c8 <adcifa_configure_sequencer+0x44c>
			mp[i] = p_adcifa_sequencer_conversion_opt[i].channel_p;
8000397e:	ef 3a ff ff 	ld.ub	r10,r7[-1]
80003982:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80003986:	12 98       	mov	r8,r9
80003988:	a1 78       	lsl	r8,0x1
8000398a:	12 08       	add	r8,r9
8000398c:	ee f9 ff bc 	ld.w	r9,r7[-68]
80003990:	f2 08 00 08 	add	r8,r9,r8
80003994:	11 88       	ld.ub	r8,r8[0x0]
80003996:	ee 0a 00 09 	add	r9,r7,r10
8000399a:	f3 68 ff dc 	st.b	r9[-36],r8
			mn[i] = p_adcifa_sequencer_conversion_opt[i].channel_n;
8000399e:	ef 3a ff ff 	ld.ub	r10,r7[-1]
800039a2:	ef 39 ff ff 	ld.ub	r9,r7[-1]
800039a6:	12 98       	mov	r8,r9
800039a8:	a1 78       	lsl	r8,0x1
800039aa:	12 08       	add	r8,r9
800039ac:	ee f9 ff bc 	ld.w	r9,r7[-68]
800039b0:	f2 08 00 08 	add	r8,r9,r8
800039b4:	11 98       	ld.ub	r8,r8[0x1]
800039b6:	ee 0a 00 09 	add	r9,r7,r10
800039ba:	f3 68 ff cc 	st.b	r9[-52],r8
		}
		ADCIFA_configure_sh1gain(g[7], g[6], g[5], g[4], g[3], g[2],
				g[1], g[0]);

		/* Configure Mux for Sequencer 1 */
		for (i = 0; i < p_adcifa_sequencer_opt->convnb; i++) {
800039be:	ef 38 ff ff 	ld.ub	r8,r7[-1]
800039c2:	2f f8       	sub	r8,-1
800039c4:	ef 68 ff ff 	st.b	r7[-1],r8
800039c8:	ee f8 ff c0 	ld.w	r8,r7[-64]
800039cc:	11 88       	ld.ub	r8,r8[0x0]
800039ce:	ef 39 ff ff 	ld.ub	r9,r7[-1]
800039d2:	f0 09 18 00 	cp.b	r9,r8
800039d6:	cd 43       	brcs	8000397e <adcifa_configure_sequencer+0x402>
			mp[i] = p_adcifa_sequencer_conversion_opt[i].channel_p;
			mn[i] = p_adcifa_sequencer_conversion_opt[i].channel_n;
		}
		ADCIFA_configure_muxsel1p(mp[7], mp[6], mp[5], mp[4], mp[3],
800039d8:	fc 78 24 00 	mov	r8,-187392
800039dc:	ef 39 ff e3 	ld.ub	r9,r7[-29]
800039e0:	f2 0a 15 18 	lsl	r10,r9,0x18
800039e4:	ef 39 ff e2 	ld.ub	r9,r7[-30]
800039e8:	b1 69       	lsl	r9,0x10
800039ea:	12 4a       	or	r10,r9
800039ec:	ef 39 ff e1 	ld.ub	r9,r7[-31]
800039f0:	a9 69       	lsl	r9,0x8
800039f2:	12 4a       	or	r10,r9
800039f4:	ef 39 ff e0 	ld.ub	r9,r7[-32]
800039f8:	f5 e9 10 09 	or	r9,r10,r9
800039fc:	91 c9       	st.w	r8[0x30],r9
800039fe:	fc 78 24 00 	mov	r8,-187392
80003a02:	ef 39 ff df 	ld.ub	r9,r7[-33]
80003a06:	f2 0a 15 18 	lsl	r10,r9,0x18
80003a0a:	ef 39 ff de 	ld.ub	r9,r7[-34]
80003a0e:	b1 69       	lsl	r9,0x10
80003a10:	12 4a       	or	r10,r9
80003a12:	ef 39 ff dd 	ld.ub	r9,r7[-35]
80003a16:	a9 69       	lsl	r9,0x8
80003a18:	12 4a       	or	r10,r9
80003a1a:	ef 39 ff dc 	ld.ub	r9,r7[-36]
80003a1e:	f5 e9 10 09 	or	r9,r10,r9
80003a22:	91 a9       	st.w	r8[0x28],r9
				mp[2], mp[1], mp[0]);
		ADCIFA_configure_muxsel1n(mn[7], mn[6], mn[5], mn[4], mn[3],
80003a24:	fc 78 24 00 	mov	r8,-187392
80003a28:	ef 39 ff d3 	ld.ub	r9,r7[-45]
80003a2c:	f2 0a 15 18 	lsl	r10,r9,0x18
80003a30:	ef 39 ff d2 	ld.ub	r9,r7[-46]
80003a34:	b1 69       	lsl	r9,0x10
80003a36:	12 4a       	or	r10,r9
80003a38:	ef 39 ff d1 	ld.ub	r9,r7[-47]
80003a3c:	a9 69       	lsl	r9,0x8
80003a3e:	12 4a       	or	r10,r9
80003a40:	ef 39 ff d0 	ld.ub	r9,r7[-48]
80003a44:	f5 e9 10 09 	or	r9,r10,r9
80003a48:	f1 49 00 40 	st.w	r8[64],r9
80003a4c:	fc 78 24 00 	mov	r8,-187392
80003a50:	ef 39 ff cf 	ld.ub	r9,r7[-49]
80003a54:	f2 0a 15 18 	lsl	r10,r9,0x18
80003a58:	ef 39 ff ce 	ld.ub	r9,r7[-50]
80003a5c:	b1 69       	lsl	r9,0x10
80003a5e:	12 4a       	or	r10,r9
80003a60:	ef 39 ff cd 	ld.ub	r9,r7[-51]
80003a64:	a9 69       	lsl	r9,0x8
80003a66:	12 4a       	or	r10,r9
80003a68:	ef 39 ff cc 	ld.ub	r9,r7[-52]
80003a6c:	f5 e9 10 09 	or	r9,r10,r9
80003a70:	91 e9       	st.w	r8[0x38],r9
				mn[2], mn[1], mn[0]);

		adcifa_seq1_configured = true;
80003a72:	48 69       	lddpc	r9,80003a88 <adcifa_configure_sequencer+0x50c>
80003a74:	30 18       	mov	r8,1
80003a76:	b2 88       	st.b	r9[0x0],r8
80003a78:	c0 28       	rjmp	80003a7c <adcifa_configure_sequencer+0x500>
			ADCIFA_configure_muxsel1n(mn[15], mn[14], mn[13], mn[12], mn[11], 
				mn[10], mn[9], mn[8]);

		}

		break;
80003a7a:	d7 03       	nop
		break;

	default:
		break;
	}
	return ADCIFA_CONFIGURATION_ACCEPTED;
80003a7c:	30 18       	mov	r8,1
}
80003a7e:	10 9c       	mov	r12,r8
80003a80:	2e fd       	sub	sp,-68
80003a82:	e3 cd 80 80 	ldm	sp++,r7,pc
80003a86:	00 00       	add	r0,r0
80003a88:	00 00       	add	r0,r0
80003a8a:	05 c0       	ld.ub	r0,r2[0x4]

80003a8c <adcifa_start_sequencer>:
/** \brief Start analog to digital conversion for a specific sequencer
 *  \param adcifa     Base address of the ADCIFA
 *  \param sequencer  Sequencer index
 */
void adcifa_start_sequencer(volatile avr32_adcifa_t *adcifa, uint8_t sequencer)
{
80003a8c:	eb cd 40 80 	pushm	r7,lr
80003a90:	1a 97       	mov	r7,sp
80003a92:	20 2d       	sub	sp,8
80003a94:	ef 4c ff fc 	st.w	r7[-4],r12
80003a98:	16 98       	mov	r8,r11
80003a9a:	ef 68 ff f8 	st.b	r7[-8],r8
	/* Sanity Check */
	Assert( adcifa != NULL );

	/* Switch Sequencer */
	switch (sequencer) {
80003a9e:	ef 38 ff f8 	ld.ub	r8,r7[-8]
80003aa2:	58 18       	cp.w	r8,1
80003aa4:	c0 a0       	breq	80003ab8 <adcifa_start_sequencer+0x2c>
80003aa6:	58 38       	cp.w	r8,3
80003aa8:	c0 d0       	breq	80003ac2 <adcifa_start_sequencer+0x36>
80003aaa:	58 08       	cp.w	r8,0
80003aac:	c0 f1       	brne	80003aca <adcifa_start_sequencer+0x3e>
	case ADCIFA_SEQ0:
		ADCIFA_softsoc_sequencer(AVR32_ADCIFA_CR_SOC0_MASK);
80003aae:	fc 78 24 00 	mov	r8,-187392
80003ab2:	30 19       	mov	r9,1
80003ab4:	91 09       	st.w	r8[0x0],r9
		break;
80003ab6:	c0 a8       	rjmp	80003aca <adcifa_start_sequencer+0x3e>

	case ADCIFA_SEQ1:
		ADCIFA_softsoc_sequencer(AVR32_ADCIFA_CR_SOC1_MASK);
80003ab8:	fc 78 24 00 	mov	r8,-187392
80003abc:	30 29       	mov	r9,2
80003abe:	91 09       	st.w	r8[0x0],r9
		break;
80003ac0:	c0 58       	rjmp	80003aca <adcifa_start_sequencer+0x3e>

	case ADCIFA_SEQ0_SEQ1:
		ADCIFA_softsoc_sequencer(
80003ac2:	fc 78 24 00 	mov	r8,-187392
80003ac6:	30 39       	mov	r9,3
80003ac8:	91 09       	st.w	r8[0x0],r9
		break;

	default:
		break;
	}
}
80003aca:	2f ed       	sub	sp,-8
80003acc:	e3 cd 80 80 	ldm	sp++,r7,pc

80003ad0 <adcifa_check_eos>:
/** \brief Get End of Conversion status bit
 *  \param adcifa     Base address of the ADCIFA
 *  \param sequencer  Sequencer index
 */
bool adcifa_check_eos(volatile avr32_adcifa_t *adcifa, uint8_t sequencer)
{
80003ad0:	eb cd 40 80 	pushm	r7,lr
80003ad4:	1a 97       	mov	r7,sp
80003ad6:	20 2d       	sub	sp,8
80003ad8:	ef 4c ff fc 	st.w	r7[-4],r12
80003adc:	16 98       	mov	r8,r11
80003ade:	ef 68 ff f8 	st.b	r7[-8],r8
	/* Sanity Check */
	Assert( adcifa != NULL );

	/* get SR register : EOS bit for channel */
	switch (sequencer) {
80003ae2:	ef 38 ff f8 	ld.ub	r8,r7[-8]
80003ae6:	58 08       	cp.w	r8,0
80003ae8:	c0 40       	breq	80003af0 <adcifa_check_eos+0x20>
80003aea:	58 18       	cp.w	r8,1
80003aec:	c0 90       	breq	80003afe <adcifa_check_eos+0x2e>
80003aee:	c1 08       	rjmp	80003b0e <adcifa_check_eos+0x3e>
	case 0:
		return ((ADCIFA_is_eos_sequencer_0()) ? true : false);
80003af0:	fc 78 24 00 	mov	r8,-187392
80003af4:	70 28       	ld.w	r8,r8[0x8]
80003af6:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80003afa:	5c 58       	castu.b	r8
80003afc:	c0 a8       	rjmp	80003b10 <adcifa_check_eos+0x40>

	case 1:
		return ((ADCIFA_is_eos_sequencer_1()) ? true : false);
80003afe:	fc 78 24 00 	mov	r8,-187392
80003b02:	70 28       	ld.w	r8,r8[0x8]
80003b04:	e2 18 00 10 	andl	r8,0x10,COH
80003b08:	5f 18       	srne	r8
80003b0a:	5c 58       	castu.b	r8
80003b0c:	c0 28       	rjmp	80003b10 <adcifa_check_eos+0x40>

	default:
		break;
	}
	return false;
80003b0e:	30 08       	mov	r8,0
}
80003b10:	10 9c       	mov	r12,r8
80003b12:	2f ed       	sub	sp,-8
80003b14:	e3 cd 80 80 	ldm	sp++,r7,pc

80003b18 <adcifa_get_values_from_sequencer>:
 */
uint8_t adcifa_get_values_from_sequencer(volatile avr32_adcifa_t *adcifa,
		uint8_t sequencer,
		adcifa_sequencer_opt_t *p_adcifa_sequencer_opt,
		int16_t *adcifa_values)
{
80003b18:	eb cd 40 80 	pushm	r7,lr
80003b1c:	1a 97       	mov	r7,sp
80003b1e:	20 5d       	sub	sp,20
80003b20:	ef 4c ff f8 	st.w	r7[-8],r12
80003b24:	16 98       	mov	r8,r11
80003b26:	ef 4a ff f0 	st.w	r7[-16],r10
80003b2a:	ef 49 ff ec 	st.w	r7[-20],r9
80003b2e:	ef 68 ff f4 	st.b	r7[-12],r8

	/* Sanity Check */
	Assert( adcifa != NULL );

	/* wait for end of sequence */
	if (adcifa_check_eos(adcifa, sequencer) != true) {
80003b32:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80003b36:	10 9b       	mov	r11,r8
80003b38:	ee fc ff f8 	ld.w	r12,r7[-8]
80003b3c:	f0 1f 00 2c 	mcall	80003bec <adcifa_get_values_from_sequencer+0xd4>
80003b40:	18 98       	mov	r8,r12
80003b42:	ec 18 00 01 	eorl	r8,0x1
80003b46:	5c 58       	castu.b	r8
80003b48:	c0 30       	breq	80003b4e <adcifa_get_values_from_sequencer+0x36>
		return ADCIFA_STATUS_NOT_COMPLETED;
80003b4a:	30 38       	mov	r8,3
80003b4c:	c4 b8       	rjmp	80003be2 <adcifa_get_values_from_sequencer+0xca>
	}

	switch (sequencer) {
80003b4e:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80003b52:	58 08       	cp.w	r8,0
80003b54:	c0 40       	breq	80003b5c <adcifa_get_values_from_sequencer+0x44>
80003b56:	58 18       	cp.w	r8,1
80003b58:	c2 30       	breq	80003b9e <adcifa_get_values_from_sequencer+0x86>
80003b5a:	c4 38       	rjmp	80003be0 <adcifa_get_values_from_sequencer+0xc8>
	case 0:
		/* Read values from Sequencer 0 */
		for (i = 0; i < p_adcifa_sequencer_opt->convnb; i++) {
80003b5c:	30 08       	mov	r8,0
80003b5e:	ef 68 ff ff 	st.b	r7[-1],r8
80003b62:	c1 58       	rjmp	80003b8c <adcifa_get_values_from_sequencer+0x74>
			adcifa_values[i] = ADCIFA_read_resx_sequencer_0(i);
80003b64:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80003b68:	a1 78       	lsl	r8,0x1
80003b6a:	ee f9 ff ec 	ld.w	r9,r7[-20]
80003b6e:	10 09       	add	r9,r8
80003b70:	fc 78 24 00 	mov	r8,-187392
80003b74:	ef 3a ff ff 	ld.ub	r10,r7[-1]
80003b78:	2d fa       	sub	r10,-33
80003b7a:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
80003b7e:	5c 88       	casts.h	r8
80003b80:	b2 08       	st.h	r9[0x0],r8
	}

	switch (sequencer) {
	case 0:
		/* Read values from Sequencer 0 */
		for (i = 0; i < p_adcifa_sequencer_opt->convnb; i++) {
80003b82:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80003b86:	2f f8       	sub	r8,-1
80003b88:	ef 68 ff ff 	st.b	r7[-1],r8
80003b8c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003b90:	11 88       	ld.ub	r8,r8[0x0]
80003b92:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80003b96:	f0 09 18 00 	cp.b	r9,r8
80003b9a:	ce 53       	brcs	80003b64 <adcifa_get_values_from_sequencer+0x4c>
			adcifa_values[i] = ADCIFA_read_resx_sequencer_0(i);
		}
		break;
80003b9c:	c2 28       	rjmp	80003be0 <adcifa_get_values_from_sequencer+0xc8>

	case 1:
		/* Read values from Sequencer 1 */
		for (i = 0; i < p_adcifa_sequencer_opt->convnb; i++) {
80003b9e:	30 08       	mov	r8,0
80003ba0:	ef 68 ff ff 	st.b	r7[-1],r8
80003ba4:	c1 68       	rjmp	80003bd0 <adcifa_get_values_from_sequencer+0xb8>
			adcifa_values[i] = ADCIFA_read_resx_sequencer_1(i);
80003ba6:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80003baa:	a1 78       	lsl	r8,0x1
80003bac:	ee f9 ff ec 	ld.w	r9,r7[-20]
80003bb0:	10 09       	add	r9,r8
80003bb2:	fc 78 24 00 	mov	r8,-187392
80003bb6:	ef 3a ff ff 	ld.ub	r10,r7[-1]
80003bba:	2f 8a       	sub	r10,-8
80003bbc:	2d fa       	sub	r10,-33
80003bbe:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
80003bc2:	5c 88       	casts.h	r8
80003bc4:	b2 08       	st.h	r9[0x0],r8
		}
		break;

	case 1:
		/* Read values from Sequencer 1 */
		for (i = 0; i < p_adcifa_sequencer_opt->convnb; i++) {
80003bc6:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80003bca:	2f f8       	sub	r8,-1
80003bcc:	ef 68 ff ff 	st.b	r7[-1],r8
80003bd0:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003bd4:	11 88       	ld.ub	r8,r8[0x0]
80003bd6:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80003bda:	f0 09 18 00 	cp.b	r9,r8
80003bde:	ce 43       	brcs	80003ba6 <adcifa_get_values_from_sequencer+0x8e>

	default:
		break;
	}

	return ADCIFA_STATUS_COMPLETED;
80003be0:	30 28       	mov	r8,2
}
80003be2:	10 9c       	mov	r12,r8
80003be4:	2f bd       	sub	sp,-20
80003be6:	e3 cd 80 80 	ldm	sp++,r7,pc
80003bea:	00 00       	add	r0,r0
80003bec:	80 00       	ld.sh	r0,r0[0x0]
80003bee:	3a d0       	mov	r0,-83

80003bf0 <flashc_get_flash_size>:
 */
//! @{


unsigned int flashc_get_flash_size(void)
{
80003bf0:	eb cd 40 80 	pushm	r7,lr
80003bf4:	1a 97       	mov	r7,sp
80003bf6:	20 8d       	sub	sp,32
		384,
		512,
		768,
		1024,
		2048,
	};
80003bf8:	48 c9       	lddpc	r9,80003c28 <flashc_get_flash_size+0x38>
80003bfa:	ee c8 00 1e 	sub	r8,r7,30
80003bfe:	31 ea       	mov	r10,30
80003c00:	12 9b       	mov	r11,r9
80003c02:	10 9c       	mov	r12,r8
80003c04:	f0 1f 00 0a 	mcall	80003c2c <flashc_get_flash_size+0x3c>
	return ((unsigned int)FLASH_SIZE[(AVR32_FLASHC.pr & AVR32_FLASHC_PR_FSZ_MASK)
80003c08:	fe 68 00 00 	mov	r8,-131072
80003c0c:	70 38       	ld.w	r8,r8[0xc]
80003c0e:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80003c12:	a1 78       	lsl	r8,0x1
80003c14:	ee 08 00 08 	add	r8,r7,r8
80003c18:	f1 08 ff e2 	ld.sh	r8,r8[-30]
80003c1c:	5c 78       	castu.h	r8
80003c1e:	ab 68       	lsl	r8,0xa
		1024,
	};
	return ((unsigned int)FLASH_SIZE[(AVR32_FLASHC.fsr & AVR32_FLASHC_FSR_FSZ_MASK)
			>> AVR32_FLASHC_FSR_FSZ_OFFSET]) << 10;
#endif
}
80003c20:	10 9c       	mov	r12,r8
80003c22:	2f 8d       	sub	sp,-32
80003c24:	e3 cd 80 80 	ldm	sp++,r7,pc
80003c28:	80 01       	ld.sh	r1,r0[0x0]
80003c2a:	24 20       	sub	r0,66
80003c2c:	80 00       	ld.sh	r0,r0[0x0]
80003c2e:	cc ba       	rjmp	800039c4 <adcifa_configure_sequencer+0x448>

80003c30 <flashc_is_ready>:
 */
//! @{


bool flashc_is_ready(void)
{
80003c30:	eb cd 40 80 	pushm	r7,lr
80003c34:	1a 97       	mov	r7,sp
	return ((AVR32_FLASHC.fsr & AVR32_FLASHC_FSR_FRDY_MASK) != 0);
80003c36:	fe 68 00 00 	mov	r8,-131072
80003c3a:	70 28       	ld.w	r8,r8[0x8]
80003c3c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80003c40:	5c 58       	castu.b	r8
}
80003c42:	10 9c       	mov	r12,r8
80003c44:	e3 cd 80 80 	ldm	sp++,r7,pc

80003c48 <flashc_default_wait_until_ready>:


void flashc_default_wait_until_ready(void)
{
80003c48:	eb cd 40 80 	pushm	r7,lr
80003c4c:	1a 97       	mov	r7,sp
	while (!flashc_is_ready());
80003c4e:	f0 1f 00 05 	mcall	80003c60 <flashc_default_wait_until_ready+0x18>
80003c52:	18 98       	mov	r8,r12
80003c54:	ec 18 00 01 	eorl	r8,0x1
80003c58:	5c 58       	castu.b	r8
80003c5a:	cf a1       	brne	80003c4e <flashc_default_wait_until_ready+0x6>
}
80003c5c:	e3 cd 80 80 	ldm	sp++,r7,pc
80003c60:	80 00       	ld.sh	r0,r0[0x0]
80003c62:	3c 30       	mov	r0,-61

80003c64 <flashc_get_error_status>:
 *          Flash Status Register (FSR). This function is therefore not part of
 *          the driver's API which instead presents \ref flashc_is_lock_error
 *          and \ref flashc_is_programming_error.
 */
static unsigned int flashc_get_error_status(void)
{
80003c64:	eb cd 40 80 	pushm	r7,lr
80003c68:	1a 97       	mov	r7,sp
	return AVR32_FLASHC.fsr & (AVR32_FLASHC_FSR_LOCKE_MASK |
80003c6a:	fe 68 00 00 	mov	r8,-131072
80003c6e:	70 28       	ld.w	r8,r8[0x8]
80003c70:	e2 18 00 0c 	andl	r8,0xc,COH
			AVR32_FLASHC_FSR_PROGE_MASK);
}
80003c74:	10 9c       	mov	r12,r8
80003c76:	e3 cd 80 80 	ldm	sp++,r7,pc
80003c7a:	d7 03       	nop

80003c7c <flashc_issue_command>:
	return (AVR32_FLASHC.fcmd & AVR32_FLASHC_FCMD_PAGEN_MASK) >> AVR32_FLASHC_FCMD_PAGEN_OFFSET;
}


void flashc_issue_command(unsigned int command, int page_number)
{
80003c7c:	eb cd 40 80 	pushm	r7,lr
80003c80:	1a 97       	mov	r7,sp
80003c82:	20 3d       	sub	sp,12
80003c84:	ef 4c ff f8 	st.w	r7[-8],r12
80003c88:	ef 4b ff f4 	st.w	r7[-12],r11
	u_avr32_flashc_fcmd_t u_avr32_flashc_fcmd;

	flashc_wait_until_ready();
80003c8c:	49 b8       	lddpc	r8,80003cf8 <flashc_issue_command+0x7c>
80003c8e:	70 08       	ld.w	r8,r8[0x0]
80003c90:	5d 18       	icall	r8
	u_avr32_flashc_fcmd.fcmd = AVR32_FLASHC.fcmd;
80003c92:	fe 68 00 00 	mov	r8,-131072
80003c96:	70 18       	ld.w	r8,r8[0x4]
80003c98:	ef 48 ff fc 	st.w	r7[-4],r8
	u_avr32_flashc_fcmd.FCMD.cmd = command;
80003c9c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003ca0:	5c 58       	castu.b	r8
80003ca2:	f1 d8 c0 06 	bfextu	r8,r8,0x0,0x6
80003ca6:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80003caa:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003cae:	f1 d9 d0 06 	bfins	r8,r9,0x0,0x6
80003cb2:	ef 48 ff fc 	st.w	r7[-4],r8
	if (page_number >= 0) {
80003cb6:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003cba:	58 08       	cp.w	r8,0
80003cbc:	c0 b5       	brlt	80003cd2 <flashc_issue_command+0x56>
		u_avr32_flashc_fcmd.FCMD.pagen = page_number;
80003cbe:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003cc2:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80003cc6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003cca:	f1 d9 d1 10 	bfins	r8,r9,0x8,0x10
80003cce:	ef 48 ff fc 	st.w	r7[-4],r8
	}
	u_avr32_flashc_fcmd.FCMD.key = AVR32_FLASHC_FCMD_KEY_KEY;
80003cd2:	3a 58       	mov	r8,-91
80003cd4:	ef 68 ff fc 	st.b	r7[-4],r8
	AVR32_FLASHC.fcmd = u_avr32_flashc_fcmd.fcmd;
80003cd8:	fe 68 00 00 	mov	r8,-131072
80003cdc:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003ce0:	91 19       	st.w	r8[0x4],r9
	flashc_error_status = flashc_get_error_status();
80003ce2:	f0 1f 00 07 	mcall	80003cfc <flashc_issue_command+0x80>
80003ce6:	18 99       	mov	r9,r12
80003ce8:	48 68       	lddpc	r8,80003d00 <flashc_issue_command+0x84>
80003cea:	91 09       	st.w	r8[0x0],r9
	flashc_wait_until_ready();
80003cec:	48 38       	lddpc	r8,80003cf8 <flashc_issue_command+0x7c>
80003cee:	70 08       	ld.w	r8,r8[0x0]
80003cf0:	5d 18       	icall	r8
}
80003cf2:	2f dd       	sub	sp,-12
80003cf4:	e3 cd 80 80 	ldm	sp++,r7,pc
80003cf8:	00 00       	add	r0,r0
80003cfa:	00 08       	add	r8,r0
80003cfc:	80 00       	ld.sh	r0,r0[0x0]
80003cfe:	3c 64       	mov	r4,-58
80003d00:	00 00       	add	r0,r0
80003d02:	05 c4       	ld.ub	r4,r2[0x4]

80003d04 <flashc_clear_page_buffer>:
 */
//! @{


void flashc_clear_page_buffer(void)
{
80003d04:	eb cd 40 80 	pushm	r7,lr
80003d08:	1a 97       	mov	r7,sp
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_CPB, -1);
80003d0a:	3f fb       	mov	r11,-1
80003d0c:	30 3c       	mov	r12,3
80003d0e:	f0 1f 00 03 	mcall	80003d18 <flashc_clear_page_buffer+0x14>
}
80003d12:	e3 cd 80 80 	ldm	sp++,r7,pc
80003d16:	00 00       	add	r0,r0
80003d18:	80 00       	ld.sh	r0,r0[0x0]
80003d1a:	3c 7c       	mov	r12,-57

80003d1c <flashc_is_page_erased>:


bool flashc_is_page_erased(void)
{
80003d1c:	eb cd 40 80 	pushm	r7,lr
80003d20:	1a 97       	mov	r7,sp
	return ((AVR32_FLASHC.fsr & AVR32_FLASHC_FSR_QPRR_MASK) != 0);
80003d22:	fe 68 00 00 	mov	r8,-131072
80003d26:	70 28       	ld.w	r8,r8[0x8]
80003d28:	e2 18 00 20 	andl	r8,0x20,COH
80003d2c:	5f 18       	srne	r8
80003d2e:	5c 58       	castu.b	r8
}
80003d30:	10 9c       	mov	r12,r8
80003d32:	e3 cd 80 80 	ldm	sp++,r7,pc
80003d36:	d7 03       	nop

80003d38 <flashc_quick_page_read>:


bool flashc_quick_page_read(int page_number)
{
80003d38:	eb cd 40 80 	pushm	r7,lr
80003d3c:	1a 97       	mov	r7,sp
80003d3e:	20 1d       	sub	sp,4
80003d40:	ef 4c ff fc 	st.w	r7[-4],r12
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_QPR, page_number);
80003d44:	ee fb ff fc 	ld.w	r11,r7[-4]
80003d48:	30 cc       	mov	r12,12
80003d4a:	f0 1f 00 05 	mcall	80003d5c <flashc_quick_page_read+0x24>
	return flashc_is_page_erased();
80003d4e:	f0 1f 00 05 	mcall	80003d60 <flashc_quick_page_read+0x28>
80003d52:	18 98       	mov	r8,r12
}
80003d54:	10 9c       	mov	r12,r8
80003d56:	2f fd       	sub	sp,-4
80003d58:	e3 cd 80 80 	ldm	sp++,r7,pc
80003d5c:	80 00       	ld.sh	r0,r0[0x0]
80003d5e:	3c 7c       	mov	r12,-57
80003d60:	80 00       	ld.sh	r0,r0[0x0]
80003d62:	3d 1c       	mov	r12,-47

80003d64 <flashc_erase_page>:


bool flashc_erase_page(int page_number, bool check)
{
80003d64:	eb cd 40 80 	pushm	r7,lr
80003d68:	1a 97       	mov	r7,sp
80003d6a:	20 4d       	sub	sp,16
80003d6c:	ef 4c ff f4 	st.w	r7[-12],r12
80003d70:	16 98       	mov	r8,r11
80003d72:	ef 68 ff f0 	st.b	r7[-16],r8
	bool page_erased = true;
80003d76:	30 18       	mov	r8,1
80003d78:	ef 68 ff fb 	st.b	r7[-5],r8

	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_EP, page_number);
80003d7c:	ee fb ff f4 	ld.w	r11,r7[-12]
80003d80:	30 2c       	mov	r12,2
80003d82:	f0 1f 00 10 	mcall	80003dc0 <flashc_erase_page+0x5c>
	if (check) {
80003d86:	ef 39 ff f0 	ld.ub	r9,r7[-16]
80003d8a:	30 08       	mov	r8,0
80003d8c:	f0 09 18 00 	cp.b	r9,r8
80003d90:	c1 20       	breq	80003db4 <flashc_erase_page+0x50>
		unsigned int error_status = flashc_error_status;
80003d92:	48 d8       	lddpc	r8,80003dc4 <flashc_erase_page+0x60>
80003d94:	70 08       	ld.w	r8,r8[0x0]
80003d96:	ef 48 ff fc 	st.w	r7[-4],r8
		page_erased = flashc_quick_page_read(-1);
80003d9a:	3f fc       	mov	r12,-1
80003d9c:	f0 1f 00 0b 	mcall	80003dc8 <flashc_erase_page+0x64>
80003da0:	18 98       	mov	r8,r12
80003da2:	ef 68 ff fb 	st.b	r7[-5],r8
		flashc_error_status |= error_status;
80003da6:	48 88       	lddpc	r8,80003dc4 <flashc_erase_page+0x60>
80003da8:	70 09       	ld.w	r9,r8[0x0]
80003daa:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003dae:	10 49       	or	r9,r8
80003db0:	48 58       	lddpc	r8,80003dc4 <flashc_erase_page+0x60>
80003db2:	91 09       	st.w	r8[0x0],r9
	}
	return page_erased;
80003db4:	ef 38 ff fb 	ld.ub	r8,r7[-5]
}
80003db8:	10 9c       	mov	r12,r8
80003dba:	2f cd       	sub	sp,-16
80003dbc:	e3 cd 80 80 	ldm	sp++,r7,pc
80003dc0:	80 00       	ld.sh	r0,r0[0x0]
80003dc2:	3c 7c       	mov	r12,-57
80003dc4:	00 00       	add	r0,r0
80003dc6:	05 c4       	ld.ub	r4,r2[0x4]
80003dc8:	80 00       	ld.sh	r0,r0[0x0]
80003dca:	3d 38       	mov	r8,-45

80003dcc <flashc_write_page>:
	return all_pages_erased;
}


void flashc_write_page(int page_number)
{
80003dcc:	eb cd 40 80 	pushm	r7,lr
80003dd0:	1a 97       	mov	r7,sp
80003dd2:	20 1d       	sub	sp,4
80003dd4:	ef 4c ff fc 	st.w	r7[-4],r12
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_WP, page_number);
80003dd8:	ee fb ff fc 	ld.w	r11,r7[-4]
80003ddc:	30 1c       	mov	r12,1
80003dde:	f0 1f 00 03 	mcall	80003de8 <flashc_write_page+0x1c>
}
80003de2:	2f fd       	sub	sp,-4
80003de4:	e3 cd 80 80 	ldm	sp++,r7,pc
80003de8:	80 00       	ld.sh	r0,r0[0x0]
80003dea:	3c 7c       	mov	r12,-57

80003dec <flashc_quick_user_page_read>:


bool flashc_quick_user_page_read(void)
{
80003dec:	eb cd 40 80 	pushm	r7,lr
80003df0:	1a 97       	mov	r7,sp
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_QPRUP, -1);
80003df2:	3f fb       	mov	r11,-1
80003df4:	30 fc       	mov	r12,15
80003df6:	f0 1f 00 05 	mcall	80003e08 <flashc_quick_user_page_read+0x1c>
	return flashc_is_page_erased();
80003dfa:	f0 1f 00 05 	mcall	80003e0c <flashc_quick_user_page_read+0x20>
80003dfe:	18 98       	mov	r8,r12
}
80003e00:	10 9c       	mov	r12,r8
80003e02:	e3 cd 80 80 	ldm	sp++,r7,pc
80003e06:	00 00       	add	r0,r0
80003e08:	80 00       	ld.sh	r0,r0[0x0]
80003e0a:	3c 7c       	mov	r12,-57
80003e0c:	80 00       	ld.sh	r0,r0[0x0]
80003e0e:	3d 1c       	mov	r12,-47

80003e10 <flashc_erase_user_page>:


bool flashc_erase_user_page(bool check)
{
80003e10:	eb cd 40 80 	pushm	r7,lr
80003e14:	1a 97       	mov	r7,sp
80003e16:	20 1d       	sub	sp,4
80003e18:	18 98       	mov	r8,r12
80003e1a:	ef 68 ff fc 	st.b	r7[-4],r8
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_EUP, -1);
80003e1e:	3f fb       	mov	r11,-1
80003e20:	30 ec       	mov	r12,14
80003e22:	f0 1f 00 09 	mcall	80003e44 <flashc_erase_user_page+0x34>
	return (check) ? flashc_quick_user_page_read() : true;
80003e26:	ef 39 ff fc 	ld.ub	r9,r7[-4]
80003e2a:	30 08       	mov	r8,0
80003e2c:	f0 09 18 00 	cp.b	r9,r8
80003e30:	c0 50       	breq	80003e3a <flashc_erase_user_page+0x2a>
80003e32:	f0 1f 00 06 	mcall	80003e48 <flashc_erase_user_page+0x38>
80003e36:	18 98       	mov	r8,r12
80003e38:	c0 28       	rjmp	80003e3c <flashc_erase_user_page+0x2c>
80003e3a:	30 18       	mov	r8,1
}
80003e3c:	10 9c       	mov	r12,r8
80003e3e:	2f fd       	sub	sp,-4
80003e40:	e3 cd 80 80 	ldm	sp++,r7,pc
80003e44:	80 00       	ld.sh	r0,r0[0x0]
80003e46:	3c 7c       	mov	r12,-57
80003e48:	80 00       	ld.sh	r0,r0[0x0]
80003e4a:	3d ec       	mov	r12,-34

80003e4c <flashc_write_user_page>:


void flashc_write_user_page(void)
{
80003e4c:	eb cd 40 80 	pushm	r7,lr
80003e50:	1a 97       	mov	r7,sp
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_WUP, -1);
80003e52:	3f fb       	mov	r11,-1
80003e54:	30 dc       	mov	r12,13
80003e56:	f0 1f 00 03 	mcall	80003e60 <flashc_write_user_page+0x14>
}
80003e5a:	e3 cd 80 80 	ldm	sp++,r7,pc
80003e5e:	00 00       	add	r0,r0
80003e60:	80 00       	ld.sh	r0,r0[0x0]
80003e62:	3c 7c       	mov	r12,-57

80003e64 <flashc_memset8>:


volatile void *flashc_memset8(volatile void *dst, uint8_t src, size_t nbytes, bool erase)
{
80003e64:	eb cd 40 80 	pushm	r7,lr
80003e68:	1a 97       	mov	r7,sp
80003e6a:	20 4d       	sub	sp,16
80003e6c:	ef 4c ff fc 	st.w	r7[-4],r12
80003e70:	ef 4a ff f4 	st.w	r7[-12],r10
80003e74:	12 98       	mov	r8,r9
80003e76:	16 99       	mov	r9,r11
80003e78:	ef 69 ff f8 	st.b	r7[-8],r9
80003e7c:	ef 68 ff f0 	st.b	r7[-16],r8
	return flashc_memset16(dst, src | (uint16_t)src << 8, nbytes, erase);
80003e80:	ef 39 ff f0 	ld.ub	r9,r7[-16]
80003e84:	ef 3a ff f8 	ld.ub	r10,r7[-8]
80003e88:	ef 38 ff f8 	ld.ub	r8,r7[-8]
80003e8c:	a9 68       	lsl	r8,0x8
80003e8e:	5c 88       	casts.h	r8
80003e90:	f5 e8 10 08 	or	r8,r10,r8
80003e94:	5c 88       	casts.h	r8
80003e96:	5c 78       	castu.h	r8
80003e98:	ee fa ff f4 	ld.w	r10,r7[-12]
80003e9c:	10 9b       	mov	r11,r8
80003e9e:	ee fc ff fc 	ld.w	r12,r7[-4]
80003ea2:	f0 1f 00 04 	mcall	80003eb0 <flashc_memset8+0x4c>
80003ea6:	18 98       	mov	r8,r12
}
80003ea8:	10 9c       	mov	r12,r8
80003eaa:	2f cd       	sub	sp,-16
80003eac:	e3 cd 80 80 	ldm	sp++,r7,pc
80003eb0:	80 00       	ld.sh	r0,r0[0x0]
80003eb2:	3e b4       	mov	r4,-21

80003eb4 <flashc_memset16>:


volatile void *flashc_memset16(volatile void *dst, uint16_t src, size_t nbytes, bool erase)
{
80003eb4:	eb cd 40 80 	pushm	r7,lr
80003eb8:	1a 97       	mov	r7,sp
80003eba:	20 4d       	sub	sp,16
80003ebc:	ef 4c ff fc 	st.w	r7[-4],r12
80003ec0:	ef 4a ff f4 	st.w	r7[-12],r10
80003ec4:	12 98       	mov	r8,r9
80003ec6:	16 99       	mov	r9,r11
80003ec8:	ef 59 ff f8 	st.h	r7[-8],r9
80003ecc:	ef 68 ff f0 	st.b	r7[-16],r8
	return flashc_memset32(dst, src | (uint32_t)src << 16, nbytes, erase);
80003ed0:	ef 39 ff f0 	ld.ub	r9,r7[-16]
80003ed4:	ef 1a ff f8 	ld.uh	r10,r7[-8]
80003ed8:	ef 18 ff f8 	ld.uh	r8,r7[-8]
80003edc:	b1 68       	lsl	r8,0x10
80003ede:	f5 e8 10 08 	or	r8,r10,r8
80003ee2:	ee fa ff f4 	ld.w	r10,r7[-12]
80003ee6:	10 9b       	mov	r11,r8
80003ee8:	ee fc ff fc 	ld.w	r12,r7[-4]
80003eec:	f0 1f 00 04 	mcall	80003efc <flashc_memset16+0x48>
80003ef0:	18 98       	mov	r8,r12
}
80003ef2:	10 9c       	mov	r12,r8
80003ef4:	2f cd       	sub	sp,-16
80003ef6:	e3 cd 80 80 	ldm	sp++,r7,pc
80003efa:	00 00       	add	r0,r0
80003efc:	80 00       	ld.sh	r0,r0[0x0]
80003efe:	3f 00       	mov	r0,-16

80003f00 <flashc_memset32>:


volatile void *flashc_memset32(volatile void *dst, uint32_t src, size_t nbytes, bool erase)
{
80003f00:	eb cd 40 8f 	pushm	r0-r3,r7,lr
80003f04:	1a 97       	mov	r7,sp
80003f06:	20 6d       	sub	sp,24
80003f08:	ef 4c ff fc 	st.w	r7[-4],r12
80003f0c:	ef 4b ff f8 	st.w	r7[-8],r11
80003f10:	ef 4a ff f4 	st.w	r7[-12],r10
80003f14:	12 98       	mov	r8,r9
80003f16:	ef 68 ff f0 	st.b	r7[-16],r8
	return flashc_memset64(dst, src | (uint64_t)src << 32, nbytes, erase);
80003f1a:	ef 38 ff f0 	ld.ub	r8,r7[-16]
80003f1e:	ee f0 ff f8 	ld.w	r0,r7[-8]
80003f22:	30 01       	mov	r1,0
80003f24:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003f28:	ef 49 ff ec 	st.w	r7[-20],r9
80003f2c:	30 09       	mov	r9,0
80003f2e:	ef 49 ff e8 	st.w	r7[-24],r9
80003f32:	ee f3 ff ec 	ld.w	r3,r7[-20]
80003f36:	a1 63       	lsl	r3,0x0
80003f38:	30 02       	mov	r2,0
80003f3a:	e1 e2 10 0a 	or	r10,r0,r2
80003f3e:	e3 e3 10 0b 	or	r11,r1,r3
80003f42:	ee f9 ff f4 	ld.w	r9,r7[-12]
80003f46:	ee fc ff fc 	ld.w	r12,r7[-4]
80003f4a:	f0 1f 00 04 	mcall	80003f58 <flashc_memset32+0x58>
80003f4e:	18 98       	mov	r8,r12
}
80003f50:	10 9c       	mov	r12,r8
80003f52:	2f ad       	sub	sp,-24
80003f54:	e3 cd 80 8f 	ldm	sp++,r0-r3,r7,pc
80003f58:	80 00       	ld.sh	r0,r0[0x0]
80003f5a:	3f 5c       	mov	r12,-11

80003f5c <flashc_memset64>:


volatile void *flashc_memset64(volatile void *dst, uint64_t src, size_t nbytes, bool erase)
{
80003f5c:	eb cd 40 80 	pushm	r7,lr
80003f60:	1a 97       	mov	r7,sp
80003f62:	21 bd       	sub	sp,108
80003f64:	ef 4c ff a4 	st.w	r7[-92],r12
80003f68:	ee eb ff 9c 	st.d	r7[-100],r10
80003f6c:	ef 49 ff 98 	st.w	r7[-104],r9
80003f70:	ef 68 ff 94 	st.b	r7[-108],r8
	// Use aggregated pointers to have several alignments available for a same address.
	UnionCVPtr flash_array_end;
	UnionVPtr dest;
	Union64 source = {0};
80003f74:	30 08       	mov	r8,0
80003f76:	30 09       	mov	r9,0
80003f78:	ee e9 ff d8 	st.d	r7[-40],r8
	StructCVPtr dest_end;
	UnionCVPtr flash_page_source_end;
	bool incomplete_flash_page_end;
	Union64 flash_dword;
	UnionVPtr tmp;
	unsigned int error_status = 0;
80003f7c:	30 08       	mov	r8,0
80003f7e:	ef 48 ff ec 	st.w	r7[-20],r8
	unsigned int i;

	// Reformat arguments.
	flash_array_end.u8ptr = AVR32_FLASH + flashc_get_flash_size();
80003f82:	f0 1f 00 fa 	mcall	80004368 <flashc_memset64+0x40c>
80003f86:	18 99       	mov	r9,r12
80003f88:	fc 18 80 00 	movh	r8,0x8000
80003f8c:	f2 08 00 08 	add	r8,r9,r8
80003f90:	ef 48 ff e4 	st.w	r7[-28],r8
	dest.u8ptr = dst;
80003f94:	ee f8 ff a4 	ld.w	r8,r7[-92]
80003f98:	ef 48 ff e0 	st.w	r7[-32],r8
	for (i = (Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)) - 1) & (sizeof(uint64_t) - 1);
80003f9c:	ee f8 ff e0 	ld.w	r8,r7[-32]
80003fa0:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80003fa4:	20 18       	sub	r8,1
80003fa6:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80003faa:	ef 48 ff f0 	st.w	r7[-16],r8
80003fae:	c1 f8       	rjmp	80003fec <flashc_memset64+0x90>
			src; i = (i - 1) & (sizeof(uint64_t) - 1)) {
		source.u8[i] = src;
80003fb0:	ee f9 ff f0 	ld.w	r9,r7[-16]
80003fb4:	ef 38 ff a3 	ld.ub	r8,r7[-93]
80003fb8:	ee 09 00 09 	add	r9,r7,r9
80003fbc:	f3 68 ff d8 	st.b	r9[-40],r8
		src >>= 8;
80003fc0:	ee f8 ff 9c 	ld.w	r8,r7[-100]
80003fc4:	b9 68       	lsl	r8,0x18
80003fc6:	ee f9 ff a0 	ld.w	r9,r7[-96]
80003fca:	a9 89       	lsr	r9,0x8
80003fcc:	f3 e8 10 08 	or	r8,r9,r8
80003fd0:	ef 48 ff a0 	st.w	r7[-96],r8
80003fd4:	ee f8 ff 9c 	ld.w	r8,r7[-100]
80003fd8:	a9 88       	lsr	r8,0x8
80003fda:	ef 48 ff 9c 	st.w	r7[-100],r8

	// Reformat arguments.
	flash_array_end.u8ptr = AVR32_FLASH + flashc_get_flash_size();
	dest.u8ptr = dst;
	for (i = (Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)) - 1) & (sizeof(uint64_t) - 1);
			src; i = (i - 1) & (sizeof(uint64_t) - 1)) {
80003fde:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003fe2:	20 18       	sub	r8,1
80003fe4:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80003fe8:	ef 48 ff f0 	st.w	r7[-16],r8
	unsigned int i;

	// Reformat arguments.
	flash_array_end.u8ptr = AVR32_FLASH + flashc_get_flash_size();
	dest.u8ptr = dst;
	for (i = (Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)) - 1) & (sizeof(uint64_t) - 1);
80003fec:	ee e8 ff 9c 	ld.d	r8,r7[-100]
80003ff0:	58 08       	cp.w	r8,0
80003ff2:	5c 29       	cpc	r9
80003ff4:	cd e1       	brne	80003fb0 <flashc_memset64+0x54>
			src; i = (i - 1) & (sizeof(uint64_t) - 1)) {
		source.u8[i] = src;
		src >>= 8;
	}
	dest_end.u8ptr = dest.u8ptr + nbytes;
80003ff6:	ee f9 ff e0 	ld.w	r9,r7[-32]
80003ffa:	ee f8 ff 98 	ld.w	r8,r7[-104]
80003ffe:	f2 08 00 08 	add	r8,r9,r8
80004002:	ef 48 ff d4 	st.w	r7[-44],r8

	// If destination is outside flash, go to next flash page if any.
	if (dest.u8ptr < AVR32_FLASH) {
80004006:	ee f8 ff e0 	ld.w	r8,r7[-32]
8000400a:	e0 69 ff ff 	mov	r9,65535
8000400e:	ea 19 7f ff 	orh	r9,0x7fff
80004012:	12 38       	cp.w	r8,r9
80004014:	e0 8b 00 07 	brhi	80004022 <flashc_memset64+0xc6>
		dest.u8ptr = AVR32_FLASH;
80004018:	fc 18 80 00 	movh	r8,0x8000
8000401c:	ef 48 ff e0 	st.w	r7[-32],r8
80004020:	c1 58       	rjmp	8000404a <flashc_memset64+0xee>
	} else if (flash_array_end.u8ptr <= dest.u8ptr && dest.u8ptr < AVR32_FLASHC_USER_PAGE) {
80004022:	ee f9 ff e4 	ld.w	r9,r7[-28]
80004026:	ee f8 ff e0 	ld.w	r8,r7[-32]
8000402a:	10 39       	cp.w	r9,r8
8000402c:	e0 8b 00 0f 	brhi	8000404a <flashc_memset64+0xee>
80004030:	ee f8 ff e0 	ld.w	r8,r7[-32]
80004034:	e0 69 ff ff 	mov	r9,65535
80004038:	ea 19 80 7f 	orh	r9,0x807f
8000403c:	12 38       	cp.w	r8,r9
8000403e:	e0 8b 00 06 	brhi	8000404a <flashc_memset64+0xee>
		dest.u8ptr = AVR32_FLASHC_USER_PAGE;
80004042:	fc 18 80 80 	movh	r8,0x8080
80004046:	ef 48 ff e0 	st.w	r7[-32],r8
	}

	// If end of destination is outside flash, move it to the end of the previous flash page if any.
	if (dest_end.u8ptr > AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE) {
8000404a:	ee f8 ff d4 	ld.w	r8,r7[-44]
8000404e:	e0 69 02 00 	mov	r9,512
80004052:	ea 19 80 80 	orh	r9,0x8080
80004056:	12 38       	cp.w	r8,r9
80004058:	e0 88 00 09 	brls	8000406a <flashc_memset64+0x10e>
		dest_end.u8ptr = AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE;
8000405c:	e0 68 02 00 	mov	r8,512
80004060:	ea 18 80 80 	orh	r8,0x8080
80004064:	ef 48 ff d4 	st.w	r7[-44],r8
80004068:	c1 38       	rjmp	8000408e <flashc_memset64+0x132>
	} else if (AVR32_FLASHC_USER_PAGE >= dest_end.u8ptr && dest_end.u8ptr > flash_array_end.u8ptr) {
8000406a:	ee f8 ff d4 	ld.w	r8,r7[-44]
8000406e:	fc 19 80 80 	movh	r9,0x8080
80004072:	12 38       	cp.w	r8,r9
80004074:	e0 8b 00 0d 	brhi	8000408e <flashc_memset64+0x132>
80004078:	ee f9 ff d4 	ld.w	r9,r7[-44]
8000407c:	ee f8 ff e4 	ld.w	r8,r7[-28]
80004080:	10 39       	cp.w	r9,r8
80004082:	e0 88 00 06 	brls	8000408e <flashc_memset64+0x132>
		dest_end.u8ptr = flash_array_end.u8ptr;
80004086:	ee f8 ff e4 	ld.w	r8,r7[-28]
8000408a:	ef 48 ff d4 	st.w	r7[-44],r8
	}

	// Align each end of destination pointer with its natural boundary.
	dest_end.u16ptr = (uint16_t *)Align_down((uint32_t)dest_end.u8ptr, sizeof(uint16_t));
8000408e:	ee f8 ff d4 	ld.w	r8,r7[-44]
80004092:	a1 c8       	cbr	r8,0x0
80004094:	ef 48 ff cc 	st.w	r7[-52],r8
	dest_end.u32ptr = (uint32_t *)Align_down((uint32_t)dest_end.u16ptr, sizeof(uint32_t));
80004098:	ee f8 ff cc 	ld.w	r8,r7[-52]
8000409c:	e0 18 ff fc 	andl	r8,0xfffc
800040a0:	ef 48 ff c4 	st.w	r7[-60],r8
	dest_end.u64ptr = (uint64_t *)Align_down((uint32_t)dest_end.u32ptr, sizeof(uint64_t));
800040a4:	ee f8 ff c4 	ld.w	r8,r7[-60]
800040a8:	e0 18 ff f8 	andl	r8,0xfff8
800040ac:	ef 48 ff bc 	st.w	r7[-68],r8

	// While end of destination is not reached...
	while (dest.u8ptr < dest_end.u8ptr) {
800040b0:	c4 b9       	rjmp	80004346 <flashc_memset64+0x3ea>
		// Clear the page buffer in order to prepare data for a flash page write.
		flashc_clear_page_buffer();
800040b2:	f0 1f 00 af 	mcall	8000436c <flashc_memset64+0x410>
		error_status |= flashc_error_status;
800040b6:	fe f8 02 ba 	ld.w	r8,pc[698]
800040ba:	70 08       	ld.w	r8,r8[0x0]
800040bc:	ee f9 ff ec 	ld.w	r9,r7[-20]
800040c0:	f3 e8 10 08 	or	r8,r9,r8
800040c4:	ef 48 ff ec 	st.w	r7[-20],r8

		// Determine where the source data will end in the current flash page.
		flash_page_source_end.u64ptr =
				(uint64_t *)min((uint32_t)dest_end.u64ptr,
800040c8:	ee f8 ff bc 	ld.w	r8,r7[-68]
800040cc:	ef 48 ff f8 	st.w	r7[-8],r8
800040d0:	ee f8 ff e0 	ld.w	r8,r7[-32]
800040d4:	e0 18 fe 00 	andl	r8,0xfe00
800040d8:	f0 c8 fe 00 	sub	r8,r8,-512
800040dc:	ef 48 ff fc 	st.w	r7[-4],r8
800040e0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800040e4:	ee f9 ff fc 	ld.w	r9,r7[-4]
800040e8:	f0 09 0d 48 	min	r8,r8,r9
800040ec:	ef 48 ff f4 	st.w	r7[-12],r8
800040f0:	ee f8 ff f4 	ld.w	r8,r7[-12]
		// Clear the page buffer in order to prepare data for a flash page write.
		flashc_clear_page_buffer();
		error_status |= flashc_error_status;

		// Determine where the source data will end in the current flash page.
		flash_page_source_end.u64ptr =
800040f4:	ef 48 ff b4 	st.w	r7[-76],r8
				(uint64_t *)min((uint32_t)dest_end.u64ptr,
				Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE) + AVR32_FLASHC_PAGE_SIZE);

		// Determine if the current destination page has an incomplete end.
		incomplete_flash_page_end = (Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE) >=
800040f8:	ee f8 ff e0 	ld.w	r8,r7[-32]
800040fc:	10 9a       	mov	r10,r8
800040fe:	e0 1a fe 00 	andl	r10,0xfe00
				Align_down((uint32_t)dest_end.u8ptr, AVR32_FLASHC_PAGE_SIZE));
80004102:	ee f8 ff d4 	ld.w	r8,r7[-44]
80004106:	10 99       	mov	r9,r8
80004108:	e0 19 fe 00 	andl	r9,0xfe00
		flash_page_source_end.u64ptr =
				(uint64_t *)min((uint32_t)dest_end.u64ptr,
				Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE) + AVR32_FLASHC_PAGE_SIZE);

		// Determine if the current destination page has an incomplete end.
		incomplete_flash_page_end = (Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE) >=
8000410c:	30 18       	mov	r8,1
8000410e:	12 3a       	cp.w	r10,r9
80004110:	c0 22       	brcc	80004114 <flashc_memset64+0x1b8>
80004112:	30 08       	mov	r8,0
80004114:	ef 68 ff eb 	st.b	r7[-21],r8
				Align_down((uint32_t)dest_end.u8ptr, AVR32_FLASHC_PAGE_SIZE));

		// Use a flash double-word buffer to manage unaligned accesses.
		flash_dword.u64 = source.u64;
80004118:	ee e8 ff d8 	ld.d	r8,r7[-40]
8000411c:	ee e9 ff ac 	st.d	r7[-84],r8

		// If destination does not point to the beginning of the current flash page...
		if (!Test_align((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE)) {
80004120:	ee f8 ff e0 	ld.w	r8,r7[-32]
80004124:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80004128:	c5 b0       	breq	800041de <flashc_memset64+0x282>
			// Fill the beginning of the page buffer with the current flash page data.
			// This is required by the hardware, even if page erase is not requested,
			// in order to be able to write successfully to erased parts of flash
			// pages that have already been written to.
			for (tmp.u8ptr = (uint8_t *)Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE);
8000412a:	ee f8 ff e0 	ld.w	r8,r7[-32]
8000412e:	e0 18 fe 00 	andl	r8,0xfe00
80004132:	ef 48 ff a8 	st.w	r7[-88],r8
80004136:	c0 e8       	rjmp	80004152 <flashc_memset64+0x1f6>
					tmp.u64ptr < (uint64_t *)Align_down((uint32_t)dest.u8ptr, sizeof(uint64_t));
					tmp.u64ptr++) {
				*tmp.u64ptr = *tmp.u64ptr;
80004138:	ee fa ff a8 	ld.w	r10,r7[-88]
8000413c:	ee f8 ff a8 	ld.w	r8,r7[-88]
80004140:	f0 e8 00 00 	ld.d	r8,r8[0]
80004144:	f4 e9 00 00 	st.d	r10[0],r8
			// This is required by the hardware, even if page erase is not requested,
			// in order to be able to write successfully to erased parts of flash
			// pages that have already been written to.
			for (tmp.u8ptr = (uint8_t *)Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE);
					tmp.u64ptr < (uint64_t *)Align_down((uint32_t)dest.u8ptr, sizeof(uint64_t));
					tmp.u64ptr++) {
80004148:	ee f8 ff a8 	ld.w	r8,r7[-88]
8000414c:	2f 88       	sub	r8,-8
8000414e:	ef 48 ff a8 	st.w	r7[-88],r8
			// Fill the beginning of the page buffer with the current flash page data.
			// This is required by the hardware, even if page erase is not requested,
			// in order to be able to write successfully to erased parts of flash
			// pages that have already been written to.
			for (tmp.u8ptr = (uint8_t *)Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE);
					tmp.u64ptr < (uint64_t *)Align_down((uint32_t)dest.u8ptr, sizeof(uint64_t));
80004152:	ee f9 ff a8 	ld.w	r9,r7[-88]
80004156:	ee f8 ff e0 	ld.w	r8,r7[-32]
8000415a:	e0 18 ff f8 	andl	r8,0xfff8
		if (!Test_align((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE)) {
			// Fill the beginning of the page buffer with the current flash page data.
			// This is required by the hardware, even if page erase is not requested,
			// in order to be able to write successfully to erased parts of flash
			// pages that have already been written to.
			for (tmp.u8ptr = (uint8_t *)Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE);
8000415e:	10 39       	cp.w	r9,r8
80004160:	ce c3       	brcs	80004138 <flashc_memset64+0x1dc>
					tmp.u64ptr++) {
				*tmp.u64ptr = *tmp.u64ptr;
			}

			// If destination is not 64-bit aligned...
			if (!Test_align((uint32_t)dest.u8ptr, sizeof(uint64_t))) {
80004162:	ee f8 ff e0 	ld.w	r8,r7[-32]
80004166:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
8000416a:	c3 a0       	breq	800041de <flashc_memset64+0x282>
				// Fill the beginning of the flash double-word buffer with the current
				// flash page data.
				// This is required by the hardware, even if page erase is not
				// requested, in order to be able to write successfully to erased parts
				// of flash pages that have already been written to.
				for (i = 0; i < Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)); i++) {
8000416c:	30 08       	mov	r8,0
8000416e:	ef 48 ff f0 	st.w	r7[-16],r8
80004172:	c1 38       	rjmp	80004198 <flashc_memset64+0x23c>
					flash_dword.u8[i] = *tmp.u8ptr++;
80004174:	ee fa ff f0 	ld.w	r10,r7[-16]
80004178:	ee f8 ff a8 	ld.w	r8,r7[-88]
8000417c:	11 89       	ld.ub	r9,r8[0x0]
8000417e:	5c 59       	castu.b	r9
80004180:	ee 0a 00 0a 	add	r10,r7,r10
80004184:	f5 69 ff ac 	st.b	r10[-84],r9
80004188:	2f f8       	sub	r8,-1
8000418a:	ef 48 ff a8 	st.w	r7[-88],r8
				// Fill the beginning of the flash double-word buffer with the current
				// flash page data.
				// This is required by the hardware, even if page erase is not
				// requested, in order to be able to write successfully to erased parts
				// of flash pages that have already been written to.
				for (i = 0; i < Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)); i++) {
8000418e:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004192:	2f f8       	sub	r8,-1
80004194:	ef 48 ff f0 	st.w	r7[-16],r8
80004198:	ee f8 ff e0 	ld.w	r8,r7[-32]
8000419c:	f3 d8 c0 03 	bfextu	r9,r8,0x0,0x3
800041a0:	ee f8 ff f0 	ld.w	r8,r7[-16]
800041a4:	10 39       	cp.w	r9,r8
800041a6:	fe 9b ff e7 	brhi	80004174 <flashc_memset64+0x218>
					flash_dword.u8[i] = *tmp.u8ptr++;
				}

				// Align the destination pointer with its 64-bit boundary.
				dest.u64ptr = (uint64_t *)Align_down((uint32_t)dest.u8ptr, sizeof(uint64_t));
800041aa:	ee f8 ff e0 	ld.w	r8,r7[-32]
800041ae:	e0 18 ff f8 	andl	r8,0xfff8
800041b2:	ef 48 ff e0 	st.w	r7[-32],r8

				// If the current destination double-word is not the last one...
				if (dest.u64ptr < dest_end.u64ptr) {
800041b6:	ee f9 ff e0 	ld.w	r9,r7[-32]
800041ba:	ee f8 ff bc 	ld.w	r8,r7[-68]
800041be:	10 39       	cp.w	r9,r8
800041c0:	c0 f2       	brcc	800041de <flashc_memset64+0x282>
					// Write the flash double-word buffer to the page buffer and reinitialize it.
					*dest.u64ptr++ = flash_dword.u64;
800041c2:	ee fa ff e0 	ld.w	r10,r7[-32]
800041c6:	ee e8 ff ac 	ld.d	r8,r7[-84]
800041ca:	f4 e9 00 00 	st.d	r10[0],r8
800041ce:	f4 c8 ff f8 	sub	r8,r10,-8
800041d2:	ef 48 ff e0 	st.w	r7[-32],r8
					flash_dword.u64 = source.u64;
800041d6:	ee e8 ff d8 	ld.d	r8,r7[-40]
800041da:	ee e9 ff ac 	st.d	r7[-84],r8
				}
			}
		}

		// Write the source data to the page buffer with 64-bit alignment.
		for (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--) {
800041de:	ee f8 ff b4 	ld.w	r8,r7[-76]
800041e2:	10 99       	mov	r9,r8
800041e4:	ee f8 ff e0 	ld.w	r8,r7[-32]
800041e8:	f2 08 01 08 	sub	r8,r9,r8
800041ec:	a3 58       	asr	r8,0x3
800041ee:	ef 48 ff f0 	st.w	r7[-16],r8
800041f2:	c1 08       	rjmp	80004212 <flashc_memset64+0x2b6>
			*dest.u64ptr++ = source.u64;
800041f4:	ee fa ff e0 	ld.w	r10,r7[-32]
800041f8:	ee e8 ff d8 	ld.d	r8,r7[-40]
800041fc:	f4 e9 00 00 	st.d	r10[0],r8
80004200:	f4 c8 ff f8 	sub	r8,r10,-8
80004204:	ef 48 ff e0 	st.w	r7[-32],r8
				}
			}
		}

		// Write the source data to the page buffer with 64-bit alignment.
		for (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--) {
80004208:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000420c:	20 18       	sub	r8,1
8000420e:	ef 48 ff f0 	st.w	r7[-16],r8
80004212:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004216:	58 08       	cp.w	r8,0
80004218:	ce e1       	brne	800041f4 <flashc_memset64+0x298>
			*dest.u64ptr++ = source.u64;
		}

		// If the current destination page has an incomplete end...
		if (incomplete_flash_page_end) {
8000421a:	ef 39 ff eb 	ld.ub	r9,r7[-21]
8000421e:	30 08       	mov	r8,0
80004220:	f0 09 18 00 	cp.b	r9,r8
80004224:	c4 70       	breq	800042b2 <flashc_memset64+0x356>
			// This is required by the hardware, even if page erase is not requested,
			// in order to be able to write successfully to erased parts of flash
			// pages that have already been written to.
			{
				tmp.u8ptr = (volatile uint8_t *)dest_end.u8ptr;
80004226:	ee f8 ff d4 	ld.w	r8,r7[-44]
8000422a:	ef 48 ff a8 	st.w	r7[-88],r8

				// If end of destination is not 64-bit aligned...
				if (!Test_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t))) {
8000422e:	ee f8 ff d4 	ld.w	r8,r7[-44]
80004232:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80004236:	c3 80       	breq	800042a6 <flashc_memset64+0x34a>
					// Fill the end of the flash double-word buffer with the current flash page data.
					for (i = Get_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t)); i < sizeof(uint64_t); i++)
80004238:	ee f8 ff d4 	ld.w	r8,r7[-44]
8000423c:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80004240:	ef 48 ff f0 	st.w	r7[-16],r8
80004244:	c1 38       	rjmp	8000426a <flashc_memset64+0x30e>
						flash_dword.u8[i] = *tmp.u8ptr++;
80004246:	ee fa ff f0 	ld.w	r10,r7[-16]
8000424a:	ee f8 ff a8 	ld.w	r8,r7[-88]
8000424e:	11 89       	ld.ub	r9,r8[0x0]
80004250:	5c 59       	castu.b	r9
80004252:	ee 0a 00 0a 	add	r10,r7,r10
80004256:	f5 69 ff ac 	st.b	r10[-84],r9
8000425a:	2f f8       	sub	r8,-1
8000425c:	ef 48 ff a8 	st.w	r7[-88],r8
				tmp.u8ptr = (volatile uint8_t *)dest_end.u8ptr;

				// If end of destination is not 64-bit aligned...
				if (!Test_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t))) {
					// Fill the end of the flash double-word buffer with the current flash page data.
					for (i = Get_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t)); i < sizeof(uint64_t); i++)
80004260:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004264:	2f f8       	sub	r8,-1
80004266:	ef 48 ff f0 	st.w	r7[-16],r8
8000426a:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000426e:	58 78       	cp.w	r8,7
80004270:	fe 98 ff eb 	brls	80004246 <flashc_memset64+0x2ea>
						flash_dword.u8[i] = *tmp.u8ptr++;

					// Write the flash double-word buffer to the page buffer.
					*dest.u64ptr++ = flash_dword.u64;
80004274:	ee fa ff e0 	ld.w	r10,r7[-32]
80004278:	ee e8 ff ac 	ld.d	r8,r7[-84]
8000427c:	f4 e9 00 00 	st.d	r10[0],r8
80004280:	f4 c8 ff f8 	sub	r8,r10,-8
80004284:	ef 48 ff e0 	st.w	r7[-32],r8
				}

				// Fill the end of the page buffer with the current flash page data.
				for (; !Test_align((uint32_t)tmp.u64ptr, AVR32_FLASHC_PAGE_SIZE); tmp.u64ptr++) {
80004288:	c1 08       	rjmp	800042a8 <flashc_memset64+0x34c>
					*tmp.u64ptr = *tmp.u64ptr;
8000428a:	ee fa ff a8 	ld.w	r10,r7[-88]
8000428e:	ee f8 ff a8 	ld.w	r8,r7[-88]
80004292:	f0 e8 00 00 	ld.d	r8,r8[0]
80004296:	f4 e9 00 00 	st.d	r10[0],r8
					// Write the flash double-word buffer to the page buffer.
					*dest.u64ptr++ = flash_dword.u64;
				}

				// Fill the end of the page buffer with the current flash page data.
				for (; !Test_align((uint32_t)tmp.u64ptr, AVR32_FLASHC_PAGE_SIZE); tmp.u64ptr++) {
8000429a:	ee f8 ff a8 	ld.w	r8,r7[-88]
8000429e:	2f 88       	sub	r8,-8
800042a0:	ef 48 ff a8 	st.w	r7[-88],r8
800042a4:	c0 28       	rjmp	800042a8 <flashc_memset64+0x34c>
800042a6:	d7 03       	nop
800042a8:	ee f8 ff a8 	ld.w	r8,r7[-88]
800042ac:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
800042b0:	ce d1       	brne	8000428a <flashc_memset64+0x32e>
				}
			}
		}

		// If the current flash page is in the flash array...
		if (dest.u8ptr <= AVR32_FLASHC_USER_PAGE) {
800042b2:	ee f8 ff e0 	ld.w	r8,r7[-32]
800042b6:	fc 19 80 80 	movh	r9,0x8080
800042ba:	12 38       	cp.w	r8,r9
800042bc:	e0 8b 00 2a 	brhi	80004310 <flashc_memset64+0x3b4>
			// Erase the current page if requested and write it from the page buffer.
			if (erase) {
800042c0:	ef 39 ff 94 	ld.ub	r9,r7[-108]
800042c4:	30 08       	mov	r8,0
800042c6:	f0 09 18 00 	cp.b	r9,r8
800042ca:	c0 d0       	breq	800042e4 <flashc_memset64+0x388>
				flashc_erase_page(-1, false);
800042cc:	30 0b       	mov	r11,0
800042ce:	3f fc       	mov	r12,-1
800042d0:	f0 1f 00 29 	mcall	80004374 <flashc_memset64+0x418>
				error_status |= flashc_error_status;
800042d4:	4a 78       	lddpc	r8,80004370 <flashc_memset64+0x414>
800042d6:	70 08       	ld.w	r8,r8[0x0]
800042d8:	ee f9 ff ec 	ld.w	r9,r7[-20]
800042dc:	f3 e8 10 08 	or	r8,r9,r8
800042e0:	ef 48 ff ec 	st.w	r7[-20],r8
			}
			flashc_write_page(-1);
800042e4:	3f fc       	mov	r12,-1
800042e6:	f0 1f 00 25 	mcall	80004378 <flashc_memset64+0x41c>
			error_status |= flashc_error_status;
800042ea:	4a 28       	lddpc	r8,80004370 <flashc_memset64+0x414>
800042ec:	70 08       	ld.w	r8,r8[0x0]
800042ee:	ee f9 ff ec 	ld.w	r9,r7[-20]
800042f2:	f3 e8 10 08 	or	r8,r9,r8
800042f6:	ef 48 ff ec 	st.w	r7[-20],r8

			// If the end of the flash array is reached, go to the User page.
			if (dest.u8ptr >= flash_array_end.u8ptr) {
800042fa:	ee f9 ff e0 	ld.w	r9,r7[-32]
800042fe:	ee f8 ff e4 	ld.w	r8,r7[-28]
80004302:	10 39       	cp.w	r9,r8
80004304:	c2 13       	brcs	80004346 <flashc_memset64+0x3ea>
				dest.u8ptr = AVR32_FLASHC_USER_PAGE;
80004306:	fc 18 80 80 	movh	r8,0x8080
8000430a:	ef 48 ff e0 	st.w	r7[-32],r8
8000430e:	c1 c8       	rjmp	80004346 <flashc_memset64+0x3ea>
			}
		} else {
			// Erase the User page if requested and write it from the page buffer.
			if (erase) {
80004310:	ef 39 ff 94 	ld.ub	r9,r7[-108]
80004314:	30 08       	mov	r8,0
80004316:	f0 09 18 00 	cp.b	r9,r8
8000431a:	c0 c0       	breq	80004332 <flashc_memset64+0x3d6>
				flashc_erase_user_page(false);
8000431c:	30 0c       	mov	r12,0
8000431e:	f0 1f 00 18 	mcall	8000437c <flashc_memset64+0x420>
				error_status |= flashc_error_status;
80004322:	49 48       	lddpc	r8,80004370 <flashc_memset64+0x414>
80004324:	70 08       	ld.w	r8,r8[0x0]
80004326:	ee f9 ff ec 	ld.w	r9,r7[-20]
8000432a:	f3 e8 10 08 	or	r8,r9,r8
8000432e:	ef 48 ff ec 	st.w	r7[-20],r8
			}
			flashc_write_user_page();
80004332:	f0 1f 00 14 	mcall	80004380 <flashc_memset64+0x424>
			error_status |= flashc_error_status;
80004336:	48 f8       	lddpc	r8,80004370 <flashc_memset64+0x414>
80004338:	70 08       	ld.w	r8,r8[0x0]
8000433a:	ee f9 ff ec 	ld.w	r9,r7[-20]
8000433e:	f3 e8 10 08 	or	r8,r9,r8
80004342:	ef 48 ff ec 	st.w	r7[-20],r8
	dest_end.u16ptr = (uint16_t *)Align_down((uint32_t)dest_end.u8ptr, sizeof(uint16_t));
	dest_end.u32ptr = (uint32_t *)Align_down((uint32_t)dest_end.u16ptr, sizeof(uint32_t));
	dest_end.u64ptr = (uint64_t *)Align_down((uint32_t)dest_end.u32ptr, sizeof(uint64_t));

	// While end of destination is not reached...
	while (dest.u8ptr < dest_end.u8ptr) {
80004346:	ee f9 ff e0 	ld.w	r9,r7[-32]
8000434a:	ee f8 ff d4 	ld.w	r8,r7[-44]
8000434e:	10 39       	cp.w	r9,r8
80004350:	fe 93 fe b1 	brlo	800040b2 <flashc_memset64+0x156>
			error_status |= flashc_error_status;
		}
	}

	// Update the FLASHC error status.
	flashc_error_status = error_status;
80004354:	48 78       	lddpc	r8,80004370 <flashc_memset64+0x414>
80004356:	ee f9 ff ec 	ld.w	r9,r7[-20]
8000435a:	91 09       	st.w	r8[0x0],r9

	// Return the initial destination pointer as the standard memset function does.
	return dst;
8000435c:	ee f8 ff a4 	ld.w	r8,r7[-92]
}
80004360:	10 9c       	mov	r12,r8
80004362:	2e 5d       	sub	sp,-108
80004364:	e3 cd 80 80 	ldm	sp++,r7,pc
80004368:	80 00       	ld.sh	r0,r0[0x0]
8000436a:	3b f0       	mov	r0,-65
8000436c:	80 00       	ld.sh	r0,r0[0x0]
8000436e:	3d 04       	mov	r4,-48
80004370:	00 00       	add	r0,r0
80004372:	05 c4       	ld.ub	r4,r2[0x4]
80004374:	80 00       	ld.sh	r0,r0[0x0]
80004376:	3d 64       	mov	r4,-42
80004378:	80 00       	ld.sh	r0,r0[0x0]
8000437a:	3d cc       	mov	r12,-36
8000437c:	80 00       	ld.sh	r0,r0[0x0]
8000437e:	3e 10       	mov	r0,-31
80004380:	80 00       	ld.sh	r0,r0[0x0]
80004382:	3e 4c       	mov	r12,-28

80004384 <flashc_memcpy>:


volatile void *flashc_memcpy(volatile void *dst, const void *src, size_t nbytes, bool erase)
{
80004384:	eb cd 40 80 	pushm	r7,lr
80004388:	1a 97       	mov	r7,sp
8000438a:	20 bd       	sub	sp,44
8000438c:	ef 4c ff e0 	st.w	r7[-32],r12
80004390:	ef 4b ff dc 	st.w	r7[-36],r11
80004394:	ef 4a ff d8 	st.w	r7[-40],r10
80004398:	12 98       	mov	r8,r9
8000439a:	ef 68 ff d4 	st.b	r7[-44],r8
	uint16_t page_pos;
	Union64 flash_dword;
	uint8_t i;
	bool b_user_page;
	unsigned int error_status = 0;
8000439e:	30 08       	mov	r8,0
800043a0:	ef 48 ff f0 	st.w	r7[-16],r8
	uint8_t* flash_add;
	uint8_t* dest_add=(uint8_t*)dst;
800043a4:	ee f8 ff e0 	ld.w	r8,r7[-32]
800043a8:	ef 48 ff f8 	st.w	r7[-8],r8
	const uint8_t* src_buf=(const uint8_t*)src;
800043ac:	ee f8 ff dc 	ld.w	r8,r7[-36]
800043b0:	ef 48 ff fc 	st.w	r7[-4],r8
	Assert( (((uint8_t *)dst >= AVR32_FLASH)
			&& (((uint8_t *)dst + nbytes) <= (AVR32_FLASH + flashc_get_flash_size())))
			|| (((uint8_t *)dst >= AVR32_FLASHC_USER_PAGE)
			&& (((uint8_t *)dst + nbytes) <= (AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE))) );

	b_user_page = (volatile uint8_t *)dst >= AVR32_FLASHC_USER_PAGE;
800043b4:	ee f9 ff e0 	ld.w	r9,r7[-32]
800043b8:	30 18       	mov	r8,1
800043ba:	e0 6a ff ff 	mov	r10,65535
800043be:	ea 1a 80 7f 	orh	r10,0x807f
800043c2:	14 39       	cp.w	r9,r10
800043c4:	e0 8b 00 03 	brhi	800043ca <flashc_memcpy+0x46>
800043c8:	30 08       	mov	r8,0
800043ca:	ef 68 ff ef 	st.b	r7[-17],r8

	flash_add = (uint8_t*)((uint32_t)dest_add - ((uint32_t)dest_add % AVR32_FLASHC_PAGE_SIZE));
800043ce:	ee f9 ff f8 	ld.w	r9,r7[-8]
800043d2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800043d6:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
800043da:	f2 08 01 08 	sub	r8,r9,r8
800043de:	ef 48 ff f4 	st.w	r7[-12],r8

	while (nbytes) {
800043e2:	c9 18       	rjmp	80004504 <flashc_memcpy+0x180>
		// Clear the page buffer in order to prepare data for a flash page write.
		flashc_clear_page_buffer();
800043e4:	f0 1f 00 50 	mcall	80004524 <flashc_memcpy+0x1a0>
		error_status |= flashc_error_status;
800043e8:	4d 08       	lddpc	r8,80004528 <flashc_memcpy+0x1a4>
800043ea:	70 08       	ld.w	r8,r8[0x0]
800043ec:	ee f9 ff f0 	ld.w	r9,r7[-16]
800043f0:	f3 e8 10 08 	or	r8,r9,r8
800043f4:	ef 48 ff f0 	st.w	r7[-16],r8

		// Loop in the page
		for (page_pos=0; page_pos<AVR32_FLASHC_PAGE_SIZE; page_pos+=sizeof(uint64_t) ) {
800043f8:	30 08       	mov	r8,0
800043fa:	ef 58 ff ec 	st.h	r7[-20],r8
800043fe:	c4 b8       	rjmp	80004494 <flashc_memcpy+0x110>
			// Read the flash double-word buffer
			flash_dword.u64 = *(volatile uint64_t*)flash_add;
80004400:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004404:	f0 e8 00 00 	ld.d	r8,r8[0]
80004408:	ee e9 ff e4 	st.d	r7[-28],r8

			// Update double-word if necessary
			for (i = 0; i < sizeof(uint64_t); i++) {
8000440c:	30 08       	mov	r8,0
8000440e:	ef 68 ff ee 	st.b	r7[-18],r8
80004412:	c2 d8       	rjmp	8000446c <flashc_memcpy+0xe8>
				if (nbytes && (flash_add == dest_add)) {
80004414:	ee f8 ff d8 	ld.w	r8,r7[-40]
80004418:	58 08       	cp.w	r8,0
8000441a:	c1 f0       	breq	80004458 <flashc_memcpy+0xd4>
8000441c:	ee f9 ff f4 	ld.w	r9,r7[-12]
80004420:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004424:	10 39       	cp.w	r9,r8
80004426:	c1 91       	brne	80004458 <flashc_memcpy+0xd4>
					// Update page with data source
					flash_dword.u8[i] = *src_buf++;
80004428:	ef 39 ff ee 	ld.ub	r9,r7[-18]
8000442c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004430:	11 88       	ld.ub	r8,r8[0x0]
80004432:	ee 09 00 09 	add	r9,r7,r9
80004436:	f3 68 ff e4 	st.b	r9[-28],r8
8000443a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000443e:	2f f8       	sub	r8,-1
80004440:	ef 48 ff fc 	st.w	r7[-4],r8
					dest_add++;
80004444:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004448:	2f f8       	sub	r8,-1
8000444a:	ef 48 ff f8 	st.w	r7[-8],r8
					nbytes--;
8000444e:	ee f8 ff d8 	ld.w	r8,r7[-40]
80004452:	20 18       	sub	r8,1
80004454:	ef 48 ff d8 	st.w	r7[-40],r8
				}
				flash_add++;
80004458:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000445c:	2f f8       	sub	r8,-1
8000445e:	ef 48 ff f4 	st.w	r7[-12],r8
		for (page_pos=0; page_pos<AVR32_FLASHC_PAGE_SIZE; page_pos+=sizeof(uint64_t) ) {
			// Read the flash double-word buffer
			flash_dword.u64 = *(volatile uint64_t*)flash_add;

			// Update double-word if necessary
			for (i = 0; i < sizeof(uint64_t); i++) {
80004462:	ef 38 ff ee 	ld.ub	r8,r7[-18]
80004466:	2f f8       	sub	r8,-1
80004468:	ef 68 ff ee 	st.b	r7[-18],r8
8000446c:	ef 39 ff ee 	ld.ub	r9,r7[-18]
80004470:	30 78       	mov	r8,7
80004472:	f0 09 18 00 	cp.b	r9,r8
80004476:	fe 98 ff cf 	brls	80004414 <flashc_memcpy+0x90>
				}
				flash_add++;
			}

			// Write the flash double-word buffer to the page buffer.
			*(volatile uint64_t*)((uint32_t)flash_add - sizeof(uint64_t))= flash_dword.u64;
8000447a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000447e:	20 88       	sub	r8,8
80004480:	10 9a       	mov	r10,r8
80004482:	ee e8 ff e4 	ld.d	r8,r7[-28]
80004486:	f4 e9 00 00 	st.d	r10[0],r8
		// Clear the page buffer in order to prepare data for a flash page write.
		flashc_clear_page_buffer();
		error_status |= flashc_error_status;

		// Loop in the page
		for (page_pos=0; page_pos<AVR32_FLASHC_PAGE_SIZE; page_pos+=sizeof(uint64_t) ) {
8000448a:	ef 08 ff ec 	ld.sh	r8,r7[-20]
8000448e:	2f 88       	sub	r8,-8
80004490:	ef 58 ff ec 	st.h	r7[-20],r8
80004494:	ef 09 ff ec 	ld.sh	r9,r7[-20]
80004498:	e0 68 01 ff 	mov	r8,511
8000449c:	f0 09 19 00 	cp.h	r9,r8
800044a0:	fe 98 ff b0 	brls	80004400 <flashc_memcpy+0x7c>
			// Write the flash double-word buffer to the page buffer.
			*(volatile uint64_t*)((uint32_t)flash_add - sizeof(uint64_t))= flash_dword.u64;
		}

		// Erase the current page if requested and write it from the page buffer.
		if (erase) {
800044a4:	ef 39 ff d4 	ld.ub	r9,r7[-44]
800044a8:	30 08       	mov	r8,0
800044aa:	f0 09 18 00 	cp.b	r9,r8
800044ae:	c1 70       	breq	800044dc <flashc_memcpy+0x158>
			(b_user_page)? flashc_erase_user_page(false) : flashc_erase_page(-1, false);
800044b0:	ef 39 ff ef 	ld.ub	r9,r7[-17]
800044b4:	30 08       	mov	r8,0
800044b6:	f0 09 18 00 	cp.b	r9,r8
800044ba:	c0 50       	breq	800044c4 <flashc_memcpy+0x140>
800044bc:	30 0c       	mov	r12,0
800044be:	f0 1f 00 1c 	mcall	8000452c <flashc_memcpy+0x1a8>
800044c2:	c0 58       	rjmp	800044cc <flashc_memcpy+0x148>
800044c4:	30 0b       	mov	r11,0
800044c6:	3f fc       	mov	r12,-1
800044c8:	f0 1f 00 1a 	mcall	80004530 <flashc_memcpy+0x1ac>
			error_status |= flashc_error_status;
800044cc:	49 78       	lddpc	r8,80004528 <flashc_memcpy+0x1a4>
800044ce:	70 08       	ld.w	r8,r8[0x0]
800044d0:	ee f9 ff f0 	ld.w	r9,r7[-16]
800044d4:	f3 e8 10 08 	or	r8,r9,r8
800044d8:	ef 48 ff f0 	st.w	r7[-16],r8
		}

		// Write the page
		(b_user_page)? flashc_write_user_page() : flashc_write_page(-1);
800044dc:	ef 39 ff ef 	ld.ub	r9,r7[-17]
800044e0:	30 08       	mov	r8,0
800044e2:	f0 09 18 00 	cp.b	r9,r8
800044e6:	c0 40       	breq	800044ee <flashc_memcpy+0x16a>
800044e8:	f0 1f 00 13 	mcall	80004534 <flashc_memcpy+0x1b0>
800044ec:	c0 48       	rjmp	800044f4 <flashc_memcpy+0x170>
800044ee:	3f fc       	mov	r12,-1
800044f0:	f0 1f 00 12 	mcall	80004538 <flashc_memcpy+0x1b4>
		error_status |= flashc_error_status;
800044f4:	48 d8       	lddpc	r8,80004528 <flashc_memcpy+0x1a4>
800044f6:	70 08       	ld.w	r8,r8[0x0]
800044f8:	ee f9 ff f0 	ld.w	r9,r7[-16]
800044fc:	f3 e8 10 08 	or	r8,r9,r8
80004500:	ef 48 ff f0 	st.w	r7[-16],r8

	b_user_page = (volatile uint8_t *)dst >= AVR32_FLASHC_USER_PAGE;

	flash_add = (uint8_t*)((uint32_t)dest_add - ((uint32_t)dest_add % AVR32_FLASHC_PAGE_SIZE));

	while (nbytes) {
80004504:	ee f8 ff d8 	ld.w	r8,r7[-40]
80004508:	58 08       	cp.w	r8,0
8000450a:	fe 91 ff 6d 	brne	800043e4 <flashc_memcpy+0x60>
		// Write the page
		(b_user_page)? flashc_write_user_page() : flashc_write_page(-1);
		error_status |= flashc_error_status;
	}
	// Update the FLASHC error status.
	flashc_error_status = error_status;
8000450e:	48 78       	lddpc	r8,80004528 <flashc_memcpy+0x1a4>
80004510:	ee f9 ff f0 	ld.w	r9,r7[-16]
80004514:	91 09       	st.w	r8[0x0],r9

	// Return the initial destination pointer as the standard memcpy function does.
	return dst;
80004516:	ee f8 ff e0 	ld.w	r8,r7[-32]
}
8000451a:	10 9c       	mov	r12,r8
8000451c:	2f 5d       	sub	sp,-44
8000451e:	e3 cd 80 80 	ldm	sp++,r7,pc
80004522:	00 00       	add	r0,r0
80004524:	80 00       	ld.sh	r0,r0[0x0]
80004526:	3d 04       	mov	r4,-48
80004528:	00 00       	add	r0,r0
8000452a:	05 c4       	ld.ub	r4,r2[0x4]
8000452c:	80 00       	ld.sh	r0,r0[0x0]
8000452e:	3e 10       	mov	r0,-31
80004530:	80 00       	ld.sh	r0,r0[0x0]
80004532:	3d 64       	mov	r4,-42
80004534:	80 00       	ld.sh	r0,r0[0x0]
80004536:	3e 4c       	mov	r12,-28
80004538:	80 00       	ld.sh	r0,r0[0x0]
8000453a:	3d cc       	mov	r12,-36

8000453c <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
8000453c:	eb cd 40 80 	pushm	r7,lr
80004540:	1a 97       	mov	r7,sp
80004542:	20 4d       	sub	sp,16
80004544:	ef 4c ff f4 	st.w	r7[-12],r12
80004548:	ef 4b ff f0 	st.w	r7[-16],r11
	uint32_t status = GPIO_SUCCESS;
8000454c:	30 08       	mov	r8,0
8000454e:	ef 48 ff f8 	st.w	r7[-8],r8
	uint32_t i;

	for (i = 0; i < size; i++) {
80004552:	30 08       	mov	r8,0
80004554:	ef 48 ff fc 	st.w	r7[-4],r8
80004558:	c1 c8       	rjmp	80004590 <gpio_enable_module+0x54>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
8000455a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000455e:	70 19       	ld.w	r9,r8[0x4]
80004560:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004564:	70 08       	ld.w	r8,r8[0x0]
80004566:	12 9b       	mov	r11,r9
80004568:	10 9c       	mov	r12,r8
8000456a:	f0 1f 00 10 	mcall	800045a8 <gpio_enable_module+0x6c>
8000456e:	18 98       	mov	r8,r12
80004570:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004574:	f3 e8 10 08 	or	r8,r9,r8
80004578:	ef 48 ff f8 	st.w	r7[-8],r8
		gpiomap++;
8000457c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004580:	2f 88       	sub	r8,-8
80004582:	ef 48 ff f4 	st.w	r7[-12],r8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80004586:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000458a:	2f f8       	sub	r8,-1
8000458c:	ef 48 ff fc 	st.w	r7[-4],r8
80004590:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004594:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004598:	10 39       	cp.w	r9,r8
8000459a:	ce 03       	brcs	8000455a <gpio_enable_module+0x1e>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
8000459c:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
800045a0:	10 9c       	mov	r12,r8
800045a2:	2f cd       	sub	sp,-16
800045a4:	e3 cd 80 80 	ldm	sp++,r7,pc
800045a8:	80 00       	ld.sh	r0,r0[0x0]
800045aa:	45 ac       	lddsp	r12,sp[0x168]

800045ac <gpio_enable_module_pin>:
 * \param function The pin function.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
800045ac:	eb cd 40 80 	pushm	r7,lr
800045b0:	1a 97       	mov	r7,sp
800045b2:	20 3d       	sub	sp,12
800045b4:	ef 4c ff f8 	st.w	r7[-8],r12
800045b8:	ef 4b ff f4 	st.w	r7[-12],r11
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800045bc:	ee f8 ff f8 	ld.w	r8,r7[-8]
800045c0:	a5 98       	lsr	r8,0x5
800045c2:	a9 78       	lsl	r8,0x9
800045c4:	e0 28 e0 00 	sub	r8,57344
800045c8:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Enable the correct function. */
	switch (function) {
800045cc:	ee f8 ff f4 	ld.w	r8,r7[-12]
800045d0:	58 78       	cp.w	r8,7
800045d2:	e0 8b 01 16 	brhi	800047fe <gpio_enable_module_pin+0x252>
800045d6:	fe f9 02 4e 	ld.w	r9,pc[590]
800045da:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800045de:	ee f8 ff f8 	ld.w	r8,r7[-8]
800045e2:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800045e6:	30 19       	mov	r9,1
800045e8:	f2 08 09 48 	lsl	r8,r9,r8
800045ec:	10 99       	mov	r9,r8
800045ee:	ee f8 ff fc 	ld.w	r8,r7[-4]
800045f2:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800045f4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800045f8:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800045fc:	30 19       	mov	r9,1
800045fe:	f2 08 09 48 	lsl	r8,r9,r8
80004602:	10 99       	mov	r9,r8
80004604:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004608:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
8000460a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000460e:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004612:	30 19       	mov	r9,1
80004614:	f2 08 09 48 	lsl	r8,r9,r8
80004618:	10 99       	mov	r9,r8
8000461a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000461e:	91 e9       	st.w	r8[0x38],r9
#endif
		break;
80004620:	cf 18       	rjmp	80004802 <gpio_enable_module_pin+0x256>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80004622:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004626:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000462a:	30 19       	mov	r9,1
8000462c:	f2 08 09 48 	lsl	r8,r9,r8
80004630:	10 99       	mov	r9,r8
80004632:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004636:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80004638:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000463c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004640:	30 19       	mov	r9,1
80004642:	f2 08 09 48 	lsl	r8,r9,r8
80004646:	10 99       	mov	r9,r8
80004648:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000464c:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
8000464e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004652:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004656:	30 19       	mov	r9,1
80004658:	f2 08 09 48 	lsl	r8,r9,r8
8000465c:	10 99       	mov	r9,r8
8000465e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004662:	91 e9       	st.w	r8[0x38],r9
#endif
		break;
80004664:	cc f8       	rjmp	80004802 <gpio_enable_module_pin+0x256>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80004666:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000466a:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000466e:	30 19       	mov	r9,1
80004670:	f2 08 09 48 	lsl	r8,r9,r8
80004674:	10 99       	mov	r9,r8
80004676:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000467a:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000467c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004680:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004684:	30 19       	mov	r9,1
80004686:	f2 08 09 48 	lsl	r8,r9,r8
8000468a:	10 99       	mov	r9,r8
8000468c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004690:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
80004692:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004696:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000469a:	30 19       	mov	r9,1
8000469c:	f2 08 09 48 	lsl	r8,r9,r8
800046a0:	10 99       	mov	r9,r8
800046a2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800046a6:	91 e9       	st.w	r8[0x38],r9
#endif
		break;
800046a8:	ca d8       	rjmp	80004802 <gpio_enable_module_pin+0x256>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800046aa:	ee f8 ff f8 	ld.w	r8,r7[-8]
800046ae:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800046b2:	30 19       	mov	r9,1
800046b4:	f2 08 09 48 	lsl	r8,r9,r8
800046b8:	10 99       	mov	r9,r8
800046ba:	ee f8 ff fc 	ld.w	r8,r7[-4]
800046be:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800046c0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800046c4:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800046c8:	30 19       	mov	r9,1
800046ca:	f2 08 09 48 	lsl	r8,r9,r8
800046ce:	10 99       	mov	r9,r8
800046d0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800046d4:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
800046d6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800046da:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800046de:	30 19       	mov	r9,1
800046e0:	f2 08 09 48 	lsl	r8,r9,r8
800046e4:	10 99       	mov	r9,r8
800046e6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800046ea:	91 e9       	st.w	r8[0x38],r9
#endif
		break;
800046ec:	c8 b8       	rjmp	80004802 <gpio_enable_module_pin+0x256>

#if (AVR32_GPIO_H_VERSION >= 210)
	case 4: /* E function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800046ee:	ee f8 ff f8 	ld.w	r8,r7[-8]
800046f2:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800046f6:	30 19       	mov	r9,1
800046f8:	f2 08 09 48 	lsl	r8,r9,r8
800046fc:	10 99       	mov	r9,r8
800046fe:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004702:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80004704:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004708:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000470c:	30 19       	mov	r9,1
8000470e:	f2 08 09 48 	lsl	r8,r9,r8
80004712:	10 99       	mov	r9,r8
80004714:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004718:	91 a9       	st.w	r8[0x28],r9
		gpio_port->pmr2s = 1 << (pin & 0x1F);
8000471a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000471e:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004722:	30 19       	mov	r9,1
80004724:	f2 08 09 48 	lsl	r8,r9,r8
80004728:	10 99       	mov	r9,r8
8000472a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000472e:	91 d9       	st.w	r8[0x34],r9
		break;
80004730:	c6 98       	rjmp	80004802 <gpio_enable_module_pin+0x256>

	case 5: /* F function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80004732:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004736:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000473a:	30 19       	mov	r9,1
8000473c:	f2 08 09 48 	lsl	r8,r9,r8
80004740:	10 99       	mov	r9,r8
80004742:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004746:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80004748:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000474c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004750:	30 19       	mov	r9,1
80004752:	f2 08 09 48 	lsl	r8,r9,r8
80004756:	10 99       	mov	r9,r8
80004758:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000475c:	91 a9       	st.w	r8[0x28],r9
		gpio_port->pmr2s = 1 << (pin & 0x1F);
8000475e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004762:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004766:	30 19       	mov	r9,1
80004768:	f2 08 09 48 	lsl	r8,r9,r8
8000476c:	10 99       	mov	r9,r8
8000476e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004772:	91 d9       	st.w	r8[0x34],r9
		break;
80004774:	c4 78       	rjmp	80004802 <gpio_enable_module_pin+0x256>

	case 6: /* G function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80004776:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000477a:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000477e:	30 19       	mov	r9,1
80004780:	f2 08 09 48 	lsl	r8,r9,r8
80004784:	10 99       	mov	r9,r8
80004786:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000478a:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000478c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004790:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004794:	30 19       	mov	r9,1
80004796:	f2 08 09 48 	lsl	r8,r9,r8
8000479a:	10 99       	mov	r9,r8
8000479c:	ee f8 ff fc 	ld.w	r8,r7[-4]
800047a0:	91 99       	st.w	r8[0x24],r9
		gpio_port->pmr2s = 1 << (pin & 0x1F);
800047a2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800047a6:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800047aa:	30 19       	mov	r9,1
800047ac:	f2 08 09 48 	lsl	r8,r9,r8
800047b0:	10 99       	mov	r9,r8
800047b2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800047b6:	91 d9       	st.w	r8[0x34],r9
		break;
800047b8:	c2 58       	rjmp	80004802 <gpio_enable_module_pin+0x256>

	case 7: /* H function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800047ba:	ee f8 ff f8 	ld.w	r8,r7[-8]
800047be:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800047c2:	30 19       	mov	r9,1
800047c4:	f2 08 09 48 	lsl	r8,r9,r8
800047c8:	10 99       	mov	r9,r8
800047ca:	ee f8 ff fc 	ld.w	r8,r7[-4]
800047ce:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800047d0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800047d4:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800047d8:	30 19       	mov	r9,1
800047da:	f2 08 09 48 	lsl	r8,r9,r8
800047de:	10 99       	mov	r9,r8
800047e0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800047e4:	91 99       	st.w	r8[0x24],r9
		gpio_port->pmr2s = 1 << (pin & 0x1F);
800047e6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800047ea:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800047ee:	30 19       	mov	r9,1
800047f0:	f2 08 09 48 	lsl	r8,r9,r8
800047f4:	10 99       	mov	r9,r8
800047f6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800047fa:	91 d9       	st.w	r8[0x34],r9
		break;
800047fc:	c0 38       	rjmp	80004802 <gpio_enable_module_pin+0x256>
#endif

	default:
		return GPIO_INVALID_ARGUMENT;
800047fe:	30 18       	mov	r8,1
80004800:	c0 d8       	rjmp	8000481a <gpio_enable_module_pin+0x26e>
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80004802:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004806:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000480a:	30 19       	mov	r9,1
8000480c:	f2 08 09 48 	lsl	r8,r9,r8
80004810:	10 99       	mov	r9,r8
80004812:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004816:	91 29       	st.w	r8[0x8],r9

	return GPIO_SUCCESS;
80004818:	30 08       	mov	r8,0
}
8000481a:	10 9c       	mov	r12,r8
8000481c:	2f dd       	sub	sp,-12
8000481e:	e3 cd 80 80 	ldm	sp++,r7,pc
80004822:	00 00       	add	r0,r0
80004824:	80 01       	ld.sh	r1,r0[0x0]
80004826:	24 40       	sub	r0,68

80004828 <gpio_configure_pin>:
 *
 * \param pin The pin number.
 * \param flags The configuration.
 */
void gpio_configure_pin(uint32_t pin, uint32_t flags)
{
80004828:	eb cd 40 80 	pushm	r7,lr
8000482c:	1a 97       	mov	r7,sp
8000482e:	20 3d       	sub	sp,12
80004830:	ef 4c ff f8 	st.w	r7[-8],r12
80004834:	ef 4b ff f4 	st.w	r7[-12],r11
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80004838:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000483c:	a5 98       	lsr	r8,0x5
8000483e:	a9 78       	lsl	r8,0x9
80004840:	e0 28 e0 00 	sub	r8,57344
80004844:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Both pull-up and pull-down set means buskeeper */
#if defined(AVR32_GPIO_200_H_INCLUDED) || defined(AVR32_GPIO_210_H_INCLUDED) ||	\
	defined(AVR32_GPIO_212_H_INCLUDED)
	if (flags & GPIO_PULL_DOWN) {
80004848:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000484c:	e2 18 00 08 	andl	r8,0x8,COH
80004850:	c0 e0       	breq	8000486c <gpio_configure_pin+0x44>
		gpio_port->pders = 1 << (pin & 0x1F);
80004852:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004856:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000485a:	30 19       	mov	r9,1
8000485c:	f2 08 09 48 	lsl	r8,r9,r8
80004860:	10 99       	mov	r9,r8
80004862:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004866:	f1 49 00 84 	st.w	r8[132],r9
8000486a:	c0 d8       	rjmp	80004884 <gpio_configure_pin+0x5c>
	} else {
		gpio_port->pderc = 1 << (pin & 0x1F);
8000486c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004870:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004874:	30 19       	mov	r9,1
80004876:	f2 08 09 48 	lsl	r8,r9,r8
8000487a:	10 99       	mov	r9,r8
8000487c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004880:	f1 49 00 88 	st.w	r8[136],r9
	}

#endif
	if (flags & GPIO_PULL_UP) {
80004884:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004888:	e2 18 00 04 	andl	r8,0x4,COH
8000488c:	c0 e0       	breq	800048a8 <gpio_configure_pin+0x80>
		gpio_port->puers = 1 << (pin & 0x1F);
8000488e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004892:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004896:	30 19       	mov	r9,1
80004898:	f2 08 09 48 	lsl	r8,r9,r8
8000489c:	10 99       	mov	r9,r8
8000489e:	ee f8 ff fc 	ld.w	r8,r7[-4]
800048a2:	f1 49 00 74 	st.w	r8[116],r9
800048a6:	c0 d8       	rjmp	800048c0 <gpio_configure_pin+0x98>
	} else {
		gpio_port->puerc = 1 << (pin & 0x1F);
800048a8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800048ac:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800048b0:	30 19       	mov	r9,1
800048b2:	f2 08 09 48 	lsl	r8,r9,r8
800048b6:	10 99       	mov	r9,r8
800048b8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800048bc:	f1 49 00 78 	st.w	r8[120],r9
	}

	/* Enable open-drain mode if requested */
#if defined(AVR32_GPIO_200_H_INCLUDED) || defined(AVR32_GPIO_210_H_INCLUDED) ||	\
	defined(AVR32_GPIO_212_H_INCLUDED)
	if (flags & GPIO_OPEN_DRAIN) {
800048c0:	ee f8 ff f4 	ld.w	r8,r7[-12]
800048c4:	e2 18 00 40 	andl	r8,0x40,COH
800048c8:	c0 e0       	breq	800048e4 <gpio_configure_pin+0xbc>
		gpio_port->odmers = 1 << (pin & 0x1F);
800048ca:	ee f8 ff f8 	ld.w	r8,r7[-8]
800048ce:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800048d2:	30 19       	mov	r9,1
800048d4:	f2 08 09 48 	lsl	r8,r9,r8
800048d8:	10 99       	mov	r9,r8
800048da:	ee f8 ff fc 	ld.w	r8,r7[-4]
800048de:	f1 49 00 e4 	st.w	r8[228],r9
800048e2:	c0 d8       	rjmp	800048fc <gpio_configure_pin+0xd4>
	} else {
		gpio_port->odmerc = 1 << (pin & 0x1F);
800048e4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800048e8:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800048ec:	30 19       	mov	r9,1
800048ee:	f2 08 09 48 	lsl	r8,r9,r8
800048f2:	10 99       	mov	r9,r8
800048f4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800048f8:	f1 49 00 e8 	st.w	r8[232],r9
#endif

#if defined(AVR32_GPIO_200_H_INCLUDED) || defined(AVR32_GPIO_210_H_INCLUDED) ||	\
	defined(AVR32_GPIO_212_H_INCLUDED)
	/* Select drive strength */
	if (flags & GPIO_DRIVE_LOW) {
800048fc:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004900:	e2 18 00 10 	andl	r8,0x10,COH
80004904:	c0 e0       	breq	80004920 <gpio_configure_pin+0xf8>
		gpio_port->odcr0s = 1 << (pin & 0x1F);
80004906:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000490a:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000490e:	30 19       	mov	r9,1
80004910:	f2 08 09 48 	lsl	r8,r9,r8
80004914:	10 99       	mov	r9,r8
80004916:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000491a:	f1 49 01 04 	st.w	r8[260],r9
8000491e:	c0 d8       	rjmp	80004938 <gpio_configure_pin+0x110>
	} else {
		gpio_port->odcr0c = 1 << (pin & 0x1F);
80004920:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004924:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004928:	30 19       	mov	r9,1
8000492a:	f2 08 09 48 	lsl	r8,r9,r8
8000492e:	10 99       	mov	r9,r8
80004930:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004934:	f1 49 01 08 	st.w	r8[264],r9
	}

	if (flags & GPIO_DRIVE_HIGH) {
80004938:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000493c:	e2 18 00 20 	andl	r8,0x20,COH
80004940:	c0 e0       	breq	8000495c <gpio_configure_pin+0x134>
		gpio_port->odcr1s = 1 << (pin & 0x1F);
80004942:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004946:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000494a:	30 19       	mov	r9,1
8000494c:	f2 08 09 48 	lsl	r8,r9,r8
80004950:	10 99       	mov	r9,r8
80004952:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004956:	f1 49 01 14 	st.w	r8[276],r9
8000495a:	c0 d8       	rjmp	80004974 <gpio_configure_pin+0x14c>
	} else {
		gpio_port->odcr1c = 1 << (pin & 0x1F);
8000495c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004960:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004964:	30 19       	mov	r9,1
80004966:	f2 08 09 48 	lsl	r8,r9,r8
8000496a:	10 99       	mov	r9,r8
8000496c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004970:	f1 49 01 18 	st.w	r8[280],r9
	}

#endif

	/* Select interrupt level for group */
	if (flags & GPIO_INTERRUPT) {
80004974:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004978:	e2 18 00 80 	andl	r8,0x80,COH
8000497c:	c5 a0       	breq	80004a30 <gpio_configure_pin+0x208>
		if (flags & GPIO_BOTHEDGES) {
8000497e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004982:	e2 18 01 80 	andl	r8,0x180,COH
80004986:	c1 a0       	breq	800049ba <gpio_configure_pin+0x192>
			gpio_port->imr0c = 1 << (pin & 0x1F);
80004988:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000498c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004990:	30 19       	mov	r9,1
80004992:	f2 08 09 48 	lsl	r8,r9,r8
80004996:	10 99       	mov	r9,r8
80004998:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000499c:	f1 49 00 a8 	st.w	r8[168],r9
			gpio_port->imr1c = 1 << (pin & 0x1F);
800049a0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800049a4:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800049a8:	30 19       	mov	r9,1
800049aa:	f2 08 09 48 	lsl	r8,r9,r8
800049ae:	10 99       	mov	r9,r8
800049b0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800049b4:	f1 49 00 b8 	st.w	r8[184],r9
800049b8:	c3 c8       	rjmp	80004a30 <gpio_configure_pin+0x208>
		} else if (flags & GPIO_RISING) {
800049ba:	ee f8 ff f4 	ld.w	r8,r7[-12]
800049be:	e2 18 02 80 	andl	r8,0x280,COH
800049c2:	c1 a0       	breq	800049f6 <gpio_configure_pin+0x1ce>
			gpio_port->imr0s = 1 << (pin & 0x1F);
800049c4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800049c8:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800049cc:	30 19       	mov	r9,1
800049ce:	f2 08 09 48 	lsl	r8,r9,r8
800049d2:	10 99       	mov	r9,r8
800049d4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800049d8:	f1 49 00 a4 	st.w	r8[164],r9
			gpio_port->imr1c = 1 << (pin & 0x1F);
800049dc:	ee f8 ff f8 	ld.w	r8,r7[-8]
800049e0:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800049e4:	30 19       	mov	r9,1
800049e6:	f2 08 09 48 	lsl	r8,r9,r8
800049ea:	10 99       	mov	r9,r8
800049ec:	ee f8 ff fc 	ld.w	r8,r7[-4]
800049f0:	f1 49 00 b8 	st.w	r8[184],r9
800049f4:	c1 e8       	rjmp	80004a30 <gpio_configure_pin+0x208>
		} else if (flags & GPIO_FALLING) {
800049f6:	ee f8 ff f4 	ld.w	r8,r7[-12]
800049fa:	e2 18 03 80 	andl	r8,0x380,COH
800049fe:	c1 90       	breq	80004a30 <gpio_configure_pin+0x208>
			gpio_port->imr0c = 1 << (pin & 0x1F);
80004a00:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004a04:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004a08:	30 19       	mov	r9,1
80004a0a:	f2 08 09 48 	lsl	r8,r9,r8
80004a0e:	10 99       	mov	r9,r8
80004a10:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a14:	f1 49 00 a8 	st.w	r8[168],r9
			gpio_port->imr1s = 1 << (pin & 0x1F);
80004a18:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004a1c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004a20:	30 19       	mov	r9,1
80004a22:	f2 08 09 48 	lsl	r8,r9,r8
80004a26:	10 99       	mov	r9,r8
80004a28:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a2c:	f1 49 00 b4 	st.w	r8[180],r9
		}
	}

	/* Select direction and initial pin state */
	if (flags & GPIO_DIR_OUTPUT) {
80004a30:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004a34:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004a38:	5c 58       	castu.b	r8
80004a3a:	c2 c0       	breq	80004a92 <gpio_configure_pin+0x26a>
		if (flags & GPIO_INIT_HIGH) {
80004a3c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004a40:	e2 18 00 02 	andl	r8,0x2,COH
80004a44:	c0 e0       	breq	80004a60 <gpio_configure_pin+0x238>
			gpio_port->ovrs = 1 << (pin & 0x1F);
80004a46:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004a4a:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004a4e:	30 19       	mov	r9,1
80004a50:	f2 08 09 48 	lsl	r8,r9,r8
80004a54:	10 99       	mov	r9,r8
80004a56:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a5a:	f1 49 00 54 	st.w	r8[84],r9
80004a5e:	c0 d8       	rjmp	80004a78 <gpio_configure_pin+0x250>
		} else {
			gpio_port->ovrc = 1 << (pin & 0x1F);
80004a60:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004a64:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004a68:	30 19       	mov	r9,1
80004a6a:	f2 08 09 48 	lsl	r8,r9,r8
80004a6e:	10 99       	mov	r9,r8
80004a70:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a74:	f1 49 00 58 	st.w	r8[88],r9
		}

		gpio_port->oders = 1 << (pin & 0x1F);
80004a78:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004a7c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004a80:	30 19       	mov	r9,1
80004a82:	f2 08 09 48 	lsl	r8,r9,r8
80004a86:	10 99       	mov	r9,r8
80004a88:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a8c:	f1 49 00 44 	st.w	r8[68],r9
80004a90:	c0 d8       	rjmp	80004aaa <gpio_configure_pin+0x282>
	} else {
		gpio_port->oderc = 1 << (pin & 0x1F);
80004a92:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004a96:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004a9a:	30 19       	mov	r9,1
80004a9c:	f2 08 09 48 	lsl	r8,r9,r8
80004aa0:	10 99       	mov	r9,r8
80004aa2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004aa6:	f1 49 00 48 	st.w	r8[72],r9
	}

	/* Enable GPIO */
	gpio_port->gpers = 1 << (pin & 0x1F);
80004aaa:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004aae:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004ab2:	30 19       	mov	r9,1
80004ab4:	f2 08 09 48 	lsl	r8,r9,r8
80004ab8:	10 99       	mov	r9,r8
80004aba:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004abe:	91 19       	st.w	r8[0x4],r9
}
80004ac0:	2f dd       	sub	sp,-12
80004ac2:	e3 cd 80 80 	ldm	sp++,r7,pc

80004ac6 <gpio_get_pin_value>:
 * \param pin The pin number.
 *
 * \return The pin value.
 */
bool gpio_get_pin_value(uint32_t pin)
{
80004ac6:	eb cd 40 80 	pushm	r7,lr
80004aca:	1a 97       	mov	r7,sp
80004acc:	20 2d       	sub	sp,8
80004ace:	ef 4c ff f8 	st.w	r7[-8],r12
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80004ad2:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004ad6:	a5 98       	lsr	r8,0x5
80004ad8:	a9 78       	lsl	r8,0x9
80004ada:	e0 28 e0 00 	sub	r8,57344
80004ade:	ef 48 ff fc 	st.w	r7[-4],r8
	
	return (gpio_port->pvr >> (pin & 0x1F)) & 1;
80004ae2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004ae6:	71 89       	ld.w	r9,r8[0x60]
80004ae8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004aec:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004af0:	f2 08 0a 48 	lsr	r8,r9,r8
80004af4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004af8:	5c 58       	castu.b	r8
}
80004afa:	10 9c       	mov	r12,r8
80004afc:	2f ed       	sub	sp,-8
80004afe:	e3 cd 80 80 	ldm	sp++,r7,pc

80004b02 <gpio_set_pin_high>:
 * \param pin The pin number.
 *
 * \note The function \ref gpio_configure_pin must be called before.
 */
void gpio_set_pin_high(uint32_t pin)
{
80004b02:	eb cd 40 80 	pushm	r7,lr
80004b06:	1a 97       	mov	r7,sp
80004b08:	20 2d       	sub	sp,8
80004b0a:	ef 4c ff f8 	st.w	r7[-8],r12
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80004b0e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004b12:	a5 98       	lsr	r8,0x5
80004b14:	a9 78       	lsl	r8,0x9
80004b16:	e0 28 e0 00 	sub	r8,57344
80004b1a:	ef 48 ff fc 	st.w	r7[-4],r8
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
80004b1e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004b22:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004b26:	30 19       	mov	r9,1
80004b28:	f2 08 09 48 	lsl	r8,r9,r8
80004b2c:	10 99       	mov	r9,r8
80004b2e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004b32:	f1 49 00 54 	st.w	r8[84],r9
}
80004b36:	2f ed       	sub	sp,-8
80004b38:	e3 cd 80 80 	ldm	sp++,r7,pc

80004b3c <gpio_set_pin_low>:
 * \param pin The pin number.
 *
 * \note The function \ref gpio_configure_pin must be called before.
 */
void gpio_set_pin_low(uint32_t pin)
{
80004b3c:	eb cd 40 80 	pushm	r7,lr
80004b40:	1a 97       	mov	r7,sp
80004b42:	20 2d       	sub	sp,8
80004b44:	ef 4c ff f8 	st.w	r7[-8],r12
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80004b48:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004b4c:	a5 98       	lsr	r8,0x5
80004b4e:	a9 78       	lsl	r8,0x9
80004b50:	e0 28 e0 00 	sub	r8,57344
80004b54:	ef 48 ff fc 	st.w	r7[-4],r8
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
80004b58:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004b5c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004b60:	30 19       	mov	r9,1
80004b62:	f2 08 09 48 	lsl	r8,r9,r8
80004b66:	10 99       	mov	r9,r8
80004b68:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004b6c:	f1 49 00 58 	st.w	r8[88],r9
}
80004b70:	2f ed       	sub	sp,-8
80004b72:	e3 cd 80 80 	ldm	sp++,r7,pc

80004b76 <gpio_toggle_pin>:
 * \param pin The pin number.
 *
 * \note The function \ref gpio_configure_pin must be called before.
 */
void gpio_toggle_pin(uint32_t pin)
{
80004b76:	eb cd 40 80 	pushm	r7,lr
80004b7a:	1a 97       	mov	r7,sp
80004b7c:	20 2d       	sub	sp,8
80004b7e:	ef 4c ff f8 	st.w	r7[-8],r12
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80004b82:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004b86:	a5 98       	lsr	r8,0x5
80004b88:	a9 78       	lsl	r8,0x9
80004b8a:	e0 28 e0 00 	sub	r8,57344
80004b8e:	ef 48 ff fc 	st.w	r7[-4],r8
	
	/* Toggle the I/O line. */
	gpio_port->ovrt  = 1 << (pin & 0x1F);
80004b92:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004b96:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004b9a:	30 19       	mov	r9,1
80004b9c:	f2 08 09 48 	lsl	r8,r9,r8
80004ba0:	10 99       	mov	r9,r8
80004ba2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004ba6:	f1 49 00 5c 	st.w	r8[92],r9
}
80004baa:	2f ed       	sub	sp,-8
80004bac:	e3 cd 80 80 	ldm	sp++,r7,pc

80004bb0 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80004bb0:	eb cd 40 80 	pushm	r7,lr
80004bb4:	1a 97       	mov	r7,sp
	// Catch unregistered interrupts.
	while (true);
80004bb6:	c0 08       	rjmp	80004bb6 <_unhandled_interrupt+0x6>

80004bb8 <_get_interrupt_handler>:
 *
 * \return Interrupt handler to execute.
 */
__int_handler _get_interrupt_handler(uint32_t int_level);
__int_handler _get_interrupt_handler(uint32_t int_level)
{
80004bb8:	eb cd 40 80 	pushm	r7,lr
80004bbc:	1a 97       	mov	r7,sp
80004bbe:	20 3d       	sub	sp,12
80004bc0:	ef 4c ff f4 	st.w	r7[-12],r12
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80004bc4:	fe 78 00 00 	mov	r8,-65536
80004bc8:	ee f9 ff f4 	ld.w	r9,r7[-12]
80004bcc:	f2 09 11 03 	rsub	r9,r9,3
80004bd0:	28 09       	sub	r9,-128
80004bd2:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80004bd6:	ef 48 ff f8 	st.w	r7[-8],r8
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80004bda:	fe 78 00 00 	mov	r8,-65536
80004bde:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004be2:	2c 09       	sub	r9,-64
80004be4:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80004be8:	ef 48 ff fc 	st.w	r7[-4],r8
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80004bec:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004bf0:	58 08       	cp.w	r8,0
80004bf2:	c1 30       	breq	80004c18 <_get_interrupt_handler+0x60>
		? _int_handler_table[int_grp]._int_line_handler_table[32
80004bf4:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004bf8:	48 b8       	lddpc	r8,80004c24 <_get_interrupt_handler+0x6c>
80004bfa:	a1 79       	lsl	r9,0x1
80004bfc:	2f f9       	sub	r9,-1
80004bfe:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
80004c02:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004c06:	f0 08 12 00 	clz	r8,r8
80004c0a:	f0 08 11 1f 	rsub	r8,r8,31
			- clz(int_req) - 1]
80004c0e:	a3 68       	lsl	r8,0x2
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
		? _int_handler_table[int_grp]._int_line_handler_table[32
80004c10:	f2 08 00 08 	add	r8,r9,r8
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80004c14:	70 08       	ld.w	r8,r8[0x0]
80004c16:	c0 28       	rjmp	80004c1a <_get_interrupt_handler+0x62>
80004c18:	30 08       	mov	r8,0
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80004c1a:	10 9c       	mov	r12,r8
80004c1c:	2f dd       	sub	sp,-12
80004c1e:	e3 cd 80 80 	ldm	sp++,r7,pc
80004c22:	00 00       	add	r0,r0
80004c24:	80 01       	ld.sh	r1,r0[0x0]
80004c26:	24 60       	sub	r0,70

80004c28 <INTC_init_evba>:
 * \internal
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
80004c28:	eb cd 40 80 	pushm	r7,lr
80004c2c:	1a 97       	mov	r7,sp
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80004c2e:	48 38       	lddpc	r8,80004c38 <INTC_init_evba+0x10>
80004c30:	e3 b8 00 01 	mtsr	0x4,r8
}
80004c34:	e3 cd 80 80 	ldm	sp++,r7,pc
80004c38:	80 01       	ld.sh	r1,r0[0x0]
80004c3a:	22 00       	sub	r0,32

80004c3c <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80004c3c:	eb cd 40 80 	pushm	r7,lr
80004c40:	1a 97       	mov	r7,sp
80004c42:	20 2d       	sub	sp,8
	uint32_t int_grp, int_req;

	INTC_init_evba();
80004c44:	f0 1f 00 20 	mcall	80004cc4 <INTC_init_interrupts+0x88>

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80004c48:	30 08       	mov	r8,0
80004c4a:	ef 48 ff f8 	st.w	r7[-8],r8
80004c4e:	c3 18       	rjmp	80004cb0 <INTC_init_interrupts+0x74>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004c50:	30 08       	mov	r8,0
80004c52:	ef 48 ff fc 	st.w	r7[-4],r8
80004c56:	c1 48       	rjmp	80004c7e <INTC_init_interrupts+0x42>
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80004c58:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004c5c:	49 b8       	lddpc	r8,80004cc8 <INTC_init_interrupts+0x8c>
80004c5e:	a1 79       	lsl	r9,0x1
80004c60:	2f f9       	sub	r9,-1
80004c62:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
80004c66:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004c6a:	a3 68       	lsl	r8,0x2
80004c6c:	f2 08 00 08 	add	r8,r9,r8
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80004c70:	49 79       	lddpc	r9,80004ccc <INTC_init_interrupts+0x90>
80004c72:	91 09       	st.w	r8[0x0],r9
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80004c74:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004c78:	2f f8       	sub	r8,-1
80004c7a:	ef 48 ff fc 	st.w	r7[-4],r8
	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
80004c7e:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004c82:	49 28       	lddpc	r8,80004cc8 <INTC_init_interrupts+0x8c>
80004c84:	f0 09 03 39 	ld.w	r9,r8[r9<<0x3]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004c88:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004c8c:	10 39       	cp.w	r9,r8
80004c8e:	fe 9b ff e5 	brhi	80004c58 <INTC_init_interrupts+0x1c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004c92:	fe 78 00 00 	mov	r8,-65536
80004c96:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004c9a:	48 eb       	lddpc	r11,80004cd0 <INTC_init_interrupts+0x94>
80004c9c:	48 ea       	lddpc	r10,80004cd4 <INTC_init_interrupts+0x98>
80004c9e:	f6 0a 01 0a 	sub	r10,r11,r10
80004ca2:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80004ca6:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004caa:	2f f8       	sub	r8,-1
80004cac:	ef 48 ff f8 	st.w	r7[-8],r8
80004cb0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004cb4:	e0 48 00 2e 	cp.w	r8,46
80004cb8:	fe 98 ff cc 	brls	80004c50 <INTC_init_interrupts+0x14>
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
	}
}
80004cbc:	2f ed       	sub	sp,-8
80004cbe:	e3 cd 80 80 	ldm	sp++,r7,pc
80004cc2:	00 00       	add	r0,r0
80004cc4:	80 00       	ld.sh	r0,r0[0x0]
80004cc6:	4c 28       	lddpc	r8,80004dcc <cpu_irq_is_enabled_flags+0x2>
80004cc8:	80 01       	ld.sh	r1,r0[0x0]
80004cca:	24 60       	sub	r0,70
80004ccc:	80 00       	ld.sh	r0,r0[0x0]
80004cce:	4b b0       	lddpc	r0,80004db8 <cpu_irq_save+0xc>
80004cd0:	80 01       	ld.sh	r1,r0[0x0]
80004cd2:	23 04       	sub	r4,48
80004cd4:	80 01       	ld.sh	r1,r0[0x0]
80004cd6:	22 00       	sub	r0,32

80004cd8 <INTC_register_interrupt>:
 *          be effective.
 *
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
80004cd8:	eb cd 40 80 	pushm	r7,lr
80004cdc:	1a 97       	mov	r7,sp
80004cde:	20 4d       	sub	sp,16
80004ce0:	ef 4c ff f8 	st.w	r7[-8],r12
80004ce4:	ef 4b ff f4 	st.w	r7[-12],r11
80004ce8:	ef 4a ff f0 	st.w	r7[-16],r10
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80004cec:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004cf0:	a5 98       	lsr	r8,0x5
80004cf2:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80004cf6:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004cfa:	4a 78       	lddpc	r8,80004d94 <INTC_register_interrupt+0xbc>
80004cfc:	a1 79       	lsl	r9,0x1
80004cfe:	2f f9       	sub	r9,-1
80004d00:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
80004d04:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004d08:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004d0c:	a3 68       	lsl	r8,0x2
80004d0e:	f2 08 00 08 	add	r8,r9,r8
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80004d12:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004d16:	91 09       	st.w	r8[0x0],r9
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80004d18:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004d1c:	58 08       	cp.w	r8,0
80004d1e:	c0 c1       	brne	80004d36 <INTC_register_interrupt+0x5e>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004d20:	fe 78 00 00 	mov	r8,-65536
80004d24:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004d28:	49 cb       	lddpc	r11,80004d98 <INTC_register_interrupt+0xc0>
80004d2a:	49 da       	lddpc	r10,80004d9c <INTC_register_interrupt+0xc4>
80004d2c:	f6 0a 01 0a 	sub	r10,r11,r10
80004d30:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
80004d34:	c2 d8       	rjmp	80004d8e <INTC_register_interrupt+0xb6>
	} else if (int_level == AVR32_INTC_INT1) {
80004d36:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004d3a:	58 18       	cp.w	r8,1
80004d3c:	c0 d1       	brne	80004d56 <INTC_register_interrupt+0x7e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80004d3e:	fe 78 00 00 	mov	r8,-65536
80004d42:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004d46:	49 7b       	lddpc	r11,80004da0 <INTC_register_interrupt+0xc8>
80004d48:	49 5a       	lddpc	r10,80004d9c <INTC_register_interrupt+0xc4>
80004d4a:	f6 0a 01 0a 	sub	r10,r11,r10
80004d4e:	bf aa       	sbr	r10,0x1e
80004d50:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
80004d54:	c1 d8       	rjmp	80004d8e <INTC_register_interrupt+0xb6>
	} else if (int_level == AVR32_INTC_INT2) {
80004d56:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004d5a:	58 28       	cp.w	r8,2
80004d5c:	c0 d1       	brne	80004d76 <INTC_register_interrupt+0x9e>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80004d5e:	fe 78 00 00 	mov	r8,-65536
80004d62:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004d66:	49 0b       	lddpc	r11,80004da4 <INTC_register_interrupt+0xcc>
80004d68:	48 da       	lddpc	r10,80004d9c <INTC_register_interrupt+0xc4>
80004d6a:	f6 0a 01 0a 	sub	r10,r11,r10
80004d6e:	bf ba       	sbr	r10,0x1f
80004d70:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
80004d74:	c0 d8       	rjmp	80004d8e <INTC_register_interrupt+0xb6>
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80004d76:	fe 78 00 00 	mov	r8,-65536
80004d7a:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004d7e:	48 bb       	lddpc	r11,80004da8 <INTC_register_interrupt+0xd0>
80004d80:	48 7a       	lddpc	r10,80004d9c <INTC_register_interrupt+0xc4>
80004d82:	f6 0a 01 0a 	sub	r10,r11,r10
80004d86:	ea 1a c0 00 	orh	r10,0xc000
80004d8a:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
	}
}
80004d8e:	2f cd       	sub	sp,-16
80004d90:	e3 cd 80 80 	ldm	sp++,r7,pc
80004d94:	80 01       	ld.sh	r1,r0[0x0]
80004d96:	24 60       	sub	r0,70
80004d98:	80 01       	ld.sh	r1,r0[0x0]
80004d9a:	23 04       	sub	r4,48
80004d9c:	80 01       	ld.sh	r1,r0[0x0]
80004d9e:	22 00       	sub	r0,32
80004da0:	80 01       	ld.sh	r1,r0[0x0]
80004da2:	23 12       	sub	r2,49
80004da4:	80 01       	ld.sh	r1,r0[0x0]
80004da6:	23 20       	sub	r0,50
80004da8:	80 01       	ld.sh	r1,r0[0x0]
80004daa:	23 2e       	sub	lr,50

80004dac <cpu_irq_save>:
#endif

typedef uint32_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
80004dac:	eb cd 40 80 	pushm	r7,lr
80004db0:	1a 97       	mov	r7,sp
80004db2:	20 1d       	sub	sp,4
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80004db4:	e1 b8 00 00 	mfsr	r8,0x0
80004db8:	ef 48 ff fc 	st.w	r7[-4],r8
	cpu_irq_disable();
80004dbc:	d3 03       	ssrf	0x10

	return flags;
80004dbe:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80004dc2:	10 9c       	mov	r12,r8
80004dc4:	2f fd       	sub	sp,-4
80004dc6:	e3 cd 80 80 	ldm	sp++,r7,pc

80004dca <cpu_irq_is_enabled_flags>:

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
80004dca:	eb cd 40 80 	pushm	r7,lr
80004dce:	1a 97       	mov	r7,sp
80004dd0:	20 1d       	sub	sp,4
80004dd2:	ef 4c ff fc 	st.w	r7[-4],r12
	return !(flags & AVR32_SR_GM_MASK);
80004dd6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004dda:	e6 18 00 01 	andh	r8,0x1,COH
80004dde:	5f 08       	sreq	r8
80004de0:	5c 58       	castu.b	r8
}
80004de2:	10 9c       	mov	r12,r8
80004de4:	2f fd       	sub	sp,-4
80004de6:	e3 cd 80 80 	ldm	sp++,r7,pc
80004dea:	d7 03       	nop

80004dec <cpu_irq_restore>:

static inline void cpu_irq_restore(irqflags_t flags)
{
80004dec:	eb cd 40 80 	pushm	r7,lr
80004df0:	1a 97       	mov	r7,sp
80004df2:	20 1d       	sub	sp,4
80004df4:	ef 4c ff fc 	st.w	r7[-4],r12
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80004df8:	ee fc ff fc 	ld.w	r12,r7[-4]
80004dfc:	f0 1f 00 05 	mcall	80004e10 <cpu_irq_restore+0x24>
80004e00:	18 98       	mov	r8,r12
80004e02:	58 08       	cp.w	r8,0
80004e04:	c0 20       	breq	80004e08 <cpu_irq_restore+0x1c>
      cpu_irq_enable();
80004e06:	d5 03       	csrf	0x10
   }

	barrier();
}
80004e08:	2f fd       	sub	sp,-4
80004e0a:	e3 cd 80 80 	ldm	sp++,r7,pc
80004e0e:	00 00       	add	r0,r0
80004e10:	80 00       	ld.sh	r0,r0[0x0]
80004e12:	4d ca       	lddpc	r10,80004f80 <twim_set_speed+0x28>

80004e14 <twim_master_interrupt_handler>:
/**
 * \internal
 * \brief TWI interrupt handler.
 */
ISR(twim_master_interrupt_handler,CONF_TWIM_IRQ_GROUP,CONF_TWIM_IRQ_LEVEL)
{
80004e14:	eb cd 40 80 	pushm	r7,lr
80004e18:	1a 97       	mov	r7,sp
80004e1a:	20 1d       	sub	sp,4
	// get masked status register value
	uint32_t status = twim_inst->sr & twim_it_mask;
80004e1c:	4c 68       	lddpc	r8,80004f34 <twim_master_interrupt_handler+0x120>
80004e1e:	70 08       	ld.w	r8,r8[0x0]
80004e20:	70 79       	ld.w	r9,r8[0x1c]
80004e22:	4c 68       	lddpc	r8,80004f38 <twim_master_interrupt_handler+0x124>
80004e24:	70 08       	ld.w	r8,r8[0x0]
80004e26:	f3 e8 00 08 	and	r8,r9,r8
80004e2a:	ef 48 ff fc 	st.w	r7[-4],r8
	// this is a NACK
	if (status & AVR32_TWIM_SR_STD_MASK) {
80004e2e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004e32:	e2 18 07 00 	andl	r8,0x700,COH
80004e36:	c1 e0       	breq	80004e72 <twim_master_interrupt_handler+0x5e>
		//if we get a nak, clear the valid bit in cmdr,
		//otherwise the command will be resent.
		transfer_status =(status & AVR32_TWIM_IER_NAK_MASK) ?
80004e38:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004e3c:	e2 18 03 00 	andl	r8,0x300,COH
80004e40:	c0 30       	breq	80004e46 <twim_master_interrupt_handler+0x32>
80004e42:	3f c8       	mov	r8,-4
80004e44:	c0 28       	rjmp	80004e48 <twim_master_interrupt_handler+0x34>
80004e46:	3f e8       	mov	r8,-2
80004e48:	4b d9       	lddpc	r9,80004f3c <twim_master_interrupt_handler+0x128>
80004e4a:	93 08       	st.w	r9[0x0],r8
							TWI_RECEIVE_NACK : TWI_ARBITRATION_LOST;
		twim_inst->CMDR.valid = 0;
80004e4c:	4b a8       	lddpc	r8,80004f34 <twim_master_interrupt_handler+0x120>
80004e4e:	70 09       	ld.w	r9,r8[0x0]
80004e50:	72 38       	ld.w	r8,r9[0xc]
80004e52:	30 0a       	mov	r10,0
80004e54:	f1 da d1 e1 	bfins	r8,r10,0xf,0x1
80004e58:	93 38       	st.w	r9[0xc],r8
		twim_inst->scr = ~0UL;
80004e5a:	4b 78       	lddpc	r8,80004f34 <twim_master_interrupt_handler+0x120>
80004e5c:	70 08       	ld.w	r8,r8[0x0]
80004e5e:	3f f9       	mov	r9,-1
80004e60:	91 b9       	st.w	r8[0x2c],r9
		twim_inst->idr = ~0UL;
80004e62:	4b 58       	lddpc	r8,80004f34 <twim_master_interrupt_handler+0x120>
80004e64:	70 08       	ld.w	r8,r8[0x0]
80004e66:	3f f9       	mov	r9,-1
80004e68:	91 99       	st.w	r8[0x24],r9
		twim_next = false;
80004e6a:	4b 69       	lddpc	r9,80004f40 <twim_master_interrupt_handler+0x12c>
80004e6c:	30 08       	mov	r8,0
80004e6e:	b2 88       	st.b	r9[0x0],r8
80004e70:	c5 e8       	rjmp	80004f2c <twim_master_interrupt_handler+0x118>
	}
	// this is a RXRDY
	else if (status & AVR32_TWIM_SR_RXRDY_MASK) {
80004e72:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004e76:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004e7a:	5c 58       	castu.b	r8
80004e7c:	c2 00       	breq	80004ebc <twim_master_interrupt_handler+0xa8>
		// get data from Receive Holding Register
		*twim_rx_data = twim_inst->rhr;
80004e7e:	4b 28       	lddpc	r8,80004f44 <twim_master_interrupt_handler+0x130>
80004e80:	70 09       	ld.w	r9,r8[0x0]
80004e82:	4a d8       	lddpc	r8,80004f34 <twim_master_interrupt_handler+0x120>
80004e84:	70 08       	ld.w	r8,r8[0x0]
80004e86:	70 58       	ld.w	r8,r8[0x14]
80004e88:	5c 58       	castu.b	r8
80004e8a:	b2 88       	st.b	r9[0x0],r8
		twim_rx_data++;
80004e8c:	4a e8       	lddpc	r8,80004f44 <twim_master_interrupt_handler+0x130>
80004e8e:	70 08       	ld.w	r8,r8[0x0]
80004e90:	f0 c9 ff ff 	sub	r9,r8,-1
80004e94:	4a c8       	lddpc	r8,80004f44 <twim_master_interrupt_handler+0x130>
80004e96:	91 09       	st.w	r8[0x0],r9
		// decrease received bytes number
		twim_rx_nb_bytes--;
80004e98:	4a c8       	lddpc	r8,80004f48 <twim_master_interrupt_handler+0x134>
80004e9a:	70 08       	ld.w	r8,r8[0x0]
80004e9c:	f0 c9 00 01 	sub	r9,r8,1
80004ea0:	4a a8       	lddpc	r8,80004f48 <twim_master_interrupt_handler+0x134>
80004ea2:	91 09       	st.w	r8[0x0],r9
		// receive complete
		if (twim_rx_nb_bytes == 0) {
80004ea4:	4a 98       	lddpc	r8,80004f48 <twim_master_interrupt_handler+0x134>
80004ea6:	70 08       	ld.w	r8,r8[0x0]
80004ea8:	58 08       	cp.w	r8,0
80004eaa:	c4 11       	brne	80004f2c <twim_master_interrupt_handler+0x118>
			// finish the receive operation
			twim_inst->idr = AVR32_TWIM_IDR_RXRDY_MASK;
80004eac:	4a 28       	lddpc	r8,80004f34 <twim_master_interrupt_handler+0x120>
80004eae:	70 08       	ld.w	r8,r8[0x0]
80004eb0:	30 19       	mov	r9,1
80004eb2:	91 99       	st.w	r8[0x24],r9
			// set busy to false
			twim_next = false;
80004eb4:	4a 39       	lddpc	r9,80004f40 <twim_master_interrupt_handler+0x12c>
80004eb6:	30 08       	mov	r8,0
80004eb8:	b2 88       	st.b	r9[0x0],r8
80004eba:	c3 98       	rjmp	80004f2c <twim_master_interrupt_handler+0x118>
		}
	}
	// this is a TXRDY
	else if (status & AVR32_TWIM_SR_TXRDY_MASK) {
80004ebc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004ec0:	e2 18 00 02 	andl	r8,0x2,COH
80004ec4:	c3 40       	breq	80004f2c <twim_master_interrupt_handler+0x118>
		// no more bytes to transmit
		if (twim_tx_nb_bytes == 0) {
80004ec6:	4a 28       	lddpc	r8,80004f4c <twim_master_interrupt_handler+0x138>
80004ec8:	70 08       	ld.w	r8,r8[0x0]
80004eca:	58 08       	cp.w	r8,0
80004ecc:	c0 91       	brne	80004ede <twim_master_interrupt_handler+0xca>
			// finish the receive operation
			twim_inst->idr = AVR32_TWIM_IDR_TXRDY_MASK;
80004ece:	49 a8       	lddpc	r8,80004f34 <twim_master_interrupt_handler+0x120>
80004ed0:	70 08       	ld.w	r8,r8[0x0]
80004ed2:	30 29       	mov	r9,2
80004ed4:	91 99       	st.w	r8[0x24],r9
			// set busy to false
			twim_next = false;
80004ed6:	49 b9       	lddpc	r9,80004f40 <twim_master_interrupt_handler+0x12c>
80004ed8:	30 08       	mov	r8,0
80004eda:	b2 88       	st.b	r9[0x0],r8
80004edc:	c2 88       	rjmp	80004f2c <twim_master_interrupt_handler+0x118>
		} else {
			// put the byte in the Transmit Holding Register
			twim_inst->thr = *twim_tx_data++;
80004ede:	49 68       	lddpc	r8,80004f34 <twim_master_interrupt_handler+0x120>
80004ee0:	70 0a       	ld.w	r10,r8[0x0]
80004ee2:	49 c8       	lddpc	r8,80004f50 <twim_master_interrupt_handler+0x13c>
80004ee4:	70 08       	ld.w	r8,r8[0x0]
80004ee6:	11 89       	ld.ub	r9,r8[0x0]
80004ee8:	5c 59       	castu.b	r9
80004eea:	95 69       	st.w	r10[0x18],r9
80004eec:	f0 c9 ff ff 	sub	r9,r8,-1
80004ef0:	49 88       	lddpc	r8,80004f50 <twim_master_interrupt_handler+0x13c>
80004ef2:	91 09       	st.w	r8[0x0],r9
			// decrease transmitted bytes number
			twim_tx_nb_bytes--;
80004ef4:	49 68       	lddpc	r8,80004f4c <twim_master_interrupt_handler+0x138>
80004ef6:	70 08       	ld.w	r8,r8[0x0]
80004ef8:	f0 c9 00 01 	sub	r9,r8,1
80004efc:	49 48       	lddpc	r8,80004f4c <twim_master_interrupt_handler+0x138>
80004efe:	91 09       	st.w	r8[0x0],r9
			if (twim_tx_nb_bytes == 0) {
80004f00:	49 38       	lddpc	r8,80004f4c <twim_master_interrupt_handler+0x138>
80004f02:	70 08       	ld.w	r8,r8[0x0]
80004f04:	58 08       	cp.w	r8,0
80004f06:	c1 31       	brne	80004f2c <twim_master_interrupt_handler+0x118>
				// Check for next transfer
				if(twim_next) {
80004f08:	48 e8       	lddpc	r8,80004f40 <twim_master_interrupt_handler+0x12c>
80004f0a:	11 88       	ld.ub	r8,r8[0x0]
80004f0c:	5c 58       	castu.b	r8
80004f0e:	c0 f0       	breq	80004f2c <twim_master_interrupt_handler+0x118>
					twim_next = false;
80004f10:	48 c9       	lddpc	r9,80004f40 <twim_master_interrupt_handler+0x12c>
80004f12:	30 08       	mov	r8,0
80004f14:	b2 88       	st.b	r9[0x0],r8
					twim_tx_nb_bytes = twim_package->length;
80004f16:	49 08       	lddpc	r8,80004f54 <twim_master_interrupt_handler+0x140>
80004f18:	70 08       	ld.w	r8,r8[0x0]
80004f1a:	70 39       	ld.w	r9,r8[0xc]
80004f1c:	48 c8       	lddpc	r8,80004f4c <twim_master_interrupt_handler+0x138>
80004f1e:	91 09       	st.w	r8[0x0],r9
					twim_tx_data = twim_package->buffer;
80004f20:	48 d8       	lddpc	r8,80004f54 <twim_master_interrupt_handler+0x140>
80004f22:	70 08       	ld.w	r8,r8[0x0]
80004f24:	70 28       	ld.w	r8,r8[0x8]
80004f26:	10 99       	mov	r9,r8
80004f28:	48 a8       	lddpc	r8,80004f50 <twim_master_interrupt_handler+0x13c>
80004f2a:	91 09       	st.w	r8[0x0],r9
				}
			}
		}
	}
	return;
}
80004f2c:	2f fd       	sub	sp,-4
80004f2e:	e3 cd 40 80 	ldm	sp++,r7,lr
80004f32:	d6 03       	rete
80004f34:	00 00       	add	r0,r0
80004f36:	07 90       	ld.ub	r0,r3[0x1]
80004f38:	00 00       	add	r0,r0
80004f3a:	07 a8       	ld.ub	r8,r3[0x2]
80004f3c:	00 00       	add	r0,r0
80004f3e:	07 9c       	ld.ub	r12,r3[0x1]
80004f40:	00 00       	add	r0,r0
80004f42:	07 b0       	ld.ub	r0,r3[0x3]
80004f44:	00 00       	add	r0,r0
80004f46:	07 98       	ld.ub	r8,r3[0x1]
80004f48:	00 00       	add	r0,r0
80004f4a:	07 a4       	ld.ub	r4,r3[0x2]
80004f4c:	00 00       	add	r0,r0
80004f4e:	07 a0       	ld.ub	r0,r3[0x2]
80004f50:	00 00       	add	r0,r0
80004f52:	07 94       	ld.ub	r4,r3[0x1]
80004f54:	00 00       	add	r0,r0
80004f56:	07 ac       	ld.ub	r12,r3[0x2]

80004f58 <twim_set_speed>:
 * \retval STATUS_OK        Transaction is successful
 * \retval ERR_INVALID_ARG  Invalid arg resulting in wrong CWGR Exponential
 */
status_code_t twim_set_speed (volatile avr32_twim_t *twim, uint32_t speed,
		uint32_t pba_hz)
{
80004f58:	eb cd 40 80 	pushm	r7,lr
80004f5c:	1a 97       	mov	r7,sp
80004f5e:	20 5d       	sub	sp,20
80004f60:	ef 4c ff f4 	st.w	r7[-12],r12
80004f64:	ef 4b ff f0 	st.w	r7[-16],r11
80004f68:	ef 4a ff ec 	st.w	r7[-20],r10
	uint32_t f_prescaled;
	uint8_t cwgr_exp = 0;
80004f6c:	30 08       	mov	r8,0
80004f6e:	ef 68 ff ff 	st.b	r7[-1],r8
	f_prescaled = (pba_hz / speed / 2);
80004f72:	ee f8 ff ec 	ld.w	r8,r7[-20]
80004f76:	ee f9 ff f0 	ld.w	r9,r7[-16]
80004f7a:	f0 09 0d 08 	divu	r8,r8,r9
80004f7e:	a1 98       	lsr	r8,0x1
80004f80:	ef 48 ff f8 	st.w	r7[-8],r8
	// f_prescaled must fit in 8 bits, cwgr_exp must fit in 3 bits
	while ((f_prescaled > 0xFF) && (cwgr_exp <= 0x7)) {
80004f84:	c0 b8       	rjmp	80004f9a <twim_set_speed+0x42>
		// increase clock divider
		cwgr_exp++;
80004f86:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80004f8a:	2f f8       	sub	r8,-1
80004f8c:	ef 68 ff ff 	st.b	r7[-1],r8
		// divide f_prescaled value
		f_prescaled /= 2;
80004f90:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004f94:	a1 98       	lsr	r8,0x1
80004f96:	ef 48 ff f8 	st.w	r7[-8],r8
{
	uint32_t f_prescaled;
	uint8_t cwgr_exp = 0;
	f_prescaled = (pba_hz / speed / 2);
	// f_prescaled must fit in 8 bits, cwgr_exp must fit in 3 bits
	while ((f_prescaled > 0xFF) && (cwgr_exp <= 0x7)) {
80004f9a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004f9e:	e0 48 00 ff 	cp.w	r8,255
80004fa2:	e0 88 00 09 	brls	80004fb4 <twim_set_speed+0x5c>
80004fa6:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80004faa:	30 78       	mov	r8,7
80004fac:	f0 09 18 00 	cp.b	r9,r8
80004fb0:	fe 98 ff eb 	brls	80004f86 <twim_set_speed+0x2e>
		// increase clock divider
		cwgr_exp++;
		// divide f_prescaled value
		f_prescaled /= 2;
	}
	if (cwgr_exp > 0x7) {
80004fb4:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80004fb8:	30 78       	mov	r8,7
80004fba:	f0 09 18 00 	cp.b	r9,r8
80004fbe:	e0 88 00 04 	brls	80004fc6 <twim_set_speed+0x6e>
		return ERR_INVALID_ARG;
80004fc2:	3f 88       	mov	r8,-8
80004fc4:	c1 a8       	rjmp	80004ff8 <twim_set_speed+0xa0>
	}
	// set clock waveform generator register
	twim->cwgr = ((f_prescaled/2) << AVR32_TWIM_CWGR_LOW_OFFSET)
80004fc6:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004fca:	f0 09 16 01 	lsr	r9,r8,0x1
			| ((f_prescaled - f_prescaled/2) << AVR32_TWIM_CWGR_HIGH_OFFSET)
80004fce:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004fd2:	a1 98       	lsr	r8,0x1
80004fd4:	ee fa ff f8 	ld.w	r10,r7[-8]
80004fd8:	f4 08 01 08 	sub	r8,r10,r8
80004fdc:	a9 68       	lsl	r8,0x8
			| (cwgr_exp << AVR32_TWIM_CWGR_EXP_OFFSET)
80004fde:	10 49       	or	r9,r8
80004fe0:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80004fe4:	bd 68       	lsl	r8,0x1c
			| (0     << AVR32_TWIM_CWGR_DATA_OFFSET)
			| (f_prescaled << AVR32_TWIM_CWGR_STASTO_OFFSET);
80004fe6:	10 49       	or	r9,r8
80004fe8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004fec:	b1 68       	lsl	r8,0x10
	}
	if (cwgr_exp > 0x7) {
		return ERR_INVALID_ARG;
	}
	// set clock waveform generator register
	twim->cwgr = ((f_prescaled/2) << AVR32_TWIM_CWGR_LOW_OFFSET)
80004fee:	10 49       	or	r9,r8
80004ff0:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004ff4:	91 19       	st.w	r8[0x4],r9
			| ((f_prescaled - f_prescaled/2) << AVR32_TWIM_CWGR_HIGH_OFFSET)
			| (cwgr_exp << AVR32_TWIM_CWGR_EXP_OFFSET)
			| (0     << AVR32_TWIM_CWGR_DATA_OFFSET)
			| (f_prescaled << AVR32_TWIM_CWGR_STASTO_OFFSET);
	return STATUS_OK;
80004ff6:	30 08       	mov	r8,0
}
80004ff8:	10 9c       	mov	r12,r8
80004ffa:	2f bd       	sub	sp,-20
80004ffc:	e3 cd 80 80 	ldm	sp++,r7,pc

80005000 <twim_master_init>:
 * \retval ERR_INVALID_ARG  Invalid arg resulting in wrong CWGR Exponential
 * \retval ERR_IO_ERROR     NACK is received or Bus Arbitration lost
 */
status_code_t twim_master_init (volatile avr32_twim_t *twim,
		const twim_options_t *opt)
{
80005000:	eb cd 40 80 	pushm	r7,lr
80005004:	1a 97       	mov	r7,sp
80005006:	20 4d       	sub	sp,16
80005008:	ef 4c ff f4 	st.w	r7[-12],r12
8000500c:	ef 4b ff f0 	st.w	r7[-16],r11
	bool global_interrupt_enabled = cpu_irq_is_enabled ();
80005010:	e1 b8 00 00 	mfsr	r8,0x0
80005014:	10 9c       	mov	r12,r8
80005016:	f0 1f 00 37 	mcall	800050f0 <twim_master_init+0xf0>
8000501a:	18 98       	mov	r8,r12
8000501c:	ef 68 ff fb 	st.b	r7[-5],r8
	// Initialize bus transfer status
	transfer_status = TWI_SUCCESS;
80005020:	4b 58       	lddpc	r8,800050f4 <twim_master_init+0xf4>
80005022:	30 09       	mov	r9,0
80005024:	91 09       	st.w	r8[0x0],r9
	// Disable TWI interrupts
	if (global_interrupt_enabled) {
80005026:	ef 39 ff fb 	ld.ub	r9,r7[-5]
8000502a:	30 08       	mov	r8,0
8000502c:	f0 09 18 00 	cp.b	r9,r8
80005030:	c0 20       	breq	80005034 <twim_master_init+0x34>
		cpu_irq_disable ();
80005032:	d3 03       	ssrf	0x10
	}
	twim->idr = ~0UL;
80005034:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005038:	3f f9       	mov	r9,-1
8000503a:	91 99       	st.w	r8[0x24],r9
	// Enable master transfer
	twim->cr = AVR32_TWIM_CR_MEN_MASK;
8000503c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005040:	30 19       	mov	r9,1
80005042:	91 09       	st.w	r8[0x0],r9
	// Reset TWI
	twim->cr = AVR32_TWIM_CR_SWRST_MASK;
80005044:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005048:	e0 69 00 80 	mov	r9,128
8000504c:	91 09       	st.w	r8[0x0],r9
	if (global_interrupt_enabled) {
8000504e:	ef 39 ff fb 	ld.ub	r9,r7[-5]
80005052:	30 08       	mov	r8,0
80005054:	f0 09 18 00 	cp.b	r9,r8
80005058:	c0 20       	breq	8000505c <twim_master_init+0x5c>
		cpu_irq_enable ();
8000505a:	d5 03       	csrf	0x10
	}
	// Clear SR
	twim->scr = ~0UL;
8000505c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005060:	3f f9       	mov	r9,-1
80005062:	91 b9       	st.w	r8[0x2c],r9

	// register Register twim_master_interrupt_handler interrupt on level CONF_TWIM_IRQ_LEVEL
	irqflags_t flags = cpu_irq_save();
80005064:	f0 1f 00 25 	mcall	800050f8 <twim_master_init+0xf8>
80005068:	18 98       	mov	r8,r12
8000506a:	ef 48 ff fc 	st.w	r7[-4],r8
	irq_register_handler(twim_master_interrupt_handler,
8000506e:	30 1a       	mov	r10,1
80005070:	e0 6b 03 20 	mov	r11,800
80005074:	4a 2c       	lddpc	r12,800050fc <twim_master_init+0xfc>
80005076:	f0 1f 00 23 	mcall	80005100 <twim_master_init+0x100>
			CONF_TWIM_IRQ_LINE, CONF_TWIM_IRQ_LEVEL);
	cpu_irq_restore(flags);
8000507a:	ee fc ff fc 	ld.w	r12,r7[-4]
8000507e:	f0 1f 00 22 	mcall	80005104 <twim_master_init+0x104>

	if (opt->smbus) {
80005082:	ee f8 ff f0 	ld.w	r8,r7[-16]
80005086:	f1 38 00 0c 	ld.ub	r8,r8[12]
8000508a:	58 08       	cp.w	r8,0
8000508c:	c0 90       	breq	8000509e <twim_master_init+0x9e>
		// Enable SMBUS Transfer
		twim->cr = AVR32_TWIM_CR_SMEN_MASK;
8000508e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005092:	31 09       	mov	r9,16
80005094:	91 09       	st.w	r8[0x0],r9
		twim->smbtr = (uint32_t) -1;
80005096:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000509a:	3f f9       	mov	r9,-1
8000509c:	91 29       	st.w	r8[0x8],r9
	}
	// Select the speed
	if (twim_set_speed (twim, opt->speed, opt->pba_hz) ==
8000509e:	ee f8 ff f0 	ld.w	r8,r7[-16]
800050a2:	70 09       	ld.w	r9,r8[0x0]
800050a4:	ee f8 ff f0 	ld.w	r8,r7[-16]
800050a8:	70 18       	ld.w	r8,r8[0x4]
800050aa:	12 9a       	mov	r10,r9
800050ac:	10 9b       	mov	r11,r8
800050ae:	ee fc ff f4 	ld.w	r12,r7[-12]
800050b2:	f0 1f 00 16 	mcall	80005108 <twim_master_init+0x108>
800050b6:	18 98       	mov	r8,r12
800050b8:	5b 88       	cp.w	r8,-8
800050ba:	c0 31       	brne	800050c0 <twim_master_init+0xc0>
			ERR_INVALID_ARG) {
		return ERR_INVALID_ARG;
800050bc:	3f 88       	mov	r8,-8
800050be:	c1 48       	rjmp	800050e6 <twim_master_init+0xe6>
	}
	// Probe the component
	twim_probe (twim, opt->chip);
800050c0:	ee f8 ff f0 	ld.w	r8,r7[-16]
800050c4:	70 28       	ld.w	r8,r8[0x8]
800050c6:	10 9b       	mov	r11,r8
800050c8:	ee fc ff f4 	ld.w	r12,r7[-12]
800050cc:	f0 1f 00 10 	mcall	8000510c <twim_master_init+0x10c>
	//Check for nack and arbitration
	if (transfer_status == TWI_RECEIVE_NACK
			|| transfer_status == TWI_ARBITRATION_LOST) {
800050d0:	48 98       	lddpc	r8,800050f4 <twim_master_init+0xf4>
800050d2:	70 08       	ld.w	r8,r8[0x0]
		return ERR_INVALID_ARG;
	}
	// Probe the component
	twim_probe (twim, opt->chip);
	//Check for nack and arbitration
	if (transfer_status == TWI_RECEIVE_NACK
800050d4:	5b c8       	cp.w	r8,-4
800050d6:	c0 50       	breq	800050e0 <twim_master_init+0xe0>
			|| transfer_status == TWI_ARBITRATION_LOST) {
800050d8:	48 78       	lddpc	r8,800050f4 <twim_master_init+0xf4>
800050da:	70 08       	ld.w	r8,r8[0x0]
		return ERR_INVALID_ARG;
	}
	// Probe the component
	twim_probe (twim, opt->chip);
	//Check for nack and arbitration
	if (transfer_status == TWI_RECEIVE_NACK
800050dc:	5b e8       	cp.w	r8,-2
800050de:	c0 31       	brne	800050e4 <twim_master_init+0xe4>
			|| transfer_status == TWI_ARBITRATION_LOST) {
		return ERR_IO_ERROR;
800050e0:	3f f8       	mov	r8,-1
800050e2:	c0 28       	rjmp	800050e6 <twim_master_init+0xe6>
	}
	return STATUS_OK;
800050e4:	30 08       	mov	r8,0
}
800050e6:	10 9c       	mov	r12,r8
800050e8:	2f cd       	sub	sp,-16
800050ea:	e3 cd 80 80 	ldm	sp++,r7,pc
800050ee:	00 00       	add	r0,r0
800050f0:	80 00       	ld.sh	r0,r0[0x0]
800050f2:	4d ca       	lddpc	r10,80005260 <twim_read_packet+0xd4>
800050f4:	00 00       	add	r0,r0
800050f6:	07 9c       	ld.ub	r12,r3[0x1]
800050f8:	80 00       	ld.sh	r0,r0[0x0]
800050fa:	4d ac       	lddpc	r12,80005260 <twim_read_packet+0xd4>
800050fc:	80 00       	ld.sh	r0,r0[0x0]
800050fe:	4e 14       	lddpc	r4,80005280 <twim_read_packet+0xf4>
80005100:	80 00       	ld.sh	r0,r0[0x0]
80005102:	4c d8       	lddpc	r8,80005234 <twim_read_packet+0xa8>
80005104:	80 00       	ld.sh	r0,r0[0x0]
80005106:	4d ec       	lddpc	r12,8000527c <twim_read_packet+0xf0>
80005108:	80 00       	ld.sh	r0,r0[0x0]
8000510a:	4f 58       	lddpc	r8,800052dc <twim_read_packet+0x150>
8000510c:	80 00       	ld.sh	r0,r0[0x0]
8000510e:	51 54       	stdsp	sp[0x54],r4

80005110 <twim_disable_interrupt>:
 * \brief Disable the TWI interrupts and clear its status register
 *
 * \param twim         Base address of the TWIM (i.e. &AVR32_TWI).
 */
void twim_disable_interrupt (volatile avr32_twim_t *twim)
{
80005110:	eb cd 40 80 	pushm	r7,lr
80005114:	1a 97       	mov	r7,sp
80005116:	20 2d       	sub	sp,8
80005118:	ef 4c ff f8 	st.w	r7[-8],r12
	bool global_interrupt_enabled = cpu_irq_is_enabled ();
8000511c:	e1 b8 00 00 	mfsr	r8,0x0
80005120:	10 9c       	mov	r12,r8
80005122:	f0 1f 00 0c 	mcall	80005150 <twim_disable_interrupt+0x40>
80005126:	18 98       	mov	r8,r12
80005128:	ef 68 ff ff 	st.b	r7[-1],r8
	if (global_interrupt_enabled) {
8000512c:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80005130:	30 08       	mov	r8,0
80005132:	f0 09 18 00 	cp.b	r9,r8
80005136:	c0 20       	breq	8000513a <twim_disable_interrupt+0x2a>
		cpu_irq_disable ();
80005138:	d3 03       	ssrf	0x10
	}
	// Clear the interrupt flags
	twim->idr = ~0UL;
8000513a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000513e:	3f f9       	mov	r9,-1
80005140:	91 99       	st.w	r8[0x24],r9
	// Clear the status flags
	twim->scr = ~0UL;
80005142:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005146:	3f f9       	mov	r9,-1
80005148:	91 b9       	st.w	r8[0x2c],r9
}
8000514a:	2f ed       	sub	sp,-8
8000514c:	e3 cd 80 80 	ldm	sp++,r7,pc
80005150:	80 00       	ld.sh	r0,r0[0x0]
80005152:	4d ca       	lddpc	r10,800052c0 <twim_read_packet+0x134>

80005154 <twim_probe>:
 * \param chip_addr       Address of the chip which is searched for
 * \retval STATUS_OK      Slave Found
 * \retval ERR_IO_ERROR   ANAK received or Bus Arbitration lost
 */
status_code_t twim_probe (volatile avr32_twim_t *twim, uint32_t chip_addr)
{
80005154:	eb cd 40 80 	pushm	r7,lr
80005158:	1a 97       	mov	r7,sp
8000515a:	20 3d       	sub	sp,12
8000515c:	ef 4c ff f8 	st.w	r7[-8],r12
80005160:	ef 4b ff f4 	st.w	r7[-12],r11
	uint8_t data[1] = { 0 };
80005164:	30 08       	mov	r8,0
80005166:	ef 68 ff fc 	st.b	r7[-4],r8
	return (twim_write (twim,data,0,chip_addr,0));
8000516a:	ee cb 00 04 	sub	r11,r7,4
8000516e:	30 08       	mov	r8,0
80005170:	ee f9 ff f4 	ld.w	r9,r7[-12]
80005174:	30 0a       	mov	r10,0
80005176:	ee fc ff f8 	ld.w	r12,r7[-8]
8000517a:	f0 1f 00 04 	mcall	80005188 <twim_probe+0x34>
8000517e:	18 98       	mov	r8,r12
}
80005180:	10 9c       	mov	r12,r8
80005182:	2f dd       	sub	sp,-12
80005184:	e3 cd 80 80 	ldm	sp++,r7,pc
80005188:	80 00       	ld.sh	r0,r0[0x0]
8000518a:	54 44       	stdsp	sp[0x110],r4

8000518c <twim_read_packet>:
 * \retval STATUS_OK      If all bytes were read successfully
 * \retval ERR_IO_ERROR   NACK received or Bus Arbitration lost
 */
status_code_t twim_read_packet (volatile avr32_twim_t *twim,
		const twim_package_t *package)
{
8000518c:	eb cd 40 80 	pushm	r7,lr
80005190:	1a 97       	mov	r7,sp
80005192:	20 2d       	sub	sp,8
80005194:	ef 4c ff fc 	st.w	r7[-4],r12
80005198:	ef 4b ff f8 	st.w	r7[-8],r11
	// Disable master transfer
	twim->cr = AVR32_TWIM_CR_MDIS_MASK;
8000519c:	ee f8 ff fc 	ld.w	r8,r7[-4]
800051a0:	30 29       	mov	r9,2
800051a2:	91 09       	st.w	r8[0x0],r9
	// Set pointer to TWIM instance for IT
	twim_inst = twim;
800051a4:	4c f8       	lddpc	r8,800052e0 <twim_read_packet+0x154>
800051a6:	ee f9 ff fc 	ld.w	r9,r7[-4]
800051aa:	91 09       	st.w	r8[0x0],r9
	// Disable the TWIM interrupts
	twim_disable_interrupt (twim_inst);
800051ac:	4c d8       	lddpc	r8,800052e0 <twim_read_packet+0x154>
800051ae:	70 08       	ld.w	r8,r8[0x0]
800051b0:	10 9c       	mov	r12,r8
800051b2:	f0 1f 00 4d 	mcall	800052e4 <twim_read_packet+0x158>
	// get a pointer to applicative data
	twim_rx_data = package->buffer;
800051b6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800051ba:	70 28       	ld.w	r8,r8[0x8]
800051bc:	10 99       	mov	r9,r8
800051be:	4c b8       	lddpc	r8,800052e8 <twim_read_packet+0x15c>
800051c0:	91 09       	st.w	r8[0x0],r9
	// get a copy of nb bytes to read
	twim_rx_nb_bytes = package->length;
800051c2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800051c6:	70 39       	ld.w	r9,r8[0xc]
800051c8:	4c 98       	lddpc	r8,800052ec <twim_read_packet+0x160>
800051ca:	91 09       	st.w	r8[0x0],r9
	// Set next write transfer to false
	twim_next = false;
800051cc:	4c 99       	lddpc	r9,800052f0 <twim_read_packet+0x164>
800051ce:	30 08       	mov	r8,0
800051d0:	b2 88       	st.b	r9[0x0],r8
	// Initialize bus transfer status
	transfer_status = TWI_SUCCESS;
800051d2:	4c 98       	lddpc	r8,800052f4 <twim_read_packet+0x168>
800051d4:	30 09       	mov	r9,0
800051d6:	91 09       	st.w	r8[0x0],r9
	//check if internal address access is performed
	if (package->addr_length) {
800051d8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800051dc:	11 f8       	ld.ub	r8,r8[0x7]
800051de:	58 08       	cp.w	r8,0
800051e0:	c3 f0       	breq	8000525e <twim_read_packet+0xd2>
		// Reset the TWIM module to clear the THR register
		twim_inst->cr = AVR32_TWIM_CR_MEN_MASK;
800051e2:	4c 08       	lddpc	r8,800052e0 <twim_read_packet+0x154>
800051e4:	70 08       	ld.w	r8,r8[0x0]
800051e6:	30 19       	mov	r9,1
800051e8:	91 09       	st.w	r8[0x0],r9
		twim_inst->cr = AVR32_TWIM_CR_SWRST_MASK;
800051ea:	4b e8       	lddpc	r8,800052e0 <twim_read_packet+0x154>
800051ec:	70 08       	ld.w	r8,r8[0x0]
800051ee:	e0 69 00 80 	mov	r9,128
800051f2:	91 09       	st.w	r8[0x0],r9
		twim_inst->cr = AVR32_TWIM_CR_MDIS_MASK;
800051f4:	4b b8       	lddpc	r8,800052e0 <twim_read_packet+0x154>
800051f6:	70 08       	ld.w	r8,r8[0x0]
800051f8:	30 29       	mov	r9,2
800051fa:	91 09       	st.w	r8[0x0],r9
		// selection of first valid byte of the address
		twim_tx_data = package->addr;
800051fc:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005200:	2f c8       	sub	r8,-4
80005202:	10 99       	mov	r9,r8
80005204:	4b d8       	lddpc	r8,800052f8 <twim_read_packet+0x16c>
80005206:	91 09       	st.w	r8[0x0],r9
		// set the number of bytes to transmit
		twim_tx_nb_bytes = package->addr_length;
80005208:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000520c:	11 f8       	ld.ub	r8,r8[0x7]
8000520e:	10 99       	mov	r9,r8
80005210:	4b b8       	lddpc	r8,800052fc <twim_read_packet+0x170>
80005212:	91 09       	st.w	r8[0x0],r9
		// mask NACK, TXRDY and RXRDY interrupts
		twim_it_mask = AVR32_TWIM_IER_STD_MASK |
80005214:	4b b8       	lddpc	r8,80005300 <twim_read_packet+0x174>
80005216:	e0 69 07 03 	mov	r9,1795
8000521a:	91 09       	st.w	r8[0x0],r9
				AVR32_TWIM_IER_TXRDY_MASK | AVR32_TWIM_IER_RXRDY_MASK;
		// Set the command register to initiate the transfer
		twim_inst->cmdr = (package->chip << AVR32_TWIM_CMDR_SADR_OFFSET)
8000521c:	4b 18       	lddpc	r8,800052e0 <twim_read_packet+0x154>
8000521e:	70 08       	ld.w	r8,r8[0x0]
				| (package->addr_length << AVR32_TWIM_CMDR_NBYTES_OFFSET)
				| (AVR32_TWIM_CMDR_VALID_MASK)
80005220:	ee f9 ff f8 	ld.w	r9,r7[-8]
80005224:	72 09       	ld.w	r9,r9[0x0]
		twim_tx_nb_bytes = package->addr_length;
		// mask NACK, TXRDY and RXRDY interrupts
		twim_it_mask = AVR32_TWIM_IER_STD_MASK |
				AVR32_TWIM_IER_TXRDY_MASK | AVR32_TWIM_IER_RXRDY_MASK;
		// Set the command register to initiate the transfer
		twim_inst->cmdr = (package->chip << AVR32_TWIM_CMDR_SADR_OFFSET)
80005226:	f2 0a 15 01 	lsl	r10,r9,0x1
				| (package->addr_length << AVR32_TWIM_CMDR_NBYTES_OFFSET)
8000522a:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000522e:	13 f9       	ld.ub	r9,r9[0x7]
80005230:	b1 69       	lsl	r9,0x10
				| (AVR32_TWIM_CMDR_VALID_MASK)
80005232:	f5 e9 10 09 	or	r9,r10,r9
		twim_tx_nb_bytes = package->addr_length;
		// mask NACK, TXRDY and RXRDY interrupts
		twim_it_mask = AVR32_TWIM_IER_STD_MASK |
				AVR32_TWIM_IER_TXRDY_MASK | AVR32_TWIM_IER_RXRDY_MASK;
		// Set the command register to initiate the transfer
		twim_inst->cmdr = (package->chip << AVR32_TWIM_CMDR_SADR_OFFSET)
80005236:	e8 19 a0 00 	orl	r9,0xa000
8000523a:	91 39       	st.w	r8[0xc],r9
				| (package->addr_length << AVR32_TWIM_CMDR_NBYTES_OFFSET)
				| (AVR32_TWIM_CMDR_VALID_MASK)
				| (AVR32_TWIM_CMDR_START_MASK)
				| (0 << AVR32_TWIM_CMDR_READ_OFFSET);
		// set the next command register to followup with the previous command
		twim_inst->ncmdr = ((package->chip) << AVR32_TWIM_CMDR_SADR_OFFSET)
8000523c:	4a 98       	lddpc	r8,800052e0 <twim_read_packet+0x154>
8000523e:	70 08       	ld.w	r8,r8[0x0]
80005240:	ee f9 ff f8 	ld.w	r9,r7[-8]
80005244:	72 09       	ld.w	r9,r9[0x0]
80005246:	f2 0a 15 01 	lsl	r10,r9,0x1
				| (package->length << AVR32_TWIM_CMDR_NBYTES_OFFSET)
				| (AVR32_TWIM_CMDR_VALID_MASK)
8000524a:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000524e:	72 39       	ld.w	r9,r9[0xc]
				| (AVR32_TWIM_CMDR_VALID_MASK)
				| (AVR32_TWIM_CMDR_START_MASK)
				| (0 << AVR32_TWIM_CMDR_READ_OFFSET);
		// set the next command register to followup with the previous command
		twim_inst->ncmdr = ((package->chip) << AVR32_TWIM_CMDR_SADR_OFFSET)
				| (package->length << AVR32_TWIM_CMDR_NBYTES_OFFSET)
80005250:	b1 69       	lsl	r9,0x10
				| (AVR32_TWIM_CMDR_VALID_MASK)
80005252:	f5 e9 10 09 	or	r9,r10,r9
				| (package->addr_length << AVR32_TWIM_CMDR_NBYTES_OFFSET)
				| (AVR32_TWIM_CMDR_VALID_MASK)
				| (AVR32_TWIM_CMDR_START_MASK)
				| (0 << AVR32_TWIM_CMDR_READ_OFFSET);
		// set the next command register to followup with the previous command
		twim_inst->ncmdr = ((package->chip) << AVR32_TWIM_CMDR_SADR_OFFSET)
80005256:	e8 19 e0 01 	orl	r9,0xe001
8000525a:	91 49       	st.w	r8[0x10],r9
8000525c:	c1 88       	rjmp	8000528c <twim_read_packet+0x100>
				| (AVR32_TWIM_CMDR_VALID_MASK)
				| (AVR32_TWIM_CMDR_START_MASK)
				| (AVR32_TWIM_CMDR_STOP_MASK)
				| (AVR32_TWIM_CMDR_READ_MASK);
	} else {
		twim_tx_nb_bytes = 0;
8000525e:	4a 88       	lddpc	r8,800052fc <twim_read_packet+0x170>
80005260:	30 09       	mov	r9,0
80005262:	91 09       	st.w	r8[0x0],r9
		// mask NACK and RXRDY interrupts
		twim_it_mask = AVR32_TWIM_IER_STD_MASK | AVR32_TWIM_IER_RXRDY_MASK;
80005264:	4a 78       	lddpc	r8,80005300 <twim_read_packet+0x174>
80005266:	e0 69 07 01 	mov	r9,1793
8000526a:	91 09       	st.w	r8[0x0],r9
		// Set the command register to initiate the transfer
		twim_inst->cmdr = (package->chip << AVR32_TWIM_CMDR_SADR_OFFSET)
8000526c:	49 d8       	lddpc	r8,800052e0 <twim_read_packet+0x154>
8000526e:	70 08       	ld.w	r8,r8[0x0]
				| (package->length << AVR32_TWIM_CMDR_NBYTES_OFFSET)
				| (AVR32_TWIM_CMDR_VALID_MASK)
80005270:	ee f9 ff f8 	ld.w	r9,r7[-8]
80005274:	72 09       	ld.w	r9,r9[0x0]
	} else {
		twim_tx_nb_bytes = 0;
		// mask NACK and RXRDY interrupts
		twim_it_mask = AVR32_TWIM_IER_STD_MASK | AVR32_TWIM_IER_RXRDY_MASK;
		// Set the command register to initiate the transfer
		twim_inst->cmdr = (package->chip << AVR32_TWIM_CMDR_SADR_OFFSET)
80005276:	f2 0a 15 01 	lsl	r10,r9,0x1
				| (package->length << AVR32_TWIM_CMDR_NBYTES_OFFSET)
				| (AVR32_TWIM_CMDR_VALID_MASK)
8000527a:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000527e:	72 39       	ld.w	r9,r9[0xc]
		twim_tx_nb_bytes = 0;
		// mask NACK and RXRDY interrupts
		twim_it_mask = AVR32_TWIM_IER_STD_MASK | AVR32_TWIM_IER_RXRDY_MASK;
		// Set the command register to initiate the transfer
		twim_inst->cmdr = (package->chip << AVR32_TWIM_CMDR_SADR_OFFSET)
				| (package->length << AVR32_TWIM_CMDR_NBYTES_OFFSET)
80005280:	b1 69       	lsl	r9,0x10
				| (AVR32_TWIM_CMDR_VALID_MASK)
80005282:	f5 e9 10 09 	or	r9,r10,r9
	} else {
		twim_tx_nb_bytes = 0;
		// mask NACK and RXRDY interrupts
		twim_it_mask = AVR32_TWIM_IER_STD_MASK | AVR32_TWIM_IER_RXRDY_MASK;
		// Set the command register to initiate the transfer
		twim_inst->cmdr = (package->chip << AVR32_TWIM_CMDR_SADR_OFFSET)
80005286:	e8 19 e0 01 	orl	r9,0xe001
8000528a:	91 39       	st.w	r8[0xc],r9
				| (AVR32_TWIM_CMDR_START_MASK)
				| (AVR32_TWIM_CMDR_STOP_MASK)
				| (AVR32_TWIM_CMDR_READ_MASK);
	}
	// update IMR through IER
	twim_inst->ier = twim_it_mask;
8000528c:	49 58       	lddpc	r8,800052e0 <twim_read_packet+0x154>
8000528e:	70 08       	ld.w	r8,r8[0x0]
80005290:	49 c9       	lddpc	r9,80005300 <twim_read_packet+0x174>
80005292:	72 09       	ld.w	r9,r9[0x0]
80005294:	91 89       	st.w	r8[0x20],r9
	// Enable master transfer
	twim->cr = AVR32_TWIM_CR_MEN_MASK;
80005296:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000529a:	30 19       	mov	r9,1
8000529c:	91 09       	st.w	r8[0x0],r9
	// Enable all interrupts
	cpu_irq_enable ();
8000529e:	d5 03       	csrf	0x10
	// get data
	while (!(transfer_status) && !(twim_status ())) {
800052a0:	c0 38       	rjmp	800052a6 <twim_read_packet+0x11a>
		cpu_relax();
800052a2:	fe cf ff fc 	sub	pc,pc,-4
	// Enable master transfer
	twim->cr = AVR32_TWIM_CR_MEN_MASK;
	// Enable all interrupts
	cpu_irq_enable ();
	// get data
	while (!(transfer_status) && !(twim_status ())) {
800052a6:	49 48       	lddpc	r8,800052f4 <twim_read_packet+0x168>
800052a8:	70 08       	ld.w	r8,r8[0x0]
800052aa:	58 08       	cp.w	r8,0
800052ac:	c0 61       	brne	800052b8 <twim_read_packet+0x12c>
800052ae:	f0 1f 00 16 	mcall	80005304 <twim_read_packet+0x178>
800052b2:	18 98       	mov	r8,r12
800052b4:	58 08       	cp.w	r8,0
800052b6:	cf 60       	breq	800052a2 <twim_read_packet+0x116>
		cpu_relax();
	}
	// Disable master transfer
	twim->cr = AVR32_TWIM_CR_MDIS_MASK;
800052b8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800052bc:	30 29       	mov	r9,2
800052be:	91 09       	st.w	r8[0x0],r9
	if (transfer_status == TWI_RECEIVE_NACK
			|| transfer_status == TWI_ARBITRATION_LOST) {
800052c0:	48 d8       	lddpc	r8,800052f4 <twim_read_packet+0x168>
800052c2:	70 08       	ld.w	r8,r8[0x0]
	while (!(transfer_status) && !(twim_status ())) {
		cpu_relax();
	}
	// Disable master transfer
	twim->cr = AVR32_TWIM_CR_MDIS_MASK;
	if (transfer_status == TWI_RECEIVE_NACK
800052c4:	5b c8       	cp.w	r8,-4
800052c6:	c0 50       	breq	800052d0 <twim_read_packet+0x144>
			|| transfer_status == TWI_ARBITRATION_LOST) {
800052c8:	48 b8       	lddpc	r8,800052f4 <twim_read_packet+0x168>
800052ca:	70 08       	ld.w	r8,r8[0x0]
	while (!(transfer_status) && !(twim_status ())) {
		cpu_relax();
	}
	// Disable master transfer
	twim->cr = AVR32_TWIM_CR_MDIS_MASK;
	if (transfer_status == TWI_RECEIVE_NACK
800052cc:	5b e8       	cp.w	r8,-2
800052ce:	c0 31       	brne	800052d4 <twim_read_packet+0x148>
			|| transfer_status == TWI_ARBITRATION_LOST) {
		return ERR_IO_ERROR;
800052d0:	3f f8       	mov	r8,-1
800052d2:	c0 28       	rjmp	800052d6 <twim_read_packet+0x14a>
	}
	return STATUS_OK;
800052d4:	30 08       	mov	r8,0
}
800052d6:	10 9c       	mov	r12,r8
800052d8:	2f ed       	sub	sp,-8
800052da:	e3 cd 80 80 	ldm	sp++,r7,pc
800052de:	00 00       	add	r0,r0
800052e0:	00 00       	add	r0,r0
800052e2:	07 90       	ld.ub	r0,r3[0x1]
800052e4:	80 00       	ld.sh	r0,r0[0x0]
800052e6:	51 10       	stdsp	sp[0x44],r0
800052e8:	00 00       	add	r0,r0
800052ea:	07 98       	ld.ub	r8,r3[0x1]
800052ec:	00 00       	add	r0,r0
800052ee:	07 a4       	ld.ub	r4,r3[0x2]
800052f0:	00 00       	add	r0,r0
800052f2:	07 b0       	ld.ub	r0,r3[0x3]
800052f4:	00 00       	add	r0,r0
800052f6:	07 9c       	ld.ub	r12,r3[0x1]
800052f8:	00 00       	add	r0,r0
800052fa:	07 94       	ld.ub	r4,r3[0x1]
800052fc:	00 00       	add	r0,r0
800052fe:	07 a0       	ld.ub	r0,r3[0x2]
80005300:	00 00       	add	r0,r0
80005302:	07 a8       	ld.ub	r8,r3[0x2]
80005304:	80 00       	ld.sh	r0,r0[0x0]
80005306:	55 48       	stdsp	sp[0x150],r8

80005308 <twim_write_packet>:
 * \retval STATUS_OK      If all bytes were send successfully
 * \retval ERR_IO_ERROR   NACK received or Bus Arbitration lost
 */
status_code_t twim_write_packet (volatile avr32_twim_t *twim,
		const twim_package_t *package)
{
80005308:	eb cd 40 80 	pushm	r7,lr
8000530c:	1a 97       	mov	r7,sp
8000530e:	20 2d       	sub	sp,8
80005310:	ef 4c ff fc 	st.w	r7[-4],r12
80005314:	ef 4b ff f8 	st.w	r7[-8],r11
	// Reset the TWIM module to clear the THR register
	twim->cr = AVR32_TWIM_CR_MEN_MASK;
80005318:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000531c:	30 19       	mov	r9,1
8000531e:	91 09       	st.w	r8[0x0],r9
	twim->cr = AVR32_TWIM_CR_SWRST_MASK;
80005320:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005324:	e0 69 00 80 	mov	r9,128
80005328:	91 09       	st.w	r8[0x0],r9
	twim->cr = AVR32_TWIM_CR_MDIS_MASK;
8000532a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000532e:	30 29       	mov	r9,2
80005330:	91 09       	st.w	r8[0x0],r9
	// Set pointer to TWIM instance for IT
	twim_inst = twim;
80005332:	4b c8       	lddpc	r8,80005420 <twim_write_packet+0x118>
80005334:	ee f9 ff fc 	ld.w	r9,r7[-4]
80005338:	91 09       	st.w	r8[0x0],r9
	// Disable the TWIM interrupts
	twim_disable_interrupt (twim_inst);
8000533a:	4b a8       	lddpc	r8,80005420 <twim_write_packet+0x118>
8000533c:	70 08       	ld.w	r8,r8[0x0]
8000533e:	10 9c       	mov	r12,r8
80005340:	f0 1f 00 39 	mcall	80005424 <twim_write_packet+0x11c>
	// Initialize bus transfer status
	transfer_status = TWI_SUCCESS;
80005344:	4b 98       	lddpc	r8,80005428 <twim_write_packet+0x120>
80005346:	30 09       	mov	r9,0
80005348:	91 09       	st.w	r8[0x0],r9
	// mask NACK and TXRDY interrupts
	twim_it_mask = AVR32_TWIM_IER_STD_MASK | AVR32_TWIM_IER_TXRDY_MASK;
8000534a:	4b 98       	lddpc	r8,8000542c <twim_write_packet+0x124>
8000534c:	e0 69 07 02 	mov	r9,1794
80005350:	91 09       	st.w	r8[0x0],r9
	// Set next transfer to false
	twim_next = false;
80005352:	4b 89       	lddpc	r9,80005430 <twim_write_packet+0x128>
80005354:	30 08       	mov	r8,0
80005356:	b2 88       	st.b	r9[0x0],r8
	//check if internal address access is performed
	if (package->addr_length) {
80005358:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000535c:	11 f8       	ld.ub	r8,r8[0x7]
8000535e:	58 08       	cp.w	r8,0
80005360:	c1 50       	breq	8000538a <twim_write_packet+0x82>
		// selection of first valid byte of the address
		twim_tx_data = package->addr;
80005362:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005366:	2f c8       	sub	r8,-4
80005368:	10 99       	mov	r9,r8
8000536a:	4b 38       	lddpc	r8,80005434 <twim_write_packet+0x12c>
8000536c:	91 09       	st.w	r8[0x0],r9
		// set the number of bytes to transmit
		twim_tx_nb_bytes = package->addr_length;
8000536e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005372:	11 f8       	ld.ub	r8,r8[0x7]
80005374:	10 99       	mov	r9,r8
80005376:	4b 18       	lddpc	r8,80005438 <twim_write_packet+0x130>
80005378:	91 09       	st.w	r8[0x0],r9
		// set next transfer to true
		twim_next = true;
8000537a:	4a e9       	lddpc	r9,80005430 <twim_write_packet+0x128>
8000537c:	30 18       	mov	r8,1
8000537e:	b2 88       	st.b	r9[0x0],r8
		// Set the number of bytes & address for next transfer
		twim_package = package;
80005380:	ee f9 ff f8 	ld.w	r9,r7[-8]
80005384:	4a e8       	lddpc	r8,8000543c <twim_write_packet+0x134>
80005386:	91 09       	st.w	r8[0x0],r9
80005388:	c0 c8       	rjmp	800053a0 <twim_write_packet+0x98>
	} else {
	// get a pointer to applicative data
	twim_tx_data = package->buffer;
8000538a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000538e:	70 28       	ld.w	r8,r8[0x8]
80005390:	10 99       	mov	r9,r8
80005392:	4a 98       	lddpc	r8,80005434 <twim_write_packet+0x12c>
80005394:	91 09       	st.w	r8[0x0],r9
	// get a copy of nb bytes to write
	twim_tx_nb_bytes = package->length;
80005396:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000539a:	70 39       	ld.w	r9,r8[0xc]
8000539c:	4a 78       	lddpc	r8,80005438 <twim_write_packet+0x130>
8000539e:	91 09       	st.w	r8[0x0],r9
	}
	// initiate the transfer to send the data
	twim->cmdr = (package->chip << AVR32_TWIM_CMDR_SADR_OFFSET)
			| ((package->length + package->addr_length)
					<< AVR32_TWIM_CMDR_NBYTES_OFFSET)
			| (AVR32_TWIM_CMDR_VALID_MASK)
800053a0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800053a4:	70 08       	ld.w	r8,r8[0x0]
	twim_tx_data = package->buffer;
	// get a copy of nb bytes to write
	twim_tx_nb_bytes = package->length;
	}
	// initiate the transfer to send the data
	twim->cmdr = (package->chip << AVR32_TWIM_CMDR_SADR_OFFSET)
800053a6:	f0 09 15 01 	lsl	r9,r8,0x1
			| ((package->length + package->addr_length)
800053aa:	ee f8 ff f8 	ld.w	r8,r7[-8]
800053ae:	70 3a       	ld.w	r10,r8[0xc]
800053b0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800053b4:	11 f8       	ld.ub	r8,r8[0x7]
800053b6:	f4 08 00 08 	add	r8,r10,r8
800053ba:	b1 68       	lsl	r8,0x10
					<< AVR32_TWIM_CMDR_NBYTES_OFFSET)
			| (AVR32_TWIM_CMDR_VALID_MASK)
800053bc:	f3 e8 10 08 	or	r8,r9,r8
	twim_tx_data = package->buffer;
	// get a copy of nb bytes to write
	twim_tx_nb_bytes = package->length;
	}
	// initiate the transfer to send the data
	twim->cmdr = (package->chip << AVR32_TWIM_CMDR_SADR_OFFSET)
800053c0:	10 99       	mov	r9,r8
800053c2:	e8 19 e0 00 	orl	r9,0xe000
800053c6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800053ca:	91 39       	st.w	r8[0xc],r9
			| (AVR32_TWIM_CMDR_VALID_MASK)
			| (AVR32_TWIM_CMDR_START_MASK)
			| (AVR32_TWIM_CMDR_STOP_MASK)
			| (0 << AVR32_TWIM_CMDR_READ_OFFSET);
	// update IMR through IER
	twim_inst->ier = twim_it_mask;
800053cc:	49 58       	lddpc	r8,80005420 <twim_write_packet+0x118>
800053ce:	70 08       	ld.w	r8,r8[0x0]
800053d0:	49 79       	lddpc	r9,8000542c <twim_write_packet+0x124>
800053d2:	72 09       	ld.w	r9,r9[0x0]
800053d4:	91 89       	st.w	r8[0x20],r9
	// Enable master transfer
	twim_inst->cr = AVR32_TWIM_CR_MEN_MASK;
800053d6:	49 38       	lddpc	r8,80005420 <twim_write_packet+0x118>
800053d8:	70 08       	ld.w	r8,r8[0x0]
800053da:	30 19       	mov	r9,1
800053dc:	91 09       	st.w	r8[0x0],r9
	// Enable all interrupts
	cpu_irq_enable ();
800053de:	d5 03       	csrf	0x10
	// send data
	while (!(transfer_status) && !(twim_status ())) {
800053e0:	c0 38       	rjmp	800053e6 <twim_write_packet+0xde>
		cpu_relax();
800053e2:	fe cf ff fc 	sub	pc,pc,-4
	// Enable master transfer
	twim_inst->cr = AVR32_TWIM_CR_MEN_MASK;
	// Enable all interrupts
	cpu_irq_enable ();
	// send data
	while (!(transfer_status) && !(twim_status ())) {
800053e6:	49 18       	lddpc	r8,80005428 <twim_write_packet+0x120>
800053e8:	70 08       	ld.w	r8,r8[0x0]
800053ea:	58 08       	cp.w	r8,0
800053ec:	c0 61       	brne	800053f8 <twim_write_packet+0xf0>
800053ee:	f0 1f 00 15 	mcall	80005440 <twim_write_packet+0x138>
800053f2:	18 98       	mov	r8,r12
800053f4:	58 08       	cp.w	r8,0
800053f6:	cf 60       	breq	800053e2 <twim_write_packet+0xda>
		cpu_relax();
	}
#if AVR32_TWIM_H_VERSION > 101	//Removed in twim100 module due to IC bug
	// Disable master transfer
	twim->cr = AVR32_TWIM_CR_MDIS_MASK;
800053f8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800053fc:	30 29       	mov	r9,2
800053fe:	91 09       	st.w	r8[0x0],r9
#endif
	// Check for nack
	if (transfer_status == TWI_RECEIVE_NACK
			|| transfer_status == TWI_ARBITRATION_LOST) {
80005400:	48 a8       	lddpc	r8,80005428 <twim_write_packet+0x120>
80005402:	70 08       	ld.w	r8,r8[0x0]
#if AVR32_TWIM_H_VERSION > 101	//Removed in twim100 module due to IC bug
	// Disable master transfer
	twim->cr = AVR32_TWIM_CR_MDIS_MASK;
#endif
	// Check for nack
	if (transfer_status == TWI_RECEIVE_NACK
80005404:	5b c8       	cp.w	r8,-4
80005406:	c0 50       	breq	80005410 <twim_write_packet+0x108>
			|| transfer_status == TWI_ARBITRATION_LOST) {
80005408:	48 88       	lddpc	r8,80005428 <twim_write_packet+0x120>
8000540a:	70 08       	ld.w	r8,r8[0x0]
#if AVR32_TWIM_H_VERSION > 101	//Removed in twim100 module due to IC bug
	// Disable master transfer
	twim->cr = AVR32_TWIM_CR_MDIS_MASK;
#endif
	// Check for nack
	if (transfer_status == TWI_RECEIVE_NACK
8000540c:	5b e8       	cp.w	r8,-2
8000540e:	c0 31       	brne	80005414 <twim_write_packet+0x10c>
			|| transfer_status == TWI_ARBITRATION_LOST) {
		return ERR_IO_ERROR;
80005410:	3f f8       	mov	r8,-1
80005412:	c0 28       	rjmp	80005416 <twim_write_packet+0x10e>
	}
	return STATUS_OK;
80005414:	30 08       	mov	r8,0
}
80005416:	10 9c       	mov	r12,r8
80005418:	2f ed       	sub	sp,-8
8000541a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000541e:	00 00       	add	r0,r0
80005420:	00 00       	add	r0,r0
80005422:	07 90       	ld.ub	r0,r3[0x1]
80005424:	80 00       	ld.sh	r0,r0[0x0]
80005426:	51 10       	stdsp	sp[0x44],r0
80005428:	00 00       	add	r0,r0
8000542a:	07 9c       	ld.ub	r12,r3[0x1]
8000542c:	00 00       	add	r0,r0
8000542e:	07 a8       	ld.ub	r8,r3[0x2]
80005430:	00 00       	add	r0,r0
80005432:	07 b0       	ld.ub	r0,r3[0x3]
80005434:	00 00       	add	r0,r0
80005436:	07 94       	ld.ub	r4,r3[0x1]
80005438:	00 00       	add	r0,r0
8000543a:	07 a0       	ld.ub	r0,r3[0x2]
8000543c:	00 00       	add	r0,r0
8000543e:	07 ac       	ld.ub	r12,r3[0x2]
80005440:	80 00       	ld.sh	r0,r0[0x0]
80005442:	55 48       	stdsp	sp[0x150],r8

80005444 <twim_write>:
 * \retval STATUS_OK      If all bytes were send successfully
 * \retval ERR_IO_ERROR   NACK received or Bus Arbitration lost
 */
status_code_t twim_write (volatile avr32_twim_t *twim, uint8_t const *buffer,
		uint32_t nbytes, uint32_t saddr, bool tenbit)
{
80005444:	eb cd 40 80 	pushm	r7,lr
80005448:	1a 97       	mov	r7,sp
8000544a:	20 5d       	sub	sp,20
8000544c:	ef 4c ff fc 	st.w	r7[-4],r12
80005450:	ef 4b ff f8 	st.w	r7[-8],r11
80005454:	ef 4a ff f4 	st.w	r7[-12],r10
80005458:	ef 49 ff f0 	st.w	r7[-16],r9
8000545c:	ef 68 ff ec 	st.b	r7[-20],r8
	// Reset the TWIM module to clear the THR register
	twim->cr = AVR32_TWIM_CR_MEN_MASK;
80005460:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005464:	30 19       	mov	r9,1
80005466:	91 09       	st.w	r8[0x0],r9
	twim->cr = AVR32_TWIM_CR_SWRST_MASK;
80005468:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000546c:	e0 69 00 80 	mov	r9,128
80005470:	91 09       	st.w	r8[0x0],r9
	twim->cr = AVR32_TWIM_CR_MDIS_MASK;
80005472:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005476:	30 29       	mov	r9,2
80005478:	91 09       	st.w	r8[0x0],r9
	// Set pointer to TWIM instance for IT
	twim_inst = twim;
8000547a:	4a c8       	lddpc	r8,80005528 <twim_write+0xe4>
8000547c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80005480:	91 09       	st.w	r8[0x0],r9
	// Disable the TWIM interrupts
	twim_disable_interrupt (twim_inst);
80005482:	4a a8       	lddpc	r8,80005528 <twim_write+0xe4>
80005484:	70 08       	ld.w	r8,r8[0x0]
80005486:	10 9c       	mov	r12,r8
80005488:	f0 1f 00 29 	mcall	8000552c <twim_write+0xe8>
	// get a pointer to applicative data
	twim_tx_data = buffer;
8000548c:	ee f9 ff f8 	ld.w	r9,r7[-8]
80005490:	4a 88       	lddpc	r8,80005530 <twim_write+0xec>
80005492:	91 09       	st.w	r8[0x0],r9
	// set the number of bytes to transmit
	twim_tx_nb_bytes = nbytes;
80005494:	4a 88       	lddpc	r8,80005534 <twim_write+0xf0>
80005496:	ee f9 ff f4 	ld.w	r9,r7[-12]
8000549a:	91 09       	st.w	r8[0x0],r9
	// Set next transfer to false
	twim_next = false;
8000549c:	4a 79       	lddpc	r9,80005538 <twim_write+0xf4>
8000549e:	30 08       	mov	r8,0
800054a0:	b2 88       	st.b	r9[0x0],r8
	// Initialize bus transfer status
	transfer_status = TWI_SUCCESS;
800054a2:	4a 78       	lddpc	r8,8000553c <twim_write+0xf8>
800054a4:	30 09       	mov	r9,0
800054a6:	91 09       	st.w	r8[0x0],r9
	// set the command to start the transfer
	twim_inst->cmdr = (saddr << AVR32_TWIM_CMDR_SADR_OFFSET)
800054a8:	4a 08       	lddpc	r8,80005528 <twim_write+0xe4>
800054aa:	70 08       	ld.w	r8,r8[0x0]
800054ac:	ee f9 ff f0 	ld.w	r9,r7[-16]
800054b0:	f2 0a 15 01 	lsl	r10,r9,0x1
			| (nbytes << AVR32_TWIM_CMDR_NBYTES_OFFSET)
800054b4:	ee f9 ff f4 	ld.w	r9,r7[-12]
800054b8:	b1 69       	lsl	r9,0x10
			| (AVR32_TWIM_CMDR_VALID_MASK)
800054ba:	12 4a       	or	r10,r9
			| (AVR32_TWIM_CMDR_START_MASK)
			| (AVR32_TWIM_CMDR_STOP_MASK)
			| ((tenbit ? 1 : 0) << AVR32_TWIM_CMDR_TENBIT_OFFSET)
800054bc:	ef 39 ff ec 	ld.ub	r9,r7[-20]
800054c0:	ab 79       	lsl	r9,0xb
	// Set next transfer to false
	twim_next = false;
	// Initialize bus transfer status
	transfer_status = TWI_SUCCESS;
	// set the command to start the transfer
	twim_inst->cmdr = (saddr << AVR32_TWIM_CMDR_SADR_OFFSET)
800054c2:	f5 e9 10 09 	or	r9,r10,r9
800054c6:	e8 19 e0 00 	orl	r9,0xe000
800054ca:	91 39       	st.w	r8[0xc],r9
			| (AVR32_TWIM_CMDR_START_MASK)
			| (AVR32_TWIM_CMDR_STOP_MASK)
			| ((tenbit ? 1 : 0) << AVR32_TWIM_CMDR_TENBIT_OFFSET)
			| (0 << AVR32_TWIM_CMDR_READ_OFFSET);
	// mask NACK and TXRDY interrupts
	twim_it_mask = AVR32_TWIM_IER_NAK_MASK | AVR32_TWIM_IER_TXRDY_MASK;
800054cc:	49 d8       	lddpc	r8,80005540 <twim_write+0xfc>
800054ce:	e0 69 03 02 	mov	r9,770
800054d2:	91 09       	st.w	r8[0x0],r9
	// update IMR through IER
	twim_inst->ier = twim_it_mask;
800054d4:	49 58       	lddpc	r8,80005528 <twim_write+0xe4>
800054d6:	70 08       	ld.w	r8,r8[0x0]
800054d8:	49 a9       	lddpc	r9,80005540 <twim_write+0xfc>
800054da:	72 09       	ld.w	r9,r9[0x0]
800054dc:	91 89       	st.w	r8[0x20],r9
	// Enable master transfer
	twim_inst->cr = AVR32_TWIM_CR_MEN_MASK;
800054de:	49 38       	lddpc	r8,80005528 <twim_write+0xe4>
800054e0:	70 08       	ld.w	r8,r8[0x0]
800054e2:	30 19       	mov	r9,1
800054e4:	91 09       	st.w	r8[0x0],r9
	// Enable all interrupts
	cpu_irq_enable ();
800054e6:	d5 03       	csrf	0x10
	// send data
	while (!(transfer_status) && !(twim_status ())) {
800054e8:	c0 38       	rjmp	800054ee <twim_write+0xaa>
		cpu_relax();
800054ea:	fe cf ff fc 	sub	pc,pc,-4
	// Enable master transfer
	twim_inst->cr = AVR32_TWIM_CR_MEN_MASK;
	// Enable all interrupts
	cpu_irq_enable ();
	// send data
	while (!(transfer_status) && !(twim_status ())) {
800054ee:	49 48       	lddpc	r8,8000553c <twim_write+0xf8>
800054f0:	70 08       	ld.w	r8,r8[0x0]
800054f2:	58 08       	cp.w	r8,0
800054f4:	c0 61       	brne	80005500 <twim_write+0xbc>
800054f6:	f0 1f 00 14 	mcall	80005544 <twim_write+0x100>
800054fa:	18 98       	mov	r8,r12
800054fc:	58 08       	cp.w	r8,0
800054fe:	cf 60       	breq	800054ea <twim_write+0xa6>
		cpu_relax();
	}
#if AVR32_TWIM_H_VERSION > 101	// Removed in twim100 module due to IC bug
	// Disable master transfer
	twim->cr = AVR32_TWIM_CR_MDIS_MASK;
80005500:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005504:	30 29       	mov	r9,2
80005506:	91 09       	st.w	r8[0x0],r9
#endif
	if (transfer_status == TWI_RECEIVE_NACK
			|| transfer_status == TWI_ARBITRATION_LOST) {
80005508:	48 d8       	lddpc	r8,8000553c <twim_write+0xf8>
8000550a:	70 08       	ld.w	r8,r8[0x0]
	}
#if AVR32_TWIM_H_VERSION > 101	// Removed in twim100 module due to IC bug
	// Disable master transfer
	twim->cr = AVR32_TWIM_CR_MDIS_MASK;
#endif
	if (transfer_status == TWI_RECEIVE_NACK
8000550c:	5b c8       	cp.w	r8,-4
8000550e:	c0 50       	breq	80005518 <twim_write+0xd4>
			|| transfer_status == TWI_ARBITRATION_LOST) {
80005510:	48 b8       	lddpc	r8,8000553c <twim_write+0xf8>
80005512:	70 08       	ld.w	r8,r8[0x0]
	}
#if AVR32_TWIM_H_VERSION > 101	// Removed in twim100 module due to IC bug
	// Disable master transfer
	twim->cr = AVR32_TWIM_CR_MDIS_MASK;
#endif
	if (transfer_status == TWI_RECEIVE_NACK
80005514:	5b e8       	cp.w	r8,-2
80005516:	c0 31       	brne	8000551c <twim_write+0xd8>
			|| transfer_status == TWI_ARBITRATION_LOST) {
		return ERR_IO_ERROR;
80005518:	3f f8       	mov	r8,-1
8000551a:	c0 28       	rjmp	8000551e <twim_write+0xda>
	}
	return STATUS_OK;
8000551c:	30 08       	mov	r8,0
}
8000551e:	10 9c       	mov	r12,r8
80005520:	2f bd       	sub	sp,-20
80005522:	e3 cd 80 80 	ldm	sp++,r7,pc
80005526:	00 00       	add	r0,r0
80005528:	00 00       	add	r0,r0
8000552a:	07 90       	ld.ub	r0,r3[0x1]
8000552c:	80 00       	ld.sh	r0,r0[0x0]
8000552e:	51 10       	stdsp	sp[0x44],r0
80005530:	00 00       	add	r0,r0
80005532:	07 94       	ld.ub	r4,r3[0x1]
80005534:	00 00       	add	r0,r0
80005536:	07 a0       	ld.ub	r0,r3[0x2]
80005538:	00 00       	add	r0,r0
8000553a:	07 b0       	ld.ub	r0,r3[0x3]
8000553c:	00 00       	add	r0,r0
8000553e:	07 9c       	ld.ub	r12,r3[0x1]
80005540:	00 00       	add	r0,r0
80005542:	07 a8       	ld.ub	r8,r3[0x2]
80005544:	80 00       	ld.sh	r0,r0[0x0]
80005546:	55 48       	stdsp	sp[0x150],r8

80005548 <twim_status>:

/**
 * \brief Information about the current status of the TWI Bus
 */
uint8_t twim_status ( void )
{
80005548:	eb cd 40 80 	pushm	r7,lr
8000554c:	1a 97       	mov	r7,sp
8000554e:	20 1d       	sub	sp,4
	uint32_t status = twim_inst->sr;
80005550:	48 98       	lddpc	r8,80005574 <twim_status+0x2c>
80005552:	70 08       	ld.w	r8,r8[0x0]
80005554:	70 78       	ld.w	r8,r8[0x1c]
80005556:	ef 48 ff fc 	st.w	r7[-4],r8
	if ((status & AVR32_TWIM_SR_IDLE_MASK)
8000555a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000555e:	e2 18 00 10 	andl	r8,0x10,COH
80005562:	c0 30       	breq	80005568 <twim_status+0x20>
#if AVR32_TWIM_H_VERSION > 101 ||(status&AVR32_TWIM_SR_BUSFREE_MASK)
#endif
		) {
		return 1;
80005564:	30 18       	mov	r8,1
80005566:	c0 28       	rjmp	8000556a <twim_status+0x22>
	} else {
		return 0;
80005568:	30 08       	mov	r8,0
	}
}
8000556a:	10 9c       	mov	r12,r8
8000556c:	2f fd       	sub	sp,-4
8000556e:	e3 cd 80 80 	ldm	sp++,r7,pc
80005572:	00 00       	add	r0,r0
80005574:	00 00       	add	r0,r0
80005576:	07 90       	ld.ub	r0,r3[0x1]

80005578 <cpu_irq_is_enabled_flags>:

	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
80005578:	eb cd 40 80 	pushm	r7,lr
8000557c:	1a 97       	mov	r7,sp
8000557e:	20 1d       	sub	sp,4
80005580:	ef 4c ff fc 	st.w	r7[-4],r12
	return !(flags & AVR32_SR_GM_MASK);
80005584:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005588:	e6 18 00 01 	andh	r8,0x1,COH
8000558c:	5f 08       	sreq	r8
8000558e:	5c 58       	castu.b	r8
}
80005590:	10 9c       	mov	r12,r8
80005592:	2f fd       	sub	sp,-4
80005594:	e3 cd 80 80 	ldm	sp++,r7,pc

80005598 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80005598:	eb cd 40 80 	pushm	r7,lr
8000559c:	1a 97       	mov	r7,sp
8000559e:	20 7d       	sub	sp,28
800055a0:	ef 4c ff ec 	st.w	r7[-20],r12
800055a4:	ef 4b ff e8 	st.w	r7[-24],r11
800055a8:	ef 4a ff e4 	st.w	r7[-28],r10
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
800055ac:	ee f8 ff e8 	ld.w	r8,r7[-24]
800055b0:	f0 09 15 04 	lsl	r9,r8,0x4
800055b4:	ee f8 ff e4 	ld.w	r8,r7[-28]
800055b8:	10 39       	cp.w	r9,r8
800055ba:	e0 8b 00 04 	brhi	800055c2 <usart_set_async_baudrate+0x2a>
800055be:	31 08       	mov	r8,16
800055c0:	c0 28       	rjmp	800055c4 <usart_set_async_baudrate+0x2c>
800055c2:	30 88       	mov	r8,8
800055c4:	ef 48 ff f0 	st.w	r7[-16],r8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
800055c8:	ee f8 ff e4 	ld.w	r8,r7[-28]
800055cc:	f0 09 15 03 	lsl	r9,r8,0x3
800055d0:	ee fa ff f0 	ld.w	r10,r7[-16]
800055d4:	ee f8 ff e8 	ld.w	r8,r7[-24]
800055d8:	f4 08 02 48 	mul	r8,r10,r8
800055dc:	a1 98       	lsr	r8,0x1
800055de:	f2 08 00 08 	add	r8,r9,r8
800055e2:	ee fa ff f0 	ld.w	r10,r7[-16]
800055e6:	ee f9 ff e8 	ld.w	r9,r7[-24]
800055ea:	f4 09 02 49 	mul	r9,r10,r9
800055ee:	f0 09 0d 08 	divu	r8,r8,r9
800055f2:	ef 48 ff f4 	st.w	r7[-12],r8
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
800055f6:	ee f8 ff f4 	ld.w	r8,r7[-12]
800055fa:	a3 98       	lsr	r8,0x3
800055fc:	ef 48 ff f8 	st.w	r7[-8],r8
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);
80005600:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005604:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80005608:	ef 48 ff fc 	st.w	r7[-4],r8

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
8000560c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005610:	58 08       	cp.w	r8,0
80005612:	c0 70       	breq	80005620 <usart_set_async_baudrate+0x88>
80005614:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005618:	e0 48 ff ff 	cp.w	r8,65535
8000561c:	e0 88 00 04 	brls	80005624 <usart_set_async_baudrate+0x8c>
    return USART_INVALID_INPUT;
80005620:	30 18       	mov	r8,1
80005622:	c2 08       	rjmp	80005662 <usart_set_async_baudrate+0xca>

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80005624:	ee f8 ff ec 	ld.w	r8,r7[-20]
80005628:	70 18       	ld.w	r8,r8[0x4]
8000562a:	10 99       	mov	r9,r8
8000562c:	e4 19 ff f7 	andh	r9,0xfff7
80005630:	e0 19 fe cf 	andl	r9,0xfecf
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80005634:	ee f8 ff f0 	ld.w	r8,r7[-16]
80005638:	59 08       	cp.w	r8,16
8000563a:	c0 40       	breq	80005642 <usart_set_async_baudrate+0xaa>
8000563c:	e8 68 00 00 	mov	r8,524288
80005640:	c0 28       	rjmp	80005644 <usart_set_async_baudrate+0xac>
80005642:	30 08       	mov	r8,0
80005644:	10 49       	or	r9,r8
80005646:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000564a:	91 19       	st.w	r8[0x4],r9
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
                fp << AVR32_USART_BRGR_FP_OFFSET;
8000564c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005650:	f0 09 15 10 	lsl	r9,r8,0x10
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80005654:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005658:	10 49       	or	r9,r8
8000565a:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000565e:	91 89       	st.w	r8[0x20],r9
                fp << AVR32_USART_BRGR_FP_OFFSET;

  return USART_SUCCESS;
80005660:	30 08       	mov	r8,0
}
80005662:	10 9c       	mov	r12,r8
80005664:	2f 9d       	sub	sp,-28
80005666:	e3 cd 80 80 	ldm	sp++,r7,pc
8000566a:	d7 03       	nop

8000566c <usart_reset>:
 */
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
8000566c:	eb cd 40 80 	pushm	r7,lr
80005670:	1a 97       	mov	r7,sp
80005672:	20 2d       	sub	sp,8
80005674:	ef 4c ff f8 	st.w	r7[-8],r12
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80005678:	e1 b8 00 00 	mfsr	r8,0x0
8000567c:	10 9c       	mov	r12,r8
8000567e:	f0 1f 00 18 	mcall	800056dc <usart_reset+0x70>
80005682:	18 98       	mov	r8,r12
80005684:	ef 68 ff ff 	st.b	r7[-1],r8

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80005688:	ef 39 ff ff 	ld.ub	r9,r7[-1]
8000568c:	30 08       	mov	r8,0
8000568e:	f0 09 18 00 	cp.b	r9,r8
80005692:	c0 20       	breq	80005696 <usart_reset+0x2a>
80005694:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80005696:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000569a:	3f f9       	mov	r9,-1
8000569c:	91 39       	st.w	r8[0xc],r9
  usart->csr;
8000569e:	ee f8 ff f8 	ld.w	r8,r7[-8]
800056a2:	70 58       	ld.w	r8,r8[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
800056a4:	ef 39 ff ff 	ld.ub	r9,r7[-1]
800056a8:	30 08       	mov	r8,0
800056aa:	f0 09 18 00 	cp.b	r9,r8
800056ae:	c0 20       	breq	800056b2 <usart_reset+0x46>
800056b0:	d5 03       	csrf	0x10

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
800056b2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800056b6:	30 09       	mov	r9,0
800056b8:	91 19       	st.w	r8[0x4],r9
  usart->rtor = 0;
800056ba:	ee f8 ff f8 	ld.w	r8,r7[-8]
800056be:	30 09       	mov	r9,0
800056c0:	91 99       	st.w	r8[0x24],r9
  usart->ttgr = 0;
800056c2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800056c6:	30 09       	mov	r9,0
800056c8:	91 a9       	st.w	r8[0x28],r9

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
800056ca:	ee f8 ff f8 	ld.w	r8,r7[-8]
800056ce:	ea 69 61 0c 	mov	r9,680204
800056d2:	91 09       	st.w	r8[0x0],r9
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
800056d4:	2f ed       	sub	sp,-8
800056d6:	e3 cd 80 80 	ldm	sp++,r7,pc
800056da:	00 00       	add	r0,r0
800056dc:	80 00       	ld.sh	r0,r0[0x0]
800056de:	55 78       	stdsp	sp[0x15c],r8

800056e0 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
800056e0:	eb cd 40 80 	pushm	r7,lr
800056e4:	1a 97       	mov	r7,sp
800056e6:	20 3d       	sub	sp,12
800056e8:	ef 4c ff fc 	st.w	r7[-4],r12
800056ec:	ef 4b ff f8 	st.w	r7[-8],r11
800056f0:	ef 4a ff f4 	st.w	r7[-12],r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
800056f4:	ee fc ff fc 	ld.w	r12,r7[-4]
800056f8:	f0 1f 00 54 	mcall	80005848 <usart_init_rs232+0x168>

  // Check input values.
  if (!opt || // Null pointer.
800056fc:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005700:	58 08       	cp.w	r8,0
80005702:	c3 90       	breq	80005774 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
80005704:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005708:	11 c9       	ld.ub	r9,r8[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
8000570a:	30 48       	mov	r8,4
8000570c:	f0 09 18 00 	cp.b	r9,r8
80005710:	e0 88 00 32 	brls	80005774 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
80005714:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005718:	11 c9       	ld.ub	r9,r8[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
8000571a:	30 98       	mov	r8,9
8000571c:	f0 09 18 00 	cp.b	r9,r8
80005720:	e0 8b 00 2a 	brhi	80005774 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80005724:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005728:	11 d9       	ld.ub	r9,r8[0x5]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
8000572a:	30 78       	mov	r8,7
8000572c:	f0 09 18 00 	cp.b	r9,r8
80005730:	e0 8b 00 22 	brhi	80005774 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
80005734:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005738:	90 39       	ld.sh	r9,r8[0x6]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
8000573a:	e0 68 01 01 	mov	r8,257
8000573e:	f0 09 19 00 	cp.h	r9,r8
80005742:	e0 8b 00 19 	brhi	80005774 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
80005746:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000574a:	f1 39 00 08 	ld.ub	r9,r8[8]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
8000574e:	30 38       	mov	r8,3
80005750:	f0 09 18 00 	cp.b	r9,r8
80005754:	e0 8b 00 10 	brhi	80005774 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80005758:	ee f9 ff f4 	ld.w	r9,r7[-12]
8000575c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005760:	70 08       	ld.w	r8,r8[0x0]
80005762:	12 9a       	mov	r10,r9
80005764:	10 9b       	mov	r11,r8
80005766:	ee fc ff fc 	ld.w	r12,r7[-4]
8000576a:	f0 1f 00 39 	mcall	8000584c <usart_init_rs232+0x16c>
8000576e:	18 98       	mov	r8,r12
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005770:	58 18       	cp.w	r8,1
80005772:	c0 31       	brne	80005778 <usart_init_rs232+0x98>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;
80005774:	30 18       	mov	r8,1
80005776:	c6 48       	rjmp	8000583e <usart_init_rs232+0x15e>

  if (opt->charlength == 9)
80005778:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000577c:	11 c9       	ld.ub	r9,r8[0x4]
8000577e:	30 98       	mov	r8,9
80005780:	f0 09 18 00 	cp.b	r9,r8
80005784:	c0 a1       	brne	80005798 <usart_init_rs232+0xb8>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80005786:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000578a:	70 18       	ld.w	r8,r8[0x4]
8000578c:	10 99       	mov	r9,r8
8000578e:	b1 b9       	sbr	r9,0x11
80005790:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005794:	91 19       	st.w	r8[0x4],r9
80005796:	c0 d8       	rjmp	800057b0 <usart_init_rs232+0xd0>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80005798:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000579c:	70 19       	ld.w	r9,r8[0x4]
8000579e:	ee f8 ff f8 	ld.w	r8,r7[-8]
800057a2:	11 c8       	ld.ub	r8,r8[0x4]
800057a4:	20 58       	sub	r8,5
800057a6:	a7 68       	lsl	r8,0x6
800057a8:	10 49       	or	r9,r8
800057aa:	ee f8 ff fc 	ld.w	r8,r7[-4]
800057ae:	91 19       	st.w	r8[0x4],r9
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
800057b0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800057b4:	70 19       	ld.w	r9,r8[0x4]
800057b6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800057ba:	11 d8       	ld.ub	r8,r8[0x5]
800057bc:	f0 0a 15 09 	lsl	r10,r8,0x9
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;
800057c0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800057c4:	f1 38 00 08 	ld.ub	r8,r8[8]
800057c8:	af 68       	lsl	r8,0xe
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
800057ca:	f5 e8 10 08 	or	r8,r10,r8
800057ce:	10 49       	or	r9,r8
800057d0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800057d4:	91 19       	st.w	r8[0x4],r9
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
800057d6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800057da:	90 39       	ld.sh	r9,r8[0x6]
800057dc:	30 28       	mov	r8,2
800057de:	f0 09 19 00 	cp.h	r9,r8
800057e2:	e0 88 00 14 	brls	8000580a <usart_init_rs232+0x12a>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
800057e6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800057ea:	70 18       	ld.w	r8,r8[0x4]
800057ec:	10 99       	mov	r9,r8
800057ee:	ad b9       	sbr	r9,0xd
800057f0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800057f4:	91 19       	st.w	r8[0x4],r9
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
800057f6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800057fa:	90 38       	ld.sh	r8,r8[0x6]
800057fc:	5c 78       	castu.h	r8
800057fe:	20 28       	sub	r8,2
80005800:	10 99       	mov	r9,r8
80005802:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005806:	91 a9       	st.w	r8[0x28],r9
80005808:	c0 d8       	rjmp	80005822 <usart_init_rs232+0x142>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
8000580a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000580e:	70 19       	ld.w	r9,r8[0x4]
80005810:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005814:	90 38       	ld.sh	r8,r8[0x6]
80005816:	5c 78       	castu.h	r8
80005818:	ad 68       	lsl	r8,0xc
8000581a:	10 49       	or	r9,r8
8000581c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005820:	91 19       	st.w	r8[0x4],r9

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80005822:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005826:	70 18       	ld.w	r8,r8[0x4]
80005828:	10 99       	mov	r9,r8
8000582a:	e0 19 ff f0 	andl	r9,0xfff0
8000582e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005832:	91 19       	st.w	r8[0x4],r9
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80005834:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005838:	35 09       	mov	r9,80
8000583a:	91 09       	st.w	r8[0x0],r9
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
8000583c:	30 08       	mov	r8,0
}
8000583e:	10 9c       	mov	r12,r8
80005840:	2f dd       	sub	sp,-12
80005842:	e3 cd 80 80 	ldm	sp++,r7,pc
80005846:	00 00       	add	r0,r0
80005848:	80 00       	ld.sh	r0,r0[0x0]
8000584a:	56 6c       	stdsp	sp[0x198],r12
8000584c:	80 00       	ld.sh	r0,r0[0x0]
8000584e:	55 98       	stdsp	sp[0x164],r8

80005850 <usart_write_char>:
  return USART_SUCCESS;
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
80005850:	eb cd 40 80 	pushm	r7,lr
80005854:	1a 97       	mov	r7,sp
80005856:	20 3d       	sub	sp,12
80005858:	ef 4c ff f8 	st.w	r7[-8],r12
8000585c:	ef 4b ff f4 	st.w	r7[-12],r11
80005860:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005864:	ef 48 ff fc 	st.w	r7[-4],r8
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80005868:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000586c:	70 58       	ld.w	r8,r8[0x14]
8000586e:	e2 18 00 02 	andl	r8,0x2,COH
80005872:	5f 18       	srne	r8
  if (usart_tx_ready(usart))
80005874:	58 08       	cp.w	r8,0
80005876:	c0 a0       	breq	8000588a <usart_write_char+0x3a>
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80005878:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000587c:	f3 d8 c0 09 	bfextu	r9,r8,0x0,0x9
80005880:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005884:	91 79       	st.w	r8[0x1c],r9
    return USART_SUCCESS;
80005886:	30 08       	mov	r8,0
80005888:	c0 28       	rjmp	8000588c <usart_write_char+0x3c>
  }
  else
    return USART_TX_BUSY;
8000588a:	30 28       	mov	r8,2
}
8000588c:	10 9c       	mov	r12,r8
8000588e:	2f dd       	sub	sp,-12
80005890:	e3 cd 80 80 	ldm	sp++,r7,pc

80005894 <usart_putchar>:


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80005894:	eb cd 40 80 	pushm	r7,lr
80005898:	1a 97       	mov	r7,sp
8000589a:	20 3d       	sub	sp,12
8000589c:	ef 4c ff f8 	st.w	r7[-8],r12
800058a0:	ef 4b ff f4 	st.w	r7[-12],r11
  int timeout = USART_DEFAULT_TIMEOUT;
800058a4:	e0 68 27 10 	mov	r8,10000
800058a8:	ef 48 ff fc 	st.w	r7[-4],r8

  do
  {
    if (!timeout--) return USART_FAILURE;
800058ac:	ee f8 ff fc 	ld.w	r8,r7[-4]
800058b0:	58 08       	cp.w	r8,0
800058b2:	5f 08       	sreq	r8
800058b4:	5c 58       	castu.b	r8
800058b6:	ee f9 ff fc 	ld.w	r9,r7[-4]
800058ba:	20 19       	sub	r9,1
800058bc:	ef 49 ff fc 	st.w	r7[-4],r9
800058c0:	58 08       	cp.w	r8,0
800058c2:	c0 30       	breq	800058c8 <usart_putchar+0x34>
800058c4:	3f f8       	mov	r8,-1
800058c6:	c0 b8       	rjmp	800058dc <usart_putchar+0x48>
  } while (usart_write_char(usart, c) != USART_SUCCESS);
800058c8:	ee fb ff f4 	ld.w	r11,r7[-12]
800058cc:	ee fc ff f8 	ld.w	r12,r7[-8]
800058d0:	f0 1f 00 05 	mcall	800058e4 <usart_putchar+0x50>
800058d4:	18 98       	mov	r8,r12
800058d6:	58 08       	cp.w	r8,0
800058d8:	ce a1       	brne	800058ac <usart_putchar+0x18>

  return USART_SUCCESS;
800058da:	30 08       	mov	r8,0
}
800058dc:	10 9c       	mov	r12,r8
800058de:	2f dd       	sub	sp,-12
800058e0:	e3 cd 80 80 	ldm	sp++,r7,pc
800058e4:	80 00       	ld.sh	r0,r0[0x0]
800058e6:	58 50       	cp.w	r0,5

800058e8 <usart_read_char>:


int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
800058e8:	eb cd 40 80 	pushm	r7,lr
800058ec:	1a 97       	mov	r7,sp
800058ee:	20 3d       	sub	sp,12
800058f0:	ef 4c ff f8 	st.w	r7[-8],r12
800058f4:	ef 4b ff f4 	st.w	r7[-12],r11
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
800058f8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800058fc:	70 58       	ld.w	r8,r8[0x14]
800058fe:	e2 18 00 e0 	andl	r8,0xe0,COH
80005902:	c0 30       	breq	80005908 <usart_read_char+0x20>
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;
80005904:	30 48       	mov	r8,4
80005906:	c1 68       	rjmp	80005932 <usart_read_char+0x4a>
80005908:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000590c:	ef 48 ff fc 	st.w	r7[-4],r8
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80005910:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005914:	70 58       	ld.w	r8,r8[0x14]
80005916:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
8000591a:	c0 b0       	breq	80005930 <usart_read_char+0x48>
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
8000591c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005920:	70 68       	ld.w	r8,r8[0x18]
80005922:	f3 d8 c0 09 	bfextu	r9,r8,0x0,0x9
80005926:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000592a:	91 09       	st.w	r8[0x0],r9
    return USART_SUCCESS;
8000592c:	30 08       	mov	r8,0
8000592e:	c0 28       	rjmp	80005932 <usart_read_char+0x4a>
  }
  else
    return USART_RX_EMPTY;
80005930:	30 38       	mov	r8,3
}
80005932:	10 9c       	mov	r12,r8
80005934:	2f dd       	sub	sp,-12
80005936:	e3 cd 80 80 	ldm	sp++,r7,pc
8000593a:	d7 03       	nop

8000593c <usart_write_line>:
  return c;
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
8000593c:	eb cd 40 80 	pushm	r7,lr
80005940:	1a 97       	mov	r7,sp
80005942:	20 2d       	sub	sp,8
80005944:	ef 4c ff fc 	st.w	r7[-4],r12
80005948:	ef 4b ff f8 	st.w	r7[-8],r11
  while (*string != '\0')
8000594c:	c0 e8       	rjmp	80005968 <usart_write_line+0x2c>
    usart_putchar(usart, *string++);
8000594e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005952:	11 88       	ld.ub	r8,r8[0x0]
80005954:	ee f9 ff f8 	ld.w	r9,r7[-8]
80005958:	2f f9       	sub	r9,-1
8000595a:	ef 49 ff f8 	st.w	r7[-8],r9
8000595e:	10 9b       	mov	r11,r8
80005960:	ee fc ff fc 	ld.w	r12,r7[-4]
80005964:	f0 1f 00 05 	mcall	80005978 <usart_write_line+0x3c>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80005968:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000596c:	11 88       	ld.ub	r8,r8[0x0]
8000596e:	58 08       	cp.w	r8,0
80005970:	ce f1       	brne	8000594e <usart_write_line+0x12>
    usart_putchar(usart, *string++);
}
80005972:	2f ed       	sub	sp,-8
80005974:	e3 cd 80 80 	ldm	sp++,r7,pc
80005978:	80 00       	ld.sh	r0,r0[0x0]
8000597a:	58 94       	cp.w	r4,9

8000597c <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
8000597c:	48 cd       	lddpc	sp,800059ac <udata_clear_loop_end+0x2>

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
8000597e:	48 d0       	lddpc	r0,800059b0 <udata_clear_loop_end+0x6>
  mtsr    AVR32_EVBA, r0
80005980:	e3 b0 00 01 	mtsr	0x4,r0

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80005984:	d5 53       	csrf	0x15

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
80005986:	48 c0       	lddpc	r0,800059b4 <udata_clear_loop_end+0xa>
  lda.w   r1, _edata
80005988:	48 c1       	lddpc	r1,800059b8 <udata_clear_loop_end+0xe>
  cp      r0, r1
8000598a:	02 30       	cp.w	r0,r1
  brhs    idata_load_loop_end
8000598c:	c0 62       	brcc	80005998 <idata_load_loop_end>
  lda.w   r2, _data_lma
8000598e:	48 c2       	lddpc	r2,800059bc <udata_clear_loop_end+0x12>

80005990 <idata_load_loop>:
idata_load_loop:
  ld.d    r4, r2++
80005990:	a5 05       	ld.d	r4,r2++
  st.d    r0++, r4
80005992:	a1 24       	st.d	r0++,r4
  cp      r0, r1
80005994:	02 30       	cp.w	r0,r1
  brlo    idata_load_loop
80005996:	cf d3       	brcs	80005990 <idata_load_loop>

80005998 <idata_load_loop_end>:
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80005998:	48 a0       	lddpc	r0,800059c0 <udata_clear_loop_end+0x16>
  lda.w   r1, _end
8000599a:	48 b1       	lddpc	r1,800059c4 <udata_clear_loop_end+0x1a>
  cp      r0, r1
8000599c:	02 30       	cp.w	r0,r1
  brhs    udata_clear_loop_end
8000599e:	c0 62       	brcc	800059aa <udata_clear_loop_end>
  mov     r2, 0
800059a0:	30 02       	mov	r2,0
  mov     r3, 0
800059a2:	30 03       	mov	r3,0

800059a4 <udata_clear_loop>:
udata_clear_loop:
  st.d    r0++, r2
800059a4:	a1 22       	st.d	r0++,r2
  cp      r0, r1
800059a6:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
800059a8:	cf e3       	brcs	800059a4 <udata_clear_loop>

800059aa <udata_clear_loop_end>:
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
800059aa:	48 8f       	lddpc	pc,800059c8 <udata_clear_loop_end+0x1e>
800059ac:	00 01       	add	r1,r0
800059ae:	00 00       	add	r0,r0
800059b0:	80 01       	ld.sh	r1,r0[0x0]
800059b2:	22 00       	sub	r0,32
800059b4:	00 00       	add	r0,r0
800059b6:	00 08       	add	r8,r0
800059b8:	00 00       	add	r0,r0
800059ba:	05 c0       	ld.ub	r0,r2[0x4]
800059bc:	80 01       	ld.sh	r1,r0[0x0]
800059be:	2c e0       	sub	r0,-50
800059c0:	00 00       	add	r0,r0
800059c2:	05 c0       	ld.ub	r0,r2[0x4]
800059c4:	00 00       	add	r0,r0
800059c6:	0d 98       	ld.ub	r8,r6[0x1]
800059c8:	80 00       	ld.sh	r0,r0[0x0]
800059ca:	ae 08       	st.h	r7[0x0],r8

800059cc <cpu_irq_save>:
#endif

typedef uint32_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
800059cc:	eb cd 40 80 	pushm	r7,lr
800059d0:	1a 97       	mov	r7,sp
800059d2:	20 1d       	sub	sp,4
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800059d4:	e1 b8 00 00 	mfsr	r8,0x0
800059d8:	ef 48 ff fc 	st.w	r7[-4],r8
	cpu_irq_disable();
800059dc:	d3 03       	ssrf	0x10

	return flags;
800059de:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
800059e2:	10 9c       	mov	r12,r8
800059e4:	2f fd       	sub	sp,-4
800059e6:	e3 cd 80 80 	ldm	sp++,r7,pc

800059ea <cpu_irq_is_enabled_flags>:

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
800059ea:	eb cd 40 80 	pushm	r7,lr
800059ee:	1a 97       	mov	r7,sp
800059f0:	20 1d       	sub	sp,4
800059f2:	ef 4c ff fc 	st.w	r7[-4],r12
	return !(flags & AVR32_SR_GM_MASK);
800059f6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800059fa:	e6 18 00 01 	andh	r8,0x1,COH
800059fe:	5f 08       	sreq	r8
80005a00:	5c 58       	castu.b	r8
}
80005a02:	10 9c       	mov	r12,r8
80005a04:	2f fd       	sub	sp,-4
80005a06:	e3 cd 80 80 	ldm	sp++,r7,pc
80005a0a:	d7 03       	nop

80005a0c <cpu_irq_restore>:

static inline void cpu_irq_restore(irqflags_t flags)
{
80005a0c:	eb cd 40 80 	pushm	r7,lr
80005a10:	1a 97       	mov	r7,sp
80005a12:	20 1d       	sub	sp,4
80005a14:	ef 4c ff fc 	st.w	r7[-4],r12
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80005a18:	ee fc ff fc 	ld.w	r12,r7[-4]
80005a1c:	f0 1f 00 05 	mcall	80005a30 <cpu_irq_restore+0x24>
80005a20:	18 98       	mov	r8,r12
80005a22:	58 08       	cp.w	r8,0
80005a24:	c0 20       	breq	80005a28 <cpu_irq_restore+0x1c>
      cpu_irq_enable();
80005a26:	d5 03       	csrf	0x10
   }

	barrier();
}
80005a28:	2f fd       	sub	sp,-4
80005a2a:	e3 cd 80 80 	ldm	sp++,r7,pc
80005a2e:	00 00       	add	r0,r0
80005a30:	80 00       	ld.sh	r0,r0[0x0]
80005a32:	59 ea       	cp.w	r10,30

80005a34 <osc_priv_enable_osc0>:
 */
#include <osc.h>

#ifdef BOARD_OSC0_HZ
void osc_priv_enable_osc0(void)
{
80005a34:	eb cd 40 80 	pushm	r7,lr
80005a38:	1a 97       	mov	r7,sp
80005a3a:	20 1d       	sub	sp,4
	irqflags_t flags;

	flags = cpu_irq_save();
80005a3c:	f0 1f 00 0c 	mcall	80005a6c <osc_priv_enable_osc0+0x38>
80005a40:	18 98       	mov	r8,r12
80005a42:	ef 48 ff fc 	st.w	r7[-4],r8
	AVR32_SCIF.unlock = 0xaa000000 | AVR32_SCIF_OSCCTRL;
80005a46:	fe 78 08 00 	mov	r8,-63488
80005a4a:	32 49       	mov	r9,36
80005a4c:	ea 19 aa 00 	orh	r9,0xaa00
80005a50:	91 69       	st.w	r8[0x18],r9
	AVR32_SCIF.oscctrl[0] =
80005a52:	fe 78 08 00 	mov	r8,-63488
80005a56:	e0 79 0c 07 	mov	r9,68615
80005a5a:	91 99       	st.w	r8[0x24],r9
			(OSC0_STARTUP_VALUE << AVR32_SCIF_OSCCTRL_STARTUP)
			| (OSC0_GAIN_VALUE << AVR32_SCIF_OSCCTRL_GAIN)
			| (OSC0_MODE_VALUE << AVR32_SCIF_OSCCTRL_MODE)
			| (1U << AVR32_SCIF_OSCCTRL_OSCEN);
	cpu_irq_restore(flags);
80005a5c:	ee fc ff fc 	ld.w	r12,r7[-4]
80005a60:	f0 1f 00 04 	mcall	80005a70 <osc_priv_enable_osc0+0x3c>
}
80005a64:	2f fd       	sub	sp,-4
80005a66:	e3 cd 80 80 	ldm	sp++,r7,pc
80005a6a:	00 00       	add	r0,r0
80005a6c:	80 00       	ld.sh	r0,r0[0x0]
80005a6e:	59 cc       	cp.w	r12,28
80005a70:	80 00       	ld.sh	r0,r0[0x0]
80005a72:	5a 0c       	cp.w	r12,-32

80005a74 <osc_priv_enable_osc32>:
}
#endif /* BOARD_OSC0_HZ */

#ifdef BOARD_OSC32_HZ
void osc_priv_enable_osc32(void)
{
80005a74:	eb cd 40 80 	pushm	r7,lr
80005a78:	1a 97       	mov	r7,sp
80005a7a:	20 1d       	sub	sp,4
	irqflags_t flags;

	flags = cpu_irq_save();
80005a7c:	f0 1f 00 0c 	mcall	80005aac <osc_priv_enable_osc32+0x38>
80005a80:	18 98       	mov	r8,r12
80005a82:	ef 48 ff fc 	st.w	r7[-4],r8
	AVR32_SCIF.unlock = 0xaa000000 | AVR32_SCIF_OSCCTRL32;
80005a86:	fe 78 08 00 	mov	r8,-63488
80005a8a:	34 c9       	mov	r9,76
80005a8c:	ea 19 aa 00 	orh	r9,0xaa00
80005a90:	91 69       	st.w	r8[0x18],r9
	AVR32_SCIF.oscctrl32 =
80005a92:	fe 78 08 00 	mov	r8,-63488
80005a96:	e2 69 01 01 	mov	r9,131329
80005a9a:	f1 49 00 4c 	st.w	r8[76],r9
			(OSC32_STARTUP_VALUE << AVR32_SCIF_OSCCTRL32_STARTUP)
			| (OSC32_MODE_VALUE << AVR32_SCIF_OSCCTRL32_MODE)
			| (1U << AVR32_SCIF_OSCCTRL32_OSC32EN);
	cpu_irq_restore(flags);
80005a9e:	ee fc ff fc 	ld.w	r12,r7[-4]
80005aa2:	f0 1f 00 04 	mcall	80005ab0 <osc_priv_enable_osc32+0x3c>
}
80005aa6:	2f fd       	sub	sp,-4
80005aa8:	e3 cd 80 80 	ldm	sp++,r7,pc
80005aac:	80 00       	ld.sh	r0,r0[0x0]
80005aae:	59 cc       	cp.w	r12,28
80005ab0:	80 00       	ld.sh	r0,r0[0x0]
80005ab2:	5a 0c       	cp.w	r12,-32

80005ab4 <osc_priv_enable_rc8m>:
	cpu_irq_restore(flags);
}
#endif /* BOARD_OSC0_HZ */

void osc_priv_enable_rc8m(void)
{
80005ab4:	eb cd 40 80 	pushm	r7,lr
80005ab8:	1a 97       	mov	r7,sp
80005aba:	20 3d       	sub	sp,12
	irqflags_t flags;
	uint32_t   rccr8;
    uint32_t* calibration_bits = (uint32_t*)0x80800200;
80005abc:	e0 68 02 00 	mov	r8,512
80005ac0:	ea 18 80 80 	orh	r8,0x8080
80005ac4:	ef 48 ff fc 	st.w	r7[-4],r8
	/* Wait for the CALIB field to be updated from fuses after reset */
	while (!(AVR32_SCIF.rccr8 & AVR32_SCIF_RCCR8_FCD_MASK)) {
80005ac8:	fe 78 08 00 	mov	r8,-63488
80005acc:	71 28       	ld.w	r8,r8[0x48]
80005ace:	e6 18 00 01 	andh	r8,0x1,COH
80005ad2:	cf b0       	breq	80005ac8 <osc_priv_enable_rc8m+0x14>
		/* Do nothing */
	}

	/* Enable the oscillator without touching the CALIB and FCD fields */
	flags = cpu_irq_save();
80005ad4:	f0 1f 00 17 	mcall	80005b30 <osc_priv_enable_rc8m+0x7c>
80005ad8:	18 98       	mov	r8,r12
80005ada:	ef 48 ff f4 	st.w	r7[-12],r8
	rccr8 = AVR32_SCIF.rccr8;
80005ade:	fe 78 08 00 	mov	r8,-63488
80005ae2:	71 28       	ld.w	r8,r8[0x48]
80005ae4:	ef 48 ff f8 	st.w	r7[-8],r8
	rccr8 &= AVR32_SCIF_RCCR8_FCD_MASK | ((*calibration_bits)&AVR32_SCIF_RCCR8_CALIB_MASK);
80005ae8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005aec:	70 08       	ld.w	r8,r8[0x0]
80005aee:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80005af2:	b1 a8       	sbr	r8,0x10
80005af4:	ee f9 ff f8 	ld.w	r9,r7[-8]
80005af8:	f3 e8 00 08 	and	r8,r9,r8
80005afc:	ef 48 ff f8 	st.w	r7[-8],r8
	rccr8 |= 1U << AVR32_SCIF_RCOSC8_EN;
80005b00:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005b04:	b9 a8       	sbr	r8,0x18
80005b06:	ef 48 ff f8 	st.w	r7[-8],r8
	AVR32_SCIF.unlock = 0xaa000000 | AVR32_SCIF_RCCR8;
80005b0a:	fe 78 08 00 	mov	r8,-63488
80005b0e:	34 89       	mov	r9,72
80005b10:	ea 19 aa 00 	orh	r9,0xaa00
80005b14:	91 69       	st.w	r8[0x18],r9
	AVR32_SCIF.rccr8 = rccr8;
80005b16:	fe 78 08 00 	mov	r8,-63488
80005b1a:	ee f9 ff f8 	ld.w	r9,r7[-8]
80005b1e:	f1 49 00 48 	st.w	r8[72],r9
	cpu_irq_restore(flags);
80005b22:	ee fc ff f4 	ld.w	r12,r7[-12]
80005b26:	f0 1f 00 04 	mcall	80005b34 <osc_priv_enable_rc8m+0x80>
}
80005b2a:	2f dd       	sub	sp,-12
80005b2c:	e3 cd 80 80 	ldm	sp++,r7,pc
80005b30:	80 00       	ld.sh	r0,r0[0x0]
80005b32:	59 cc       	cp.w	r12,28
80005b34:	80 00       	ld.sh	r0,r0[0x0]
80005b36:	5a 0c       	cp.w	r12,-32

80005b38 <osc_priv_enable_rc120m>:
	AVR32_SCIF.rccr8 = rccr8;
	cpu_irq_restore(flags);
}

void osc_priv_enable_rc120m(void)
{
80005b38:	eb cd 40 80 	pushm	r7,lr
80005b3c:	1a 97       	mov	r7,sp
80005b3e:	20 1d       	sub	sp,4
	irqflags_t flags;

	flags = cpu_irq_save();
80005b40:	f0 1f 00 0c 	mcall	80005b70 <osc_priv_enable_rc120m+0x38>
80005b44:	18 98       	mov	r8,r12
80005b46:	ef 48 ff fc 	st.w	r7[-4],r8
	AVR32_SCIF.unlock = 0xaa000000 | AVR32_SCIF_RC120MCR;
80005b4a:	fe 78 08 00 	mov	r8,-63488
80005b4e:	35 89       	mov	r9,88
80005b50:	ea 19 aa 00 	orh	r9,0xaa00
80005b54:	91 69       	st.w	r8[0x18],r9
	AVR32_SCIF.rc120mcr = 1U << AVR32_SCIF_RC120MCR_EN;
80005b56:	fe 78 08 00 	mov	r8,-63488
80005b5a:	30 19       	mov	r9,1
80005b5c:	f1 49 00 58 	st.w	r8[88],r9
	cpu_irq_restore(flags);
80005b60:	ee fc ff fc 	ld.w	r12,r7[-4]
80005b64:	f0 1f 00 04 	mcall	80005b74 <osc_priv_enable_rc120m+0x3c>
}
80005b68:	2f fd       	sub	sp,-4
80005b6a:	e3 cd 80 80 	ldm	sp++,r7,pc
80005b6e:	00 00       	add	r0,r0
80005b70:	80 00       	ld.sh	r0,r0[0x0]
80005b72:	59 cc       	cp.w	r12,28
80005b74:	80 00       	ld.sh	r0,r0[0x0]
80005b76:	5a 0c       	cp.w	r12,-32

80005b78 <cpu_irq_save>:
#endif

typedef uint32_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
80005b78:	eb cd 40 80 	pushm	r7,lr
80005b7c:	1a 97       	mov	r7,sp
80005b7e:	20 1d       	sub	sp,4
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80005b80:	e1 b8 00 00 	mfsr	r8,0x0
80005b84:	ef 48 ff fc 	st.w	r7[-4],r8
	cpu_irq_disable();
80005b88:	d3 03       	ssrf	0x10

	return flags;
80005b8a:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80005b8e:	10 9c       	mov	r12,r8
80005b90:	2f fd       	sub	sp,-4
80005b92:	e3 cd 80 80 	ldm	sp++,r7,pc

80005b96 <cpu_irq_is_enabled_flags>:

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
80005b96:	eb cd 40 80 	pushm	r7,lr
80005b9a:	1a 97       	mov	r7,sp
80005b9c:	20 1d       	sub	sp,4
80005b9e:	ef 4c ff fc 	st.w	r7[-4],r12
	return !(flags & AVR32_SR_GM_MASK);
80005ba2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005ba6:	e6 18 00 01 	andh	r8,0x1,COH
80005baa:	5f 08       	sreq	r8
80005bac:	5c 58       	castu.b	r8
}
80005bae:	10 9c       	mov	r12,r8
80005bb0:	2f fd       	sub	sp,-4
80005bb2:	e3 cd 80 80 	ldm	sp++,r7,pc
80005bb6:	d7 03       	nop

80005bb8 <cpu_irq_restore>:

static inline void cpu_irq_restore(irqflags_t flags)
{
80005bb8:	eb cd 40 80 	pushm	r7,lr
80005bbc:	1a 97       	mov	r7,sp
80005bbe:	20 1d       	sub	sp,4
80005bc0:	ef 4c ff fc 	st.w	r7[-4],r12
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80005bc4:	ee fc ff fc 	ld.w	r12,r7[-4]
80005bc8:	f0 1f 00 05 	mcall	80005bdc <cpu_irq_restore+0x24>
80005bcc:	18 98       	mov	r8,r12
80005bce:	58 08       	cp.w	r8,0
80005bd0:	c0 20       	breq	80005bd4 <cpu_irq_restore+0x1c>
      cpu_irq_enable();
80005bd2:	d5 03       	csrf	0x10
   }

	barrier();
}
80005bd4:	2f fd       	sub	sp,-4
80005bd6:	e3 cd 80 80 	ldm	sp++,r7,pc
80005bda:	00 00       	add	r0,r0
80005bdc:	80 00       	ld.sh	r0,r0[0x0]
80005bde:	5b 96       	cp.w	r6,-7

80005be0 <pll_enable>:
	AVR32_SCIF.pll[pll_id] = cfg->ctrl;
	cpu_irq_restore(flags);
}

void pll_enable(const struct pll_config *cfg, unsigned int pll_id)
{
80005be0:	eb cd 40 80 	pushm	r7,lr
80005be4:	1a 97       	mov	r7,sp
80005be6:	20 3d       	sub	sp,12
80005be8:	ef 4c ff f8 	st.w	r7[-8],r12
80005bec:	ef 4b ff f4 	st.w	r7[-12],r11
	irqflags_t flags;

	Assert(pll_id < NR_PLLS);

	flags = cpu_irq_save();
80005bf0:	f0 1f 00 10 	mcall	80005c30 <pll_enable+0x50>
80005bf4:	18 98       	mov	r8,r12
80005bf6:	ef 48 ff fc 	st.w	r7[-4],r8
	AVR32_SCIF.unlock = 0xaa000000 | (AVR32_SCIF_PLL + (4 * pll_id));
80005bfa:	fe 78 08 00 	mov	r8,-63488
80005bfe:	ee f9 ff f4 	ld.w	r9,r7[-12]
80005c02:	2f 99       	sub	r9,-7
80005c04:	a3 69       	lsl	r9,0x2
80005c06:	ea 19 aa 00 	orh	r9,0xaa00
80005c0a:	91 69       	st.w	r8[0x18],r9
	AVR32_SCIF.pll[pll_id] = cfg->ctrl | (1U << AVR32_SCIF_PLLEN);
80005c0c:	fe 78 08 00 	mov	r8,-63488
80005c10:	ee f9 ff f4 	ld.w	r9,r7[-12]
80005c14:	ee fa ff f8 	ld.w	r10,r7[-8]
80005c18:	74 0a       	ld.w	r10,r10[0x0]
80005c1a:	a1 aa       	sbr	r10,0x0
80005c1c:	2f 99       	sub	r9,-7
80005c1e:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
	cpu_irq_restore(flags);
80005c22:	ee fc ff fc 	ld.w	r12,r7[-4]
80005c26:	f0 1f 00 04 	mcall	80005c34 <pll_enable+0x54>
}
80005c2a:	2f dd       	sub	sp,-12
80005c2c:	e3 cd 80 80 	ldm	sp++,r7,pc
80005c30:	80 00       	ld.sh	r0,r0[0x0]
80005c32:	5b 78       	cp.w	r8,-9
80005c34:	80 00       	ld.sh	r0,r0[0x0]
80005c36:	5b b8       	cp.w	r8,-5

80005c38 <pll_disable>:

void pll_disable(unsigned int pll_id)
{
80005c38:	eb cd 40 80 	pushm	r7,lr
80005c3c:	1a 97       	mov	r7,sp
80005c3e:	20 2d       	sub	sp,8
80005c40:	ef 4c ff f8 	st.w	r7[-8],r12
	irqflags_t flags;

	Assert(pll_id < NR_PLLS);

	flags = cpu_irq_save();
80005c44:	f0 1f 00 0f 	mcall	80005c80 <pll_disable+0x48>
80005c48:	18 98       	mov	r8,r12
80005c4a:	ef 48 ff fc 	st.w	r7[-4],r8
	AVR32_SCIF.unlock = 0xaa000000 | (AVR32_SCIF_PLL + (4 * pll_id));
80005c4e:	fe 78 08 00 	mov	r8,-63488
80005c52:	ee f9 ff f8 	ld.w	r9,r7[-8]
80005c56:	2f 99       	sub	r9,-7
80005c58:	a3 69       	lsl	r9,0x2
80005c5a:	ea 19 aa 00 	orh	r9,0xaa00
80005c5e:	91 69       	st.w	r8[0x18],r9
	AVR32_SCIF.pll[pll_id] = 0;
80005c60:	fe 78 08 00 	mov	r8,-63488
80005c64:	ee f9 ff f8 	ld.w	r9,r7[-8]
80005c68:	2f 99       	sub	r9,-7
80005c6a:	30 0a       	mov	r10,0
80005c6c:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
	cpu_irq_restore(flags);
80005c70:	ee fc ff fc 	ld.w	r12,r7[-4]
80005c74:	f0 1f 00 04 	mcall	80005c84 <pll_disable+0x4c>
}
80005c78:	2f ed       	sub	sp,-8
80005c7a:	e3 cd 80 80 	ldm	sp++,r7,pc
80005c7e:	00 00       	add	r0,r0
80005c80:	80 00       	ld.sh	r0,r0[0x0]
80005c82:	5b 78       	cp.w	r8,-9
80005c84:	80 00       	ld.sh	r0,r0[0x0]
80005c86:	5b b8       	cp.w	r8,-5

80005c88 <cpu_irq_save>:
#endif

typedef uint32_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
80005c88:	eb cd 40 80 	pushm	r7,lr
80005c8c:	1a 97       	mov	r7,sp
80005c8e:	20 1d       	sub	sp,4
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80005c90:	e1 b8 00 00 	mfsr	r8,0x0
80005c94:	ef 48 ff fc 	st.w	r7[-4],r8
	cpu_irq_disable();
80005c98:	d3 03       	ssrf	0x10

	return flags;
80005c9a:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80005c9e:	10 9c       	mov	r12,r8
80005ca0:	2f fd       	sub	sp,-4
80005ca2:	e3 cd 80 80 	ldm	sp++,r7,pc

80005ca6 <cpu_irq_is_enabled_flags>:

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
80005ca6:	eb cd 40 80 	pushm	r7,lr
80005caa:	1a 97       	mov	r7,sp
80005cac:	20 1d       	sub	sp,4
80005cae:	ef 4c ff fc 	st.w	r7[-4],r12
	return !(flags & AVR32_SR_GM_MASK);
80005cb2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005cb6:	e6 18 00 01 	andh	r8,0x1,COH
80005cba:	5f 08       	sreq	r8
80005cbc:	5c 58       	castu.b	r8
}
80005cbe:	10 9c       	mov	r12,r8
80005cc0:	2f fd       	sub	sp,-4
80005cc2:	e3 cd 80 80 	ldm	sp++,r7,pc
80005cc6:	d7 03       	nop

80005cc8 <cpu_irq_restore>:

static inline void cpu_irq_restore(irqflags_t flags)
{
80005cc8:	eb cd 40 80 	pushm	r7,lr
80005ccc:	1a 97       	mov	r7,sp
80005cce:	20 1d       	sub	sp,4
80005cd0:	ef 4c ff fc 	st.w	r7[-4],r12
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80005cd4:	ee fc ff fc 	ld.w	r12,r7[-4]
80005cd8:	f0 1f 00 05 	mcall	80005cec <cpu_irq_restore+0x24>
80005cdc:	18 98       	mov	r8,r12
80005cde:	58 08       	cp.w	r8,0
80005ce0:	c0 20       	breq	80005ce4 <cpu_irq_restore+0x1c>
      cpu_irq_enable();
80005ce2:	d5 03       	csrf	0x10
   }

	barrier();
}
80005ce4:	2f fd       	sub	sp,-4
80005ce6:	e3 cd 80 80 	ldm	sp++,r7,pc
80005cea:	00 00       	add	r0,r0
80005cec:	80 00       	ld.sh	r0,r0[0x0]
80005cee:	5c a6       	swap.h	r6

80005cf0 <sysclk_set_prescalers>:
 * \param pbc_shift The PBC clock will be divided by \f$2^{pbc\_shift}\f$
 */
void sysclk_set_prescalers(unsigned int cpu_shift,
		unsigned int pba_shift, unsigned int pbb_shift,
		unsigned int pbc_shift)
{
80005cf0:	eb cd 40 80 	pushm	r7,lr
80005cf4:	1a 97       	mov	r7,sp
80005cf6:	20 9d       	sub	sp,36
80005cf8:	ef 4c ff e8 	st.w	r7[-24],r12
80005cfc:	ef 4b ff e4 	st.w	r7[-28],r11
80005d00:	ef 4a ff e0 	st.w	r7[-32],r10
80005d04:	ef 49 ff dc 	st.w	r7[-36],r9
	irqflags_t flags;
	uint32_t   cpu_cksel = 0;
80005d08:	30 08       	mov	r8,0
80005d0a:	ef 48 ff f0 	st.w	r7[-16],r8
	uint32_t   pba_cksel = 0;
80005d0e:	30 08       	mov	r8,0
80005d10:	ef 48 ff f4 	st.w	r7[-12],r8
	uint32_t   pbb_cksel = 0;
80005d14:	30 08       	mov	r8,0
80005d16:	ef 48 ff f8 	st.w	r7[-8],r8
	uint32_t   pbc_cksel = 0;
80005d1a:	30 08       	mov	r8,0
80005d1c:	ef 48 ff fc 	st.w	r7[-4],r8

	Assert(cpu_shift <= pba_shift);
	Assert(cpu_shift <= pbb_shift);

	if (cpu_shift > 0)
80005d20:	ee f8 ff e8 	ld.w	r8,r7[-24]
80005d24:	58 08       	cp.w	r8,0
80005d26:	c0 70       	breq	80005d34 <sysclk_set_prescalers+0x44>
		cpu_cksel = ((cpu_shift - 1) << AVR32_PM_CPUSEL_CPUSEL)
80005d28:	ee f8 ff e8 	ld.w	r8,r7[-24]
80005d2c:	20 18       	sub	r8,1
80005d2e:	a7 b8       	sbr	r8,0x7
80005d30:	ef 48 ff f0 	st.w	r7[-16],r8
				| (1U << AVR32_PM_CPUDIV);

	if (pba_shift > 0)
80005d34:	ee f8 ff e4 	ld.w	r8,r7[-28]
80005d38:	58 08       	cp.w	r8,0
80005d3a:	c0 70       	breq	80005d48 <sysclk_set_prescalers+0x58>
		pba_cksel = ((pba_shift - 1) << AVR32_PM_PBASEL_PBSEL)
80005d3c:	ee f8 ff e4 	ld.w	r8,r7[-28]
80005d40:	20 18       	sub	r8,1
80005d42:	a7 b8       	sbr	r8,0x7
80005d44:	ef 48 ff f4 	st.w	r7[-12],r8
				| (1U << AVR32_PM_PBADIV);

	if (pbb_shift > 0)
80005d48:	ee f8 ff e0 	ld.w	r8,r7[-32]
80005d4c:	58 08       	cp.w	r8,0
80005d4e:	c0 70       	breq	80005d5c <sysclk_set_prescalers+0x6c>
		pbb_cksel = ((pbb_shift - 1) << AVR32_PM_PBBSEL_PBSEL)
80005d50:	ee f8 ff e0 	ld.w	r8,r7[-32]
80005d54:	20 18       	sub	r8,1
80005d56:	a7 b8       	sbr	r8,0x7
80005d58:	ef 48 ff f8 	st.w	r7[-8],r8
				| (1U << AVR32_PM_PBBDIV);

	if (pbc_shift > 0)
80005d5c:	ee f8 ff dc 	ld.w	r8,r7[-36]
80005d60:	58 08       	cp.w	r8,0
80005d62:	c0 70       	breq	80005d70 <sysclk_set_prescalers+0x80>
		pbc_cksel = ((pbc_shift - 1) << AVR32_PM_PBCSEL_PBSEL)
80005d64:	ee f8 ff dc 	ld.w	r8,r7[-36]
80005d68:	20 18       	sub	r8,1
80005d6a:	a7 b8       	sbr	r8,0x7
80005d6c:	ef 48 ff fc 	st.w	r7[-4],r8
				| (1U << AVR32_PM_PBCDIV);

	flags = cpu_irq_save();
80005d70:	f0 1f 00 1e 	mcall	80005de8 <sysclk_set_prescalers+0xf8>
80005d74:	18 98       	mov	r8,r12
80005d76:	ef 48 ff ec 	st.w	r7[-20],r8
	AVR32_PM.unlock = 0xaa000000 | AVR32_PM_CPUSEL;
80005d7a:	fe 78 04 00 	mov	r8,-64512
80005d7e:	30 49       	mov	r9,4
80005d80:	ea 19 aa 00 	orh	r9,0xaa00
80005d84:	f1 49 00 58 	st.w	r8[88],r9
	AVR32_PM.cpusel = cpu_cksel;
80005d88:	fe 78 04 00 	mov	r8,-64512
80005d8c:	ee f9 ff f0 	ld.w	r9,r7[-16]
80005d90:	91 19       	st.w	r8[0x4],r9
	AVR32_PM.unlock = 0xaa000000 | AVR32_PM_PBASEL;
80005d92:	fe 78 04 00 	mov	r8,-64512
80005d96:	30 c9       	mov	r9,12
80005d98:	ea 19 aa 00 	orh	r9,0xaa00
80005d9c:	f1 49 00 58 	st.w	r8[88],r9
	AVR32_PM.pbasel = pba_cksel;
80005da0:	fe 78 04 00 	mov	r8,-64512
80005da4:	ee f9 ff f4 	ld.w	r9,r7[-12]
80005da8:	91 39       	st.w	r8[0xc],r9
	AVR32_PM.unlock = 0xaa000000 | AVR32_PM_PBBSEL;
80005daa:	fe 78 04 00 	mov	r8,-64512
80005dae:	31 09       	mov	r9,16
80005db0:	ea 19 aa 00 	orh	r9,0xaa00
80005db4:	f1 49 00 58 	st.w	r8[88],r9
	AVR32_PM.pbbsel = pbb_cksel;
80005db8:	fe 78 04 00 	mov	r8,-64512
80005dbc:	ee f9 ff f8 	ld.w	r9,r7[-8]
80005dc0:	91 49       	st.w	r8[0x10],r9
	AVR32_PM.unlock = 0xaa000000 | AVR32_PM_PBCSEL;
80005dc2:	fe 78 04 00 	mov	r8,-64512
80005dc6:	31 49       	mov	r9,20
80005dc8:	ea 19 aa 00 	orh	r9,0xaa00
80005dcc:	f1 49 00 58 	st.w	r8[88],r9
	AVR32_PM.pbcsel = pbc_cksel;
80005dd0:	fe 78 04 00 	mov	r8,-64512
80005dd4:	ee f9 ff fc 	ld.w	r9,r7[-4]
80005dd8:	91 59       	st.w	r8[0x14],r9
	cpu_irq_restore(flags);
80005dda:	ee fc ff ec 	ld.w	r12,r7[-20]
80005dde:	f0 1f 00 04 	mcall	80005dec <sysclk_set_prescalers+0xfc>
}
80005de2:	2f 7d       	sub	sp,-36
80005de4:	e3 cd 80 80 	ldm	sp++,r7,pc
80005de8:	80 00       	ld.sh	r0,r0[0x0]
80005dea:	5c 88       	casts.h	r8
80005dec:	80 00       	ld.sh	r0,r0[0x0]
80005dee:	5c c8       	swap.bh	r8

80005df0 <sysclk_set_source>:
 *
 * \param src The new system clock source. Must be one of the constants
 * from the <em>System Clock Sources</em> section.
 */
void sysclk_set_source(uint_fast8_t src)
{
80005df0:	eb cd 40 80 	pushm	r7,lr
80005df4:	1a 97       	mov	r7,sp
80005df6:	20 2d       	sub	sp,8
80005df8:	ef 4c ff f8 	st.w	r7[-8],r12
	irqflags_t flags;

	Assert(src <= SYSCLK_SRC_RC120M);

	flags = cpu_irq_save();
80005dfc:	f0 1f 00 0c 	mcall	80005e2c <sysclk_set_source+0x3c>
80005e00:	18 98       	mov	r8,r12
80005e02:	ef 48 ff fc 	st.w	r7[-4],r8
	AVR32_PM.unlock = 0xaa000000 | AVR32_PM_MCCTRL;
80005e06:	fe 78 04 00 	mov	r8,-64512
80005e0a:	fc 19 aa 00 	movh	r9,0xaa00
80005e0e:	f1 49 00 58 	st.w	r8[88],r9
	AVR32_PM.mcctrl = src;
80005e12:	fe 78 04 00 	mov	r8,-64512
80005e16:	ee f9 ff f8 	ld.w	r9,r7[-8]
80005e1a:	91 09       	st.w	r8[0x0],r9
	cpu_irq_restore(flags);
80005e1c:	ee fc ff fc 	ld.w	r12,r7[-4]
80005e20:	f0 1f 00 04 	mcall	80005e30 <sysclk_set_source+0x40>
}
80005e24:	2f ed       	sub	sp,-8
80005e26:	e3 cd 80 80 	ldm	sp++,r7,pc
80005e2a:	00 00       	add	r0,r0
80005e2c:	80 00       	ld.sh	r0,r0[0x0]
80005e2e:	5c 88       	casts.h	r8
80005e30:	80 00       	ld.sh	r0,r0[0x0]
80005e32:	5c c8       	swap.bh	r8

80005e34 <twi_master_read>:
 *                     (see \ref twim_package_t)
 * \return STATUS_OK   If all bytes were read, error code otherwise
 */
static inline status_code_t twi_master_read (volatile avr32_twi_t *twim,
		const twi_package_t *package)
{
80005e34:	eb cd 40 80 	pushm	r7,lr
80005e38:	1a 97       	mov	r7,sp
80005e3a:	20 2d       	sub	sp,8
80005e3c:	ef 4c ff fc 	st.w	r7[-4],r12
80005e40:	ef 4b ff f8 	st.w	r7[-8],r11
	return (twim_read_packet (twim, package));
80005e44:	ee fb ff f8 	ld.w	r11,r7[-8]
80005e48:	ee fc ff fc 	ld.w	r12,r7[-4]
80005e4c:	f0 1f 00 04 	mcall	80005e5c <twi_master_read+0x28>
80005e50:	18 98       	mov	r8,r12
}
80005e52:	10 9c       	mov	r12,r8
80005e54:	2f ed       	sub	sp,-8
80005e56:	e3 cd 80 80 	ldm	sp++,r7,pc
80005e5a:	00 00       	add	r0,r0
80005e5c:	80 00       	ld.sh	r0,r0[0x0]
80005e5e:	51 8c       	stdsp	sp[0x60],r12

80005e60 <twi_master_write>:
 *                     (see \ref twim_package_t)
 * \return STATUS_OK   if all bytes were written, error code otherwise
 */
static inline status_code_t twi_master_write (volatile avr32_twi_t *twim,
		const twi_package_t *package)
{
80005e60:	eb cd 40 80 	pushm	r7,lr
80005e64:	1a 97       	mov	r7,sp
80005e66:	20 2d       	sub	sp,8
80005e68:	ef 4c ff fc 	st.w	r7[-4],r12
80005e6c:	ef 4b ff f8 	st.w	r7[-8],r11
	return (twim_write_packet (twim, package));
80005e70:	ee fb ff f8 	ld.w	r11,r7[-8]
80005e74:	ee fc ff fc 	ld.w	r12,r7[-4]
80005e78:	f0 1f 00 04 	mcall	80005e88 <twi_master_write+0x28>
80005e7c:	18 98       	mov	r8,r12
}
80005e7e:	10 9c       	mov	r12,r8
80005e80:	2f ed       	sub	sp,-8
80005e82:	e3 cd 80 80 	ldm	sp++,r7,pc
80005e86:	00 00       	add	r0,r0
80005e88:	80 00       	ld.sh	r0,r0[0x0]
80005e8a:	53 08       	stdsp	sp[0xc0],r8

80005e8c <PCA9952_write_reg>:
 *
 * \param reg_index Register address. Use macros as defined in the header file.
 * \param data Data that should be written to the device register.
 */
void PCA9952_write_reg(unsigned char topBotn, uint8_t reg_index, uint8_t data)
{
80005e8c:	eb cd 40 80 	pushm	r7,lr
80005e90:	1a 97       	mov	r7,sp
80005e92:	20 9d       	sub	sp,36
80005e94:	16 99       	mov	r9,r11
80005e96:	14 98       	mov	r8,r10
80005e98:	18 9a       	mov	r10,r12
80005e9a:	ef 6a ff e4 	st.b	r7[-28],r10
80005e9e:	ef 69 ff e0 	st.b	r7[-32],r9
80005ea2:	ef 68 ff dc 	st.b	r7[-36],r8
uint8_t pack[2];
twi_package_t twi_package;

	pack[0] = reg_index;
80005ea6:	ef 38 ff e0 	ld.ub	r8,r7[-32]
80005eaa:	ef 68 ff fc 	st.b	r7[-4],r8
	pack[1] = data;
80005eae:	ef 38 ff dc 	ld.ub	r8,r7[-36]
80005eb2:	ef 68 ff fd 	st.b	r7[-3],r8

//7apr15	twi_package.chip = PCA9952_TWI_ADDRESS;

	if (topBotn == LED_TOP)
80005eb6:	ef 39 ff e4 	ld.ub	r9,r7[-28]
80005eba:	30 08       	mov	r8,0
80005ebc:	f0 09 18 00 	cp.b	r9,r8
80005ec0:	c0 51       	brne	80005eca <PCA9952_write_reg+0x3e>
	{
		twi_package.chip = PCA9952_U7_TOPDRIVE_TWI_ADDRESS;
80005ec2:	36 08       	mov	r8,96
80005ec4:	ef 48 ff e8 	st.w	r7[-24],r8
80005ec8:	c0 a8       	rjmp	80005edc <PCA9952_write_reg+0x50>
	}
	else if (topBotn == LED_BOTTOM)
80005eca:	ef 39 ff e4 	ld.ub	r9,r7[-28]
80005ece:	30 18       	mov	r8,1
80005ed0:	f0 09 18 00 	cp.b	r9,r8
80005ed4:	c0 41       	brne	80005edc <PCA9952_write_reg+0x50>
	{
		twi_package.chip = PCA9952_U8_BOTDRIVE_TWI_ADDRESS;
80005ed6:	36 18       	mov	r8,97
80005ed8:	ef 48 ff e8 	st.w	r7[-24],r8
	}

	twi_package.addr_length = 0;
80005edc:	30 08       	mov	r8,0
80005ede:	ef 68 ff ef 	st.b	r7[-17],r8
	twi_package.buffer = &pack;
80005ee2:	ee c8 00 04 	sub	r8,r7,4
80005ee6:	ef 48 ff f0 	st.w	r7[-16],r8
	twi_package.length = sizeof(pack);
80005eea:	30 28       	mov	r8,2
80005eec:	ef 48 ff f4 	st.w	r7[-12],r8

	while(twi_master_write(PCA9952_TWI, &twi_package)!=TWI_SUCCESS);
80005ef0:	ee c8 00 18 	sub	r8,r7,24
80005ef4:	10 9b       	mov	r11,r8
80005ef6:	fe 7c 38 00 	mov	r12,-51200
80005efa:	f0 1f 00 05 	mcall	80005f0c <PCA9952_write_reg+0x80>
80005efe:	18 98       	mov	r8,r12
80005f00:	58 08       	cp.w	r8,0
80005f02:	cf 71       	brne	80005ef0 <PCA9952_write_reg+0x64>

	return;
}
80005f04:	2f 7d       	sub	sp,-36
80005f06:	e3 cd 80 80 	ldm	sp++,r7,pc
80005f0a:	00 00       	add	r0,r0
80005f0c:	80 00       	ld.sh	r0,r0[0x0]
80005f0e:	5e 60       	retmi	r0

80005f10 <PCA9952_read_reg>:
 *
 * \param reg_index Register address.
 * \returns Register content.
 */
uint8_t PCA9952_read_reg(unsigned char topBotn, uint8_t reg_index)
{
80005f10:	eb cd 40 8f 	pushm	r0-r3,r7,lr
80005f14:	1a 97       	mov	r7,sp
80005f16:	21 3d       	sub	sp,76
80005f18:	18 99       	mov	r9,r12
80005f1a:	16 98       	mov	r8,r11
80005f1c:	ef 69 ff b8 	st.b	r7[-72],r9
80005f20:	ef 68 ff b4 	st.b	r7[-76],r8
uint8_t data;
twi_package_t twi_package;

//7apr15	twi_package.chip = PCA9952_TWI_ADDRESS;

	if (topBotn == LED_TOP)
80005f24:	ef 39 ff b8 	ld.ub	r9,r7[-72]
80005f28:	30 08       	mov	r8,0
80005f2a:	f0 09 18 00 	cp.b	r9,r8
80005f2e:	c0 51       	brne	80005f38 <PCA9952_read_reg+0x28>
	{
		twi_package.chip = PCA9952_U7_TOPDRIVE_TWI_ADDRESS;
80005f30:	36 08       	mov	r8,96
80005f32:	ef 48 ff c8 	st.w	r7[-56],r8
80005f36:	c0 a8       	rjmp	80005f4a <PCA9952_read_reg+0x3a>
	}
	else if (topBotn == LED_BOTTOM)
80005f38:	ef 39 ff b8 	ld.ub	r9,r7[-72]
80005f3c:	30 18       	mov	r8,1
80005f3e:	f0 09 18 00 	cp.b	r9,r8
80005f42:	c0 41       	brne	80005f4a <PCA9952_read_reg+0x3a>
	{
		twi_package.chip = PCA9952_U8_BOTDRIVE_TWI_ADDRESS;
80005f44:	36 18       	mov	r8,97
80005f46:	ef 48 ff c8 	st.w	r7[-56],r8
	}

	twi_package.addr_length = 0;
80005f4a:	30 08       	mov	r8,0
80005f4c:	ef 68 ff cf 	st.b	r7[-49],r8
	twi_package.buffer = &reg_index;
80005f50:	ee c8 00 4c 	sub	r8,r7,76
80005f54:	ef 48 ff d0 	st.w	r7[-48],r8
	twi_package.length = 1;
80005f58:	30 18       	mov	r8,1
80005f5a:	ef 48 ff d4 	st.w	r7[-44],r8
	while(twi_master_write(PCA9952_TWI, &twi_package)!=TWI_SUCCESS);
80005f5e:	ee c8 00 38 	sub	r8,r7,56
80005f62:	10 9b       	mov	r11,r8
80005f64:	fe 7c 38 00 	mov	r12,-51200
80005f68:	f0 1f 00 5e 	mcall	800060e0 <PCA9952_read_reg+0x1d0>
80005f6c:	18 98       	mov	r8,r12
80005f6e:	58 08       	cp.w	r8,0
80005f70:	cf 71       	brne	80005f5e <PCA9952_read_reg+0x4e>
	* specified in the datasheet.
	* Also there seems to be a bug in the TWI module or the driver
	* since some delay here (code or real delay) adds about 500us
	* between the write and the next read cycle.
	*/
	cpu_delay_us(20, cpu_hz);
80005f72:	4d d8       	lddpc	r8,800060e4 <PCA9952_read_reg+0x1d4>
80005f74:	70 08       	ld.w	r8,r8[0x0]
80005f76:	31 49       	mov	r9,20
80005f78:	ef 49 ff e4 	st.w	r7[-28],r9
80005f7c:	ef 48 ff e0 	st.w	r7[-32],r8
80005f80:	ee f8 ff e4 	ld.w	r8,r7[-28]
80005f84:	ef 48 ff ec 	st.w	r7[-20],r8
80005f88:	ee f8 ff e0 	ld.w	r8,r7[-32]
80005f8c:	ef 48 ff e8 	st.w	r7[-24],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_us_2_cy(unsigned long us, unsigned long fcpu_hz)
{
  return ((unsigned long long)us * fcpu_hz + 999999) / 1000000;
80005f90:	ee f0 ff ec 	ld.w	r0,r7[-20]
80005f94:	30 01       	mov	r1,0
80005f96:	ee f2 ff e8 	ld.w	r2,r7[-24]
80005f9a:	30 03       	mov	r3,0
80005f9c:	e2 02 02 4a 	mul	r10,r1,r2
80005fa0:	e6 00 02 48 	mul	r8,r3,r0
80005fa4:	10 0a       	add	r10,r8
80005fa6:	e0 02 06 48 	mulu.d	r8,r0,r2
80005faa:	12 0a       	add	r10,r9
80005fac:	14 99       	mov	r9,r10
80005fae:	ee 7a 42 3f 	mov	r10,999999
80005fb2:	30 0b       	mov	r11,0
80005fb4:	f0 0a 00 0a 	add	r10,r8,r10
80005fb8:	f2 0b 00 4b 	adc	r11,r9,r11
80005fbc:	ee 78 42 40 	mov	r8,1000000
80005fc0:	30 09       	mov	r9,0
80005fc2:	f0 1f 00 4a 	mcall	800060e8 <PCA9952_read_reg+0x1d8>
80005fc6:	14 98       	mov	r8,r10
80005fc8:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_us(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_us_2_cy(delay, fcpu_hz), &timer);
80005fca:	ef 48 ff f4 	st.w	r7[-12],r8
80005fce:	ee c8 00 44 	sub	r8,r7,68
80005fd2:	ef 48 ff f0 	st.w	r7[-16],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80005fd6:	e1 b8 00 42 	mfsr	r8,0x108
80005fda:	10 99       	mov	r9,r8
80005fdc:	ee f8 ff f0 	ld.w	r8,r7[-16]
80005fe0:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80005fe2:	ee f8 ff f0 	ld.w	r8,r7[-16]
80005fe6:	70 09       	ld.w	r9,r8[0x0]
80005fe8:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005fec:	10 09       	add	r9,r8
80005fee:	ee f8 ff f0 	ld.w	r8,r7[-16]
80005ff2:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
80005ff4:	ee f9 ff f0 	ld.w	r9,r7[-16]
80005ff8:	30 08       	mov	r8,0
80005ffa:	f3 68 00 08 	st.b	r9[8],r8
80005ffe:	ee c8 00 44 	sub	r8,r7,68
80006002:	ef 48 ff f8 	st.w	r7[-8],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80006006:	e1 b8 00 42 	mfsr	r8,0x108
8000600a:	ef 48 ff fc 	st.w	r7[-4],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
8000600e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006012:	f1 39 00 08 	ld.ub	r9,r8[8]
80006016:	30 28       	mov	r8,2
80006018:	f0 09 18 00 	cp.b	r9,r8
8000601c:	c0 31       	brne	80006022 <PCA9952_read_reg+0x112>
    return false;
8000601e:	30 08       	mov	r8,0
80006020:	c4 38       	rjmp	800060a6 <PCA9952_read_reg+0x196>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
80006022:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006026:	f1 39 00 08 	ld.ub	r9,r8[8]
8000602a:	30 18       	mov	r8,1
8000602c:	f0 09 18 00 	cp.b	r9,r8
80006030:	c0 31       	brne	80006036 <PCA9952_read_reg+0x126>
    return true;
80006032:	30 18       	mov	r8,1
80006034:	c3 98       	rjmp	800060a6 <PCA9952_read_reg+0x196>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80006036:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000603a:	70 09       	ld.w	r9,r8[0x0]
8000603c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006040:	70 18       	ld.w	r8,r8[0x4]
80006042:	10 39       	cp.w	r9,r8
80006044:	e0 88 00 1a 	brls	80006078 <PCA9952_read_reg+0x168>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80006048:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000604c:	70 08       	ld.w	r8,r8[0x0]
8000604e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006052:	10 39       	cp.w	r9,r8
80006054:	c1 02       	brcc	80006074 <PCA9952_read_reg+0x164>
80006056:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000605a:	70 18       	ld.w	r8,r8[0x4]
8000605c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006060:	10 39       	cp.w	r9,r8
80006062:	e0 88 00 09 	brls	80006074 <PCA9952_read_reg+0x164>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80006066:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000606a:	30 18       	mov	r8,1
8000606c:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80006070:	30 18       	mov	r8,1
80006072:	c1 a8       	rjmp	800060a6 <PCA9952_read_reg+0x196>
    }
    return false;
80006074:	30 08       	mov	r8,0
80006076:	c1 88       	rjmp	800060a6 <PCA9952_read_reg+0x196>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80006078:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000607c:	70 08       	ld.w	r8,r8[0x0]
8000607e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006082:	10 39       	cp.w	r9,r8
80006084:	c0 93       	brcs	80006096 <PCA9952_read_reg+0x186>
80006086:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000608a:	70 18       	ld.w	r8,r8[0x4]
8000608c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006090:	10 39       	cp.w	r9,r8
80006092:	e0 88 00 09 	brls	800060a4 <PCA9952_read_reg+0x194>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80006096:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000609a:	30 18       	mov	r8,1
8000609c:	f3 68 00 08 	st.b	r9[8],r8
      return true;
800060a0:	30 18       	mov	r8,1
800060a2:	c0 28       	rjmp	800060a6 <PCA9952_read_reg+0x196>
    }
    return false;
800060a4:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_us(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_us_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
800060a6:	58 08       	cp.w	r8,0
800060a8:	ca b0       	breq	80005ffe <PCA9952_read_reg+0xee>

//7apr15 this was set above, no need to reassign	twi_package.chip = PCA9952_TWI_ADDRESS;
	twi_package.addr_length = 0;
800060aa:	30 08       	mov	r8,0
800060ac:	ef 68 ff cf 	st.b	r7[-49],r8
	twi_package.buffer = &data;
800060b0:	ee c8 00 21 	sub	r8,r7,33
800060b4:	ef 48 ff d0 	st.w	r7[-48],r8
	twi_package.length = 1;
800060b8:	30 18       	mov	r8,1
800060ba:	ef 48 ff d4 	st.w	r7[-44],r8
	while(twi_master_read(PCA9952_TWI, &twi_package)!=TWI_SUCCESS);
800060be:	ee c8 00 38 	sub	r8,r7,56
800060c2:	10 9b       	mov	r11,r8
800060c4:	fe 7c 38 00 	mov	r12,-51200
800060c8:	f0 1f 00 09 	mcall	800060ec <PCA9952_read_reg+0x1dc>
800060cc:	18 98       	mov	r8,r12
800060ce:	58 08       	cp.w	r8,0
800060d0:	cf 71       	brne	800060be <PCA9952_read_reg+0x1ae>

	return data;
800060d2:	ef 38 ff df 	ld.ub	r8,r7[-33]
}
800060d6:	10 9c       	mov	r12,r8
800060d8:	2e dd       	sub	sp,-76
800060da:	e3 cd 80 8f 	ldm	sp++,r0-r3,r7,pc
800060de:	00 00       	add	r0,r0
800060e0:	80 00       	ld.sh	r0,r0[0x0]
800060e2:	5e 60       	retmi	r0
800060e4:	00 00       	add	r0,r0
800060e6:	07 b4       	ld.ub	r4,r3[0x3]
800060e8:	80 00       	ld.sh	r0,r0[0x0]
800060ea:	ca 56       	brmi	80006034 <PCA9952_read_reg+0x124>
800060ec:	80 00       	ld.sh	r0,r0[0x0]
800060ee:	5e 34       	retlo	r4

800060f0 <PCA9952_init>:


void PCA9952_init(void) //7apr15
{
800060f0:	eb cd 40 80 	pushm	r7,lr
800060f4:	1a 97       	mov	r7,sp
800060f6:	20 1d       	sub	sp,4
	/* Store cpu frequency locally*/
//7apr15	cpu_hz = fcpu;

	//Note output is off at the chip level before coming into this routine, LED_OEn set high before calling this function from main()

	PCA9952_write_reg(LED_TOP, PCA9952_MODE1, 0);		//No autoincrement, normal mode not sleep, does not respond to sub or allcall addresses
800060f8:	30 0a       	mov	r10,0
800060fa:	30 0b       	mov	r11,0
800060fc:	30 0c       	mov	r12,0
800060fe:	f0 1f 00 33 	mcall	800061c8 <PCA9952_init+0xd8>
	PCA9952_write_reg(LED_TOP, PCA9952_MODE2, 0);		//Dimming not blinking, change on stop not ack (don't really care but have to pick something)
80006102:	30 0a       	mov	r10,0
80006104:	30 1b       	mov	r11,1
80006106:	30 0c       	mov	r12,0
80006108:	f0 1f 00 30 	mcall	800061c8 <PCA9952_init+0xd8>
	PCA9952_write_reg(LED_TOP, PCA9952_IREFALL, LED_DRIVER_CURRENT); //9apr15 drive at half current for now, power supply circuit needs modification
8000610c:	e0 6a 00 c8 	mov	r10,200
80006110:	34 3b       	mov	r11,67
80006112:	30 0c       	mov	r12,0
80006114:	f0 1f 00 2d 	mcall	800061c8 <PCA9952_init+0xd8>
	PCA9952_write_reg(LED_TOP, PCA9952_LEDOUT0, 0);		//Setting all channels off for now
80006118:	30 0a       	mov	r10,0
8000611a:	30 2b       	mov	r11,2
8000611c:	30 0c       	mov	r12,0
8000611e:	f0 1f 00 2b 	mcall	800061c8 <PCA9952_init+0xd8>
	PCA9952_write_reg(LED_TOP, PCA9952_LEDOUT1, 0);
80006122:	30 0a       	mov	r10,0
80006124:	30 3b       	mov	r11,3
80006126:	30 0c       	mov	r12,0
80006128:	f0 1f 00 28 	mcall	800061c8 <PCA9952_init+0xd8>
	PCA9952_write_reg(LED_TOP, PCA9952_LEDOUT2, 0);
8000612c:	30 0a       	mov	r10,0
8000612e:	30 4b       	mov	r11,4
80006130:	30 0c       	mov	r12,0
80006132:	f0 1f 00 26 	mcall	800061c8 <PCA9952_init+0xd8>
	PCA9952_write_reg(LED_TOP, PCA9952_LEDOUT3, 0);
80006136:	30 0a       	mov	r10,0
80006138:	30 5b       	mov	r11,5
8000613a:	30 0c       	mov	r12,0
8000613c:	f0 1f 00 23 	mcall	800061c8 <PCA9952_init+0xd8>

	tmp1 = PCA9952_read_reg(LED_TOP, PCA9952_EFLAG0);	//TODO: just see what we get, will need to weave error checking into this system later
80006140:	34 4b       	mov	r11,68
80006142:	30 0c       	mov	r12,0
80006144:	f0 1f 00 22 	mcall	800061cc <PCA9952_init+0xdc>
80006148:	18 98       	mov	r8,r12
8000614a:	ef 68 ff ff 	st.b	r7[-1],r8
	tmp2 = PCA9952_read_reg(LED_TOP, PCA9952_EFLAG1);
8000614e:	34 5b       	mov	r11,69
80006150:	30 0c       	mov	r12,0
80006152:	f0 1f 00 1f 	mcall	800061cc <PCA9952_init+0xdc>
80006156:	18 98       	mov	r8,r12
80006158:	ef 68 ff fe 	st.b	r7[-2],r8

	PCA9952_write_reg(LED_BOTTOM, PCA9952_MODE1, 0);		//No autoincrement, normal mode not sleep, does not respond to sub or allcall addresses
8000615c:	30 0a       	mov	r10,0
8000615e:	30 0b       	mov	r11,0
80006160:	30 1c       	mov	r12,1
80006162:	f0 1f 00 1a 	mcall	800061c8 <PCA9952_init+0xd8>
	PCA9952_write_reg(LED_BOTTOM, PCA9952_MODE2, 0);		//Dimming not blinking, change on stop not ack (don't really care but have to pick something)
80006166:	30 0a       	mov	r10,0
80006168:	30 1b       	mov	r11,1
8000616a:	30 1c       	mov	r12,1
8000616c:	f0 1f 00 17 	mcall	800061c8 <PCA9952_init+0xd8>
	PCA9952_write_reg(LED_BOTTOM, PCA9952_IREFALL, LED_DRIVER_CURRENT); //9apr15 drive at half current for now, power supply circuit needs modification
80006170:	e0 6a 00 c8 	mov	r10,200
80006174:	34 3b       	mov	r11,67
80006176:	30 1c       	mov	r12,1
80006178:	f0 1f 00 14 	mcall	800061c8 <PCA9952_init+0xd8>
	PCA9952_write_reg(LED_BOTTOM, PCA9952_LEDOUT0, 0);		//Setting all channels off for now
8000617c:	30 0a       	mov	r10,0
8000617e:	30 2b       	mov	r11,2
80006180:	30 1c       	mov	r12,1
80006182:	f0 1f 00 12 	mcall	800061c8 <PCA9952_init+0xd8>
	PCA9952_write_reg(LED_BOTTOM, PCA9952_LEDOUT1, 0);
80006186:	30 0a       	mov	r10,0
80006188:	30 3b       	mov	r11,3
8000618a:	30 1c       	mov	r12,1
8000618c:	f0 1f 00 0f 	mcall	800061c8 <PCA9952_init+0xd8>
	PCA9952_write_reg(LED_BOTTOM, PCA9952_LEDOUT2, 0);
80006190:	30 0a       	mov	r10,0
80006192:	30 4b       	mov	r11,4
80006194:	30 1c       	mov	r12,1
80006196:	f0 1f 00 0d 	mcall	800061c8 <PCA9952_init+0xd8>
	PCA9952_write_reg(LED_BOTTOM, PCA9952_LEDOUT3, 0);
8000619a:	30 0a       	mov	r10,0
8000619c:	30 5b       	mov	r11,5
8000619e:	30 1c       	mov	r12,1
800061a0:	f0 1f 00 0a 	mcall	800061c8 <PCA9952_init+0xd8>

	tmp3 = PCA9952_read_reg(LED_BOTTOM, PCA9952_EFLAG0);	//TODO: just see what we get, will need to weave error checking into this system later
800061a4:	34 4b       	mov	r11,68
800061a6:	30 1c       	mov	r12,1
800061a8:	f0 1f 00 09 	mcall	800061cc <PCA9952_init+0xdc>
800061ac:	18 98       	mov	r8,r12
800061ae:	ef 68 ff fd 	st.b	r7[-3],r8
	tmp4 = PCA9952_read_reg(LED_BOTTOM, PCA9952_EFLAG1);
800061b2:	34 5b       	mov	r11,69
800061b4:	30 1c       	mov	r12,1
800061b6:	f0 1f 00 06 	mcall	800061cc <PCA9952_init+0xdc>
800061ba:	18 98       	mov	r8,r12
800061bc:	ef 68 ff fc 	st.b	r7[-4],r8

}
800061c0:	2f fd       	sub	sp,-4
800061c2:	e3 cd 80 80 	ldm	sp++,r7,pc
800061c6:	00 00       	add	r0,r0
800061c8:	80 00       	ld.sh	r0,r0[0x0]
800061ca:	5e 8c       	retls	r12
800061cc:	80 00       	ld.sh	r0,r0[0x0]
800061ce:	5f 10       	srne	r0

800061d0 <PCA9952_channel>:


void PCA9952_channel(unsigned char topBotn, unsigned char channel, unsigned char onOffn);
void PCA9952_channel(unsigned char topBotn, unsigned char channel, unsigned char onOffn)
{
800061d0:	eb cd 40 80 	pushm	r7,lr
800061d4:	1a 97       	mov	r7,sp
800061d6:	20 5d       	sub	sp,20
800061d8:	16 99       	mov	r9,r11
800061da:	14 98       	mov	r8,r10
800061dc:	18 9a       	mov	r10,r12
800061de:	ef 6a ff f4 	st.b	r7[-12],r10
800061e2:	ef 69 ff f0 	st.b	r7[-16],r9
800061e6:	ef 68 ff ec 	st.b	r7[-20],r8
	unsigned char regIdx, regPos, regShadow, maskVal, writeVal;
	
	regIdx = (channel / 4); //LEDOUT0 controls channels 0..3, LEDOUT1 controls channels 4..7 etc.
800061ea:	ef 38 ff f0 	ld.ub	r8,r7[-16]
800061ee:	a3 88       	lsr	r8,0x2
800061f0:	ef 68 ff fb 	st.b	r7[-5],r8
	regPos = (channel % 4);
800061f4:	ef 38 ff f0 	ld.ub	r8,r7[-16]
800061f8:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800061fc:	ef 68 ff fc 	st.b	r7[-4],r8
	
	switch(regIdx)
80006200:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80006204:	58 18       	cp.w	r8,1
80006206:	c1 50       	breq	80006230 <PCA9952_channel+0x60>
80006208:	e0 89 00 05 	brgt	80006212 <PCA9952_channel+0x42>
8000620c:	58 08       	cp.w	r8,0
8000620e:	c0 70       	breq	8000621c <PCA9952_channel+0x4c>
80006210:	c2 d8       	rjmp	8000626a <PCA9952_channel+0x9a>
80006212:	58 28       	cp.w	r8,2
80006214:	c1 80       	breq	80006244 <PCA9952_channel+0x74>
80006216:	58 38       	cp.w	r8,3
80006218:	c2 00       	breq	80006258 <PCA9952_channel+0x88>
8000621a:	c2 88       	rjmp	8000626a <PCA9952_channel+0x9a>
	{
		case 0:
			regShadow = PCA9952_read_reg(topBotn,PCA9952_LEDOUT0);
8000621c:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80006220:	30 2b       	mov	r11,2
80006222:	10 9c       	mov	r12,r8
80006224:	f0 1f 00 49 	mcall	80006348 <PCA9952_channel+0x178>
80006228:	18 98       	mov	r8,r12
8000622a:	ef 68 ff fd 	st.b	r7[-3],r8
			break;
8000622e:	c1 e8       	rjmp	8000626a <PCA9952_channel+0x9a>
		case 1:
			regShadow = PCA9952_read_reg(topBotn,PCA9952_LEDOUT1);
80006230:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80006234:	30 3b       	mov	r11,3
80006236:	10 9c       	mov	r12,r8
80006238:	f0 1f 00 44 	mcall	80006348 <PCA9952_channel+0x178>
8000623c:	18 98       	mov	r8,r12
8000623e:	ef 68 ff fd 	st.b	r7[-3],r8
			break;
80006242:	c1 48       	rjmp	8000626a <PCA9952_channel+0x9a>
		case 2:
			regShadow = PCA9952_read_reg(topBotn,PCA9952_LEDOUT2);
80006244:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80006248:	30 4b       	mov	r11,4
8000624a:	10 9c       	mov	r12,r8
8000624c:	f0 1f 00 3f 	mcall	80006348 <PCA9952_channel+0x178>
80006250:	18 98       	mov	r8,r12
80006252:	ef 68 ff fd 	st.b	r7[-3],r8
			break;
80006256:	c0 a8       	rjmp	8000626a <PCA9952_channel+0x9a>
		case 3:
			regShadow = PCA9952_read_reg(topBotn,PCA9952_LEDOUT3);
80006258:	ef 38 ff f4 	ld.ub	r8,r7[-12]
8000625c:	30 5b       	mov	r11,5
8000625e:	10 9c       	mov	r12,r8
80006260:	f0 1f 00 3a 	mcall	80006348 <PCA9952_channel+0x178>
80006264:	18 98       	mov	r8,r12
80006266:	ef 68 ff fd 	st.b	r7[-3],r8
			break;		
	}

	maskVal = 0xFF << (regPos * 2);
8000626a:	ef 38 ff fc 	ld.ub	r8,r7[-4]
8000626e:	a1 78       	lsl	r8,0x1
80006270:	e0 69 00 ff 	mov	r9,255
80006274:	f2 08 09 48 	lsl	r8,r9,r8
80006278:	ef 68 ff fe 	st.b	r7[-2],r8
	maskVal = maskVal ^ 0xFF;
8000627c:	ef 38 ff fe 	ld.ub	r8,r7[-2]
80006280:	5c d8       	com	r8
80006282:	ef 68 ff fe 	st.b	r7[-2],r8
	regShadow &= maskVal;
80006286:	ef 39 ff fd 	ld.ub	r9,r7[-3]
8000628a:	ef 38 ff fe 	ld.ub	r8,r7[-2]
8000628e:	f3 e8 00 08 	and	r8,r9,r8
80006292:	ef 68 ff fd 	st.b	r7[-3],r8

	if (onOffn == LED_ON)
80006296:	ef 39 ff ec 	ld.ub	r9,r7[-20]
8000629a:	30 18       	mov	r8,1
8000629c:	f0 09 18 00 	cp.b	r9,r8
800062a0:	c0 a1       	brne	800062b4 <PCA9952_channel+0xe4>
	{
		writeVal = (0x01 << (regPos * 2));
800062a2:	ef 38 ff fc 	ld.ub	r8,r7[-4]
800062a6:	a1 78       	lsl	r8,0x1
800062a8:	30 19       	mov	r9,1
800062aa:	f2 08 09 48 	lsl	r8,r9,r8
800062ae:	ef 68 ff ff 	st.b	r7[-1],r8
800062b2:	c0 a8       	rjmp	800062c6 <PCA9952_channel+0xf6>
	}
	else if (onOffn == LED_OFF)
800062b4:	ef 39 ff ec 	ld.ub	r9,r7[-20]
800062b8:	30 08       	mov	r8,0
800062ba:	f0 09 18 00 	cp.b	r9,r8
800062be:	c0 41       	brne	800062c6 <PCA9952_channel+0xf6>
	{
		writeVal = 0;
800062c0:	30 08       	mov	r8,0
800062c2:	ef 68 ff ff 	st.b	r7[-1],r8
	}
	
	regShadow |= writeVal;
800062c6:	ef 39 ff fd 	ld.ub	r9,r7[-3]
800062ca:	ef 38 ff ff 	ld.ub	r8,r7[-1]
800062ce:	f3 e8 10 08 	or	r8,r9,r8
800062d2:	ef 68 ff fd 	st.b	r7[-3],r8
	
	switch(regIdx)
800062d6:	ef 38 ff fb 	ld.ub	r8,r7[-5]
800062da:	58 18       	cp.w	r8,1
800062dc:	c1 50       	breq	80006306 <PCA9952_channel+0x136>
800062de:	e0 89 00 05 	brgt	800062e8 <PCA9952_channel+0x118>
800062e2:	58 08       	cp.w	r8,0
800062e4:	c0 70       	breq	800062f2 <PCA9952_channel+0x122>
800062e6:	c2 d8       	rjmp	80006340 <PCA9952_channel+0x170>
800062e8:	58 28       	cp.w	r8,2
800062ea:	c1 80       	breq	8000631a <PCA9952_channel+0x14a>
800062ec:	58 38       	cp.w	r8,3
800062ee:	c2 00       	breq	8000632e <PCA9952_channel+0x15e>
800062f0:	c2 88       	rjmp	80006340 <PCA9952_channel+0x170>
	{
		case 0:
			PCA9952_write_reg(topBotn,PCA9952_LEDOUT0, regShadow);
800062f2:	ef 39 ff fd 	ld.ub	r9,r7[-3]
800062f6:	ef 38 ff f4 	ld.ub	r8,r7[-12]
800062fa:	12 9a       	mov	r10,r9
800062fc:	30 2b       	mov	r11,2
800062fe:	10 9c       	mov	r12,r8
80006300:	f0 1f 00 13 	mcall	8000634c <PCA9952_channel+0x17c>
			break;
80006304:	c1 e8       	rjmp	80006340 <PCA9952_channel+0x170>
		case 1:
			PCA9952_write_reg(topBotn,PCA9952_LEDOUT1, regShadow);
80006306:	ef 39 ff fd 	ld.ub	r9,r7[-3]
8000630a:	ef 38 ff f4 	ld.ub	r8,r7[-12]
8000630e:	12 9a       	mov	r10,r9
80006310:	30 3b       	mov	r11,3
80006312:	10 9c       	mov	r12,r8
80006314:	f0 1f 00 0e 	mcall	8000634c <PCA9952_channel+0x17c>
			break;
80006318:	c1 48       	rjmp	80006340 <PCA9952_channel+0x170>
		case 2:
			PCA9952_write_reg(topBotn,PCA9952_LEDOUT2, regShadow);
8000631a:	ef 39 ff fd 	ld.ub	r9,r7[-3]
8000631e:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80006322:	12 9a       	mov	r10,r9
80006324:	30 4b       	mov	r11,4
80006326:	10 9c       	mov	r12,r8
80006328:	f0 1f 00 09 	mcall	8000634c <PCA9952_channel+0x17c>
			break;
8000632c:	c0 a8       	rjmp	80006340 <PCA9952_channel+0x170>
		case 3:
			PCA9952_write_reg(topBotn,PCA9952_LEDOUT3, regShadow);
8000632e:	ef 39 ff fd 	ld.ub	r9,r7[-3]
80006332:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80006336:	12 9a       	mov	r10,r9
80006338:	30 5b       	mov	r11,5
8000633a:	10 9c       	mov	r12,r8
8000633c:	f0 1f 00 04 	mcall	8000634c <PCA9952_channel+0x17c>
			break;
	}

}
80006340:	2f bd       	sub	sp,-20
80006342:	e3 cd 80 80 	ldm	sp++,r7,pc
80006346:	00 00       	add	r0,r0
80006348:	80 00       	ld.sh	r0,r0[0x0]
8000634a:	5f 10       	srne	r0
8000634c:	80 00       	ld.sh	r0,r0[0x0]
8000634e:	5e 8c       	retls	r12

80006350 <led_shelf>:

void led_shelf(unsigned char shelf, unsigned char onOffn)
{
80006350:	eb cd 40 80 	pushm	r7,lr
80006354:	1a 97       	mov	r7,sp
80006356:	20 2d       	sub	sp,8
80006358:	18 99       	mov	r9,r12
8000635a:	16 98       	mov	r8,r11
8000635c:	ef 69 ff fc 	st.b	r7[-4],r9
80006360:	ef 68 ff f8 	st.b	r7[-8],r8
	switch(shelf)
80006364:	ef 38 ff fc 	ld.ub	r8,r7[-4]
80006368:	58 18       	cp.w	r8,1
8000636a:	c2 f0       	breq	800063c8 <led_shelf+0x78>
8000636c:	e0 89 00 05 	brgt	80006376 <led_shelf+0x26>
80006370:	58 08       	cp.w	r8,0
80006372:	c0 70       	breq	80006380 <led_shelf+0x30>
80006374:	c9 58       	rjmp	8000649e <led_shelf+0x14e>
80006376:	58 28       	cp.w	r8,2
80006378:	c4 c0       	breq	80006410 <led_shelf+0xc0>
8000637a:	58 38       	cp.w	r8,3
8000637c:	c6 e0       	breq	80006458 <led_shelf+0x108>
8000637e:	c9 08       	rjmp	8000649e <led_shelf+0x14e>
	{
		case 0: //bottom of LED board 0 which is the upper board in the shelf, and top of LED board 1 which is the lower board in the shelf
			PCA9952_channel(LED_BOTTOM, 0, onOffn);
80006380:	ef 38 ff f8 	ld.ub	r8,r7[-8]
80006384:	10 9a       	mov	r10,r8
80006386:	30 0b       	mov	r11,0
80006388:	30 1c       	mov	r12,1
8000638a:	f0 1f 00 47 	mcall	800064a4 <led_shelf+0x154>
			PCA9952_channel(LED_BOTTOM, 1, onOffn);
8000638e:	ef 38 ff f8 	ld.ub	r8,r7[-8]
80006392:	10 9a       	mov	r10,r8
80006394:	30 1b       	mov	r11,1
80006396:	30 1c       	mov	r12,1
80006398:	f0 1f 00 43 	mcall	800064a4 <led_shelf+0x154>
			PCA9952_channel(LED_BOTTOM, 2, onOffn);
8000639c:	ef 38 ff f8 	ld.ub	r8,r7[-8]
800063a0:	10 9a       	mov	r10,r8
800063a2:	30 2b       	mov	r11,2
800063a4:	30 1c       	mov	r12,1
800063a6:	f0 1f 00 40 	mcall	800064a4 <led_shelf+0x154>
			PCA9952_channel(LED_TOP, 0, onOffn);
800063aa:	ef 38 ff f8 	ld.ub	r8,r7[-8]
800063ae:	10 9a       	mov	r10,r8
800063b0:	30 0b       	mov	r11,0
800063b2:	30 0c       	mov	r12,0
800063b4:	f0 1f 00 3c 	mcall	800064a4 <led_shelf+0x154>
			PCA9952_channel(LED_TOP, 1, onOffn);
800063b8:	ef 38 ff f8 	ld.ub	r8,r7[-8]
800063bc:	10 9a       	mov	r10,r8
800063be:	30 1b       	mov	r11,1
800063c0:	30 0c       	mov	r12,0
800063c2:	f0 1f 00 39 	mcall	800064a4 <led_shelf+0x154>
			break;
800063c6:	c6 c8       	rjmp	8000649e <led_shelf+0x14e>

		case 1: //bottom of LED board 1 which is the upper board in the shelf, and top of LED board 2 which is the lower board in the shelf
			PCA9952_channel(LED_BOTTOM, 3, onOffn);
800063c8:	ef 38 ff f8 	ld.ub	r8,r7[-8]
800063cc:	10 9a       	mov	r10,r8
800063ce:	30 3b       	mov	r11,3
800063d0:	30 1c       	mov	r12,1
800063d2:	f0 1f 00 35 	mcall	800064a4 <led_shelf+0x154>
			PCA9952_channel(LED_BOTTOM, 4, onOffn);
800063d6:	ef 38 ff f8 	ld.ub	r8,r7[-8]
800063da:	10 9a       	mov	r10,r8
800063dc:	30 4b       	mov	r11,4
800063de:	30 1c       	mov	r12,1
800063e0:	f0 1f 00 31 	mcall	800064a4 <led_shelf+0x154>
			PCA9952_channel(LED_BOTTOM, 5, onOffn);
800063e4:	ef 38 ff f8 	ld.ub	r8,r7[-8]
800063e8:	10 9a       	mov	r10,r8
800063ea:	30 5b       	mov	r11,5
800063ec:	30 1c       	mov	r12,1
800063ee:	f0 1f 00 2e 	mcall	800064a4 <led_shelf+0x154>
			PCA9952_channel(LED_TOP, 2, onOffn);
800063f2:	ef 38 ff f8 	ld.ub	r8,r7[-8]
800063f6:	10 9a       	mov	r10,r8
800063f8:	30 2b       	mov	r11,2
800063fa:	30 0c       	mov	r12,0
800063fc:	f0 1f 00 2a 	mcall	800064a4 <led_shelf+0x154>
			PCA9952_channel(LED_TOP, 3, onOffn);
80006400:	ef 38 ff f8 	ld.ub	r8,r7[-8]
80006404:	10 9a       	mov	r10,r8
80006406:	30 3b       	mov	r11,3
80006408:	30 0c       	mov	r12,0
8000640a:	f0 1f 00 27 	mcall	800064a4 <led_shelf+0x154>
			break;
8000640e:	c4 88       	rjmp	8000649e <led_shelf+0x14e>

		case 2: //bottom of LED board 2 which is the upper board in the shelf, and top of LED board 3 which is the lower board in the shelf
			PCA9952_channel(LED_BOTTOM, 6, onOffn);
80006410:	ef 38 ff f8 	ld.ub	r8,r7[-8]
80006414:	10 9a       	mov	r10,r8
80006416:	30 6b       	mov	r11,6
80006418:	30 1c       	mov	r12,1
8000641a:	f0 1f 00 23 	mcall	800064a4 <led_shelf+0x154>
			PCA9952_channel(LED_BOTTOM, 7, onOffn);
8000641e:	ef 38 ff f8 	ld.ub	r8,r7[-8]
80006422:	10 9a       	mov	r10,r8
80006424:	30 7b       	mov	r11,7
80006426:	30 1c       	mov	r12,1
80006428:	f0 1f 00 1f 	mcall	800064a4 <led_shelf+0x154>
			PCA9952_channel(LED_BOTTOM, 8, onOffn);
8000642c:	ef 38 ff f8 	ld.ub	r8,r7[-8]
80006430:	10 9a       	mov	r10,r8
80006432:	30 8b       	mov	r11,8
80006434:	30 1c       	mov	r12,1
80006436:	f0 1f 00 1c 	mcall	800064a4 <led_shelf+0x154>
			PCA9952_channel(LED_TOP, 4, onOffn);
8000643a:	ef 38 ff f8 	ld.ub	r8,r7[-8]
8000643e:	10 9a       	mov	r10,r8
80006440:	30 4b       	mov	r11,4
80006442:	30 0c       	mov	r12,0
80006444:	f0 1f 00 18 	mcall	800064a4 <led_shelf+0x154>
			PCA9952_channel(LED_TOP, 5, onOffn);
80006448:	ef 38 ff f8 	ld.ub	r8,r7[-8]
8000644c:	10 9a       	mov	r10,r8
8000644e:	30 5b       	mov	r11,5
80006450:	30 0c       	mov	r12,0
80006452:	f0 1f 00 15 	mcall	800064a4 <led_shelf+0x154>
			break;
80006456:	c2 48       	rjmp	8000649e <led_shelf+0x14e>

		case 3: //bottom of LED board 3 which is the upper board in the shelf, and top of LED board 4 which is the lower board in the shelf
			PCA9952_channel(LED_BOTTOM, 9, onOffn);
80006458:	ef 38 ff f8 	ld.ub	r8,r7[-8]
8000645c:	10 9a       	mov	r10,r8
8000645e:	30 9b       	mov	r11,9
80006460:	30 1c       	mov	r12,1
80006462:	f0 1f 00 11 	mcall	800064a4 <led_shelf+0x154>
			PCA9952_channel(LED_BOTTOM, 10, onOffn);
80006466:	ef 38 ff f8 	ld.ub	r8,r7[-8]
8000646a:	10 9a       	mov	r10,r8
8000646c:	30 ab       	mov	r11,10
8000646e:	30 1c       	mov	r12,1
80006470:	f0 1f 00 0d 	mcall	800064a4 <led_shelf+0x154>
			PCA9952_channel(LED_BOTTOM, 11, onOffn);
80006474:	ef 38 ff f8 	ld.ub	r8,r7[-8]
80006478:	10 9a       	mov	r10,r8
8000647a:	30 bb       	mov	r11,11
8000647c:	30 1c       	mov	r12,1
8000647e:	f0 1f 00 0a 	mcall	800064a4 <led_shelf+0x154>
			PCA9952_channel(LED_TOP, 6, onOffn);
80006482:	ef 38 ff f8 	ld.ub	r8,r7[-8]
80006486:	10 9a       	mov	r10,r8
80006488:	30 6b       	mov	r11,6
8000648a:	30 0c       	mov	r12,0
8000648c:	f0 1f 00 06 	mcall	800064a4 <led_shelf+0x154>
			PCA9952_channel(LED_TOP, 7, onOffn);
80006490:	ef 38 ff f8 	ld.ub	r8,r7[-8]
80006494:	10 9a       	mov	r10,r8
80006496:	30 7b       	mov	r11,7
80006498:	30 0c       	mov	r12,0
8000649a:	f0 1f 00 03 	mcall	800064a4 <led_shelf+0x154>
			break;
	}	
	
}
8000649e:	2f ed       	sub	sp,-8
800064a0:	e3 cd 80 80 	ldm	sp++,r7,pc
800064a4:	80 00       	ld.sh	r0,r0[0x0]
800064a6:	61 d0       	ld.w	r0,r0[0x74]
800064a8:	43 68       	lddsp	r8,sp[0xd8]
800064aa:	61 73       	ld.w	r3,r0[0x5c]
800064ac:	73 69       	ld.w	r9,r9[0x58]
800064ae:	73 20       	ld.w	r0,r9[0x48]
800064b0:	65 72       	ld.w	r2,r2[0x5c]
800064b2:	72 6f       	ld.w	pc,r9[0x18]
800064b4:	72 2e       	ld.w	lr,r9[0x8]
800064b6:	2e 2e       	sub	lr,-30
800064b8:	73 68       	ld.w	r8,r9[0x58]
800064ba:	75 74       	ld.w	r4,r10[0x5c]
800064bc:	74 69       	ld.w	r9,r10[0x18]
800064be:	6e 67       	ld.w	r7,r7[0x18]
800064c0:	20 64       	sub	r4,6
800064c2:	6f 77       	ld.w	r7,r7[0x5c]
800064c4:	6e 2e       	ld.w	lr,r7[0x8]
800064c6:	0d 0a       	ld.w	r10,r6++
800064c8:	00 00       	add	r0,r0
800064ca:	00 00       	add	r0,r0
800064cc:	25 64       	sub	r4,86
800064ce:	00 00       	add	r0,r0
800064d0:	4c 45       	lddpc	r5,800065e0 <led_shelf+0x290>
800064d2:	44 20       	lddsp	r0,sp[0x108]
800064d4:	62 6f       	ld.w	pc,r1[0x18]
800064d6:	61 72       	ld.w	r2,r0[0x5c]
800064d8:	64 20       	ld.w	r0,r2[0x8]
800064da:	64 65       	ld.w	r5,r2[0x18]
800064dc:	74 65       	ld.w	r5,r10[0x18]
800064de:	63 74       	ld.w	r4,r1[0x5c]
800064e0:	65 64       	ld.w	r4,r2[0x58]
800064e2:	20 69       	sub	r9,6
800064e4:	6e 20       	ld.w	r0,r7[0x8]
800064e6:	73 6c       	ld.w	r12,r9[0x58]
800064e8:	6f 74       	ld.w	r4,r7[0x5c]
800064ea:	20 00       	sub	r0,0
800064ec:	0d 0a       	ld.w	r10,r6++
800064ee:	00 00       	add	r0,r0
800064f0:	53 68       	stdsp	sp[0xd8],r8
800064f2:	65 6c       	ld.w	r12,r2[0x58]
800064f4:	66 20       	ld.w	r0,r3[0x8]
800064f6:	30 20       	mov	r0,2
800064f8:	70 72       	ld.w	r2,r8[0x1c]
800064fa:	65 73       	ld.w	r3,r2[0x5c]
800064fc:	65 6e       	ld.w	lr,r2[0x58]
800064fe:	74 0d       	ld.w	sp,r10[0x0]
80006500:	0a 00       	add	r0,r5
80006502:	00 00       	add	r0,r0
80006504:	53 68       	stdsp	sp[0xd8],r8
80006506:	65 6c       	ld.w	r12,r2[0x58]
80006508:	66 20       	ld.w	r0,r3[0x8]
8000650a:	31 20       	mov	r0,18
8000650c:	70 72       	ld.w	r2,r8[0x1c]
8000650e:	65 73       	ld.w	r3,r2[0x5c]
80006510:	65 6e       	ld.w	lr,r2[0x58]
80006512:	74 0d       	ld.w	sp,r10[0x0]
80006514:	0a 00       	add	r0,r5
80006516:	00 00       	add	r0,r0
80006518:	53 68       	stdsp	sp[0xd8],r8
8000651a:	65 6c       	ld.w	r12,r2[0x58]
8000651c:	66 20       	ld.w	r0,r3[0x8]
8000651e:	32 20       	mov	r0,34
80006520:	70 72       	ld.w	r2,r8[0x1c]
80006522:	65 73       	ld.w	r3,r2[0x5c]
80006524:	65 6e       	ld.w	lr,r2[0x58]
80006526:	74 0d       	ld.w	sp,r10[0x0]
80006528:	0a 00       	add	r0,r5
8000652a:	00 00       	add	r0,r0
8000652c:	53 68       	stdsp	sp[0xd8],r8
8000652e:	65 6c       	ld.w	r12,r2[0x58]
80006530:	66 20       	ld.w	r0,r3[0x8]
80006532:	33 20       	mov	r0,50
80006534:	70 72       	ld.w	r2,r8[0x1c]
80006536:	65 73       	ld.w	r3,r2[0x5c]
80006538:	65 6e       	ld.w	lr,r2[0x58]
8000653a:	74 0d       	ld.w	sp,r10[0x0]
8000653c:	0a 00       	add	r0,r5
8000653e:	00 00       	add	r0,r0
80006540:	49 6e       	lddpc	lr,80006598 <led_shelf+0x248>
80006542:	76 61       	ld.w	r1,r11[0x18]
80006544:	6c 69       	ld.w	r9,r6[0x18]
80006546:	64 20       	ld.w	r0,r2[0x8]
80006548:	73 65       	ld.w	r5,r9[0x58]
8000654a:	72 69       	ld.w	r9,r9[0x18]
8000654c:	61 6c       	ld.w	r12,r0[0x58]
8000654e:	20 49       	sub	r9,4
80006550:	44 20       	lddsp	r0,sp[0x108]
80006552:	63 68       	ld.w	r8,r1[0x58]
80006554:	65 63       	ld.w	r3,r2[0x58]
80006556:	6b 73       	ld.w	r3,r5[0x5c]
80006558:	75 6d       	ld.w	sp,r10[0x58]
8000655a:	2e 0d       	sub	sp,-128
8000655c:	0a 00       	add	r0,r5
8000655e:	00 00       	add	r0,r0
80006560:	73 68       	ld.w	r8,r9[0x58]
80006562:	65 6c       	ld.w	r12,r2[0x58]
80006564:	66 20       	ld.w	r0,r3[0x8]
80006566:	25 64       	sub	r4,86
80006568:	3a 20       	mov	r0,-94
8000656a:	62 6c       	ld.w	r12,r1[0x18]
8000656c:	75 65       	ld.w	r5,r10[0x58]
8000656e:	73 65       	ld.w	r5,r9[0x58]
80006570:	6e 73       	ld.w	r3,r7[0x1c]
80006572:	65 5b       	ld.w	r11,r2[0x54]
80006574:	25 64       	sub	r4,86
80006576:	5d 3d       	musfr	sp
80006578:	30 78       	mov	r8,7
8000657a:	25 58       	sub	r8,85
8000657c:	0d 0a       	ld.w	r10,r6++
8000657e:	00 00       	add	r0,r0
80006580:	44 65       	lddsp	r5,sp[0x118]
80006582:	76 69       	ld.w	r9,r11[0x18]
80006584:	63 65       	ld.w	r5,r1[0x58]
80006586:	73 20       	ld.w	r0,r9[0x48]
80006588:	64 65       	ld.w	r5,r2[0x18]
8000658a:	74 65       	ld.w	r5,r10[0x18]
8000658c:	63 74       	ld.w	r4,r1[0x5c]
8000658e:	65 64       	ld.w	r4,r2[0x58]
80006590:	20 6f       	sub	pc,6
80006592:	6e 20       	ld.w	r0,r7[0x8]
80006594:	73 68       	ld.w	r8,r9[0x58]
80006596:	65 6c       	ld.w	r12,r2[0x58]
80006598:	66 20       	ld.w	r0,r3[0x8]
8000659a:	00 00       	add	r0,r0
8000659c:	50 43       	stdsp	sp[0x10],r3
8000659e:	41 39       	lddsp	r9,sp[0x4c]
800065a0:	39 35       	mov	r5,-109
800065a2:	32 20       	mov	r0,34
800065a4:	45 72       	lddsp	r2,sp[0x15c]
800065a6:	72 6f       	ld.w	pc,r9[0x18]
800065a8:	72 28       	ld.w	r8,r9[0x8]
800065aa:	73 29       	ld.w	r9,r9[0x48]
800065ac:	20 6f       	sub	pc,6
800065ae:	6e 20       	ld.w	r0,r7[0x8]
800065b0:	54 4f       	stdsp	sp[0x110],pc
800065b2:	50 44       	stdsp	sp[0x10],r4
800065b4:	52 49       	stdsp	sp[0x90],r9
800065b6:	56 45       	stdsp	sp[0x190],r5
800065b8:	20 00       	sub	r0,0
800065ba:	00 00       	add	r0,r0
800065bc:	20 00       	sub	r0,0
800065be:	00 00       	add	r0,r0
800065c0:	45 52       	lddsp	r2,sp[0x154]
800065c2:	52 4f       	stdsp	sp[0x90],pc
800065c4:	52 20       	stdsp	sp[0x88],r0
800065c6:	6f 6e       	ld.w	lr,r7[0x58]
800065c8:	20 75       	sub	r5,7
800065ca:	6e 75       	ld.w	r5,r7[0x1c]
800065cc:	73 65       	ld.w	r5,r9[0x58]
800065ce:	64 20       	ld.w	r0,r2[0x8]
800065d0:	63 68       	ld.w	r8,r1[0x58]
800065d2:	61 6e       	ld.w	lr,r0[0x58]
800065d4:	6e 65       	ld.w	r5,r7[0x18]
800065d6:	6c 73       	ld.w	r3,r6[0x1c]
800065d8:	3a 20       	mov	r0,-94
800065da:	50 43       	stdsp	sp[0x10],r3
800065dc:	41 39       	lddsp	r9,sp[0x4c]
800065de:	39 35       	mov	r5,-109
800065e0:	32 20       	mov	r0,34
800065e2:	2d 20       	sub	r0,-46
800065e4:	43 6f       	lddsp	pc,sp[0xd8]
800065e6:	6e 74       	ld.w	r4,r7[0x1c]
800065e8:	72 6f       	ld.w	pc,r9[0x18]
800065ea:	6c 6c       	ld.w	r12,r6[0x18]
800065ec:	65 72       	ld.w	r2,r2[0x5c]
800065ee:	20 62       	sub	r2,6
800065f0:	6f 61       	ld.w	r1,r7[0x58]
800065f2:	72 64       	ld.w	r4,r9[0x18]
800065f4:	20 55       	sub	r5,5
800065f6:	37 0d       	mov	sp,112
800065f8:	0a 00       	add	r0,r5
800065fa:	00 00       	add	r0,r0
800065fc:	50 43       	stdsp	sp[0x10],r3
800065fe:	41 39       	lddsp	r9,sp[0x4c]
80006600:	39 35       	mov	r5,-109
80006602:	32 20       	mov	r0,34
80006604:	45 72       	lddsp	r2,sp[0x15c]
80006606:	72 6f       	ld.w	pc,r9[0x18]
80006608:	72 28       	ld.w	r8,r9[0x8]
8000660a:	73 29       	ld.w	r9,r9[0x48]
8000660c:	20 6f       	sub	pc,6
8000660e:	6e 20       	ld.w	r0,r7[0x8]
80006610:	42 4f       	lddsp	pc,sp[0x90]
80006612:	54 44       	stdsp	sp[0x110],r4
80006614:	52 49       	stdsp	sp[0x90],r9
80006616:	56 45       	stdsp	sp[0x190],r5
80006618:	20 00       	sub	r0,0
8000661a:	00 00       	add	r0,r0
8000661c:	45 52       	lddsp	r2,sp[0x154]
8000661e:	52 4f       	stdsp	sp[0x90],pc
80006620:	52 20       	stdsp	sp[0x88],r0
80006622:	6f 6e       	ld.w	lr,r7[0x58]
80006624:	20 75       	sub	r5,7
80006626:	6e 75       	ld.w	r5,r7[0x1c]
80006628:	73 65       	ld.w	r5,r9[0x58]
8000662a:	64 20       	ld.w	r0,r2[0x8]
8000662c:	63 68       	ld.w	r8,r1[0x58]
8000662e:	61 6e       	ld.w	lr,r0[0x58]
80006630:	6e 65       	ld.w	r5,r7[0x18]
80006632:	6c 73       	ld.w	r3,r6[0x1c]
80006634:	3a 20       	mov	r0,-94
80006636:	50 43       	stdsp	sp[0x10],r3
80006638:	41 39       	lddsp	r9,sp[0x4c]
8000663a:	39 35       	mov	r5,-109
8000663c:	32 20       	mov	r0,34
8000663e:	2d 20       	sub	r0,-46
80006640:	43 6f       	lddsp	pc,sp[0xd8]
80006642:	6e 74       	ld.w	r4,r7[0x1c]
80006644:	72 6f       	ld.w	pc,r9[0x18]
80006646:	6c 6c       	ld.w	r12,r6[0x18]
80006648:	65 72       	ld.w	r2,r2[0x5c]
8000664a:	20 62       	sub	r2,6
8000664c:	6f 61       	ld.w	r1,r7[0x58]
8000664e:	72 64       	ld.w	r4,r9[0x18]
80006650:	20 55       	sub	r5,5
80006652:	38 0d       	mov	sp,-128
80006654:	0a 00       	add	r0,r5
80006656:	00 00       	add	r0,r0
80006658:	53 68       	stdsp	sp[0xd8],r8
8000665a:	65 6c       	ld.w	r12,r2[0x58]
8000665c:	66 20       	ld.w	r0,r3[0x8]
8000665e:	30 20       	mov	r0,2
80006660:	61 63       	ld.w	r3,r0[0x58]
80006662:	74 69       	ld.w	r9,r10[0x18]
80006664:	76 65       	ld.w	r5,r11[0x18]
80006666:	0d 0a       	ld.w	r10,r6++
80006668:	00 00       	add	r0,r0
8000666a:	00 00       	add	r0,r0
8000666c:	53 68       	stdsp	sp[0xd8],r8
8000666e:	65 6c       	ld.w	r12,r2[0x58]
80006670:	66 20       	ld.w	r0,r3[0x8]
80006672:	31 20       	mov	r0,18
80006674:	61 63       	ld.w	r3,r0[0x58]
80006676:	74 69       	ld.w	r9,r10[0x18]
80006678:	76 65       	ld.w	r5,r11[0x18]
8000667a:	0d 0a       	ld.w	r10,r6++
8000667c:	00 00       	add	r0,r0
8000667e:	00 00       	add	r0,r0
80006680:	53 68       	stdsp	sp[0xd8],r8
80006682:	65 6c       	ld.w	r12,r2[0x58]
80006684:	66 20       	ld.w	r0,r3[0x8]
80006686:	32 20       	mov	r0,34
80006688:	61 63       	ld.w	r3,r0[0x58]
8000668a:	74 69       	ld.w	r9,r10[0x18]
8000668c:	76 65       	ld.w	r5,r11[0x18]
8000668e:	0d 0a       	ld.w	r10,r6++
80006690:	00 00       	add	r0,r0
80006692:	00 00       	add	r0,r0
80006694:	53 68       	stdsp	sp[0xd8],r8
80006696:	65 6c       	ld.w	r12,r2[0x58]
80006698:	66 20       	ld.w	r0,r3[0x8]
8000669a:	33 20       	mov	r0,50
8000669c:	61 63       	ld.w	r3,r0[0x58]
8000669e:	74 69       	ld.w	r9,r10[0x18]
800066a0:	76 65       	ld.w	r5,r11[0x18]
800066a2:	0d 0a       	ld.w	r10,r6++
800066a4:	00 00       	add	r0,r0
800066a6:	00 00       	add	r0,r0
800066a8:	44 6f       	lddsp	pc,sp[0x118]
800066aa:	6f 72       	ld.w	r2,r7[0x5c]
800066ac:	20 6c       	sub	r12,6
800066ae:	61 74       	ld.w	r4,r0[0x5c]
800066b0:	63 68       	ld.w	r8,r1[0x58]
800066b2:	20 6f       	sub	pc,6
800066b4:	70 65       	ld.w	r5,r8[0x18]
800066b6:	6e 65       	ld.w	r5,r7[0x18]
800066b8:	64 2c       	ld.w	r12,r2[0x8]
800066ba:	20 6b       	sub	r11,6
800066bc:	69 6c       	ld.w	r12,r4[0x58]
800066be:	6c 20       	ld.w	r0,r6[0x8]
800066c0:	61 6c       	ld.w	r12,r0[0x58]
800066c2:	6c 20       	ld.w	r0,r6[0x8]
800066c4:	73 68       	ld.w	r8,r9[0x58]
800066c6:	65 6c       	ld.w	r12,r2[0x58]
800066c8:	76 65       	ld.w	r5,r11[0x18]
800066ca:	73 20       	ld.w	r0,r9[0x48]
800066cc:	66 6f       	ld.w	pc,r3[0x18]
800066ce:	72 20       	ld.w	r0,r9[0x8]
800066d0:	73 61       	ld.w	r1,r9[0x58]
800066d2:	66 65       	ld.w	r5,r3[0x18]
800066d4:	74 79       	ld.w	r9,r10[0x1c]
800066d6:	2e 0d       	sub	sp,-128
800066d8:	0a 00       	add	r0,r5
800066da:	00 00       	add	r0,r0
800066dc:	65 76       	ld.w	r6,r2[0x5c]
800066de:	61 6c       	ld.w	r12,r0[0x58]
800066e0:	5f 72       	srpl	r2
800066e2:	65 67       	ld.w	r7,r2[0x58]
800066e4:	69 6f       	ld.w	pc,r4[0x58]
800066e6:	6e 28       	ld.w	r8,r7[0x8]
800066e8:	29 20       	sub	r0,-110
800066ea:	00 00       	add	r0,r0
800066ec:	72 65       	ld.w	r5,r9[0x18]
800066ee:	67 69       	ld.w	r9,r3[0x58]
800066f0:	6f 6e       	ld.w	lr,r7[0x58]
800066f2:	20 30       	sub	r0,3
800066f4:	20 2d       	sub	sp,8
800066f6:	20 73       	sub	r3,7
800066f8:	65 72       	ld.w	r2,r2[0x5c]
800066fa:	69 61       	ld.w	r1,r4[0x58]
800066fc:	6c 20       	ld.w	r0,r6[0x8]
800066fe:	49 44       	lddpc	r4,8000674c <led_shelf+0x3fc>
80006700:	20 61       	sub	r1,6
80006702:	6e 64       	ld.w	r4,r7[0x18]
80006704:	20 66       	sub	r6,6
80006706:	6c 61       	ld.w	r1,r6[0x18]
80006708:	67 73       	ld.w	r3,r3[0x5c]
8000670a:	0d 0a       	ld.w	r10,r6++
8000670c:	00 00       	add	r0,r0
8000670e:	00 00       	add	r0,r0
80006710:	67 6f       	ld.w	pc,r3[0x58]
80006712:	6f 64       	ld.w	r4,r7[0x58]
80006714:	20 63       	sub	r3,6
80006716:	73 75       	ld.w	r5,r9[0x5c]
80006718:	6d 0d       	ld.w	sp,r6[0x40]
8000671a:	0a 00       	add	r0,r5
8000671c:	73 66       	ld.w	r6,r9[0x58]
8000671e:	46 6c       	lddsp	r12,sp[0x198]
80006720:	61 73       	ld.w	r3,r0[0x5c]
80006722:	68 49       	ld.w	r9,r4[0x10]
80006724:	64 78       	ld.w	r8,r2[0x1c]
80006726:	20 00       	sub	r0,0
80006728:	72 65       	ld.w	r5,r9[0x18]
8000672a:	67 69       	ld.w	r9,r3[0x58]
8000672c:	6f 6e       	ld.w	lr,r7[0x58]
8000672e:	20 31       	sub	r1,3
80006730:	20 2d       	sub	sp,8
80006732:	20 73       	sub	r3,7
80006734:	61 6e       	ld.w	lr,r0[0x58]
80006736:	69 74       	ld.w	r4,r4[0x5c]
80006738:	61 74       	ld.w	r4,r0[0x5c]
8000673a:	69 6f       	ld.w	pc,r4[0x58]
8000673c:	6e 20       	ld.w	r0,r7[0x8]
8000673e:	63 79       	ld.w	r9,r1[0x5c]
80006740:	63 6c       	ld.w	r12,r1[0x58]
80006742:	65 73       	ld.w	r3,r2[0x5c]
80006744:	0d 0a       	ld.w	r10,r6++
80006746:	00 00       	add	r0,r0
80006748:	73 61       	ld.w	r1,r9[0x58]
8000674a:	6e 43       	ld.w	r3,r7[0x10]
8000674c:	79 63       	ld.w	r3,r12[0x58]
8000674e:	6c 65       	ld.w	r5,r6[0x18]
80006750:	46 6c       	lddsp	r12,sp[0x198]
80006752:	61 73       	ld.w	r3,r0[0x5c]
80006754:	68 49       	ld.w	r9,r4[0x10]
80006756:	64 78       	ld.w	r8,r2[0x1c]
80006758:	20 00       	sub	r0,0
8000675a:	00 00       	add	r0,r0
8000675c:	72 65       	ld.w	r5,r9[0x18]
8000675e:	67 69       	ld.w	r9,r3[0x58]
80006760:	6f 6e       	ld.w	lr,r7[0x58]
80006762:	20 32       	sub	r2,3
80006764:	20 2d       	sub	sp,8
80006766:	20 75       	sub	r5,7
80006768:	73 61       	ld.w	r1,r9[0x58]
8000676a:	67 65       	ld.w	r5,r3[0x58]
8000676c:	20 68       	sub	r8,6
8000676e:	6f 75       	ld.w	r5,r7[0x5c]
80006770:	72 73       	ld.w	r3,r9[0x1c]
80006772:	0d 0a       	ld.w	r10,r6++
80006774:	00 00       	add	r0,r0
80006776:	00 00       	add	r0,r0
80006778:	68 46       	ld.w	r6,r4[0x10]
8000677a:	6c 61       	ld.w	r1,r6[0x18]
8000677c:	73 68       	ld.w	r8,r9[0x58]
8000677e:	49 64       	lddpc	r4,800067d4 <led_shelf+0x484>
80006780:	78 20       	ld.w	r0,r12[0x8]
80006782:	00 00       	add	r0,r0
80006784:	72 65       	ld.w	r5,r9[0x18]
80006786:	67 69       	ld.w	r9,r3[0x58]
80006788:	6f 6e       	ld.w	lr,r7[0x58]
8000678a:	20 33       	sub	r3,3
8000678c:	20 2d       	sub	sp,8
8000678e:	20 75       	sub	r5,7
80006790:	73 61       	ld.w	r1,r9[0x58]
80006792:	67 65       	ld.w	r5,r3[0x58]
80006794:	20 6d       	sub	sp,24
80006796:	69 6e       	ld.w	lr,r4[0x58]
80006798:	75 74       	ld.w	r4,r10[0x5c]
8000679a:	65 73       	ld.w	r3,r2[0x5c]
8000679c:	0d 0a       	ld.w	r10,r6++
8000679e:	00 00       	add	r0,r0
800067a0:	6d 46       	ld.w	r6,r6[0x50]
800067a2:	6c 61       	ld.w	r1,r6[0x18]
800067a4:	73 68       	ld.w	r8,r9[0x58]
800067a6:	49 64       	lddpc	r4,800067fc <led_shelf+0x4ac>
800067a8:	78 20       	ld.w	r0,r12[0x8]
800067aa:	00 00       	add	r0,r0
800067ac:	72 65       	ld.w	r5,r9[0x18]
800067ae:	67 69       	ld.w	r9,r3[0x58]
800067b0:	6f 6e       	ld.w	lr,r7[0x58]
800067b2:	20 34       	sub	r4,3
800067b4:	20 2d       	sub	sp,8
800067b6:	20 63       	sub	r3,6
800067b8:	6f 6e       	ld.w	lr,r7[0x58]
800067ba:	66 69       	ld.w	r9,r3[0x18]
800067bc:	67 75       	ld.w	r5,r3[0x5c]
800067be:	72 61       	ld.w	r1,r9[0x18]
800067c0:	74 69       	ld.w	r9,r10[0x18]
800067c2:	6f 6e       	ld.w	lr,r7[0x58]
800067c4:	0d 0a       	ld.w	r10,r6++
800067c6:	00 00       	add	r0,r0
800067c8:	63 6f       	ld.w	pc,r1[0x58]
800067ca:	6e 66       	ld.w	r6,r7[0x18]
800067cc:	69 67       	ld.w	r7,r4[0x58]
800067ce:	46 6c       	lddsp	r12,sp[0x198]
800067d0:	61 73       	ld.w	r3,r0[0x5c]
800067d2:	68 49       	ld.w	r9,r4[0x10]
800067d4:	64 78       	ld.w	r8,r2[0x1c]
800067d6:	20 00       	sub	r0,0
800067d8:	4e 6f       	lddpc	pc,80006970 <led_shelf+0x620>
800067da:	20 6d       	sub	sp,24
800067dc:	6f 72       	ld.w	r2,r7[0x5c]
800067de:	65 20       	ld.w	r0,r2[0x48]
800067e0:	72 6f       	ld.w	pc,r9[0x18]
800067e2:	6f 6d       	ld.w	sp,r7[0x58]
800067e4:	20 66       	sub	r6,6
800067e6:	6f 72       	ld.w	r2,r7[0x5c]
800067e8:	20 4c       	sub	r12,4
800067ea:	45 44       	lddsp	r4,sp[0x150]
800067ec:	20 62       	sub	r2,6
800067ee:	6f 61       	ld.w	r1,r7[0x58]
800067f0:	72 64       	ld.w	r4,r9[0x18]
800067f2:	20 69       	sub	r9,6
800067f4:	6e 66       	ld.w	r6,r7[0x18]
800067f6:	6f 2e       	ld.w	lr,r7[0x48]
800067f8:	20 43       	sub	r3,4
800067fa:	61 6e       	ld.w	lr,r0[0x58]
800067fc:	6e 6f       	ld.w	pc,r7[0x18]
800067fe:	74 20       	ld.w	r0,r10[0x8]
80006800:	74 72       	ld.w	r2,r10[0x1c]
80006802:	61 63       	ld.w	r3,r0[0x58]
80006804:	6b 20       	ld.w	r0,r5[0x48]
80006806:	6d 69       	ld.w	r9,r6[0x58]
80006808:	6e 75       	ld.w	r5,r7[0x1c]
8000680a:	74 65       	ld.w	r5,r10[0x18]
8000680c:	20 75       	sub	r5,7
8000680e:	73 61       	ld.w	r1,r9[0x58]
80006810:	67 65       	ld.w	r5,r3[0x58]
80006812:	20 66       	sub	r6,6
80006814:	6f 72       	ld.w	r2,r7[0x5c]
80006816:	20 61       	sub	r1,6
80006818:	64 64       	ld.w	r4,r2[0x18]
8000681a:	69 74       	ld.w	r4,r4[0x5c]
8000681c:	69 6f       	ld.w	pc,r4[0x58]
8000681e:	6e 61       	ld.w	r1,r7[0x18]
80006820:	6c 20       	ld.w	r0,r6[0x8]
80006822:	62 6f       	ld.w	pc,r1[0x18]
80006824:	61 72       	ld.w	r2,r0[0x5c]
80006826:	64 73       	ld.w	r3,r2[0x1c]
80006828:	2e 0d       	sub	sp,-128
8000682a:	0a 00       	add	r0,r5
8000682c:	41 6c       	lddsp	r12,sp[0x58]
8000682e:	6c 20       	ld.w	r0,r6[0x8]
80006830:	35 20       	mov	r0,82
80006832:	66 6c       	ld.w	r12,r3[0x18]
80006834:	61 73       	ld.w	r3,r0[0x5c]
80006836:	68 20       	ld.w	r0,r4[0x8]
80006838:	72 65       	ld.w	r5,r9[0x18]
8000683a:	67 69       	ld.w	r9,r3[0x58]
8000683c:	6f 6e       	ld.w	lr,r7[0x58]
8000683e:	73 20       	ld.w	r0,r9[0x48]
80006840:	68 61       	ld.w	r1,r4[0x18]
80006842:	76 65       	ld.w	r5,r11[0x18]
80006844:	20 67       	sub	r7,6
80006846:	6f 6f       	ld.w	pc,r7[0x58]
80006848:	64 20       	ld.w	r0,r2[0x8]
8000684a:	64 61       	ld.w	r1,r2[0x18]
8000684c:	74 61       	ld.w	r1,r10[0x18]
8000684e:	20 73       	sub	r3,7
80006850:	65 74       	ld.w	r4,r2[0x5c]
80006852:	73 2e       	ld.w	lr,r9[0x48]
80006854:	0d 0a       	ld.w	r10,r6++
80006856:	00 00       	add	r0,r0
80006858:	46 6c       	lddsp	r12,sp[0x198]
8000685a:	61 73       	ld.w	r3,r0[0x5c]
8000685c:	68 20       	ld.w	r0,r4[0x8]
8000685e:	61 72       	ld.w	r2,r0[0x5c]
80006860:	65 61       	ld.w	r1,r2[0x58]
80006862:	20 45       	sub	r5,4
80006864:	52 52       	stdsp	sp[0x94],r2
80006866:	4f 52       	lddpc	r2,80006a38 <led_shelf+0x6e8>
80006868:	3a 20       	mov	r0,-94
8000686a:	72 65       	ld.w	r5,r9[0x18]
8000686c:	67 69       	ld.w	r9,r3[0x58]
8000686e:	6f 6e       	ld.w	lr,r7[0x58]
80006870:	20 00       	sub	r0,0
80006872:	00 00       	add	r0,r0
80006874:	0d 0a       	ld.w	r10,r6++
80006876:	2a 2d       	sub	sp,-376
80006878:	2d 2d       	sub	sp,-184
8000687a:	2d 2d       	sub	sp,-184
8000687c:	2d 2d       	sub	sp,-184
8000687e:	2d 2d       	sub	sp,-184
80006880:	2d 2d       	sub	sp,-184
80006882:	2d 2d       	sub	sp,-184
80006884:	2d 2d       	sub	sp,-184
80006886:	2d 2d       	sub	sp,-184
80006888:	2d 2d       	sub	sp,-184
8000688a:	2d 2d       	sub	sp,-184
8000688c:	2d 2d       	sub	sp,-184
8000688e:	2d 2d       	sub	sp,-184
80006890:	2d 2d       	sub	sp,-184
80006892:	2d 2d       	sub	sp,-184
80006894:	2d 2d       	sub	sp,-184
80006896:	2d 2d       	sub	sp,-184
80006898:	2d 2d       	sub	sp,-184
8000689a:	2d 2d       	sub	sp,-184
8000689c:	2d 2d       	sub	sp,-184
8000689e:	2d 2d       	sub	sp,-184
800068a0:	2d 2d       	sub	sp,-184
800068a2:	2d 2d       	sub	sp,-184
800068a4:	2d 2d       	sub	sp,-184
800068a6:	2d 2d       	sub	sp,-184
800068a8:	2d 2d       	sub	sp,-184
800068aa:	2a 0d       	sub	sp,-384
800068ac:	0a 00       	add	r0,r5
800068ae:	00 00       	add	r0,r0
800068b0:	45 4c       	lddsp	r12,sp[0x150]
800068b2:	45 43       	lddsp	r3,sp[0x150]
800068b4:	54 52       	stdsp	sp[0x114],r2
800068b6:	4f 43       	lddpc	r3,80006a84 <led_shelf+0x734>
800068b8:	4c 41       	lddpc	r1,800069c8 <led_shelf+0x678>
800068ba:	56 45       	stdsp	sp[0x190],r5
800068bc:	0d 0a       	ld.w	r10,r6++
800068be:	43 6f       	lddsp	pc,sp[0xd8]
800068c0:	70 79       	ld.w	r9,r8[0x1c]
800068c2:	72 69       	ld.w	r9,r9[0x18]
800068c4:	67 68       	ld.w	r8,r3[0x58]
800068c6:	74 20       	ld.w	r0,r10[0x8]
800068c8:	28 63       	sub	r3,-122
800068ca:	29 20       	sub	r0,-110
800068cc:	32 30       	mov	r0,35
800068ce:	31 36       	mov	r6,19
800068d0:	20 53       	sub	r3,5
800068d2:	65 61       	ld.w	r1,r2[0x58]
800068d4:	6c 20       	ld.w	r0,r6[0x8]
800068d6:	53 68       	stdsp	sp[0xd8],r8
800068d8:	69 65       	ld.w	r5,r4[0x58]
800068da:	6c 64       	ld.w	r4,r6[0x18]
800068dc:	2c 20       	sub	r0,-62
800068de:	49 6e       	lddpc	lr,80006934 <led_shelf+0x5e4>
800068e0:	63 2e       	ld.w	lr,r1[0x48]
800068e2:	20 0d       	sub	sp,0
800068e4:	0a 00       	add	r0,r5
800068e6:	00 00       	add	r0,r0
800068e8:	48 61       	lddpc	r1,80006900 <led_shelf+0x5b0>
800068ea:	72 64       	ld.w	r4,r9[0x18]
800068ec:	77 61       	ld.w	r1,r11[0x58]
800068ee:	72 65       	ld.w	r5,r9[0x18]
800068f0:	20 56       	sub	r6,5
800068f2:	65 72       	ld.w	r2,r2[0x5c]
800068f4:	73 69       	ld.w	r9,r9[0x58]
800068f6:	6f 6e       	ld.w	lr,r7[0x58]
800068f8:	3a 20       	mov	r0,-94
800068fa:	43 6c       	lddsp	r12,sp[0xd8]
800068fc:	61 73       	ld.w	r3,r0[0x5c]
800068fe:	73 69       	ld.w	r9,r9[0x58]
80006900:	63 20       	ld.w	r0,r1[0x48]
80006902:	2b 2b       	sub	r11,-78
80006904:	2b 20       	sub	r0,-78
80006906:	53 6f       	stdsp	sp[0xd8],pc
80006908:	66 74       	ld.w	r4,r3[0x1c]
8000690a:	77 61       	ld.w	r1,r11[0x58]
8000690c:	72 65       	ld.w	r5,r9[0x18]
8000690e:	20 56       	sub	r6,5
80006910:	65 72       	ld.w	r2,r2[0x5c]
80006912:	73 69       	ld.w	r9,r9[0x58]
80006914:	6f 6e       	ld.w	lr,r7[0x58]
80006916:	3a 20       	mov	r0,-94
80006918:	30 2e       	mov	lr,2
8000691a:	30 37       	mov	r7,3
8000691c:	37 0d       	mov	sp,112
8000691e:	0a 00       	add	r0,r5
80006920:	0d 0a       	ld.w	r10,r6++
80006922:	2a 2a       	sub	r10,-94
80006924:	2a 49       	sub	r9,-92
80006926:	4e 53       	lddpc	r3,80006ab8 <led_shelf+0x768>
80006928:	54 41       	stdsp	sp[0x110],r1
8000692a:	4c 4c       	lddpc	r12,80006a38 <led_shelf+0x6e8>
8000692c:	45 44       	lddsp	r4,sp[0x150]
8000692e:	20 4c       	sub	r12,4
80006930:	45 44       	lddsp	r4,sp[0x150]
80006932:	20 42       	sub	r2,4
80006934:	4f 41       	lddpc	r1,80006b04 <led_shelf+0x7b4>
80006936:	52 44       	stdsp	sp[0x90],r4
80006938:	53 2a       	stdsp	sp[0xc8],r10
8000693a:	2a 2a       	sub	r10,-94
8000693c:	0d 0a       	ld.w	r10,r6++
8000693e:	0d 0a       	ld.w	r10,r6++
80006940:	00 00       	add	r0,r0
80006942:	00 00       	add	r0,r0
80006944:	20 4c       	sub	r12,4
80006946:	45 44       	lddsp	r4,sp[0x150]
80006948:	20 7c       	sub	r12,7
8000694a:	20 4c       	sub	r12,4
8000694c:	45 44       	lddsp	r4,sp[0x150]
8000694e:	20 42       	sub	r2,4
80006950:	4f 41       	lddpc	r1,80006b20 <led_shelf+0x7d0>
80006952:	52 44       	stdsp	sp[0x90],r4
80006954:	20 20       	sub	r0,2
80006956:	20 20       	sub	r0,2
80006958:	7c 20       	ld.w	r0,lr[0x8]
8000695a:	20 20       	sub	r0,2
8000695c:	55 50       	stdsp	sp[0x154],r0
8000695e:	50 45       	stdsp	sp[0x10],r5
80006960:	52 20       	stdsp	sp[0x88],r0
80006962:	53 49       	stdsp	sp[0xd0],r9
80006964:	44 45       	lddsp	r5,sp[0x110]
80006966:	20 20       	sub	r0,2
80006968:	20 20       	sub	r0,2
8000696a:	20 7c       	sub	r12,7
8000696c:	20 20       	sub	r0,2
8000696e:	20 4c       	sub	r12,4
80006970:	4f 57       	lddpc	r7,80006b44 <led_shelf+0x7f4>
80006972:	45 52       	lddsp	r2,sp[0x154]
80006974:	20 53       	sub	r3,5
80006976:	49 44       	lddpc	r4,800069c4 <led_shelf+0x674>
80006978:	45 20       	lddsp	r0,sp[0x148]
8000697a:	20 20       	sub	r0,2
8000697c:	20 0d       	sub	sp,0
8000697e:	0a 00       	add	r0,r5
80006980:	53 4c       	stdsp	sp[0xd0],r12
80006982:	4f 54       	lddpc	r4,80006b54 <led_shelf+0x804>
80006984:	20 7c       	sub	r12,7
80006986:	20 20       	sub	r0,2
80006988:	20 20       	sub	r0,2
8000698a:	49 44       	lddpc	r4,800069d8 <led_shelf+0x688>
8000698c:	20 20       	sub	r0,2
8000698e:	20 20       	sub	r0,2
80006990:	20 20       	sub	r0,2
80006992:	20 20       	sub	r0,2
80006994:	7c 20       	ld.w	r0,lr[0x8]
80006996:	48 52       	lddpc	r2,800069a8 <led_shelf+0x658>
80006998:	53 3a       	stdsp	sp[0xcc],r10
8000699a:	4d 49       	lddpc	r9,80006ae8 <led_shelf+0x798>
8000699c:	4e 20       	lddpc	r0,80006b24 <led_shelf+0x7d4>
8000699e:	20 20       	sub	r0,2
800069a0:	20 44       	sub	r4,4
800069a2:	54 45       	stdsp	sp[0x110],r5
800069a4:	20 20       	sub	r0,2
800069a6:	20 7c       	sub	r12,7
800069a8:	20 48       	sub	r8,4
800069aa:	52 53       	stdsp	sp[0x94],r3
800069ac:	3a 4d       	mov	sp,-92
800069ae:	49 4e       	lddpc	lr,800069fc <led_shelf+0x6ac>
800069b0:	20 20       	sub	r0,2
800069b2:	20 20       	sub	r0,2
800069b4:	44 54       	lddsp	r4,sp[0x114]
800069b6:	45 20       	lddsp	r0,sp[0x148]
800069b8:	20 20       	sub	r0,2
800069ba:	0d 0a       	ld.w	r10,r6++
800069bc:	00 00       	add	r0,r0
800069be:	00 00       	add	r0,r0
800069c0:	2d 2d       	sub	sp,-184
800069c2:	2d 2d       	sub	sp,-184
800069c4:	2d 2d       	sub	sp,-184
800069c6:	2d 2d       	sub	sp,-184
800069c8:	2d 2d       	sub	sp,-184
800069ca:	2d 2d       	sub	sp,-184
800069cc:	2d 2d       	sub	sp,-184
800069ce:	2d 2d       	sub	sp,-184
800069d0:	2d 2d       	sub	sp,-184
800069d2:	2d 2d       	sub	sp,-184
800069d4:	2d 2d       	sub	sp,-184
800069d6:	2d 2d       	sub	sp,-184
800069d8:	2d 2d       	sub	sp,-184
800069da:	2d 2d       	sub	sp,-184
800069dc:	2d 2d       	sub	sp,-184
800069de:	2d 2d       	sub	sp,-184
800069e0:	2d 2d       	sub	sp,-184
800069e2:	2d 2d       	sub	sp,-184
800069e4:	2d 2d       	sub	sp,-184
800069e6:	2d 2d       	sub	sp,-184
800069e8:	2d 2d       	sub	sp,-184
800069ea:	2d 2d       	sub	sp,-184
800069ec:	2d 2d       	sub	sp,-184
800069ee:	2d 2d       	sub	sp,-184
800069f0:	2d 2d       	sub	sp,-184
800069f2:	2d 2d       	sub	sp,-184
800069f4:	2d 2d       	sub	sp,-184
800069f6:	2d 2d       	sub	sp,-184
800069f8:	2d 2d       	sub	sp,-184
800069fa:	0d 0a       	ld.w	r10,r6++
800069fc:	00 00       	add	r0,r0
800069fe:	00 00       	add	r0,r0
80006a00:	25 32       	sub	r2,83
80006a02:	64 20       	ld.w	r0,r2[0x8]
80006a04:	20 20       	sub	r0,2
80006a06:	20 20       	sub	r0,2
80006a08:	25 30       	sub	r0,83
80006a0a:	32 58       	mov	r8,37
80006a0c:	25 30       	sub	r0,83
80006a0e:	32 58       	mov	r8,37
80006a10:	25 30       	sub	r0,83
80006a12:	32 58       	mov	r8,37
80006a14:	25 30       	sub	r0,83
80006a16:	32 58       	mov	r8,37
80006a18:	25 30       	sub	r0,83
80006a1a:	32 58       	mov	r8,37
80006a1c:	25 30       	sub	r0,83
80006a1e:	32 58       	mov	r8,37
80006a20:	20 20       	sub	r0,2
80006a22:	25 30       	sub	r0,83
80006a24:	34 64       	mov	r4,70
80006a26:	3a 25       	mov	r5,-94
80006a28:	30 32       	mov	r2,3
80006a2a:	64 20       	ld.w	r0,r2[0x8]
80006a2c:	20 20       	sub	r0,2
80006a2e:	20 20       	sub	r0,2
80006a30:	25 30       	sub	r0,83
80006a32:	32 64       	mov	r4,38
80006a34:	20 20       	sub	r0,2
80006a36:	20 20       	sub	r0,2
80006a38:	20 25       	sub	r5,2
80006a3a:	30 34       	mov	r4,3
80006a3c:	64 3a       	ld.w	r10,r2[0xc]
80006a3e:	25 30       	sub	r0,83
80006a40:	32 64       	mov	r4,38
80006a42:	20 20       	sub	r0,2
80006a44:	20 20       	sub	r0,2
80006a46:	20 25       	sub	r5,2
80006a48:	30 32       	mov	r2,3
80006a4a:	64 0d       	ld.w	sp,r2[0x0]
80006a4c:	0a 00       	add	r0,r5
80006a4e:	00 00       	add	r0,r0
80006a50:	4d 41       	lddpc	r1,80006ba0 <led_shelf+0x850>
80006a52:	58 20       	cp.w	r0,2
80006a54:	44 54       	lddsp	r4,sp[0x114]
80006a56:	45 3a       	lddsp	r10,sp[0x14c]
80006a58:	20 00       	sub	r0,0
80006a5a:	00 00       	add	r0,r0
80006a5c:	20 4d       	sub	sp,16
80006a5e:	49 4e       	lddpc	lr,80006aac <led_shelf+0x75c>
80006a60:	20 44       	sub	r4,4
80006a62:	54 45       	stdsp	sp[0x110],r5
80006a64:	3a 20       	mov	r0,-94
80006a66:	00 00       	add	r0,r0
80006a68:	54 4f       	stdsp	sp[0x110],pc
80006a6a:	54 41       	stdsp	sp[0x110],r1
80006a6c:	4c 20       	lddpc	r0,80006b74 <led_shelf+0x824>
80006a6e:	53 41       	stdsp	sp[0xd0],r1
80006a70:	4e 49       	lddpc	r9,80006c00 <led_shelf+0x8b0>
80006a72:	54 49       	stdsp	sp[0x110],r9
80006a74:	5a 45       	cp.w	r5,-28
80006a76:	20 54       	sub	r4,5
80006a78:	49 4d       	lddpc	sp,80006ac8 <led_shelf+0x778>
80006a7a:	45 3a       	lddsp	r10,sp[0x14c]
80006a7c:	20 00       	sub	r0,0
80006a7e:	00 00       	add	r0,r0
80006a80:	30 00       	mov	r0,0
80006a82:	00 00       	add	r0,r0
80006a84:	3a 00       	mov	r0,-96
80006a86:	00 00       	add	r0,r0
80006a88:	20 20       	sub	r0,2
80006a8a:	54 4f       	stdsp	sp[0x110],pc
80006a8c:	54 41       	stdsp	sp[0x110],r1
80006a8e:	4c 20       	lddpc	r0,80006b94 <led_shelf+0x844>
80006a90:	53 41       	stdsp	sp[0xd0],r1
80006a92:	4e 49       	lddpc	r9,80006c20 <led_shelf+0x8d0>
80006a94:	54 49       	stdsp	sp[0x110],r9
80006a96:	5a 45       	cp.w	r5,-28
80006a98:	20 43       	sub	r3,4
80006a9a:	59 43       	cp.w	r3,20
80006a9c:	4c 45       	lddpc	r5,80006bac <led_shelf+0x85c>
80006a9e:	53 3a       	stdsp	sp[0xcc],r10
80006aa0:	20 00       	sub	r0,0
80006aa2:	00 00       	add	r0,r0
80006aa4:	0d 0a       	ld.w	r10,r6++
80006aa6:	2a 2a       	sub	r10,-94
80006aa8:	2a 53       	sub	r3,-91
80006aaa:	59 53       	cp.w	r3,21
80006aac:	54 45       	stdsp	sp[0x110],r5
80006aae:	4d 20       	lddpc	r0,80006bf4 <led_shelf+0x8a4>
80006ab0:	54 45       	stdsp	sp[0x110],r5
80006ab2:	53 54       	stdsp	sp[0xd4],r4
80006ab4:	53 2a       	stdsp	sp[0xc8],r10
80006ab6:	2a 2a       	sub	r10,-94
80006ab8:	0d 0a       	ld.w	r10,r6++
80006aba:	0d 0a       	ld.w	r10,r6++
80006abc:	00 00       	add	r0,r0
80006abe:	00 00       	add	r0,r0
80006ac0:	4c 45       	lddpc	r5,80006bd0 <led_shelf+0x880>
80006ac2:	44 20       	lddsp	r0,sp[0x108]
80006ac4:	44 72       	lddsp	r2,sp[0x11c]
80006ac6:	69 76       	ld.w	r6,r4[0x5c]
80006ac8:	65 72       	ld.w	r2,r2[0x5c]
80006aca:	3a 20       	mov	r0,-94
80006acc:	54 4f       	stdsp	sp[0x110],pc
80006ace:	50 20       	stdsp	sp[0x8],r0
80006ad0:	28 30       	sub	r0,-125
80006ad2:	2e 2e       	sub	lr,-30
80006ad4:	37 29       	mov	r9,114
80006ad6:	20 20       	sub	r0,2
80006ad8:	20 20       	sub	r0,2
80006ada:	20 20       	sub	r0,2
80006adc:	20 20       	sub	r0,2
80006ade:	20 20       	sub	r0,2
80006ae0:	20 20       	sub	r0,2
80006ae2:	20 20       	sub	r0,2
80006ae4:	20 20       	sub	r0,2
80006ae6:	20 00       	sub	r0,0
80006ae8:	46 20       	lddsp	r0,sp[0x188]
80006aea:	00 00       	add	r0,r0
80006aec:	50 20       	stdsp	sp[0x8],r0
80006aee:	00 00       	add	r0,r0
80006af0:	4c 45       	lddpc	r5,80006c00 <led_shelf+0x8b0>
80006af2:	44 20       	lddsp	r0,sp[0x108]
80006af4:	44 72       	lddsp	r2,sp[0x11c]
80006af6:	69 76       	ld.w	r6,r4[0x5c]
80006af8:	65 72       	ld.w	r2,r2[0x5c]
80006afa:	3a 20       	mov	r0,-94
80006afc:	42 4f       	lddsp	pc,sp[0x90]
80006afe:	54 54       	stdsp	sp[0x114],r4
80006b00:	4f 4d       	lddpc	sp,80006cd0 <led_shelf+0x980>
80006b02:	20 28       	sub	r8,2
80006b04:	30 2e       	mov	lr,2
80006b06:	2e 31       	sub	r1,-29
80006b08:	31 29       	mov	r9,18
80006b0a:	20 20       	sub	r0,2
80006b0c:	20 20       	sub	r0,2
80006b0e:	20 20       	sub	r0,2
80006b10:	20 20       	sub	r0,2
80006b12:	20 20       	sub	r0,2
80006b14:	20 20       	sub	r0,2
80006b16:	20 00       	sub	r0,0
80006b18:	46 6c       	lddsp	r12,sp[0x198]
80006b1a:	61 73       	ld.w	r3,r0[0x5c]
80006b1c:	68 20       	ld.w	r0,r4[0x8]
80006b1e:	28 30       	sub	r0,-125
80006b20:	2e 2e       	sub	lr,-30
80006b22:	34 29       	mov	r9,66
80006b24:	20 20       	sub	r0,2
80006b26:	20 20       	sub	r0,2
80006b28:	20 20       	sub	r0,2
80006b2a:	20 20       	sub	r0,2
80006b2c:	20 20       	sub	r0,2
80006b2e:	20 20       	sub	r0,2
80006b30:	20 20       	sub	r0,2
80006b32:	20 20       	sub	r0,2
80006b34:	20 20       	sub	r0,2
80006b36:	20 20       	sub	r0,2
80006b38:	20 20       	sub	r0,2
80006b3a:	20 20       	sub	r0,2
80006b3c:	20 20       	sub	r0,2
80006b3e:	20 00       	sub	r0,0
80006b40:	4c 45       	lddpc	r5,80006c50 <led_shelf+0x900>
80006b42:	44 20       	lddsp	r0,sp[0x108]
80006b44:	42 6f       	lddsp	pc,sp[0x98]
80006b46:	61 72       	ld.w	r2,r0[0x5c]
80006b48:	64 20       	ld.w	r0,r2[0x8]
80006b4a:	53 65       	stdsp	sp[0xd8],r5
80006b4c:	72 69       	ld.w	r9,r9[0x18]
80006b4e:	61 6c       	ld.w	r12,r0[0x58]
80006b50:	20 49       	sub	r9,4
80006b52:	44 20       	lddsp	r0,sp[0x108]
80006b54:	43 68       	lddsp	r8,sp[0xd8]
80006b56:	65 63       	ld.w	r3,r2[0x58]
80006b58:	6b 73       	ld.w	r3,r5[0x5c]
80006b5a:	75 6d       	ld.w	sp,r10[0x58]
80006b5c:	73 20       	ld.w	r0,r9[0x48]
80006b5e:	28 30       	sub	r0,-125
80006b60:	2e 2e       	sub	lr,-30
80006b62:	34 29       	mov	r9,66
80006b64:	20 20       	sub	r0,2
80006b66:	20 00       	sub	r0,0
80006b68:	4c 45       	lddpc	r5,80006c78 <led_shelf+0x928>
80006b6a:	44 20       	lddsp	r0,sp[0x108]
80006b6c:	42 6f       	lddsp	pc,sp[0x98]
80006b6e:	61 72       	ld.w	r2,r0[0x5c]
80006b70:	64 20       	ld.w	r0,r2[0x8]
80006b72:	53 69       	stdsp	sp[0xd8],r9
80006b74:	64 65       	ld.w	r5,r2[0x18]
80006b76:	20 4d       	sub	sp,16
80006b78:	61 78       	ld.w	r8,r0[0x5c]
80006b7a:	20 55       	sub	r5,5
80006b7c:	73 61       	ld.w	r1,r9[0x58]
80006b7e:	67 65       	ld.w	r5,r3[0x58]
80006b80:	20 28       	sub	r8,2
80006b82:	30 2e       	mov	lr,2
80006b84:	2e 37       	sub	r7,-29
80006b86:	29 20       	sub	r0,-110
80006b88:	20 20       	sub	r0,2
80006b8a:	20 20       	sub	r0,2
80006b8c:	20 20       	sub	r0,2
80006b8e:	20 00       	sub	r0,0
80006b90:	55 73       	stdsp	sp[0x15c],r3
80006b92:	61 67       	ld.w	r7,r0[0x58]
80006b94:	65 20       	ld.w	r0,r2[0x48]
80006b96:	53 74       	stdsp	sp[0xdc],r4
80006b98:	72 75       	ld.w	r5,r9[0x1c]
80006b9a:	63 74       	ld.w	r4,r1[0x5c]
80006b9c:	20 4f       	sub	pc,4
80006b9e:	70 65       	ld.w	r5,r8[0x18]
80006ba0:	6e 20       	ld.w	r0,r7[0x8]
80006ba2:	53 6c       	stdsp	sp[0xd8],r12
80006ba4:	6f 74       	ld.w	r4,r7[0x5c]
80006ba6:	73 20       	ld.w	r0,r9[0x48]
80006ba8:	20 20       	sub	r0,2
80006baa:	20 20       	sub	r0,2
80006bac:	20 20       	sub	r0,2
80006bae:	20 20       	sub	r0,2
80006bb0:	20 20       	sub	r0,2
80006bb2:	20 20       	sub	r0,2
80006bb4:	20 20       	sub	r0,2
80006bb6:	20 00       	sub	r0,0
80006bb8:	46 20       	lddsp	r0,sp[0x188]
80006bba:	0d 0a       	ld.w	r10,r6++
80006bbc:	00 00       	add	r0,r0
80006bbe:	00 00       	add	r0,r0
80006bc0:	50 20       	stdsp	sp[0x8],r0
80006bc2:	0d 0a       	ld.w	r10,r6++
80006bc4:	00 00       	add	r0,r0
80006bc6:	00 00       	add	r0,r0
80006bc8:	0d 0a       	ld.w	r10,r6++
80006bca:	2a 2a       	sub	r10,-94
80006bcc:	2a 4c       	sub	r12,-92
80006bce:	45 44       	lddsp	r4,sp[0x150]
80006bd0:	20 42       	sub	r2,4
80006bd2:	4f 41       	lddpc	r1,80006da0 <led_shelf+0xa50>
80006bd4:	52 44       	stdsp	sp[0x90],r4
80006bd6:	53 20       	stdsp	sp[0xc8],r0
80006bd8:	4d 41       	lddpc	r1,80006d28 <led_shelf+0x9d8>
80006bda:	53 54       	stdsp	sp[0xd4],r4
80006bdc:	45 52       	lddsp	r2,sp[0x154]
80006bde:	20 4c       	sub	r12,4
80006be0:	49 53       	lddpc	r3,80006c34 <led_shelf+0x8e4>
80006be2:	54 2a       	stdsp	sp[0x108],r10
80006be4:	2a 2a       	sub	r10,-94
80006be6:	0d 0a       	ld.w	r10,r6++
80006be8:	0d 0a       	ld.w	r10,r6++
80006bea:	00 00       	add	r0,r0
80006bec:	25 32       	sub	r2,83
80006bee:	64 29       	ld.w	r9,r2[0x8]
80006bf0:	20 25       	sub	r5,2
80006bf2:	30 32       	mov	r2,3
80006bf4:	58 25       	cp.w	r5,2
80006bf6:	30 32       	mov	r2,3
80006bf8:	58 25       	cp.w	r5,2
80006bfa:	30 32       	mov	r2,3
80006bfc:	58 25       	cp.w	r5,2
80006bfe:	30 32       	mov	r2,3
80006c00:	58 25       	cp.w	r5,2
80006c02:	30 32       	mov	r2,3
80006c04:	58 25       	cp.w	r5,2
80006c06:	30 32       	mov	r2,3
80006c08:	58 20       	cp.w	r0,2
80006c0a:	00 00       	add	r0,r0
80006c0c:	20 54       	sub	r4,5
80006c0e:	4f 50       	lddpc	r0,80006de0 <led_shelf+0xa90>
80006c10:	0d 0a       	ld.w	r10,r6++
80006c12:	00 00       	add	r0,r0
80006c14:	20 42       	sub	r2,4
80006c16:	4f 54       	lddpc	r4,80006de8 <led_shelf+0xa98>
80006c18:	0d 0a       	ld.w	r10,r6++
80006c1a:	00 00       	add	r0,r0
80006c1c:	0d 0a       	ld.w	r10,r6++
80006c1e:	0d 0a       	ld.w	r10,r6++
80006c20:	00 00       	add	r0,r0
80006c22:	00 00       	add	r0,r0
80006c24:	54 79       	stdsp	sp[0x11c],r9
80006c26:	70 65       	ld.w	r5,r8[0x18]
80006c28:	20 27       	sub	r7,2
80006c2a:	48 27       	lddpc	r7,80006c30 <led_shelf+0x8e0>
80006c2c:	20 66       	sub	r6,6
80006c2e:	6f 72       	ld.w	r2,r7[0x5c]
80006c30:	20 68       	sub	r8,6
80006c32:	65 6c       	ld.w	r12,r2[0x58]
80006c34:	70 2e       	ld.w	lr,r8[0x8]
80006c36:	0d 0a       	ld.w	r10,r6++
80006c38:	0d 0a       	ld.w	r10,r6++
80006c3a:	00 00       	add	r0,r0
80006c3c:	0d 0a       	ld.w	r10,r6++
80006c3e:	2a 2a       	sub	r10,-94
80006c40:	2d 2d       	sub	sp,-184
80006c42:	2d 2d       	sub	sp,-184
80006c44:	2d 2d       	sub	sp,-184
80006c46:	2d 2d       	sub	sp,-184
80006c48:	2d 2d       	sub	sp,-184
80006c4a:	2d 2d       	sub	sp,-184
80006c4c:	2d 2d       	sub	sp,-184
80006c4e:	2d 2d       	sub	sp,-184
80006c50:	2d 2a       	sub	r10,-46
80006c52:	2a 0d       	sub	sp,-384
80006c54:	0a 00       	add	r0,r5
80006c56:	00 00       	add	r0,r0
80006c58:	20 20       	sub	r0,2
80006c5a:	45 6c       	lddsp	r12,sp[0x158]
80006c5c:	65 63       	ld.w	r3,r2[0x58]
80006c5e:	74 72       	ld.w	r2,r10[0x1c]
80006c60:	6f 63       	ld.w	r3,r7[0x58]
80006c62:	6c 61       	ld.w	r1,r6[0x18]
80006c64:	76 65       	ld.w	r5,r11[0x18]
80006c66:	20 48       	sub	r8,4
80006c68:	45 4c       	lddsp	r12,sp[0x150]
80006c6a:	50 0d       	stdsp	sp[0x0],sp
80006c6c:	0a 00       	add	r0,r5
80006c6e:	00 00       	add	r0,r0
80006c70:	2a 2a       	sub	r10,-94
80006c72:	2d 2d       	sub	sp,-184
80006c74:	2d 2d       	sub	sp,-184
80006c76:	2d 2d       	sub	sp,-184
80006c78:	2d 2d       	sub	sp,-184
80006c7a:	2d 2d       	sub	sp,-184
80006c7c:	2d 2d       	sub	sp,-184
80006c7e:	2d 2d       	sub	sp,-184
80006c80:	2d 2d       	sub	sp,-184
80006c82:	2d 2a       	sub	r10,-46
80006c84:	2a 0d       	sub	sp,-384
80006c86:	0a 00       	add	r0,r5
80006c88:	20 20       	sub	r0,2
80006c8a:	20 20       	sub	r0,2
80006c8c:	48 20       	lddpc	r0,80006c94 <led_shelf+0x944>
80006c8e:	20 20       	sub	r0,2
80006c90:	20 20       	sub	r0,2
80006c92:	20 20       	sub	r0,2
80006c94:	20 2d       	sub	sp,8
80006c96:	20 54       	sub	r4,5
80006c98:	68 69       	ld.w	r9,r4[0x18]
80006c9a:	73 20       	ld.w	r0,r9[0x48]
80006c9c:	68 65       	ld.w	r5,r4[0x18]
80006c9e:	6c 70       	ld.w	r0,r6[0x1c]
80006ca0:	20 6d       	sub	sp,24
80006ca2:	65 6e       	ld.w	lr,r2[0x58]
80006ca4:	75 0d       	ld.w	sp,r10[0x40]
80006ca6:	0a 00       	add	r0,r5
80006ca8:	20 20       	sub	r0,2
80006caa:	20 20       	sub	r0,2
80006cac:	44 20       	lddsp	r0,sp[0x108]
80006cae:	20 20       	sub	r0,2
80006cb0:	20 20       	sub	r0,2
80006cb2:	20 20       	sub	r0,2
80006cb4:	20 2d       	sub	sp,8
80006cb6:	20 53       	sub	r3,5
80006cb8:	68 6f       	ld.w	pc,r4[0x18]
80006cba:	77 20       	ld.w	r0,r11[0x48]
80006cbc:	63 75       	ld.w	r5,r1[0x5c]
80006cbe:	72 72       	ld.w	r2,r9[0x1c]
80006cc0:	65 6e       	ld.w	lr,r2[0x58]
80006cc2:	74 20       	ld.w	r0,r10[0x8]
80006cc4:	44 54       	lddsp	r4,sp[0x114]
80006cc6:	45 20       	lddsp	r0,sp[0x148]
80006cc8:	73 65       	ld.w	r5,r9[0x58]
80006cca:	74 74       	ld.w	r4,r10[0x1c]
80006ccc:	69 6e       	ld.w	lr,r4[0x58]
80006cce:	67 0d       	ld.w	sp,r3[0x40]
80006cd0:	0a 00       	add	r0,r5
80006cd2:	00 00       	add	r0,r0
80006cd4:	20 20       	sub	r0,2
80006cd6:	20 20       	sub	r0,2
80006cd8:	44 20       	lddsp	r0,sp[0x108]
80006cda:	20 78       	sub	r8,7
80006cdc:	78 20       	ld.w	r0,r12[0x8]
80006cde:	20 20       	sub	r0,2
80006ce0:	20 2d       	sub	sp,8
80006ce2:	20 43       	sub	r3,4
80006ce4:	68 61       	ld.w	r1,r4[0x18]
80006ce6:	6e 67       	ld.w	r7,r7[0x18]
80006ce8:	65 20       	ld.w	r0,r2[0x48]
80006cea:	69 6e       	ld.w	lr,r4[0x58]
80006cec:	69 74       	ld.w	r4,r4[0x5c]
80006cee:	69 61       	ld.w	r1,r4[0x58]
80006cf0:	6c 20       	ld.w	r0,r6[0x8]
80006cf2:	44 54       	lddsp	r4,sp[0x114]
80006cf4:	45 20       	lddsp	r0,sp[0x148]
80006cf6:	74 6f       	ld.w	pc,r10[0x18]
80006cf8:	20 78       	sub	r8,7
80006cfa:	78 20       	ld.w	r0,r12[0x8]
80006cfc:	6d 69       	ld.w	r9,r6[0x58]
80006cfe:	6e 75       	ld.w	r5,r7[0x1c]
80006d00:	74 65       	ld.w	r5,r10[0x18]
80006d02:	73 20       	ld.w	r0,r9[0x48]
80006d04:	77 68       	ld.w	r8,r11[0x58]
80006d06:	65 72       	ld.w	r2,r2[0x5c]
80006d08:	65 20       	ld.w	r0,r2[0x48]
80006d0a:	32 20       	mov	r0,34
80006d0c:	3e 3d       	mov	sp,-29
80006d0e:	20 78       	sub	r8,7
80006d10:	78 20       	ld.w	r0,r12[0x8]
80006d12:	3e 3d       	mov	sp,-29
80006d14:	20 35       	sub	r5,3
80006d16:	39 2e       	mov	lr,-110
80006d18:	0d 0a       	ld.w	r10,r6++
80006d1a:	00 00       	add	r0,r0
80006d1c:	20 20       	sub	r0,2
80006d1e:	20 20       	sub	r0,2
80006d20:	53 20       	stdsp	sp[0xc8],r0
80006d22:	20 20       	sub	r0,2
80006d24:	20 20       	sub	r0,2
80006d26:	20 20       	sub	r0,2
80006d28:	20 2d       	sub	sp,8
80006d2a:	20 53       	sub	r3,5
80006d2c:	79 73       	ld.w	r3,r12[0x5c]
80006d2e:	74 65       	ld.w	r5,r10[0x18]
80006d30:	6d 20       	ld.w	r0,r6[0x48]
80006d32:	73 74       	ld.w	r4,r9[0x5c]
80006d34:	61 74       	ld.w	r4,r0[0x5c]
80006d36:	75 73       	ld.w	r3,r10[0x5c]
80006d38:	0d 0a       	ld.w	r10,r6++
80006d3a:	00 00       	add	r0,r0
80006d3c:	3e 00       	mov	r0,-32
80006d3e:	00 00       	add	r0,r0
80006d40:	49 6e       	lddpc	lr,80006d98 <led_shelf+0xa48>
80006d42:	69 74       	ld.w	r4,r4[0x5c]
80006d44:	69 61       	ld.w	r1,r4[0x58]
80006d46:	6c 20       	ld.w	r0,r6[0x8]
80006d48:	44 54       	lddsp	r4,sp[0x114]
80006d4a:	45 20       	lddsp	r0,sp[0x148]
80006d4c:	73 65       	ld.w	r5,r9[0x58]
80006d4e:	74 20       	ld.w	r0,r10[0x8]
80006d50:	74 6f       	ld.w	pc,r10[0x18]
80006d52:	3a 20       	mov	r0,-94
80006d54:	00 00       	add	r0,r0
80006d56:	00 00       	add	r0,r0
80006d58:	20 6d       	sub	sp,24
80006d5a:	69 6e       	ld.w	lr,r4[0x58]
80006d5c:	75 74       	ld.w	r4,r10[0x5c]
80006d5e:	65 73       	ld.w	r3,r2[0x5c]
80006d60:	2e 0d       	sub	sp,-128
80006d62:	0a 3e       	cp.w	lr,r5
80006d64:	00 00       	add	r0,r0
80006d66:	00 00       	add	r0,r0
80006d68:	49 6e       	lddpc	lr,80006dc0 <led_shelf+0xa70>
80006d6a:	69 74       	ld.w	r4,r4[0x5c]
80006d6c:	69 61       	ld.w	r1,r4[0x58]
80006d6e:	6c 20       	ld.w	r0,r6[0x8]
80006d70:	44 54       	lddsp	r4,sp[0x114]
80006d72:	45 20       	lddsp	r0,sp[0x148]
80006d74:	6e 6f       	ld.w	pc,r7[0x18]
80006d76:	77 20       	ld.w	r0,r11[0x48]
80006d78:	73 65       	ld.w	r5,r9[0x58]
80006d7a:	74 20       	ld.w	r0,r10[0x8]
80006d7c:	74 6f       	ld.w	pc,r10[0x18]
80006d7e:	3a 20       	mov	r0,-94
80006d80:	00 00       	add	r0,r0
80006d82:	00 00       	add	r0,r0
80006d84:	0d 0a       	ld.w	r10,r6++
80006d86:	3e 00       	mov	r0,-32
80006d88:	45 72       	lddsp	r2,sp[0x15c]
80006d8a:	72 6f       	ld.w	pc,r9[0x18]
80006d8c:	72 2e       	ld.w	lr,r9[0x8]
80006d8e:	20 49       	sub	r9,4
80006d90:	6e 69       	ld.w	r9,r7[0x18]
80006d92:	74 69       	ld.w	r9,r10[0x18]
80006d94:	61 6c       	ld.w	r12,r0[0x58]
80006d96:	20 44       	sub	r4,4
80006d98:	54 45       	stdsp	sp[0x110],r5
80006d9a:	20 6e       	sub	lr,6
80006d9c:	6f 74       	ld.w	r4,r7[0x5c]
80006d9e:	20 6d       	sub	sp,24
80006da0:	6f 64       	ld.w	r4,r7[0x58]
80006da2:	69 66       	ld.w	r6,r4[0x58]
80006da4:	69 65       	ld.w	r5,r4[0x58]
80006da6:	64 2e       	ld.w	lr,r2[0x8]
80006da8:	20 0d       	sub	sp,0
80006daa:	0a 00       	add	r0,r5
80006dac:	4d 75       	lddpc	r5,80006f08 <led_shelf+0xbb8>
80006dae:	73 74       	ld.w	r4,r9[0x5c]
80006db0:	20 62       	sub	r2,6
80006db2:	65 20       	ld.w	r0,r2[0x48]
80006db4:	61 20       	ld.w	r0,r0[0x48]
80006db6:	76 61       	ld.w	r1,r11[0x18]
80006db8:	6c 75       	ld.w	r5,r6[0x1c]
80006dba:	65 20       	ld.w	r0,r2[0x48]
80006dbc:	62 65       	ld.w	r5,r1[0x18]
80006dbe:	74 77       	ld.w	r7,r10[0x1c]
80006dc0:	65 65       	ld.w	r5,r2[0x58]
80006dc2:	6e 20       	ld.w	r0,r7[0x8]
80006dc4:	32 20       	mov	r0,34
80006dc6:	61 6e       	ld.w	lr,r0[0x58]
80006dc8:	64 20       	ld.w	r0,r2[0x8]
80006dca:	35 39       	mov	r9,83
80006dcc:	2e 0d       	sub	sp,-128
80006dce:	0a 3e       	cp.w	lr,r5
80006dd0:	00 00       	add	r0,r0
80006dd2:	00 00       	add	r0,r0
80006dd4:	44 6f       	lddsp	pc,sp[0x118]
80006dd6:	6f 72       	ld.w	r2,r7[0x5c]
80006dd8:	20 6c       	sub	r12,6
80006dda:	61 74       	ld.w	r4,r0[0x5c]
80006ddc:	63 68       	ld.w	r8,r1[0x58]
80006dde:	20 64       	sub	r4,6
80006de0:	65 74       	ld.w	r4,r2[0x5c]
80006de2:	65 63       	ld.w	r3,r2[0x58]
80006de4:	74 65       	ld.w	r5,r10[0x18]
80006de6:	64 0d       	ld.w	sp,r2[0x0]
80006de8:	0a 00       	add	r0,r5
80006dea:	00 00       	add	r0,r0
80006dec:	41 63       	lddsp	r3,sp[0x58]
80006dee:	74 69       	ld.w	r9,r10[0x18]
80006df0:	6f 6e       	ld.w	lr,r7[0x58]
80006df2:	20 70       	sub	r0,7
80006df4:	75 73       	ld.w	r3,r10[0x5c]
80006df6:	68 20       	ld.w	r0,r4[0x8]
80006df8:	62 75       	ld.w	r5,r1[0x1c]
80006dfa:	74 74       	ld.w	r4,r10[0x1c]
80006dfc:	6f 6e       	ld.w	lr,r7[0x58]
80006dfe:	20 70       	sub	r0,7
80006e00:	72 65       	ld.w	r5,r9[0x18]
80006e02:	73 73       	ld.w	r3,r9[0x5c]
80006e04:	20 64       	sub	r4,6
80006e06:	65 74       	ld.w	r4,r2[0x5c]
80006e08:	65 63       	ld.w	r3,r2[0x58]
80006e0a:	74 65       	ld.w	r5,r10[0x18]
80006e0c:	64 0d       	ld.w	sp,r2[0x0]
80006e0e:	0a 00       	add	r0,r5
80006e10:	41 63       	lddsp	r3,sp[0x58]
80006e12:	74 69       	ld.w	r9,r10[0x18]
80006e14:	6f 6e       	ld.w	lr,r7[0x58]
80006e16:	20 70       	sub	r0,7
80006e18:	75 73       	ld.w	r3,r10[0x5c]
80006e1a:	68 20       	ld.w	r0,r4[0x8]
80006e1c:	62 75       	ld.w	r5,r1[0x1c]
80006e1e:	74 74       	ld.w	r4,r10[0x1c]
80006e20:	6f 6e       	ld.w	lr,r7[0x58]
80006e22:	20 72       	sub	r2,7
80006e24:	65 6c       	ld.w	r12,r2[0x58]
80006e26:	65 61       	ld.w	r1,r2[0x58]
80006e28:	73 65       	ld.w	r5,r9[0x58]
80006e2a:	20 64       	sub	r4,6
80006e2c:	65 74       	ld.w	r4,r2[0x5c]
80006e2e:	65 63       	ld.w	r3,r2[0x58]
80006e30:	74 65       	ld.w	r5,r10[0x18]
80006e32:	64 0d       	ld.w	sp,r2[0x0]
80006e34:	0a 00       	add	r0,r5
80006e36:	00 00       	add	r0,r0
80006e38:	53 61       	stdsp	sp[0xd8],r1
80006e3a:	6e 69       	ld.w	r9,r7[0x18]
80006e3c:	74 69       	ld.w	r9,r10[0x18]
80006e3e:	7a 69       	ld.w	r9,sp[0x18]
80006e40:	6e 67       	ld.w	r7,r7[0x18]
80006e42:	0d 0a       	ld.w	r10,r6++
80006e44:	00 00       	add	r0,r0
80006e46:	00 00       	add	r0,r0
80006e48:	41 74       	lddsp	r4,sp[0x5c]
80006e4a:	20 6c       	sub	r12,6
80006e4c:	65 61       	ld.w	r1,r2[0x58]
80006e4e:	73 74       	ld.w	r4,r9[0x5c]
80006e50:	20 6f       	sub	pc,6
80006e52:	6e 65       	ld.w	r5,r7[0x18]
80006e54:	20 73       	sub	r3,7
80006e56:	68 65       	ld.w	r5,r4[0x18]
80006e58:	6c 66       	ld.w	r6,r6[0x18]
80006e5a:	20 69       	sub	r9,6
80006e5c:	73 20       	ld.w	r0,r9[0x48]
80006e5e:	70 72       	ld.w	r2,r8[0x1c]
80006e60:	65 73       	ld.w	r3,r2[0x5c]
80006e62:	65 6e       	ld.w	lr,r2[0x58]
80006e64:	74 2c       	ld.w	r12,r10[0x8]
80006e66:	20 62       	sub	r2,6
80006e68:	75 74       	ld.w	r4,r10[0x5c]
80006e6a:	20 6e       	sub	lr,6
80006e6c:	6f 20       	ld.w	r0,r7[0x48]
80006e6e:	64 65       	ld.w	r5,r2[0x18]
80006e70:	76 69       	ld.w	r9,r11[0x18]
80006e72:	63 65       	ld.w	r5,r1[0x58]
80006e74:	73 20       	ld.w	r0,r9[0x48]
80006e76:	74 6f       	ld.w	pc,r10[0x18]
80006e78:	20 62       	sub	r2,6
80006e7a:	65 20       	ld.w	r0,r2[0x48]
80006e7c:	63 6c       	ld.w	r12,r1[0x58]
80006e7e:	65 61       	ld.w	r1,r2[0x58]
80006e80:	6e 65       	ld.w	r5,r7[0x18]
80006e82:	64 2e       	ld.w	lr,r2[0x8]
80006e84:	0d 0a       	ld.w	r10,r6++
80006e86:	00 00       	add	r0,r0
80006e88:	4e 6f       	lddpc	pc,80007020 <osc_get_rate+0x24>
80006e8a:	20 73       	sub	r3,7
80006e8c:	68 65       	ld.w	r5,r4[0x18]
80006e8e:	6c 76       	ld.w	r6,r6[0x1c]
80006e90:	65 73       	ld.w	r3,r2[0x5c]
80006e92:	2c 20       	sub	r0,-62
80006e94:	6f 72       	ld.w	r2,r7[0x5c]
80006e96:	20 73       	sub	r3,7
80006e98:	68 65       	ld.w	r5,r4[0x18]
80006e9a:	6c 76       	ld.w	r6,r6[0x1c]
80006e9c:	65 73       	ld.w	r3,r2[0x5c]
80006e9e:	20 61       	sub	r1,6
80006ea0:	72 65       	ld.w	r5,r9[0x18]
80006ea2:	20 70       	sub	r0,7
80006ea4:	61 73       	ld.w	r3,r0[0x5c]
80006ea6:	74 20       	ld.w	r0,r10[0x8]
80006ea8:	6c 69       	ld.w	r9,r6[0x18]
80006eaa:	66 65       	ld.w	r5,r3[0x18]
80006eac:	74 69       	ld.w	r9,r10[0x18]
80006eae:	6d 65       	ld.w	r5,r6[0x58]
80006eb0:	0d 0a       	ld.w	r10,r6++
80006eb2:	00 00       	add	r0,r0
80006eb4:	73 61       	ld.w	r1,r9[0x58]
80006eb6:	6e 69       	ld.w	r9,r7[0x18]
80006eb8:	74 69       	ld.w	r9,r10[0x18]
80006eba:	7a 65       	ld.w	r5,sp[0x18]
80006ebc:	4d 69       	lddpc	r9,80007014 <osc_get_rate+0x18>
80006ebe:	6e 75       	ld.w	r5,r7[0x1c]
80006ec0:	74 65       	ld.w	r5,r10[0x18]
80006ec2:	73 3a       	ld.w	r10,r9[0x4c]
80006ec4:	20 25       	sub	r5,2
80006ec6:	6c 64       	ld.w	r4,r6[0x18]
80006ec8:	20 74       	sub	r4,7
80006eca:	6d 70       	ld.w	r0,r6[0x5c]
80006ecc:	53 61       	stdsp	sp[0xd8],r1
80006ece:	6e 69       	ld.w	r9,r7[0x18]
80006ed0:	74 69       	ld.w	r9,r10[0x18]
80006ed2:	7a 65       	ld.w	r5,sp[0x18]
80006ed4:	4d 69       	lddpc	r9,8000702c <osc_get_rate+0x30>
80006ed6:	6e 75       	ld.w	r5,r7[0x1c]
80006ed8:	74 65       	ld.w	r5,r10[0x18]
80006eda:	73 3a       	ld.w	r10,r9[0x4c]
80006edc:	20 25       	sub	r5,2
80006ede:	6c 64       	ld.w	r4,r6[0x18]
80006ee0:	0d 0a       	ld.w	r10,r6++
80006ee2:	00 00       	add	r0,r0
80006ee4:	53 68       	stdsp	sp[0xd8],r8
80006ee6:	65 6c       	ld.w	r12,r2[0x58]
80006ee8:	66 20       	ld.w	r0,r3[0x8]
80006eea:	63 6c       	ld.w	r12,r1[0x58]
80006eec:	65 61       	ld.w	r1,r2[0x58]
80006eee:	6e 0d       	ld.w	sp,r7[0x0]
80006ef0:	0a 00       	add	r0,r5
80006ef2:	00 00       	add	r0,r0
80006ef4:	44 6f       	lddsp	pc,sp[0x118]
80006ef6:	6f 72       	ld.w	r2,r7[0x5c]
80006ef8:	20 6c       	sub	r12,6
80006efa:	61 74       	ld.w	r4,r0[0x5c]
80006efc:	63 68       	ld.w	r8,r1[0x58]
80006efe:	20 6f       	sub	pc,6
80006f00:	70 65       	ld.w	r5,r8[0x18]
80006f02:	6e 65       	ld.w	r5,r7[0x18]
80006f04:	64 2c       	ld.w	r12,r2[0x8]
80006f06:	20 73       	sub	r3,7
80006f08:	68 75       	ld.w	r5,r4[0x1c]
80006f0a:	74 74       	ld.w	r4,r10[0x1c]
80006f0c:	69 6e       	ld.w	lr,r4[0x58]
80006f0e:	67 20       	ld.w	r0,r3[0x48]
80006f10:	64 6f       	ld.w	pc,r2[0x18]
80006f12:	77 6e       	ld.w	lr,r11[0x58]
80006f14:	20 61       	sub	r1,6
80006f16:	6c 6c       	ld.w	r12,r6[0x18]
80006f18:	20 70       	sub	r0,7
80006f1a:	72 6f       	ld.w	pc,r9[0x18]
80006f1c:	63 65       	ld.w	r5,r1[0x58]
80006f1e:	73 73       	ld.w	r3,r9[0x5c]
80006f20:	65 73       	ld.w	r3,r2[0x5c]
80006f22:	0d 0a       	ld.w	r10,r6++
80006f24:	00 00       	add	r0,r0
	...

80006f28 <osc_enable>:
extern void osc_priv_enable_rc120m(void);
extern void osc_priv_disable_rc120m(void);
extern bool osc_priv_rc120m_is_ready(void);

static inline void osc_enable(uint8_t id)
{
80006f28:	eb cd 40 80 	pushm	r7,lr
80006f2c:	1a 97       	mov	r7,sp
80006f2e:	20 1d       	sub	sp,4
80006f30:	18 98       	mov	r8,r12
80006f32:	ef 68 ff fc 	st.b	r7[-4],r8
	switch (id) {
80006f36:	ef 38 ff fc 	ld.ub	r8,r7[-4]
80006f3a:	58 28       	cp.w	r8,2
80006f3c:	c1 10       	breq	80006f5e <osc_enable+0x36>
80006f3e:	e0 89 00 05 	brgt	80006f48 <osc_enable+0x20>
80006f42:	58 08       	cp.w	r8,0
80006f44:	c0 70       	breq	80006f52 <osc_enable+0x2a>
80006f46:	c1 18       	rjmp	80006f68 <osc_enable+0x40>
80006f48:	58 38       	cp.w	r8,3
80006f4a:	c0 70       	breq	80006f58 <osc_enable+0x30>
80006f4c:	58 48       	cp.w	r8,4
80006f4e:	c0 b0       	breq	80006f64 <osc_enable+0x3c>
80006f50:	c0 c8       	rjmp	80006f68 <osc_enable+0x40>
#ifdef BOARD_OSC0_HZ
	case OSC_ID_OSC0:
		osc_priv_enable_osc0();
80006f52:	f0 1f 00 08 	mcall	80006f70 <osc_enable+0x48>
		break;
80006f56:	c0 98       	rjmp	80006f68 <osc_enable+0x40>
		break;
#endif

#ifdef BOARD_OSC32_HZ
	case OSC_ID_OSC32:
		osc_priv_enable_osc32();
80006f58:	f0 1f 00 07 	mcall	80006f74 <osc_enable+0x4c>
		break;
80006f5c:	c0 68       	rjmp	80006f68 <osc_enable+0x40>
#endif

	case OSC_ID_RC8M:
		osc_priv_enable_rc8m();
80006f5e:	f0 1f 00 07 	mcall	80006f78 <osc_enable+0x50>
		break;
80006f62:	c0 38       	rjmp	80006f68 <osc_enable+0x40>

	case OSC_ID_RC120M:
		osc_priv_enable_rc120m();
80006f64:	f0 1f 00 06 	mcall	80006f7c <osc_enable+0x54>

	default:
		/* unhandled_case(id); */
		break;
	}
}
80006f68:	2f fd       	sub	sp,-4
80006f6a:	e3 cd 80 80 	ldm	sp++,r7,pc
80006f6e:	00 00       	add	r0,r0
80006f70:	80 00       	ld.sh	r0,r0[0x0]
80006f72:	5a 34       	cp.w	r4,-29
80006f74:	80 00       	ld.sh	r0,r0[0x0]
80006f76:	5a 74       	cp.w	r4,-25
80006f78:	80 00       	ld.sh	r0,r0[0x0]
80006f7a:	5a b4       	cp.w	r4,-21
80006f7c:	80 00       	ld.sh	r0,r0[0x0]
80006f7e:	5b 38       	cp.w	r8,-13

80006f80 <osc_is_ready>:
		break;
	}
}

static inline bool osc_is_ready(uint8_t id)
{
80006f80:	eb cd 40 80 	pushm	r7,lr
80006f84:	1a 97       	mov	r7,sp
80006f86:	20 1d       	sub	sp,4
80006f88:	18 98       	mov	r8,r12
80006f8a:	ef 68 ff fc 	st.b	r7[-4],r8
	switch (id) {
80006f8e:	ef 38 ff fc 	ld.ub	r8,r7[-4]
80006f92:	58 38       	cp.w	r8,3
80006f94:	c1 50       	breq	80006fbe <osc_is_ready+0x3e>
80006f96:	e0 89 00 07 	brgt	80006fa4 <osc_is_ready+0x24>
80006f9a:	58 08       	cp.w	r8,0
80006f9c:	c0 90       	breq	80006fae <osc_is_ready+0x2e>
80006f9e:	58 28       	cp.w	r8,2
80006fa0:	c1 70       	breq	80006fce <osc_is_ready+0x4e>
80006fa2:	c2 88       	rjmp	80006ff2 <osc_is_ready+0x72>
80006fa4:	58 48       	cp.w	r8,4
80006fa6:	c1 c0       	breq	80006fde <osc_is_ready+0x5e>
80006fa8:	58 58       	cp.w	r8,5
80006faa:	c2 20       	breq	80006fee <osc_is_ready+0x6e>
80006fac:	c2 38       	rjmp	80006ff2 <osc_is_ready+0x72>
#ifdef BOARD_OSC0_HZ
	case OSC_ID_OSC0:
		return !!(AVR32_SCIF.pclksr & (1 << AVR32_SCIF_OSC0RDY));
80006fae:	fe 78 08 00 	mov	r8,-63488
80006fb2:	70 58       	ld.w	r8,r8[0x14]
80006fb4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006fb8:	5f 18       	srne	r8
80006fba:	5c 58       	castu.b	r8
80006fbc:	c1 c8       	rjmp	80006ff4 <osc_is_ready+0x74>
		return !!(AVR32_SCIF.pclksr & (1 << AVR32_SCIF_OSC1RDY));
#endif

#ifdef BOARD_OSC32_HZ
	case OSC_ID_OSC32:
		return !!(AVR32_SCIF.pclksr & (1 << AVR32_SCIF_OSC32RDY));
80006fbe:	fe 78 08 00 	mov	r8,-63488
80006fc2:	70 58       	ld.w	r8,r8[0x14]
80006fc4:	e2 18 00 04 	andl	r8,0x4,COH
80006fc8:	5f 18       	srne	r8
80006fca:	5c 58       	castu.b	r8
80006fcc:	c1 48       	rjmp	80006ff4 <osc_is_ready+0x74>
#endif

	case OSC_ID_RC8M:
		return !!(AVR32_SCIF.pclksr & (1U << AVR32_SCIF_RCOSC8MRDY));
80006fce:	fe 78 08 00 	mov	r8,-63488
80006fd2:	70 58       	ld.w	r8,r8[0x14]
80006fd4:	e2 18 00 08 	andl	r8,0x8,COH
80006fd8:	5f 18       	srne	r8
80006fda:	5c 58       	castu.b	r8
80006fdc:	c0 c8       	rjmp	80006ff4 <osc_is_ready+0x74>

	case OSC_ID_RC120M:
		return !!(AVR32_SCIF.rc120mcr & (1 << AVR32_SCIF_RC120MCR_EN));
80006fde:	fe 78 08 00 	mov	r8,-63488
80006fe2:	71 68       	ld.w	r8,r8[0x58]
80006fe4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006fe8:	5f 18       	srne	r8
80006fea:	5c 58       	castu.b	r8
80006fec:	c0 48       	rjmp	80006ff4 <osc_is_ready+0x74>

	case OSC_ID_RCSYS:
		/* RCSYS is always ready */
		return true;
80006fee:	30 18       	mov	r8,1
80006ff0:	c0 28       	rjmp	80006ff4 <osc_is_ready+0x74>

	default:
		/* unhandled_case(id); */
		return false;
80006ff2:	30 08       	mov	r8,0
	}
}
80006ff4:	10 9c       	mov	r12,r8
80006ff6:	2f fd       	sub	sp,-4
80006ff8:	e3 cd 80 80 	ldm	sp++,r7,pc

80006ffc <osc_get_rate>:
/**
 * \todo RC8M may run at either 8 MHz or 1 MHz. Currently, we assume
 * it's always running at 8 MHz.
 */
static inline uint32_t osc_get_rate(uint8_t id)
{
80006ffc:	eb cd 40 80 	pushm	r7,lr
80007000:	1a 97       	mov	r7,sp
80007002:	20 1d       	sub	sp,4
80007004:	18 98       	mov	r8,r12
80007006:	ef 68 ff fc 	st.b	r7[-4],r8
	switch (id) {
8000700a:	ef 38 ff fc 	ld.ub	r8,r7[-4]
8000700e:	58 38       	cp.w	r8,3
80007010:	c1 20       	breq	80007034 <osc_get_rate+0x38>
80007012:	e0 89 00 07 	brgt	80007020 <osc_get_rate+0x24>
80007016:	58 08       	cp.w	r8,0
80007018:	c0 90       	breq	8000702a <osc_get_rate+0x2e>
8000701a:	58 28       	cp.w	r8,2
8000701c:	c0 f0       	breq	8000703a <osc_get_rate+0x3e>
8000701e:	c1 b8       	rjmp	80007054 <osc_get_rate+0x58>
80007020:	58 48       	cp.w	r8,4
80007022:	c1 10       	breq	80007044 <osc_get_rate+0x48>
80007024:	58 58       	cp.w	r8,5
80007026:	c1 40       	breq	8000704e <osc_get_rate+0x52>
80007028:	c1 68       	rjmp	80007054 <osc_get_rate+0x58>
#ifdef BOARD_OSC0_HZ
	case OSC_ID_OSC0:
		return BOARD_OSC0_HZ;
8000702a:	e0 68 24 00 	mov	r8,9216
8000702e:	ea 18 00 f4 	orh	r8,0xf4
80007032:	c1 28       	rjmp	80007056 <osc_get_rate+0x5a>
		return BOARD_OSC1_HZ;
#endif

#ifdef BOARD_OSC32_HZ
	case OSC_ID_OSC32:
		return BOARD_OSC32_HZ;
80007034:	e0 68 80 00 	mov	r8,32768
80007038:	c0 f8       	rjmp	80007056 <osc_get_rate+0x5a>
#endif

	case OSC_ID_RC8M:
		return OSC_RC8M_NOMINAL_HZ;
8000703a:	e0 68 12 00 	mov	r8,4608
8000703e:	ea 18 00 7a 	orh	r8,0x7a
80007042:	c0 a8       	rjmp	80007056 <osc_get_rate+0x5a>

	case OSC_ID_RC120M:
		return OSC_RC120M_NOMINAL_HZ;
80007044:	e0 68 0e 00 	mov	r8,3584
80007048:	ea 18 07 27 	orh	r8,0x727
8000704c:	c0 58       	rjmp	80007056 <osc_get_rate+0x5a>

	case OSC_ID_RCSYS:
		return OSC_RCSYS_NOMINAL_HZ;
8000704e:	e0 78 c1 38 	mov	r8,115000
80007052:	c0 28       	rjmp	80007056 <osc_get_rate+0x5a>

	default:
		/* unhandled_case(id); */
		return 0;
80007054:	30 08       	mov	r8,0
	}
}
80007056:	10 9c       	mov	r12,r8
80007058:	2f fd       	sub	sp,-4
8000705a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000705e:	d7 03       	nop

80007060 <osc_wait_ready>:
 * to become stable and ready to use as a clock source.
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
80007060:	eb cd 40 80 	pushm	r7,lr
80007064:	1a 97       	mov	r7,sp
80007066:	20 1d       	sub	sp,4
80007068:	18 98       	mov	r8,r12
8000706a:	ef 68 ff fc 	st.b	r7[-4],r8
	while (!osc_is_ready(id)) {
8000706e:	ef 38 ff fc 	ld.ub	r8,r7[-4]
80007072:	10 9c       	mov	r12,r8
80007074:	f0 1f 00 05 	mcall	80007088 <osc_wait_ready+0x28>
80007078:	18 98       	mov	r8,r12
8000707a:	ec 18 00 01 	eorl	r8,0x1
8000707e:	5c 58       	castu.b	r8
80007080:	cf 71       	brne	8000706e <osc_wait_ready+0xe>
		/* Do nothing */
	}
}
80007082:	2f fd       	sub	sp,-4
80007084:	e3 cd 80 80 	ldm	sp++,r7,pc
80007088:	80 00       	ld.sh	r0,r0[0x0]
8000708a:	6f 80       	ld.w	r0,r7[0x60]

8000708c <pll_config_set_option>:
			* CONFIG_PLL##pll_id##_MUL)                            \
			/ CONFIG_PLL##pll_id##_DIV)

static inline void pll_config_set_option(struct pll_config *cfg,
		unsigned int option)
{
8000708c:	eb cd 40 80 	pushm	r7,lr
80007090:	1a 97       	mov	r7,sp
80007092:	20 2d       	sub	sp,8
80007094:	ef 4c ff fc 	st.w	r7[-4],r12
80007098:	ef 4b ff f8 	st.w	r7[-8],r11
	Assert(option < PLL_NR_OPTIONS);

	cfg->ctrl |= 1U << (AVR32_SCIF_PLLOPT + option);
8000709c:	ee f8 ff fc 	ld.w	r8,r7[-4]
800070a0:	70 09       	ld.w	r9,r8[0x0]
800070a2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800070a6:	2f d8       	sub	r8,-3
800070a8:	30 1a       	mov	r10,1
800070aa:	f4 08 09 48 	lsl	r8,r10,r8
800070ae:	10 49       	or	r9,r8
800070b0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800070b4:	91 09       	st.w	r8[0x0],r9
}
800070b6:	2f ed       	sub	sp,-8
800070b8:	e3 cd 80 80 	ldm	sp++,r7,pc

800070bc <pll_config_init>:
 * The PLL options #PLL_OPT_VCO_RANGE_LOW and #PLL_OPT_OUTPUT_DIV will
 * be set automatically based on the calculated target frequency.
 */
static inline void pll_config_init(struct pll_config *cfg,
		enum pll_source src, unsigned int div, unsigned int mul)
{
800070bc:	eb cd 40 80 	pushm	r7,lr
800070c0:	1a 97       	mov	r7,sp
800070c2:	20 5d       	sub	sp,20
800070c4:	ef 4c ff f8 	st.w	r7[-8],r12
800070c8:	ef 4b ff f4 	st.w	r7[-12],r11
800070cc:	ef 4a ff f0 	st.w	r7[-16],r10
800070d0:	ef 49 ff ec 	st.w	r7[-20],r9
	uint32_t vco_hz;

	Assert(src < PLL_NR_SOURCES);

	/* Calculate internal VCO frequency */
	vco_hz = osc_get_rate(src) * mul;
800070d4:	ee f8 ff f4 	ld.w	r8,r7[-12]
800070d8:	5c 58       	castu.b	r8
800070da:	10 9c       	mov	r12,r8
800070dc:	f0 1f 00 2e 	mcall	80007194 <pll_config_init+0xd8>
800070e0:	18 99       	mov	r9,r12
800070e2:	ee f8 ff ec 	ld.w	r8,r7[-20]
800070e6:	f2 08 02 48 	mul	r8,r9,r8
800070ea:	ef 48 ff fc 	st.w	r7[-4],r8
	vco_hz /= div;
800070ee:	ee f8 ff fc 	ld.w	r8,r7[-4]
800070f2:	ee f9 ff f0 	ld.w	r9,r7[-16]
800070f6:	f0 09 0d 08 	divu	r8,r8,r9
800070fa:	ef 48 ff fc 	st.w	r7[-4],r8
	Assert(vco_hz >= PLL_MIN_HZ);
	Assert(vco_hz <= PLL_MAX_HZ);

	cfg->ctrl = 0;
800070fe:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007102:	30 09       	mov	r9,0
80007104:	91 09       	st.w	r8[0x0],r9

	/* Bring the internal VCO frequency up to the minimum value */
	if ((vco_hz < PLL_MIN_HZ * 2) && (mul <= 8)) {
80007106:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000710a:	e0 69 b3 ff 	mov	r9,46079
8000710e:	ea 19 04 c4 	orh	r9,0x4c4
80007112:	12 38       	cp.w	r8,r9
80007114:	e0 8b 00 16 	brhi	80007140 <pll_config_init+0x84>
80007118:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000711c:	58 88       	cp.w	r8,8
8000711e:	e0 8b 00 11 	brhi	80007140 <pll_config_init+0x84>
		mul *= 2;
80007122:	ee f8 ff ec 	ld.w	r8,r7[-20]
80007126:	a1 78       	lsl	r8,0x1
80007128:	ef 48 ff ec 	st.w	r7[-20],r8
		vco_hz *= 2;
8000712c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007130:	a1 78       	lsl	r8,0x1
80007132:	ef 48 ff fc 	st.w	r7[-4],r8
		pll_config_set_option(cfg, PLL_OPT_OUTPUT_DIV);
80007136:	30 1b       	mov	r11,1
80007138:	ee fc ff f8 	ld.w	r12,r7[-8]
8000713c:	f0 1f 00 17 	mcall	80007198 <pll_config_init+0xdc>
	}

	/* Set VCO frequency range according to calculated value */
	if (vco_hz < PLL_VCO_LOW_THRESHOLD)
80007140:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007144:	e0 69 fe 7f 	mov	r9,65151
80007148:	ea 19 0a 21 	orh	r9,0xa21
8000714c:	12 38       	cp.w	r8,r9
8000714e:	e0 8b 00 07 	brhi	8000715c <pll_config_init+0xa0>
		pll_config_set_option(cfg, PLL_OPT_VCO_RANGE_LOW);
80007152:	30 0b       	mov	r11,0
80007154:	ee fc ff f8 	ld.w	r12,r7[-8]
80007158:	f0 1f 00 10 	mcall	80007198 <pll_config_init+0xdc>

	Assert(mul > 2 && mul <= 16);
	Assert(div > 0 && div <= 15);

	cfg->ctrl |= ((mul - 1) << AVR32_SCIF_PLLMUL)
8000715c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007160:	70 09       	ld.w	r9,r8[0x0]
80007162:	ee f8 ff ec 	ld.w	r8,r7[-20]
80007166:	20 18       	sub	r8,1
80007168:	f0 0a 15 10 	lsl	r10,r8,0x10
		| (div << AVR32_SCIF_PLLDIV)
8000716c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007170:	a9 68       	lsl	r8,0x8
		| (PLL_MAX_STARTUP_CYCLES << AVR32_SCIF_PLLCOUNT)
80007172:	10 4a       	or	r10,r8
		| (src << AVR32_SCIF_PLLOSC);
80007174:	ee f8 ff f4 	ld.w	r8,r7[-12]
80007178:	a1 78       	lsl	r8,0x1
		pll_config_set_option(cfg, PLL_OPT_VCO_RANGE_LOW);

	Assert(mul > 2 && mul <= 16);
	Assert(div > 0 && div <= 15);

	cfg->ctrl |= ((mul - 1) << AVR32_SCIF_PLLMUL)
8000717a:	f5 e8 10 08 	or	r8,r10,r8
8000717e:	f3 e8 10 08 	or	r8,r9,r8
80007182:	10 99       	mov	r9,r8
80007184:	ea 19 3f 00 	orh	r9,0x3f00
80007188:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000718c:	91 09       	st.w	r8[0x0],r9
		| (div << AVR32_SCIF_PLLDIV)
		| (PLL_MAX_STARTUP_CYCLES << AVR32_SCIF_PLLCOUNT)
		| (src << AVR32_SCIF_PLLOSC);
}
8000718e:	2f bd       	sub	sp,-20
80007190:	e3 cd 80 80 	ldm	sp++,r7,pc
80007194:	80 00       	ld.sh	r0,r0[0x0]
80007196:	6f fc       	ld.w	r12,r7[0x7c]
80007198:	80 00       	ld.sh	r0,r0[0x0]
8000719a:	70 8c       	ld.w	r12,r8[0x20]

8000719c <pll_is_locked>:
extern void pll_config_write(const struct pll_config *cfg, unsigned int pll_id);
extern void pll_enable(const struct pll_config *cfg, unsigned int pll_id);
extern void pll_disable(unsigned int pll_id);

static inline bool pll_is_locked(unsigned int pll_id)
{
8000719c:	eb cd 40 80 	pushm	r7,lr
800071a0:	1a 97       	mov	r7,sp
800071a2:	20 1d       	sub	sp,4
800071a4:	ef 4c ff fc 	st.w	r7[-4],r12
	Assert(pll_id < NR_PLLS);

	return !!(AVR32_SCIF.pclksr & (1U << (AVR32_SCIF_PLL0_LOCK + pll_id)));
800071a8:	fe 78 08 00 	mov	r8,-63488
800071ac:	70 59       	ld.w	r9,r8[0x14]
800071ae:	ee f8 ff fc 	ld.w	r8,r7[-4]
800071b2:	2f c8       	sub	r8,-4
800071b4:	30 1a       	mov	r10,1
800071b6:	f4 08 09 48 	lsl	r8,r10,r8
800071ba:	f3 e8 00 08 	and	r8,r9,r8
800071be:	5f 18       	srne	r8
800071c0:	5c 58       	castu.b	r8
}
800071c2:	10 9c       	mov	r12,r8
800071c4:	2f fd       	sub	sp,-4
800071c6:	e3 cd 80 80 	ldm	sp++,r7,pc
800071ca:	d7 03       	nop

800071cc <pll_wait_for_lock>:
 *
 * \retval STATUS_OK The PLL is now locked.
 * \retval ERR_TIMEOUT Timed out waiting for PLL to become locked.
 */
static inline int pll_wait_for_lock(unsigned int pll_id)
{
800071cc:	eb cd 40 80 	pushm	r7,lr
800071d0:	1a 97       	mov	r7,sp
800071d2:	20 1d       	sub	sp,4
800071d4:	ef 4c ff fc 	st.w	r7[-4],r12
	Assert(pll_id < NR_PLLS);

	while (!pll_is_locked(pll_id)) {
800071d8:	ee fc ff fc 	ld.w	r12,r7[-4]
800071dc:	f0 1f 00 06 	mcall	800071f4 <pll_wait_for_lock+0x28>
800071e0:	18 98       	mov	r8,r12
800071e2:	ec 18 00 01 	eorl	r8,0x1
800071e6:	5c 58       	castu.b	r8
800071e8:	cf 81       	brne	800071d8 <pll_wait_for_lock+0xc>
		/* Do nothing */
	}

	return 0;
800071ea:	30 08       	mov	r8,0
}
800071ec:	10 9c       	mov	r12,r8
800071ee:	2f fd       	sub	sp,-4
800071f0:	e3 cd 80 80 	ldm	sp++,r7,pc
800071f4:	80 00       	ld.sh	r0,r0[0x0]
800071f6:	71 9c       	ld.w	r12,r8[0x64]

800071f8 <init_sysErr>:

#define BIT(x) (1<<(x))

void init_sysErr(void);
void init_sysErr(void)
{
800071f8:	eb cd 40 80 	pushm	r7,lr
800071fc:	1a 97       	mov	r7,sp
	memset(&sysErr, 0x00, sizeof(sysErr)); //Init everything to "PASS"
800071fe:	31 0a       	mov	r10,16
80007200:	30 0b       	mov	r11,0
80007202:	48 3c       	lddpc	r12,8000720c <init_sysErr+0x14>
80007204:	f0 1f 00 03 	mcall	80007210 <init_sysErr+0x18>
}
80007208:	e3 cd 80 80 	ldm	sp++,r7,pc
8000720c:	00 00       	add	r0,r0
8000720e:	0b d4       	ld.ub	r4,r5[0x5]
80007210:	80 00       	ld.sh	r0,r0[0x0]
80007212:	ce 02       	brcc	800071d2 <pll_wait_for_lock+0x6>

80007214 <display_text>:
};


void display_text(unsigned char idx);
void display_text(unsigned char idx)
{
80007214:	eb cd 40 80 	pushm	r7,lr
80007218:	1a 97       	mov	r7,sp
8000721a:	20 2d       	sub	sp,8
8000721c:	18 98       	mov	r8,r12
8000721e:	ef 68 ff f8 	st.b	r7[-8],r8
	for (int i = 0; i<7; i++)
80007222:	30 08       	mov	r8,0
80007224:	ef 48 ff fc 	st.w	r7[-4],r8
80007228:	c1 58       	rjmp	80007252 <display_text+0x3e>
	{
		usart_putchar(DISPLAY_USART, ((unsigned char) ((*(cmdPtrArray[idx]+i)))));
8000722a:	ef 39 ff f8 	ld.ub	r9,r7[-8]
8000722e:	48 e8       	lddpc	r8,80007264 <display_text+0x50>
80007230:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
80007234:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007238:	f2 08 00 08 	add	r8,r9,r8
8000723c:	11 88       	ld.ub	r8,r8[0x0]
8000723e:	10 9b       	mov	r11,r8
80007240:	fc 7c 14 00 	mov	r12,-191488
80007244:	f0 1f 00 09 	mcall	80007268 <display_text+0x54>


void display_text(unsigned char idx);
void display_text(unsigned char idx)
{
	for (int i = 0; i<7; i++)
80007248:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000724c:	2f f8       	sub	r8,-1
8000724e:	ef 48 ff fc 	st.w	r7[-4],r8
80007252:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007256:	58 68       	cp.w	r8,6
80007258:	fe 9a ff e9 	brle	8000722a <display_text+0x16>
	{
		usart_putchar(DISPLAY_USART, ((unsigned char) ((*(cmdPtrArray[idx]+i)))));
	}
	
}
8000725c:	2f ed       	sub	sp,-8
8000725e:	e3 cd 80 80 	ldm	sp++,r7,pc
80007262:	00 00       	add	r0,r0
80007264:	00 00       	add	r0,r0
80007266:	00 60       	and	r0,r0
80007268:	80 00       	ld.sh	r0,r0[0x0]
8000726a:	58 94       	cp.w	r4,9

8000726c <chassis_error>:

void chassis_error(void);
void chassis_error(void)
{
8000726c:	eb cd 40 80 	pushm	r7,lr
80007270:	1a 97       	mov	r7,sp
	display_text(IDX_ERROR);
80007272:	30 4c       	mov	r12,4
80007274:	f0 1f 00 03 	mcall	80007280 <chassis_error+0x14>
	print_ecdbg("Chassis error...shutting down.\r\n");
80007278:	48 3c       	lddpc	r12,80007284 <chassis_error+0x18>
8000727a:	f0 1f 00 04 	mcall	80007288 <chassis_error+0x1c>
	
	while(1); //catastrophic error, just hang TODO: allow technician interface to work here possibly
8000727e:	c0 08       	rjmp	8000727e <chassis_error+0x12>
80007280:	80 00       	ld.sh	r0,r0[0x0]
80007282:	72 14       	ld.w	r4,r9[0x4]
80007284:	80 00       	ld.sh	r0,r0[0x0]
80007286:	64 a8       	ld.w	r8,r2[0x28]
80007288:	80 00       	ld.sh	r0,r0[0x0]
8000728a:	33 38       	mov	r8,51

8000728c <init_io>:
	
}

void init_io(void);
void init_io(void)
{
8000728c:	eb cd 40 80 	pushm	r7,lr
80007290:	1a 97       	mov	r7,sp
80007292:	20 1d       	sub	sp,4
	uint32_t ioFlags;
	
	
	ioFlags = (GPIO_DIR_INPUT);
80007294:	30 08       	mov	r8,0
80007296:	ef 48 ff fc 	st.w	r7[-4],r8
	gpio_configure_pin(ECLAVE_DOOR_LATCH, ioFlags);
8000729a:	ee fb ff fc 	ld.w	r11,r7[-4]
8000729e:	33 ec       	mov	r12,62
800072a0:	f0 1f 00 2b 	mcall	8000734c <init_io+0xc0>

	ioFlags = (GPIO_DIR_INPUT);
800072a4:	30 08       	mov	r8,0
800072a6:	ef 48 ff fc 	st.w	r7[-4],r8
	gpio_configure_pin(ECLAVE_ACTION_PB, ioFlags);
800072aa:	ee fb ff fc 	ld.w	r11,r7[-4]
800072ae:	33 fc       	mov	r12,63
800072b0:	f0 1f 00 27 	mcall	8000734c <init_io+0xc0>

	ioFlags = (GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
800072b4:	30 38       	mov	r8,3
800072b6:	ef 48 ff fc 	st.w	r7[-4],r8
	gpio_configure_pin(ECLAVE_SERIAL_ID0, ioFlags);
800072ba:	ee fb ff fc 	ld.w	r11,r7[-4]
800072be:	33 3c       	mov	r12,51
800072c0:	f0 1f 00 23 	mcall	8000734c <init_io+0xc0>

	ioFlags = (GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
800072c4:	30 38       	mov	r8,3
800072c6:	ef 48 ff fc 	st.w	r7[-4],r8
	gpio_configure_pin(ECLAVE_SERIAL_ID1, ioFlags);
800072ca:	ee fb ff fc 	ld.w	r11,r7[-4]
800072ce:	33 4c       	mov	r12,52
800072d0:	f0 1f 00 1f 	mcall	8000734c <init_io+0xc0>

	ioFlags = (GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
800072d4:	30 38       	mov	r8,3
800072d6:	ef 48 ff fc 	st.w	r7[-4],r8
	gpio_configure_pin(ECLAVE_SERIAL_ID2, ioFlags);
800072da:	ee fb ff fc 	ld.w	r11,r7[-4]
800072de:	33 5c       	mov	r12,53
800072e0:	f0 1f 00 1b 	mcall	8000734c <init_io+0xc0>

	ioFlags = (GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
800072e4:	30 38       	mov	r8,3
800072e6:	ef 48 ff fc 	st.w	r7[-4],r8
	gpio_configure_pin(ECLAVE_SERIAL_ID3, ioFlags);
800072ea:	ee fb ff fc 	ld.w	r11,r7[-4]
800072ee:	33 6c       	mov	r12,54
800072f0:	f0 1f 00 17 	mcall	8000734c <init_io+0xc0>

	ioFlags = (GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
800072f4:	30 38       	mov	r8,3
800072f6:	ef 48 ff fc 	st.w	r7[-4],r8
	gpio_configure_pin(ECLAVE_SERIAL_ID4, ioFlags);
800072fa:	ee fb ff fc 	ld.w	r11,r7[-4]
800072fe:	33 7c       	mov	r12,55
80007300:	f0 1f 00 13 	mcall	8000734c <init_io+0xc0>

	ioFlags = (GPIO_DIR_OUTPUT | GPIO_INIT_LOW);
80007304:	30 18       	mov	r8,1
80007306:	ef 48 ff fc 	st.w	r7[-4],r8
	gpio_configure_pin(ECLAVE_DEBUG_LED, ioFlags);
8000730a:	ee fb ff fc 	ld.w	r11,r7[-4]
8000730e:	37 cc       	mov	r12,124
80007310:	f0 1f 00 0f 	mcall	8000734c <init_io+0xc0>

	ioFlags = (GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
80007314:	30 38       	mov	r8,3
80007316:	ef 48 ff fc 	st.w	r7[-4],r8
	gpio_configure_pin(ECLAVE_PSUPPLY_ONn, ioFlags);
8000731a:	ee fb ff fc 	ld.w	r11,r7[-4]
8000731e:	31 7c       	mov	r12,23
80007320:	f0 1f 00 0b 	mcall	8000734c <init_io+0xc0>

	ioFlags = (GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
80007324:	30 38       	mov	r8,3
80007326:	ef 48 ff fc 	st.w	r7[-4],r8
	gpio_configure_pin(ECLAVE_LED_OEn, ioFlags);
8000732a:	ee fb ff fc 	ld.w	r11,r7[-4]
8000732e:	31 6c       	mov	r12,22
80007330:	f0 1f 00 07 	mcall	8000734c <init_io+0xc0>

	ioFlags = (GPIO_DIR_OUTPUT | GPIO_INIT_LOW); //high=1x multiplier, low=4x multiplier 10apr15;
80007334:	30 18       	mov	r8,1
80007336:	ef 48 ff fc 	st.w	r7[-4],r8
	gpio_configure_pin(ECLAVE_MFP, ioFlags);
8000733a:	ee fb ff fc 	ld.w	r11,r7[-4]
8000733e:	31 5c       	mov	r12,21
80007340:	f0 1f 00 03 	mcall	8000734c <init_io+0xc0>

}
80007344:	2f fd       	sub	sp,-4
80007346:	e3 cd 80 80 	ldm	sp++,r7,pc
8000734a:	00 00       	add	r0,r0
8000734c:	80 00       	ld.sh	r0,r0[0x0]
8000734e:	48 28       	lddpc	r8,80007354 <print_ecdbg_num+0x4>

80007350 <print_ecdbg_num>:
};


void print_ecdbg_num(unsigned int num);
void print_ecdbg_num(unsigned int num)
{
80007350:	eb cd 40 80 	pushm	r7,lr
80007354:	1a 97       	mov	r7,sp
80007356:	20 3d       	sub	sp,12
80007358:	ef 4c ff f4 	st.w	r7[-12],r12
	char str[6];
	
	sprintf(str, "%d", num);	
8000735c:	ee c8 00 08 	sub	r8,r7,8
80007360:	ee f9 ff f4 	ld.w	r9,r7[-12]
80007364:	1a d9       	st.w	--sp,r9
80007366:	48 7b       	lddpc	r11,80007380 <print_ecdbg_num+0x30>
80007368:	10 9c       	mov	r12,r8
8000736a:	f0 1f 00 07 	mcall	80007384 <print_ecdbg_num+0x34>
8000736e:	2f fd       	sub	sp,-4
	
	print_ecdbg(str);
80007370:	ee c8 00 08 	sub	r8,r7,8
80007374:	10 9c       	mov	r12,r8
80007376:	f0 1f 00 05 	mcall	80007388 <print_ecdbg_num+0x38>
}
8000737a:	2f dd       	sub	sp,-12
8000737c:	e3 cd 80 80 	ldm	sp++,r7,pc
80007380:	80 00       	ld.sh	r0,r0[0x0]
80007382:	64 cc       	ld.w	r12,r2[0x30]
80007384:	80 00       	ld.sh	r0,r0[0x0]
80007386:	ce 10       	breq	80007348 <init_io+0xbc>
80007388:	80 00       	ld.sh	r0,r0[0x0]
8000738a:	33 38       	mov	r8,51

8000738c <read_led_board_serial_ids>:

/* One serial ID chip per board */
void read_led_board_serial_ids(void);
void read_led_board_serial_ids(void)
{
8000738c:	eb cd 40 e0 	pushm	r5-r7,lr
80007390:	1a 97       	mov	r7,sp
80007392:	20 4d       	sub	sp,16
	/*
	 * Check for LED board presence by issuing a reset to the serial ID chip and checking for a response.
	 */
	
	SetSpeed(1); //1==standard speed, not overdrive 
80007394:	30 1c       	mov	r12,1
80007396:	f0 1f 00 b4 	mcall	80007664 <read_led_board_serial_ids+0x2d8>
	
	for (int i=0; i<NUM_LED_BOARDS; i++)
8000739a:	30 08       	mov	r8,0
8000739c:	ef 48 ff f0 	st.w	r7[-16],r8
800073a0:	c3 88       	rjmp	80007410 <read_led_board_serial_ids+0x84>
	{
		ledBrd[i].present = !OWTouchReset(i);
800073a2:	ee f6 ff f0 	ld.w	r6,r7[-16]
800073a6:	ee f8 ff f0 	ld.w	r8,r7[-16]
800073aa:	5c 58       	castu.b	r8
800073ac:	10 9c       	mov	r12,r8
800073ae:	f0 1f 00 af 	mcall	80007668 <read_led_board_serial_ids+0x2dc>
800073b2:	18 98       	mov	r8,r12
800073b4:	58 08       	cp.w	r8,0
800073b6:	5f 09       	sreq	r9
800073b8:	fe fa 02 b4 	ld.w	r10,pc[692]
800073bc:	0c 98       	mov	r8,r6
800073be:	a3 78       	lsl	r8,0x3
800073c0:	0c 18       	sub	r8,r6
800073c2:	a1 78       	lsl	r8,0x1
800073c4:	f4 08 00 08 	add	r8,r10,r8
800073c8:	f0 ca ff f8 	sub	r10,r8,-8
800073cc:	12 98       	mov	r8,r9
800073ce:	b4 88       	st.b	r10[0x0],r8
		if (ledBrd[i].present)
800073d0:	ee f9 ff f0 	ld.w	r9,r7[-16]
800073d4:	fe fa 02 98 	ld.w	r10,pc[664]
800073d8:	12 98       	mov	r8,r9
800073da:	a3 78       	lsl	r8,0x3
800073dc:	12 18       	sub	r8,r9
800073de:	a1 78       	lsl	r8,0x1
800073e0:	f4 08 00 08 	add	r8,r10,r8
800073e4:	2f 88       	sub	r8,-8
800073e6:	11 88       	ld.ub	r8,r8[0x0]
800073e8:	58 08       	cp.w	r8,0
800073ea:	c0 e0       	breq	80007406 <read_led_board_serial_ids+0x7a>
		{
			print_ecdbg("LED board detected in slot ");
800073ec:	fe fc 02 84 	ld.w	r12,pc[644]
800073f0:	f0 1f 00 a1 	mcall	80007674 <read_led_board_serial_ids+0x2e8>
			print_ecdbg_num(i);
800073f4:	ee f8 ff f0 	ld.w	r8,r7[-16]
800073f8:	10 9c       	mov	r12,r8
800073fa:	f0 1f 00 a0 	mcall	80007678 <read_led_board_serial_ids+0x2ec>
			print_ecdbg("\r\n");
800073fe:	fe fc 02 7e 	ld.w	r12,pc[638]
80007402:	f0 1f 00 9d 	mcall	80007674 <read_led_board_serial_ids+0x2e8>
	 * Check for LED board presence by issuing a reset to the serial ID chip and checking for a response.
	 */
	
	SetSpeed(1); //1==standard speed, not overdrive 
	
	for (int i=0; i<NUM_LED_BOARDS; i++)
80007406:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000740a:	2f f8       	sub	r8,-1
8000740c:	ef 48 ff f0 	st.w	r7[-16],r8
80007410:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007414:	58 48       	cp.w	r8,4
80007416:	fe 9a ff c6 	brle	800073a2 <read_led_board_serial_ids+0x16>
			print_ecdbg_num(i);
			print_ecdbg("\r\n");
		}
	}
	
	if (ledBrd[0].present && ledBrd[1].present)
8000741a:	fe f8 02 52 	ld.w	r8,pc[594]
8000741e:	f1 38 00 08 	ld.ub	r8,r8[8]
80007422:	58 08       	cp.w	r8,0
80007424:	c0 f0       	breq	80007442 <read_led_board_serial_ids+0xb6>
80007426:	fe f8 02 46 	ld.w	r8,pc[582]
8000742a:	f1 38 00 16 	ld.ub	r8,r8[22]
8000742e:	58 08       	cp.w	r8,0
80007430:	c0 90       	breq	80007442 <read_led_board_serial_ids+0xb6>
	{
		shelf[0].present = 1;
80007432:	fe f9 02 4e 	ld.w	r9,pc[590]
80007436:	30 18       	mov	r8,1
80007438:	b2 c8       	st.b	r9[0x4],r8
		
		print_ecdbg("Shelf 0 present\r\n");
8000743a:	fe fc 02 4a 	ld.w	r12,pc[586]
8000743e:	f0 1f 00 8e 	mcall	80007674 <read_led_board_serial_ids+0x2e8>
	}
	if (ledBrd[1].present && ledBrd[2].present)
80007442:	fe f8 02 2a 	ld.w	r8,pc[554]
80007446:	f1 38 00 16 	ld.ub	r8,r8[22]
8000744a:	58 08       	cp.w	r8,0
8000744c:	c1 00       	breq	8000746c <read_led_board_serial_ids+0xe0>
8000744e:	fe f8 02 1e 	ld.w	r8,pc[542]
80007452:	f1 38 00 24 	ld.ub	r8,r8[36]
80007456:	58 08       	cp.w	r8,0
80007458:	c0 a0       	breq	8000746c <read_led_board_serial_ids+0xe0>
	{
		shelf[1].present = 1;
8000745a:	fe f9 02 26 	ld.w	r9,pc[550]
8000745e:	30 18       	mov	r8,1
80007460:	f3 68 00 09 	st.b	r9[9],r8
		print_ecdbg("Shelf 1 present\r\n");
80007464:	fe fc 02 24 	ld.w	r12,pc[548]
80007468:	f0 1f 00 83 	mcall	80007674 <read_led_board_serial_ids+0x2e8>
	}
	if (ledBrd[2].present && ledBrd[3].present)
8000746c:	fe f8 02 00 	ld.w	r8,pc[512]
80007470:	f1 38 00 24 	ld.ub	r8,r8[36]
80007474:	58 08       	cp.w	r8,0
80007476:	c0 f0       	breq	80007494 <read_led_board_serial_ids+0x108>
80007478:	4f d8       	lddpc	r8,8000766c <read_led_board_serial_ids+0x2e0>
8000747a:	f1 38 00 32 	ld.ub	r8,r8[50]
8000747e:	58 08       	cp.w	r8,0
80007480:	c0 a0       	breq	80007494 <read_led_board_serial_ids+0x108>
	{
		shelf[2].present = 1;
80007482:	fe f9 01 fe 	ld.w	r9,pc[510]
80007486:	30 18       	mov	r8,1
80007488:	f3 68 00 0e 	st.b	r9[14],r8
		print_ecdbg("Shelf 2 present\r\n");
8000748c:	fe fc 02 00 	ld.w	r12,pc[512]
80007490:	f0 1f 00 79 	mcall	80007674 <read_led_board_serial_ids+0x2e8>
	}
	if (ledBrd[3].present && ledBrd[4].present)
80007494:	4f 68       	lddpc	r8,8000766c <read_led_board_serial_ids+0x2e0>
80007496:	f1 38 00 32 	ld.ub	r8,r8[50]
8000749a:	58 08       	cp.w	r8,0
8000749c:	c0 d0       	breq	800074b6 <read_led_board_serial_ids+0x12a>
8000749e:	4f 48       	lddpc	r8,8000766c <read_led_board_serial_ids+0x2e0>
800074a0:	f1 38 00 40 	ld.ub	r8,r8[64]
800074a4:	58 08       	cp.w	r8,0
800074a6:	c0 80       	breq	800074b6 <read_led_board_serial_ids+0x12a>
	{
		shelf[3].present = 1;
800074a8:	4f 69       	lddpc	r9,80007680 <read_led_board_serial_ids+0x2f4>
800074aa:	30 18       	mov	r8,1
800074ac:	f3 68 00 13 	st.b	r9[19],r8
		print_ecdbg("Shelf 3 present\r\n");
800074b0:	4f 8c       	lddpc	r12,80007690 <read_led_board_serial_ids+0x304>
800074b2:	f0 1f 00 71 	mcall	80007674 <read_led_board_serial_ids+0x2e8>
	}
	

	for (int i=0; i<NUM_LED_BOARDS; i++)
800074b6:	30 08       	mov	r8,0
800074b8:	ef 48 ff f4 	st.w	r7[-12],r8
800074bc:	cc b8       	rjmp	80007652 <read_led_board_serial_ids+0x2c6>
	{
		unsigned char acc = 0;
800074be:	30 08       	mov	r8,0
800074c0:	ef 68 ff fb 	st.b	r7[-5],r8
		
		if (ledBrd[i].present)
800074c4:	ee f9 ff f4 	ld.w	r9,r7[-12]
800074c8:	4e 9a       	lddpc	r10,8000766c <read_led_board_serial_ids+0x2e0>
800074ca:	12 98       	mov	r8,r9
800074cc:	a3 78       	lsl	r8,0x3
800074ce:	12 18       	sub	r8,r9
800074d0:	a1 78       	lsl	r8,0x1
800074d2:	f4 08 00 08 	add	r8,r10,r8
800074d6:	2f 88       	sub	r8,-8
800074d8:	11 88       	ld.ub	r8,r8[0x0]
800074da:	58 08       	cp.w	r8,0
800074dc:	e0 80 00 b6 	breq	80007648 <read_led_board_serial_ids+0x2bc>
		{
			OWWriteByte(i, 0x33); //Read ID command
800074e0:	ee f8 ff f4 	ld.w	r8,r7[-12]
800074e4:	5c 58       	castu.b	r8
800074e6:	33 3b       	mov	r11,51
800074e8:	10 9c       	mov	r12,r8
800074ea:	f0 1f 00 6b 	mcall	80007694 <read_led_board_serial_ids+0x308>
			
			ledBrd[i].idFamily = OWReadByte(i);
800074ee:	ee f6 ff f4 	ld.w	r6,r7[-12]
800074f2:	ee f8 ff f4 	ld.w	r8,r7[-12]
800074f6:	5c 58       	castu.b	r8
800074f8:	10 9c       	mov	r12,r8
800074fa:	f0 1f 00 68 	mcall	80007698 <read_led_board_serial_ids+0x30c>
800074fe:	18 98       	mov	r8,r12
80007500:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80007504:	4d aa       	lddpc	r10,8000766c <read_led_board_serial_ids+0x2e0>
80007506:	0c 98       	mov	r8,r6
80007508:	a3 78       	lsl	r8,0x3
8000750a:	0c 18       	sub	r8,r6
8000750c:	a1 78       	lsl	r8,0x1
8000750e:	10 0a       	add	r10,r8
80007510:	12 98       	mov	r8,r9
80007512:	b4 88       	st.b	r10[0x0],r8
			
			acc = crc8_add(0x00, ledBrd[i].idFamily);
80007514:	ee f9 ff f4 	ld.w	r9,r7[-12]
80007518:	4d 5a       	lddpc	r10,8000766c <read_led_board_serial_ids+0x2e0>
8000751a:	12 98       	mov	r8,r9
8000751c:	a3 78       	lsl	r8,0x3
8000751e:	12 18       	sub	r8,r9
80007520:	a1 78       	lsl	r8,0x1
80007522:	f4 08 00 08 	add	r8,r10,r8
80007526:	11 88       	ld.ub	r8,r8[0x0]
80007528:	10 9b       	mov	r11,r8
8000752a:	30 0c       	mov	r12,0
8000752c:	f0 1f 00 5c 	mcall	8000769c <read_led_board_serial_ids+0x310>
80007530:	18 98       	mov	r8,r12
80007532:	ef 68 ff fb 	st.b	r7[-5],r8
			
			for (int j=0; j<6; j++)
80007536:	30 08       	mov	r8,0
80007538:	ef 48 ff fc 	st.w	r7[-4],r8
8000753c:	c3 78       	rjmp	800075aa <read_led_board_serial_ids+0x21e>
			{
				ledBrd[i].id[j] = OWReadByte(i);
8000753e:	ee f6 ff f4 	ld.w	r6,r7[-12]
80007542:	ee f5 ff fc 	ld.w	r5,r7[-4]
80007546:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000754a:	5c 58       	castu.b	r8
8000754c:	10 9c       	mov	r12,r8
8000754e:	f0 1f 00 53 	mcall	80007698 <read_led_board_serial_ids+0x30c>
80007552:	18 98       	mov	r8,r12
80007554:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80007558:	4c 5a       	lddpc	r10,8000766c <read_led_board_serial_ids+0x2e0>
8000755a:	0c 98       	mov	r8,r6
8000755c:	a3 78       	lsl	r8,0x3
8000755e:	0c 18       	sub	r8,r6
80007560:	a1 78       	lsl	r8,0x1
80007562:	f4 08 00 08 	add	r8,r10,r8
80007566:	0a 08       	add	r8,r5
80007568:	f0 ca ff ff 	sub	r10,r8,-1
8000756c:	12 98       	mov	r8,r9
8000756e:	b4 88       	st.b	r10[0x0],r8
				acc = crc8_add(acc, ledBrd[i].id[j]);
80007570:	ee f9 ff f4 	ld.w	r9,r7[-12]
80007574:	ee fa ff fc 	ld.w	r10,r7[-4]
80007578:	4b db       	lddpc	r11,8000766c <read_led_board_serial_ids+0x2e0>
8000757a:	12 98       	mov	r8,r9
8000757c:	a3 78       	lsl	r8,0x3
8000757e:	12 18       	sub	r8,r9
80007580:	a1 78       	lsl	r8,0x1
80007582:	f6 08 00 08 	add	r8,r11,r8
80007586:	14 08       	add	r8,r10
80007588:	2f f8       	sub	r8,-1
8000758a:	11 88       	ld.ub	r8,r8[0x0]
8000758c:	10 99       	mov	r9,r8
8000758e:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80007592:	12 9b       	mov	r11,r9
80007594:	10 9c       	mov	r12,r8
80007596:	f0 1f 00 42 	mcall	8000769c <read_led_board_serial_ids+0x310>
8000759a:	18 98       	mov	r8,r12
8000759c:	ef 68 ff fb 	st.b	r7[-5],r8
			
			ledBrd[i].idFamily = OWReadByte(i);
			
			acc = crc8_add(0x00, ledBrd[i].idFamily);
			
			for (int j=0; j<6; j++)
800075a0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800075a4:	2f f8       	sub	r8,-1
800075a6:	ef 48 ff fc 	st.w	r7[-4],r8
800075aa:	ee f8 ff fc 	ld.w	r8,r7[-4]
800075ae:	58 58       	cp.w	r8,5
800075b0:	fe 9a ff c7 	brle	8000753e <read_led_board_serial_ids+0x1b2>
			{
				ledBrd[i].id[j] = OWReadByte(i);
				acc = crc8_add(acc, ledBrd[i].id[j]);
			}
			
			ledBrd[i].idcsum = OWReadByte(i);
800075b4:	ee f6 ff f4 	ld.w	r6,r7[-12]
800075b8:	ee f8 ff f4 	ld.w	r8,r7[-12]
800075bc:	5c 58       	castu.b	r8
800075be:	10 9c       	mov	r12,r8
800075c0:	f0 1f 00 36 	mcall	80007698 <read_led_board_serial_ids+0x30c>
800075c4:	18 98       	mov	r8,r12
800075c6:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800075ca:	4a 9a       	lddpc	r10,8000766c <read_led_board_serial_ids+0x2e0>
800075cc:	0c 98       	mov	r8,r6
800075ce:	a3 78       	lsl	r8,0x3
800075d0:	0c 18       	sub	r8,r6
800075d2:	a1 78       	lsl	r8,0x1
800075d4:	f4 08 00 08 	add	r8,r10,r8
800075d8:	f0 ca ff f9 	sub	r10,r8,-7
800075dc:	12 98       	mov	r8,r9
800075de:	b4 88       	st.b	r10[0x0],r8
			
			if (acc != ledBrd[i].idcsum)
800075e0:	ee f9 ff f4 	ld.w	r9,r7[-12]
800075e4:	4a 2a       	lddpc	r10,8000766c <read_led_board_serial_ids+0x2e0>
800075e6:	12 98       	mov	r8,r9
800075e8:	a3 78       	lsl	r8,0x3
800075ea:	12 18       	sub	r8,r9
800075ec:	a1 78       	lsl	r8,0x1
800075ee:	f4 08 00 08 	add	r8,r10,r8
800075f2:	2f 98       	sub	r8,-7
800075f4:	11 88       	ld.ub	r8,r8[0x0]
800075f6:	ef 39 ff fb 	ld.ub	r9,r7[-5]
800075fa:	f0 09 18 00 	cp.b	r9,r8
800075fe:	c2 50       	breq	80007648 <read_led_board_serial_ids+0x2bc>
			{
				sysErr.ledBrdSerialIdCsum |= BIT(i); //SE_FAIL;
80007600:	4a 88       	lddpc	r8,800076a0 <read_led_board_serial_ids+0x314>
80007602:	f1 38 00 0c 	ld.ub	r8,r8[12]
80007606:	10 99       	mov	r9,r8
80007608:	30 1a       	mov	r10,1
8000760a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000760e:	f4 08 09 48 	lsl	r8,r10,r8
80007612:	5c 58       	castu.b	r8
80007614:	f3 e8 10 08 	or	r8,r9,r8
80007618:	5c 58       	castu.b	r8
8000761a:	5c 58       	castu.b	r8
8000761c:	4a 19       	lddpc	r9,800076a0 <read_led_board_serial_ids+0x314>
8000761e:	f3 68 00 0c 	st.b	r9[12],r8
				ledBrd[i].present = 0; //crc8 wasn't valid for this ID chip, don't trust the board
80007622:	ee f9 ff f4 	ld.w	r9,r7[-12]
80007626:	49 2a       	lddpc	r10,8000766c <read_led_board_serial_ids+0x2e0>
80007628:	12 98       	mov	r8,r9
8000762a:	a3 78       	lsl	r8,0x3
8000762c:	12 18       	sub	r8,r9
8000762e:	a1 78       	lsl	r8,0x1
80007630:	f4 08 00 08 	add	r8,r10,r8
80007634:	f0 c9 ff f8 	sub	r9,r8,-8
80007638:	30 08       	mov	r8,0
8000763a:	b2 88       	st.b	r9[0x0],r8
				print_ecdbg("Invalid serial ID checksum.\r\n");
8000763c:	49 ac       	lddpc	r12,800076a4 <read_led_board_serial_ids+0x318>
8000763e:	f0 1f 00 0e 	mcall	80007674 <read_led_board_serial_ids+0x2e8>
				
				electroclaveState = STATE_CHASSIS_ERROR;
80007642:	49 a9       	lddpc	r9,800076a8 <read_led_board_serial_ids+0x31c>
80007644:	30 88       	mov	r8,8
80007646:	b2 88       	st.b	r9[0x0],r8
		shelf[3].present = 1;
		print_ecdbg("Shelf 3 present\r\n");
	}
	

	for (int i=0; i<NUM_LED_BOARDS; i++)
80007648:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000764c:	2f f8       	sub	r8,-1
8000764e:	ef 48 ff f4 	st.w	r7[-12],r8
80007652:	ee f8 ff f4 	ld.w	r8,r7[-12]
80007656:	58 48       	cp.w	r8,4
80007658:	fe 9a ff 33 	brle	800074be <read_led_board_serial_ids+0x132>
				
				electroclaveState = STATE_CHASSIS_ERROR;
			}
		}
	}
}
8000765c:	2f cd       	sub	sp,-16
8000765e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80007662:	00 00       	add	r0,r0
80007664:	80 00       	ld.sh	r0,r0[0x0]
80007666:	21 74       	sub	r4,23
80007668:	80 00       	ld.sh	r0,r0[0x0]
8000766a:	22 34       	sub	r4,35
8000766c:	00 00       	add	r0,r0
8000766e:	0b 4a       	ld.w	r10,--r5
80007670:	80 00       	ld.sh	r0,r0[0x0]
80007672:	64 d0       	ld.w	r0,r2[0x34]
80007674:	80 00       	ld.sh	r0,r0[0x0]
80007676:	33 38       	mov	r8,51
80007678:	80 00       	ld.sh	r0,r0[0x0]
8000767a:	73 50       	ld.w	r0,r9[0x54]
8000767c:	80 00       	ld.sh	r0,r0[0x0]
8000767e:	64 ec       	ld.w	r12,r2[0x38]
80007680:	00 00       	add	r0,r0
80007682:	0b 91       	ld.ub	r1,r5[0x1]
80007684:	80 00       	ld.sh	r0,r0[0x0]
80007686:	64 f0       	ld.w	r0,r2[0x3c]
80007688:	80 00       	ld.sh	r0,r0[0x0]
8000768a:	65 04       	ld.w	r4,r2[0x40]
8000768c:	80 00       	ld.sh	r0,r0[0x0]
8000768e:	65 18       	ld.w	r8,r2[0x44]
80007690:	80 00       	ld.sh	r0,r0[0x0]
80007692:	65 2c       	ld.w	r12,r2[0x48]
80007694:	80 00       	ld.sh	r0,r0[0x0]
80007696:	31 04       	mov	r4,16
80007698:	80 00       	ld.sh	r0,r0[0x0]
8000769a:	31 5c       	mov	r12,21
8000769c:	80 00       	ld.sh	r0,r0[0x0]
8000769e:	31 c0       	mov	r0,28
800076a0:	00 00       	add	r0,r0
800076a2:	0b d4       	ld.ub	r4,r5[0x5]
800076a4:	80 00       	ld.sh	r0,r0[0x0]
800076a6:	65 40       	ld.w	r0,r2[0x50]
800076a8:	00 00       	add	r0,r0
800076aa:	07 b9       	ld.ub	r9,r3[0x3]

800076ac <check_led_brd_side_lifetime>:
};

/* Each side of an LED board will get different usage */
unsigned char check_led_brd_side_lifetime(unsigned char sideIdx);
unsigned char check_led_brd_side_lifetime(unsigned char sideIdx)
{
800076ac:	eb cd 40 cc 	pushm	r2-r3,r6-r7,lr
800076b0:	1a 97       	mov	r7,sp
800076b2:	20 4d       	sub	sp,16
800076b4:	18 98       	mov	r8,r12
800076b6:	ef 68 ff f0 	st.b	r7[-16],r8
	 * Find the record for this board's serial ID number, and check the usage hours and see if we
	 *	are past the 2000 hour mark. If we are, this board is considered un-usuable until it is
	 *	refurbished. 
	 */
	
	idx = ledBrdSide[sideIdx].ushdwIdx;
800076ba:	ef 39 ff f0 	ld.ub	r9,r7[-16]
800076be:	4c 7a       	lddpc	r10,800077d8 <check_led_brd_side_lifetime+0x12c>
800076c0:	12 98       	mov	r8,r9
800076c2:	a3 68       	lsl	r8,0x2
800076c4:	12 08       	add	r8,r9
800076c6:	f4 08 00 08 	add	r8,r10,r8
800076ca:	2f f8       	sub	r8,-1
800076cc:	11 88       	ld.ub	r8,r8[0x0]
800076ce:	ef 68 ff f7 	st.b	r7[-9],r8
		hours++;
	}
	
#else
	
	hours = h.hrs[idx];
800076d2:	ef 39 ff f7 	ld.ub	r9,r7[-9]
800076d6:	4c 28       	lddpc	r8,800077dc <check_led_brd_side_lifetime+0x130>
800076d8:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
800076dc:	5c 78       	castu.h	r8
800076de:	ef 48 ff f8 	st.w	r7[-8],r8
		

/*
 * Since we have to calculate the hours to see if the shelf is valid, finish out the calculations for the sanitizing time also. We'll need it later.
 */
	intensity = ((0.00002 * hours * hours) - (0.0699 * hours) + 91.879);
800076e2:	ee fc ff f8 	ld.w	r12,r7[-8]
800076e6:	f0 1f 00 3f 	mcall	800077e0 <check_led_brd_side_lifetime+0x134>
800076ea:	e0 68 68 f1 	mov	r8,26865
800076ee:	ea 18 88 e3 	orh	r8,0x88e3
800076f2:	e0 69 f8 b5 	mov	r9,63669
800076f6:	ea 19 3e f4 	orh	r9,0x3ef4
800076fa:	f0 1f 00 3b 	mcall	800077e4 <check_led_brd_side_lifetime+0x138>
800076fe:	14 98       	mov	r8,r10
80007700:	16 99       	mov	r9,r11
80007702:	10 92       	mov	r2,r8
80007704:	12 93       	mov	r3,r9
80007706:	ee fc ff f8 	ld.w	r12,r7[-8]
8000770a:	f0 1f 00 36 	mcall	800077e0 <check_led_brd_side_lifetime+0x134>
8000770e:	14 98       	mov	r8,r10
80007710:	16 99       	mov	r9,r11
80007712:	04 9a       	mov	r10,r2
80007714:	06 9b       	mov	r11,r3
80007716:	f0 1f 00 34 	mcall	800077e4 <check_led_brd_side_lifetime+0x138>
8000771a:	14 98       	mov	r8,r10
8000771c:	16 99       	mov	r9,r11
8000771e:	10 92       	mov	r2,r8
80007720:	12 93       	mov	r3,r9
80007722:	ee fc ff f8 	ld.w	r12,r7[-8]
80007726:	f0 1f 00 2f 	mcall	800077e0 <check_led_brd_side_lifetime+0x134>
8000772a:	e0 68 8a db 	mov	r8,35547
8000772e:	ea 18 65 fd 	orh	r8,0x65fd
80007732:	e0 69 e4 f7 	mov	r9,58615
80007736:	ea 19 bf b1 	orh	r9,0xbfb1
8000773a:	f0 1f 00 2b 	mcall	800077e4 <check_led_brd_side_lifetime+0x138>
8000773e:	14 98       	mov	r8,r10
80007740:	16 99       	mov	r9,r11
80007742:	04 9a       	mov	r10,r2
80007744:	06 9b       	mov	r11,r3
80007746:	f0 1f 00 29 	mcall	800077e8 <check_led_brd_side_lifetime+0x13c>
8000774a:	14 98       	mov	r8,r10
8000774c:	16 99       	mov	r9,r11
8000774e:	10 9a       	mov	r10,r8
80007750:	12 9b       	mov	r11,r9
80007752:	e0 68 4b c7 	mov	r8,19399
80007756:	ea 18 89 37 	orh	r8,0x8937
8000775a:	e0 69 f8 41 	mov	r9,63553
8000775e:	ea 19 40 56 	orh	r9,0x4056
80007762:	f0 1f 00 22 	mcall	800077e8 <check_led_brd_side_lifetime+0x13c>
80007766:	14 98       	mov	r8,r10
80007768:	16 99       	mov	r9,r11
8000776a:	10 9a       	mov	r10,r8
8000776c:	12 9b       	mov	r11,r9
8000776e:	f0 1f 00 20 	mcall	800077ec <check_led_brd_side_lifetime+0x140>
80007772:	18 98       	mov	r8,r12
80007774:	ef 48 ff fc 	st.w	r7[-4],r8
		
	ledBrdSide[sideIdx].sanitizeMinutes = (c.initialDTE * 100)/intensity; //Shortest sanitize time is 20 minutes. Sanitize time increases as LED intensity drops with usage. Sanitize time is around 49 minutes when usage is at 2000 hours.
80007778:	ef 36 ff f0 	ld.ub	r6,r7[-16]
8000777c:	49 d8       	lddpc	r8,800077f0 <check_led_brd_side_lifetime+0x144>
8000777e:	11 88       	ld.ub	r8,r8[0x0]
80007780:	f0 08 10 64 	mul	r8,r8,100
80007784:	e5 a6 08 08 	cop	cp0,cr8,cr0,cr8,0x4c
80007788:	ee fb ff fc 	ld.w	r11,r7[-4]
8000778c:	10 9c       	mov	r12,r8
8000778e:	f0 1f 00 1a 	mcall	800077f4 <check_led_brd_side_lifetime+0x148>
80007792:	18 98       	mov	r8,r12
80007794:	e5 a9 08 08 	cop	cp0,cr8,cr0,cr8,0x52
80007798:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
8000779c:	48 fa       	lddpc	r10,800077d8 <check_led_brd_side_lifetime+0x12c>
8000779e:	0c 98       	mov	r8,r6
800077a0:	a3 68       	lsl	r8,0x2
800077a2:	0c 08       	add	r8,r6
800077a4:	10 0a       	add	r10,r8
800077a6:	12 98       	mov	r8,r9
800077a8:	b4 88       	st.b	r10[0x0],r8
	
//	ledBrdSide[sideIdx].sanitizeMinutes = 60; //DEBUG hard code to 1 minute per Christian 24jun15 take this out later
//	ledBrdSide[sideIdx].sanitizeMinutes = 255; //DEBUG hard code to 10 minutes to debug BOTDRIVE problem 31jul15 take this out later
	ledBrdSide[sideIdx].sanitizeMinutes = 30; //DEBUG hard code to 30 minutes for sanitation tests 16jan16
800077aa:	ef 39 ff f0 	ld.ub	r9,r7[-16]
800077ae:	48 ba       	lddpc	r10,800077d8 <check_led_brd_side_lifetime+0x12c>
800077b0:	12 98       	mov	r8,r9
800077b2:	a3 68       	lsl	r8,0x2
800077b4:	12 08       	add	r8,r9
800077b6:	f4 08 00 09 	add	r9,r10,r8
800077ba:	31 e8       	mov	r8,30
800077bc:	b2 88       	st.b	r9[0x0],r8


	if (hours < 2001)
800077be:	ee f8 ff f8 	ld.w	r8,r7[-8]
800077c2:	e0 48 07 d0 	cp.w	r8,2000
800077c6:	e0 8b 00 04 	brhi	800077ce <check_led_brd_side_lifetime+0x122>
	{
		return LED_BOARD_SIDE_WITHIN_LIFETIME_LIMIT;
800077ca:	30 18       	mov	r8,1
800077cc:	c0 28       	rjmp	800077d0 <check_led_brd_side_lifetime+0x124>
	}
	else
	{
		return LED_BOARD_SIDE_PAST_LIFETIME_LIMIT;
800077ce:	30 08       	mov	r8,0
//DEBUG 24jun15 need to function even with these errors for demo purposes		electroclaveState = STATE_CHASSIS_ERROR;
	}
}
800077d0:	10 9c       	mov	r12,r8
800077d2:	2f cd       	sub	sp,-16
800077d4:	e3 cd 80 cc 	ldm	sp++,r2-r3,r6-r7,pc
800077d8:	00 00       	add	r0,r0
800077da:	0b fe       	ld.ub	lr,r5[0x7]
800077dc:	00 00       	add	r0,r0
800077de:	0c 2c       	rsub	r12,r6
800077e0:	80 00       	ld.sh	r0,r0[0x0]
800077e2:	c7 84       	brge	800078d2 <adc_process_task+0x42>
800077e4:	80 00       	ld.sh	r0,r0[0x0]
800077e6:	c3 00       	breq	80007846 <check_led_brd_side_lifetimes+0x4e>
800077e8:	80 00       	ld.sh	r0,r0[0x0]
800077ea:	c6 74       	brge	800078b8 <adc_process_task+0x28>
800077ec:	80 00       	ld.sh	r0,r0[0x0]
800077ee:	c9 cc       	rcall	80007926 <adc_process_task+0x96>
800077f0:	00 00       	add	r0,r0
800077f2:	0b fc       	ld.ub	r12,r5[0x7]
800077f4:	80 00       	ld.sh	r0,r0[0x0]
800077f6:	c8 6c       	rcall	80007902 <adc_process_task+0x72>

800077f8 <check_led_brd_side_lifetimes>:

/* Aggregate the information */
void check_led_brd_side_lifetimes(void);
void check_led_brd_side_lifetimes(void)
{
800077f8:	eb cd 40 c0 	pushm	r6-r7,lr
800077fc:	1a 97       	mov	r7,sp
800077fe:	20 2d       	sub	sp,8
	unsigned char brdIdx;
	
	for (int i=0; i<NUM_LED_BOARD_SIDES; i++)
80007800:	30 08       	mov	r8,0
80007802:	ef 48 ff fc 	st.w	r7[-4],r8
80007806:	c3 78       	rjmp	80007874 <check_led_brd_side_lifetimes+0x7c>
	{
		brdIdx = ledBrdSide[i].boardIdx;
80007808:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000780c:	49 ea       	lddpc	r10,80007884 <check_led_brd_side_lifetimes+0x8c>
8000780e:	12 98       	mov	r8,r9
80007810:	a3 68       	lsl	r8,0x2
80007812:	12 08       	add	r8,r9
80007814:	f4 08 00 08 	add	r8,r10,r8
80007818:	2f c8       	sub	r8,-4
8000781a:	11 88       	ld.ub	r8,r8[0x0]
8000781c:	ef 68 ff fb 	st.b	r7[-5],r8
		
		if (ledBrd[brdIdx].present)
80007820:	ef 39 ff fb 	ld.ub	r9,r7[-5]
80007824:	49 9a       	lddpc	r10,80007888 <check_led_brd_side_lifetimes+0x90>
80007826:	12 98       	mov	r8,r9
80007828:	a3 78       	lsl	r8,0x3
8000782a:	12 18       	sub	r8,r9
8000782c:	a1 78       	lsl	r8,0x1
8000782e:	f4 08 00 08 	add	r8,r10,r8
80007832:	2f 88       	sub	r8,-8
80007834:	11 88       	ld.ub	r8,r8[0x0]
80007836:	58 08       	cp.w	r8,0
80007838:	c1 90       	breq	8000786a <check_led_brd_side_lifetimes+0x72>
		{
			ledBrdSide[i].maxUsageReached = !check_led_brd_side_lifetime(i);	
8000783a:	ee f6 ff fc 	ld.w	r6,r7[-4]
8000783e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007842:	5c 58       	castu.b	r8
80007844:	10 9c       	mov	r12,r8
80007846:	f0 1f 00 12 	mcall	8000788c <check_led_brd_side_lifetimes+0x94>
8000784a:	18 98       	mov	r8,r12
8000784c:	10 99       	mov	r9,r8
8000784e:	30 08       	mov	r8,0
80007850:	f0 09 18 00 	cp.b	r9,r8
80007854:	5f 09       	sreq	r9
80007856:	48 ca       	lddpc	r10,80007884 <check_led_brd_side_lifetimes+0x8c>
80007858:	0c 98       	mov	r8,r6
8000785a:	a3 68       	lsl	r8,0x2
8000785c:	0c 08       	add	r8,r6
8000785e:	f4 08 00 08 	add	r8,r10,r8
80007862:	f0 ca ff fe 	sub	r10,r8,-2
80007866:	12 98       	mov	r8,r9
80007868:	b4 88       	st.b	r10[0x0],r8
void check_led_brd_side_lifetimes(void);
void check_led_brd_side_lifetimes(void)
{
	unsigned char brdIdx;
	
	for (int i=0; i<NUM_LED_BOARD_SIDES; i++)
8000786a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000786e:	2f f8       	sub	r8,-1
80007870:	ef 48 ff fc 	st.w	r7[-4],r8
80007874:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007878:	58 78       	cp.w	r8,7
8000787a:	fe 9a ff c7 	brle	80007808 <check_led_brd_side_lifetimes+0x10>
		if (ledBrd[brdIdx].present)
		{
			ledBrdSide[i].maxUsageReached = !check_led_brd_side_lifetime(i);	
		}	
	}
}
8000787e:	2f ed       	sub	sp,-8
80007880:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007884:	00 00       	add	r0,r0
80007886:	0b fe       	ld.ub	lr,r5[0x7]
80007888:	00 00       	add	r0,r0
8000788a:	0b 4a       	ld.w	r10,--r5
8000788c:	80 00       	ld.sh	r0,r0[0x0]
8000788e:	76 ac       	ld.w	r12,r11[0x28]

80007890 <adc_process_task>:

volatile avr32_adcifa_t *adcifa = &AVR32_ADCIFA; // ADCIFA IP registers address

int16_t adc_process_task(unsigned char shelfIdx);
int16_t adc_process_task(unsigned char shelfIdx)
{
80007890:	eb cd 40 80 	pushm	r7,lr
80007894:	1a 97       	mov	r7,sp
80007896:	20 1d       	sub	sp,4
80007898:	18 98       	mov	r8,r12
8000789a:	ef 68 ff fc 	st.b	r7[-4],r8
	// Configure ADCIFA sequencer 0 for this particular shelf
	adcifa_configure_sequencer(adcifa, 0, &adcifa_sequence_opt,
8000789e:	ef 39 ff fc 	ld.ub	r9,r7[-4]
		&adcifa_sequence_conversion_opt_seq0_shelf[shelfIdx]);
800078a2:	12 98       	mov	r8,r9
800078a4:	a1 78       	lsl	r8,0x1
800078a6:	f0 09 00 09 	add	r9,r8,r9

int16_t adc_process_task(unsigned char shelfIdx);
int16_t adc_process_task(unsigned char shelfIdx)
{
	// Configure ADCIFA sequencer 0 for this particular shelf
	adcifa_configure_sequencer(adcifa, 0, &adcifa_sequence_opt,
800078aa:	49 88       	lddpc	r8,80007908 <adc_process_task+0x78>
800078ac:	10 09       	add	r9,r8
800078ae:	49 88       	lddpc	r8,8000790c <adc_process_task+0x7c>
800078b0:	70 08       	ld.w	r8,r8[0x0]
800078b2:	49 8a       	lddpc	r10,80007910 <adc_process_task+0x80>
800078b4:	30 0b       	mov	r11,0
800078b6:	10 9c       	mov	r12,r8
800078b8:	f0 1f 00 17 	mcall	80007914 <adc_process_task+0x84>
		&adcifa_sequence_conversion_opt_seq0_shelf[shelfIdx]);

	// Start ADCIFA sequencer 0
	adcifa_start_sequencer(adcifa, 0);
800078bc:	49 48       	lddpc	r8,8000790c <adc_process_task+0x7c>
800078be:	70 08       	ld.w	r8,r8[0x0]
800078c0:	30 0b       	mov	r11,0
800078c2:	10 9c       	mov	r12,r8
800078c4:	f0 1f 00 15 	mcall	80007918 <adc_process_task+0x88>
800078c8:	c0 28       	rjmp	800078cc <adc_process_task+0x3c>
//30may15			{
//30may15				bluesense_buf[shelfIdx] = 0;
//30may15			}
			return bluesense_buf[shelfIdx];
		}
	}
800078ca:	d7 03       	nop
	// Get Values from sequencer 0
	while(1)
	{
		//TODO: need a timeout here and error handling in case the ADC gets stuck for some reason
		
		if (adcifa_get_values_from_sequencer(adcifa, 0, &adcifa_sequence_opt, &adc_values_seq0) == ADCIFA_STATUS_COMPLETED) 
800078cc:	49 08       	lddpc	r8,8000790c <adc_process_task+0x7c>
800078ce:	70 08       	ld.w	r8,r8[0x0]
800078d0:	49 39       	lddpc	r9,8000791c <adc_process_task+0x8c>
800078d2:	49 0a       	lddpc	r10,80007910 <adc_process_task+0x80>
800078d4:	30 0b       	mov	r11,0
800078d6:	10 9c       	mov	r12,r8
800078d8:	f0 1f 00 12 	mcall	80007920 <adc_process_task+0x90>
800078dc:	18 98       	mov	r8,r12
800078de:	10 99       	mov	r9,r8
800078e0:	30 28       	mov	r8,2
800078e2:	f0 09 18 00 	cp.b	r9,r8
800078e6:	cf 21       	brne	800078ca <adc_process_task+0x3a>
		{
			bluesense_buf[shelfIdx] = adc_values_seq0;
800078e8:	ef 3a ff fc 	ld.ub	r10,r7[-4]
800078ec:	48 c8       	lddpc	r8,8000791c <adc_process_task+0x8c>
800078ee:	90 08       	ld.sh	r8,r8[0x0]
800078f0:	48 d9       	lddpc	r9,80007924 <adc_process_task+0x94>
800078f2:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
//30may15			if (bluesense_buf[shelfIdx] & 0x8000) //30may15 this number is 2's complement, we should just set negative numbers to 0
//30may15			{
//30may15				bluesense_buf[shelfIdx] = 0;
//30may15			}
			return bluesense_buf[shelfIdx];
800078f6:	ef 39 ff fc 	ld.ub	r9,r7[-4]
800078fa:	48 b8       	lddpc	r8,80007924 <adc_process_task+0x94>
800078fc:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
		}
	}
}
80007900:	10 9c       	mov	r12,r8
80007902:	2f fd       	sub	sp,-4
80007904:	e3 cd 80 80 	ldm	sp++,r7,pc
80007908:	00 00       	add	r0,r0
8000790a:	00 a3       	st.w	r0++,r3
8000790c:	00 00       	add	r0,r0
8000790e:	00 b0       	st.h	r0++,r0
80007910:	00 00       	add	r0,r0
80007912:	00 9c       	mov	r12,r0
80007914:	80 00       	ld.sh	r0,r0[0x0]
80007916:	35 7c       	mov	r12,87
80007918:	80 00       	ld.sh	r0,r0[0x0]
8000791a:	3a 8c       	mov	r12,-88
8000791c:	00 00       	add	r0,r0
8000791e:	0b 48       	ld.w	r8,--r5
80007920:	80 00       	ld.sh	r0,r0[0x0]
80007922:	3b 18       	mov	r8,-79
80007924:	00 00       	add	r0,r0
80007926:	08 40       	or	r0,r4

80007928 <check_shelf_for_devices>:
	DEVICES_PRESENT
};

unsigned char check_shelf_for_devices(unsigned char shelfPosition);
unsigned char check_shelf_for_devices(unsigned char shelfPosition)
{
80007928:	eb cd 40 cf 	pushm	r0-r3,r6-r7,lr
8000792c:	1a 97       	mov	r7,sp
8000792e:	fa cd 00 a0 	sub	sp,sp,160
80007932:	18 98       	mov	r8,r12
80007934:	ef 68 ff 60 	st.b	r7[-160],r8
	U16 bluesense[8] = {0,0,0,0,0,0,0,0};
80007938:	30 08       	mov	r8,0
8000793a:	ef 58 ff c0 	st.h	r7[-64],r8
8000793e:	30 08       	mov	r8,0
80007940:	ef 58 ff c2 	st.h	r7[-62],r8
80007944:	30 08       	mov	r8,0
80007946:	ef 58 ff c4 	st.h	r7[-60],r8
8000794a:	30 08       	mov	r8,0
8000794c:	ef 58 ff c6 	st.h	r7[-58],r8
80007950:	30 08       	mov	r8,0
80007952:	ef 58 ff c8 	st.h	r7[-56],r8
80007956:	30 08       	mov	r8,0
80007958:	ef 58 ff ca 	st.h	r7[-54],r8
8000795c:	30 08       	mov	r8,0
8000795e:	ef 58 ff cc 	st.h	r7[-52],r8
80007962:	30 08       	mov	r8,0
80007964:	ef 58 ff ce 	st.h	r7[-50],r8
	unsigned long bluesenseAccumulated = 0;
80007968:	30 08       	mov	r8,0
8000796a:	ef 48 ff d0 	st.w	r7[-48],r8
	unsigned int bluesenseAvg = 0;
8000796e:	30 08       	mov	r8,0
80007970:	ef 48 ff d4 	st.w	r7[-44],r8
	
	char str[80];
	
	led_shelf(shelfPosition, LED_ON); //TODO: do we finish this task fast enough to not check the door latch in here? Can't have LEDs on if the door opens
80007974:	ef 38 ff 60 	ld.ub	r8,r7[-160]
80007978:	30 1b       	mov	r11,1
8000797a:	10 9c       	mov	r12,r8
8000797c:	f0 1f 00 93 	mcall	80007bc8 <check_shelf_for_devices+0x2a0>
80007980:	36 48       	mov	r8,100
80007982:	ef 48 ff e4 	st.w	r7[-28],r8
80007986:	e0 68 12 00 	mov	r8,4608
8000798a:	ea 18 00 7a 	orh	r8,0x7a
8000798e:	ef 48 ff e0 	st.w	r7[-32],r8
80007992:	ee f8 ff e4 	ld.w	r8,r7[-28]
80007996:	ef 48 ff ec 	st.w	r7[-20],r8
8000799a:	ee f8 ff e0 	ld.w	r8,r7[-32]
8000799e:	ef 48 ff e8 	st.w	r7[-24],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
800079a2:	ee f0 ff ec 	ld.w	r0,r7[-20]
800079a6:	30 01       	mov	r1,0
800079a8:	ee f2 ff e8 	ld.w	r2,r7[-24]
800079ac:	30 03       	mov	r3,0
800079ae:	e2 02 02 4a 	mul	r10,r1,r2
800079b2:	e6 00 02 48 	mul	r8,r3,r0
800079b6:	10 0a       	add	r10,r8
800079b8:	e0 02 06 48 	mulu.d	r8,r0,r2
800079bc:	12 0a       	add	r10,r9
800079be:	14 99       	mov	r9,r10
800079c0:	e0 6a 03 e7 	mov	r10,999
800079c4:	30 0b       	mov	r11,0
800079c6:	f0 0a 00 0a 	add	r10,r8,r10
800079ca:	f2 0b 00 4b 	adc	r11,r9,r11
800079ce:	e0 68 03 e8 	mov	r8,1000
800079d2:	30 09       	mov	r9,0
800079d4:	f0 1f 00 7e 	mcall	80007bcc <check_shelf_for_devices+0x2a4>
800079d8:	14 98       	mov	r8,r10
800079da:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
800079dc:	ef 48 ff f4 	st.w	r7[-12],r8
800079e0:	ee c8 00 9c 	sub	r8,r7,156
800079e4:	ef 48 ff f0 	st.w	r7[-16],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800079e8:	e1 b8 00 42 	mfsr	r8,0x108
800079ec:	10 99       	mov	r9,r8
800079ee:	ee f8 ff f0 	ld.w	r8,r7[-16]
800079f2:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800079f4:	ee f8 ff f0 	ld.w	r8,r7[-16]
800079f8:	70 09       	ld.w	r9,r8[0x0]
800079fa:	ee f8 ff f4 	ld.w	r8,r7[-12]
800079fe:	10 09       	add	r9,r8
80007a00:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007a04:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
80007a06:	ee f9 ff f0 	ld.w	r9,r7[-16]
80007a0a:	30 08       	mov	r8,0
80007a0c:	f3 68 00 08 	st.b	r9[8],r8
80007a10:	ee c8 00 9c 	sub	r8,r7,156
80007a14:	ef 48 ff f8 	st.w	r7[-8],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80007a18:	e1 b8 00 42 	mfsr	r8,0x108
80007a1c:	ef 48 ff fc 	st.w	r7[-4],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
80007a20:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007a24:	f1 39 00 08 	ld.ub	r9,r8[8]
80007a28:	30 28       	mov	r8,2
80007a2a:	f0 09 18 00 	cp.b	r9,r8
80007a2e:	c0 31       	brne	80007a34 <check_shelf_for_devices+0x10c>
    return false;
80007a30:	30 08       	mov	r8,0
80007a32:	c4 38       	rjmp	80007ab8 <check_shelf_for_devices+0x190>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
80007a34:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007a38:	f1 39 00 08 	ld.ub	r9,r8[8]
80007a3c:	30 18       	mov	r8,1
80007a3e:	f0 09 18 00 	cp.b	r9,r8
80007a42:	c0 31       	brne	80007a48 <check_shelf_for_devices+0x120>
    return true;
80007a44:	30 18       	mov	r8,1
80007a46:	c3 98       	rjmp	80007ab8 <check_shelf_for_devices+0x190>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80007a48:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007a4c:	70 09       	ld.w	r9,r8[0x0]
80007a4e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007a52:	70 18       	ld.w	r8,r8[0x4]
80007a54:	10 39       	cp.w	r9,r8
80007a56:	e0 88 00 1a 	brls	80007a8a <check_shelf_for_devices+0x162>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80007a5a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007a5e:	70 08       	ld.w	r8,r8[0x0]
80007a60:	ee f9 ff fc 	ld.w	r9,r7[-4]
80007a64:	10 39       	cp.w	r9,r8
80007a66:	c1 02       	brcc	80007a86 <check_shelf_for_devices+0x15e>
80007a68:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007a6c:	70 18       	ld.w	r8,r8[0x4]
80007a6e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80007a72:	10 39       	cp.w	r9,r8
80007a74:	e0 88 00 09 	brls	80007a86 <check_shelf_for_devices+0x15e>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80007a78:	ee f9 ff f8 	ld.w	r9,r7[-8]
80007a7c:	30 18       	mov	r8,1
80007a7e:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80007a82:	30 18       	mov	r8,1
80007a84:	c1 a8       	rjmp	80007ab8 <check_shelf_for_devices+0x190>
    }
    return false;
80007a86:	30 08       	mov	r8,0
80007a88:	c1 88       	rjmp	80007ab8 <check_shelf_for_devices+0x190>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80007a8a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007a8e:	70 08       	ld.w	r8,r8[0x0]
80007a90:	ee f9 ff fc 	ld.w	r9,r7[-4]
80007a94:	10 39       	cp.w	r9,r8
80007a96:	c0 93       	brcs	80007aa8 <check_shelf_for_devices+0x180>
80007a98:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007a9c:	70 18       	ld.w	r8,r8[0x4]
80007a9e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80007aa2:	10 39       	cp.w	r9,r8
80007aa4:	e0 88 00 09 	brls	80007ab6 <check_shelf_for_devices+0x18e>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80007aa8:	ee f9 ff f8 	ld.w	r9,r7[-8]
80007aac:	30 18       	mov	r8,1
80007aae:	f3 68 00 08 	st.b	r9[8],r8
      return true;
80007ab2:	30 18       	mov	r8,1
80007ab4:	c0 28       	rjmp	80007ab8 <check_shelf_for_devices+0x190>
    }
    return false;
80007ab6:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_ms(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_ms_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
80007ab8:	58 08       	cp.w	r8,0
80007aba:	ca b0       	breq	80007a10 <check_shelf_for_devices+0xe8>
	
	cpu_delay_ms(100, EC_CPU_CLOCK_FREQ); //30may15 was 50ms, trying 100 to see if we can get more consistent
		
	//Read bluesense for this shelf

	for (int i=0; i<8; i++)
80007abc:	30 08       	mov	r8,0
80007abe:	ef 48 ff d8 	st.w	r7[-40],r8
80007ac2:	c3 08       	rjmp	80007b22 <check_shelf_for_devices+0x1fa>
	{
		bluesense[i] = adc_process_task(shelfPosition);
80007ac4:	ee f6 ff d8 	ld.w	r6,r7[-40]
80007ac8:	ef 38 ff 60 	ld.ub	r8,r7[-160]
80007acc:	10 9c       	mov	r12,r8
80007ace:	f0 1f 00 41 	mcall	80007bd0 <check_shelf_for_devices+0x2a8>
80007ad2:	18 98       	mov	r8,r12
80007ad4:	10 99       	mov	r9,r8
80007ad6:	ec 08 15 01 	lsl	r8,r6,0x1
80007ada:	ee 08 00 08 	add	r8,r7,r8
80007ade:	f1 59 ff c0 	st.h	r8[-64],r9
		
		if (bluesense[i] & 0x8000) //don't try to average negative numbers
80007ae2:	ee f8 ff d8 	ld.w	r8,r7[-40]
80007ae6:	a1 78       	lsl	r8,0x1
80007ae8:	ee 08 00 08 	add	r8,r7,r8
80007aec:	f1 08 ff c0 	ld.sh	r8,r8[-64]
80007af0:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80007af4:	30 08       	mov	r8,0
80007af6:	f0 09 19 00 	cp.h	r9,r8
80007afa:	c0 f5       	brlt	80007b18 <check_shelf_for_devices+0x1f0>
		{
			bluesenseAccumulated += 0;
		}
		else
		{
			bluesenseAccumulated += bluesense[i];
80007afc:	ee f8 ff d8 	ld.w	r8,r7[-40]
80007b00:	a1 78       	lsl	r8,0x1
80007b02:	ee 08 00 08 	add	r8,r7,r8
80007b06:	f1 08 ff c0 	ld.sh	r8,r8[-64]
80007b0a:	5c 78       	castu.h	r8
80007b0c:	ee f9 ff d0 	ld.w	r9,r7[-48]
80007b10:	f2 08 00 08 	add	r8,r9,r8
80007b14:	ef 48 ff d0 	st.w	r7[-48],r8
	
	cpu_delay_ms(100, EC_CPU_CLOCK_FREQ); //30may15 was 50ms, trying 100 to see if we can get more consistent
		
	//Read bluesense for this shelf

	for (int i=0; i<8; i++)
80007b18:	ee f8 ff d8 	ld.w	r8,r7[-40]
80007b1c:	2f f8       	sub	r8,-1
80007b1e:	ef 48 ff d8 	st.w	r7[-40],r8
80007b22:	ee f8 ff d8 	ld.w	r8,r7[-40]
80007b26:	58 78       	cp.w	r8,7
80007b28:	fe 9a ff ce 	brle	80007ac4 <check_shelf_for_devices+0x19c>
		{
			bluesenseAccumulated += bluesense[i];
		}
	}
	
	bluesenseAvg = bluesenseAccumulated/8;
80007b2c:	ee f8 ff d0 	ld.w	r8,r7[-48]
80007b30:	a3 98       	lsr	r8,0x3
80007b32:	ef 48 ff d4 	st.w	r7[-44],r8
	
	led_shelf(shelfPosition, LED_OFF);
80007b36:	ef 38 ff 60 	ld.ub	r8,r7[-160]
80007b3a:	30 0b       	mov	r11,0
80007b3c:	10 9c       	mov	r12,r8
80007b3e:	f0 1f 00 23 	mcall	80007bc8 <check_shelf_for_devices+0x2a0>
	
	memset(str,0x00, 80);
80007b42:	ee c8 00 90 	sub	r8,r7,144
80007b46:	35 0a       	mov	r10,80
80007b48:	30 0b       	mov	r11,0
80007b4a:	10 9c       	mov	r12,r8
80007b4c:	f0 1f 00 22 	mcall	80007bd4 <check_shelf_for_devices+0x2ac>

	for (int i=0; i<8; i++)
80007b50:	30 08       	mov	r8,0
80007b52:	ef 48 ff dc 	st.w	r7[-36],r8
80007b56:	c2 28       	rjmp	80007b9a <check_shelf_for_devices+0x272>
	{
		sprintf(str, "shelf %d: bluesense[%d]=0x%X\r\n", shelfPosition, i, bluesense[i]);
80007b58:	ee f8 ff dc 	ld.w	r8,r7[-36]
80007b5c:	a1 78       	lsl	r8,0x1
80007b5e:	ee 08 00 08 	add	r8,r7,r8
80007b62:	f1 08 ff c0 	ld.sh	r8,r8[-64]
80007b66:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
80007b6a:	ef 39 ff 60 	ld.ub	r9,r7[-160]
80007b6e:	ee c8 00 90 	sub	r8,r7,144
80007b72:	1a da       	st.w	--sp,r10
80007b74:	ee fa ff dc 	ld.w	r10,r7[-36]
80007b78:	1a da       	st.w	--sp,r10
80007b7a:	1a d9       	st.w	--sp,r9
80007b7c:	49 7b       	lddpc	r11,80007bd8 <check_shelf_for_devices+0x2b0>
80007b7e:	10 9c       	mov	r12,r8
80007b80:	f0 1f 00 17 	mcall	80007bdc <check_shelf_for_devices+0x2b4>
80007b84:	2f dd       	sub	sp,-12
		print_ecdbg(str);
80007b86:	ee c8 00 90 	sub	r8,r7,144
80007b8a:	10 9c       	mov	r12,r8
80007b8c:	f0 1f 00 15 	mcall	80007be0 <check_shelf_for_devices+0x2b8>
	
	led_shelf(shelfPosition, LED_OFF);
	
	memset(str,0x00, 80);

	for (int i=0; i<8; i++)
80007b90:	ee f8 ff dc 	ld.w	r8,r7[-36]
80007b94:	2f f8       	sub	r8,-1
80007b96:	ef 48 ff dc 	st.w	r7[-36],r8
80007b9a:	ee f8 ff dc 	ld.w	r8,r7[-36]
80007b9e:	58 78       	cp.w	r8,7
80007ba0:	fe 9a ff dc 	brle	80007b58 <check_shelf_for_devices+0x230>
	{
		sprintf(str, "shelf %d: bluesense[%d]=0x%X\r\n", shelfPosition, i, bluesense[i]);
		print_ecdbg(str);
	}

	if ((bluesenseAvg < 0x300) ||  (bluesenseAvg & 0x8000))//full range for 12 bit number is 0xFFF, but this number is 2's complement meaning it can (and it does) go negative
80007ba4:	ee f8 ff d4 	ld.w	r8,r7[-44]
80007ba8:	e0 48 02 ff 	cp.w	r8,767
80007bac:	e0 88 00 07 	brls	80007bba <check_shelf_for_devices+0x292>
80007bb0:	ee f8 ff d4 	ld.w	r8,r7[-44]
80007bb4:	e2 18 80 00 	andl	r8,0x8000,COH
80007bb8:	c0 30       	breq	80007bbe <check_shelf_for_devices+0x296>
	{
		return DEVICES_PRESENT;
80007bba:	30 18       	mov	r8,1
80007bbc:	c0 28       	rjmp	80007bc0 <check_shelf_for_devices+0x298>
	}
	else
	{
		return NO_DEVICES_PRESENT;
80007bbe:	30 08       	mov	r8,0
	}
}
80007bc0:	10 9c       	mov	r12,r8
80007bc2:	2d 8d       	sub	sp,-160
80007bc4:	e3 cd 80 cf 	ldm	sp++,r0-r3,r6-r7,pc
80007bc8:	80 00       	ld.sh	r0,r0[0x0]
80007bca:	63 50       	ld.w	r0,r1[0x54]
80007bcc:	80 00       	ld.sh	r0,r0[0x0]
80007bce:	ca 56       	brmi	80007b18 <check_shelf_for_devices+0x1f0>
80007bd0:	80 00       	ld.sh	r0,r0[0x0]
80007bd2:	78 90       	ld.w	r0,r12[0x24]
80007bd4:	80 00       	ld.sh	r0,r0[0x0]
80007bd6:	ce 02       	brcc	80007b96 <check_shelf_for_devices+0x26e>
80007bd8:	80 00       	ld.sh	r0,r0[0x0]
80007bda:	65 60       	ld.w	r0,r2[0x58]
80007bdc:	80 00       	ld.sh	r0,r0[0x0]
80007bde:	ce 10       	breq	80007ba0 <check_shelf_for_devices+0x278>
80007be0:	80 00       	ld.sh	r0,r0[0x0]
80007be2:	33 38       	mov	r8,51

80007be4 <check_shelves_for_devices>:

void check_shelves_for_devices(void);
void check_shelves_for_devices(void)
{
80007be4:	eb cd 40 c0 	pushm	r6-r7,lr
80007be8:	1a 97       	mov	r7,sp
80007bea:	20 1d       	sub	sp,4
	for (int i=0; i<NUM_SHELVES; i++)
80007bec:	30 08       	mov	r8,0
80007bee:	ef 48 ff fc 	st.w	r7[-4],r8
80007bf2:	c3 d8       	rjmp	80007c6c <check_shelves_for_devices+0x88>
	{
		if (shelf[i].present)
80007bf4:	ee f9 ff fc 	ld.w	r9,r7[-4]
80007bf8:	4a 1a       	lddpc	r10,80007c7c <check_shelves_for_devices+0x98>
80007bfa:	12 98       	mov	r8,r9
80007bfc:	a3 68       	lsl	r8,0x2
80007bfe:	12 08       	add	r8,r9
80007c00:	f4 08 00 08 	add	r8,r10,r8
80007c04:	2f c8       	sub	r8,-4
80007c06:	11 88       	ld.ub	r8,r8[0x0]
80007c08:	58 08       	cp.w	r8,0
80007c0a:	c2 c0       	breq	80007c62 <check_shelves_for_devices+0x7e>
		{
			shelf[i].devicesPresent = check_shelf_for_devices(i);
80007c0c:	ee f6 ff fc 	ld.w	r6,r7[-4]
80007c10:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007c14:	5c 58       	castu.b	r8
80007c16:	10 9c       	mov	r12,r8
80007c18:	f0 1f 00 1a 	mcall	80007c80 <check_shelves_for_devices+0x9c>
80007c1c:	18 98       	mov	r8,r12
80007c1e:	10 99       	mov	r9,r8
80007c20:	49 7a       	lddpc	r10,80007c7c <check_shelves_for_devices+0x98>
80007c22:	0c 98       	mov	r8,r6
80007c24:	a3 68       	lsl	r8,0x2
80007c26:	0c 08       	add	r8,r6
80007c28:	f4 08 00 08 	add	r8,r10,r8
80007c2c:	f0 ca ff fd 	sub	r10,r8,-3
80007c30:	12 98       	mov	r8,r9
80007c32:	b4 88       	st.b	r10[0x0],r8
			
			if (shelf[i].devicesPresent)
80007c34:	ee f9 ff fc 	ld.w	r9,r7[-4]
80007c38:	49 1a       	lddpc	r10,80007c7c <check_shelves_for_devices+0x98>
80007c3a:	12 98       	mov	r8,r9
80007c3c:	a3 68       	lsl	r8,0x2
80007c3e:	12 08       	add	r8,r9
80007c40:	f4 08 00 08 	add	r8,r10,r8
80007c44:	2f d8       	sub	r8,-3
80007c46:	11 88       	ld.ub	r8,r8[0x0]
80007c48:	58 08       	cp.w	r8,0
80007c4a:	c0 c0       	breq	80007c62 <check_shelves_for_devices+0x7e>
			{
				print_ecdbg("Devices detected on shelf ");
80007c4c:	48 ec       	lddpc	r12,80007c84 <check_shelves_for_devices+0xa0>
80007c4e:	f0 1f 00 0f 	mcall	80007c88 <check_shelves_for_devices+0xa4>
				print_ecdbg_num(i);
80007c52:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007c56:	10 9c       	mov	r12,r8
80007c58:	f0 1f 00 0d 	mcall	80007c8c <check_shelves_for_devices+0xa8>
				print_ecdbg("\r\n");
80007c5c:	48 dc       	lddpc	r12,80007c90 <check_shelves_for_devices+0xac>
80007c5e:	f0 1f 00 0b 	mcall	80007c88 <check_shelves_for_devices+0xa4>
}

void check_shelves_for_devices(void);
void check_shelves_for_devices(void)
{
	for (int i=0; i<NUM_SHELVES; i++)
80007c62:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007c66:	2f f8       	sub	r8,-1
80007c68:	ef 48 ff fc 	st.w	r7[-4],r8
80007c6c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007c70:	58 38       	cp.w	r8,3
80007c72:	fe 9a ff c1 	brle	80007bf4 <check_shelves_for_devices+0x10>
				print_ecdbg_num(i);
				print_ecdbg("\r\n");
			}
		}
	}
}
80007c76:	2f fd       	sub	sp,-4
80007c78:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007c7c:	00 00       	add	r0,r0
80007c7e:	0b 91       	ld.ub	r1,r5[0x1]
80007c80:	80 00       	ld.sh	r0,r0[0x0]
80007c82:	79 28       	ld.w	r8,r12[0x48]
80007c84:	80 00       	ld.sh	r0,r0[0x0]
80007c86:	65 80       	ld.w	r0,r2[0x60]
80007c88:	80 00       	ld.sh	r0,r0[0x0]
80007c8a:	33 38       	mov	r8,51
80007c8c:	80 00       	ld.sh	r0,r0[0x0]
80007c8e:	73 50       	ld.w	r0,r9[0x54]
80007c90:	80 00       	ld.sh	r0,r0[0x0]
80007c92:	64 ec       	ld.w	r12,r2[0x38]

80007c94 <print_pca9952_errors>:


void print_pca9952_errors(unsigned char sideSel, unsigned char eflag0, unsigned char eflag1);
void print_pca9952_errors(unsigned char sideSel, unsigned char eflag0, unsigned char eflag1)
{
80007c94:	eb cd 40 80 	pushm	r7,lr
80007c98:	1a 97       	mov	r7,sp
80007c9a:	20 7d       	sub	sp,28
80007c9c:	16 99       	mov	r9,r11
80007c9e:	14 98       	mov	r8,r10
80007ca0:	18 9a       	mov	r10,r12
80007ca2:	ef 6a ff ec 	st.b	r7[-20],r10
80007ca6:	ef 69 ff e8 	st.b	r7[-24],r9
80007caa:	ef 68 ff e4 	st.b	r7[-28],r8
	unsigned char bit;
	
	switch (sideSel)
80007cae:	ef 38 ff ec 	ld.ub	r8,r7[-20]
80007cb2:	58 08       	cp.w	r8,0
80007cb4:	c4 c0       	breq	80007d4c <print_pca9952_errors+0xb8>
80007cb6:	58 18       	cp.w	r8,1
80007cb8:	e0 81 00 bd 	brne	80007e32 <print_pca9952_errors+0x19e>
	{
		case TOP:
			print_ecdbg("PCA9952 Error(s) on TOPDRIVE ");
80007cbc:	4d fc       	lddpc	r12,80007e38 <print_pca9952_errors+0x1a4>
80007cbe:	f0 1f 00 60 	mcall	80007e3c <print_pca9952_errors+0x1a8>
			
			for (int i=0; i<8; i++)
80007cc2:	30 08       	mov	r8,0
80007cc4:	ef 48 ff f4 	st.w	r7[-12],r8
80007cc8:	c2 c8       	rjmp	80007d20 <print_pca9952_errors+0x8c>
			{
				bit = (1 << i);
80007cca:	30 19       	mov	r9,1
80007ccc:	ee f8 ff f4 	ld.w	r8,r7[-12]
80007cd0:	f2 08 09 48 	lsl	r8,r9,r8
80007cd4:	ef 68 ff f3 	st.b	r7[-13],r8
				if (bit & eflag0)
80007cd8:	ef 39 ff f3 	ld.ub	r9,r7[-13]
80007cdc:	ef 38 ff e8 	ld.ub	r8,r7[-24]
80007ce0:	f3 e8 00 08 	and	r8,r9,r8
80007ce4:	5c 58       	castu.b	r8
80007ce6:	c1 80       	breq	80007d16 <print_pca9952_errors+0x82>
				{
					print_ecdbg_num(i);
80007ce8:	ee f8 ff f4 	ld.w	r8,r7[-12]
80007cec:	10 9c       	mov	r12,r8
80007cee:	f0 1f 00 55 	mcall	80007e40 <print_pca9952_errors+0x1ac>
					print_ecdbg(" ");
80007cf2:	4d 5c       	lddpc	r12,80007e44 <print_pca9952_errors+0x1b0>
80007cf4:	f0 1f 00 52 	mcall	80007e3c <print_pca9952_errors+0x1a8>
					sysErr.topdrive |= BIT(i); //SE_FAIL
80007cf8:	4d 48       	lddpc	r8,80007e48 <print_pca9952_errors+0x1b4>
80007cfa:	11 88       	ld.ub	r8,r8[0x0]
80007cfc:	10 99       	mov	r9,r8
80007cfe:	30 1a       	mov	r10,1
80007d00:	ee f8 ff f4 	ld.w	r8,r7[-12]
80007d04:	f4 08 09 48 	lsl	r8,r10,r8
80007d08:	5c 58       	castu.b	r8
80007d0a:	f3 e8 10 08 	or	r8,r9,r8
80007d0e:	5c 58       	castu.b	r8
80007d10:	5c 58       	castu.b	r8
80007d12:	4c e9       	lddpc	r9,80007e48 <print_pca9952_errors+0x1b4>
80007d14:	b2 88       	st.b	r9[0x0],r8
	switch (sideSel)
	{
		case TOP:
			print_ecdbg("PCA9952 Error(s) on TOPDRIVE ");
			
			for (int i=0; i<8; i++)
80007d16:	ee f8 ff f4 	ld.w	r8,r7[-12]
80007d1a:	2f f8       	sub	r8,-1
80007d1c:	ef 48 ff f4 	st.w	r7[-12],r8
80007d20:	ee f8 ff f4 	ld.w	r8,r7[-12]
80007d24:	58 78       	cp.w	r8,7
80007d26:	fe 9a ff d2 	brle	80007cca <print_pca9952_errors+0x36>
					sysErr.topdrive |= BIT(i); //SE_FAIL
//DEBUG 24jun15 need to function even with these errors for demo purposes					electroclaveState = STATE_CHASSIS_ERROR;
				}
			}
			
			print_ecdbg("\r\n");
80007d2a:	4c 9c       	lddpc	r12,80007e4c <print_pca9952_errors+0x1b8>
80007d2c:	f0 1f 00 44 	mcall	80007e3c <print_pca9952_errors+0x1a8>
			
			if (eflag1 != 0)
80007d30:	ef 39 ff e4 	ld.ub	r9,r7[-28]
80007d34:	30 08       	mov	r8,0
80007d36:	f0 09 18 00 	cp.b	r9,r8
80007d3a:	e0 80 00 7b 	breq	80007e30 <print_pca9952_errors+0x19c>
			{
				print_ecdbg("ERROR on unused channels: PCA9952 - Controller board U7\r\n");
80007d3e:	4c 5c       	lddpc	r12,80007e50 <print_pca9952_errors+0x1bc>
80007d40:	f0 1f 00 3f 	mcall	80007e3c <print_pca9952_errors+0x1a8>
				electroclaveState = STATE_CHASSIS_ERROR;
80007d44:	4c 49       	lddpc	r9,80007e54 <print_pca9952_errors+0x1c0>
80007d46:	30 88       	mov	r8,8
80007d48:	b2 88       	st.b	r9[0x0],r8
			}
			
			break;
80007d4a:	c7 48       	rjmp	80007e32 <print_pca9952_errors+0x19e>

		case BOTTOM:
			print_ecdbg("PCA9952 Error(s) on BOTDRIVE ");
80007d4c:	4c 3c       	lddpc	r12,80007e58 <print_pca9952_errors+0x1c4>
80007d4e:	f0 1f 00 3c 	mcall	80007e3c <print_pca9952_errors+0x1a8>
			
			for (int i=0; i<8; i++)
80007d52:	30 08       	mov	r8,0
80007d54:	ef 48 ff f8 	st.w	r7[-8],r8
80007d58:	c2 78       	rjmp	80007da6 <print_pca9952_errors+0x112>
			{
				bit = (1 << i);
80007d5a:	30 19       	mov	r9,1
80007d5c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007d60:	f2 08 09 48 	lsl	r8,r9,r8
80007d64:	ef 68 ff f3 	st.b	r7[-13],r8
				if (bit & eflag0)
80007d68:	ef 39 ff f3 	ld.ub	r9,r7[-13]
80007d6c:	ef 38 ff e8 	ld.ub	r8,r7[-24]
80007d70:	f3 e8 00 08 	and	r8,r9,r8
80007d74:	5c 58       	castu.b	r8
80007d76:	c1 30       	breq	80007d9c <print_pca9952_errors+0x108>
				{
					print_ecdbg_num(i);
80007d78:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007d7c:	10 9c       	mov	r12,r8
80007d7e:	f0 1f 00 31 	mcall	80007e40 <print_pca9952_errors+0x1ac>
					print_ecdbg(" ");
80007d82:	4b 1c       	lddpc	r12,80007e44 <print_pca9952_errors+0x1b0>
80007d84:	f0 1f 00 2e 	mcall	80007e3c <print_pca9952_errors+0x1a8>
					sysErr.botdrive |= BIT(i); //SE_FAIL;
80007d88:	4b 08       	lddpc	r8,80007e48 <print_pca9952_errors+0x1b4>
80007d8a:	70 19       	ld.w	r9,r8[0x4]
80007d8c:	30 1a       	mov	r10,1
80007d8e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007d92:	f4 08 09 48 	lsl	r8,r10,r8
80007d96:	10 49       	or	r9,r8
80007d98:	4a c8       	lddpc	r8,80007e48 <print_pca9952_errors+0x1b4>
80007d9a:	91 19       	st.w	r8[0x4],r9
			break;

		case BOTTOM:
			print_ecdbg("PCA9952 Error(s) on BOTDRIVE ");
			
			for (int i=0; i<8; i++)
80007d9c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007da0:	2f f8       	sub	r8,-1
80007da2:	ef 48 ff f8 	st.w	r7[-8],r8
80007da6:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007daa:	58 78       	cp.w	r8,7
80007dac:	fe 9a ff d7 	brle	80007d5a <print_pca9952_errors+0xc6>
					sysErr.botdrive |= BIT(i); //SE_FAIL;
//DEBUG 24jun15 need to function even with these errors for demo purposes					electroclaveState = STATE_CHASSIS_ERROR;
				}
			}
			
			for (int i=0; i<4; i++)
80007db0:	30 08       	mov	r8,0
80007db2:	ef 48 ff fc 	st.w	r7[-4],r8
80007db6:	c2 98       	rjmp	80007e08 <print_pca9952_errors+0x174>
			{
				bit = (1 << i);
80007db8:	30 19       	mov	r9,1
80007dba:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007dbe:	f2 08 09 48 	lsl	r8,r9,r8
80007dc2:	ef 68 ff f3 	st.b	r7[-13],r8
				if (bit & eflag1)
80007dc6:	ef 39 ff f3 	ld.ub	r9,r7[-13]
80007dca:	ef 38 ff e4 	ld.ub	r8,r7[-28]
80007dce:	f3 e8 00 08 	and	r8,r9,r8
80007dd2:	5c 58       	castu.b	r8
80007dd4:	c1 50       	breq	80007dfe <print_pca9952_errors+0x16a>
				{
					print_ecdbg_num((i+8));
80007dd6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007dda:	2f 88       	sub	r8,-8
80007ddc:	10 9c       	mov	r12,r8
80007dde:	f0 1f 00 19 	mcall	80007e40 <print_pca9952_errors+0x1ac>
					print_ecdbg(" ");
80007de2:	49 9c       	lddpc	r12,80007e44 <print_pca9952_errors+0x1b0>
80007de4:	f0 1f 00 16 	mcall	80007e3c <print_pca9952_errors+0x1a8>
					sysErr.botdrive |= BIT(i+8); //SE_FAIL;
80007de8:	49 88       	lddpc	r8,80007e48 <print_pca9952_errors+0x1b4>
80007dea:	70 19       	ld.w	r9,r8[0x4]
80007dec:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007df0:	2f 88       	sub	r8,-8
80007df2:	30 1a       	mov	r10,1
80007df4:	f4 08 09 48 	lsl	r8,r10,r8
80007df8:	10 49       	or	r9,r8
80007dfa:	49 48       	lddpc	r8,80007e48 <print_pca9952_errors+0x1b4>
80007dfc:	91 19       	st.w	r8[0x4],r9
					sysErr.botdrive |= BIT(i); //SE_FAIL;
//DEBUG 24jun15 need to function even with these errors for demo purposes					electroclaveState = STATE_CHASSIS_ERROR;
				}
			}
			
			for (int i=0; i<4; i++)
80007dfe:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007e02:	2f f8       	sub	r8,-1
80007e04:	ef 48 ff fc 	st.w	r7[-4],r8
80007e08:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007e0c:	58 38       	cp.w	r8,3
80007e0e:	fe 9a ff d5 	brle	80007db8 <print_pca9952_errors+0x124>
					sysErr.botdrive |= BIT(i+8); //SE_FAIL;
//DEBUG 24jun15 need to function even with these errors for demo purposes					electroclaveState = STATE_CHASSIS_ERROR;
				}
			}
			
			print_ecdbg("\r\n");
80007e12:	48 fc       	lddpc	r12,80007e4c <print_pca9952_errors+0x1b8>
80007e14:	f0 1f 00 0a 	mcall	80007e3c <print_pca9952_errors+0x1a8>
			
			if ((eflag1 & 0xF0) != 0)
80007e18:	ef 38 ff e4 	ld.ub	r8,r7[-28]
80007e1c:	e2 18 00 f0 	andl	r8,0xf0,COH
80007e20:	c0 90       	breq	80007e32 <print_pca9952_errors+0x19e>
			{
				print_ecdbg("ERROR on unused channels: PCA9952 - Controller board U8\r\n");
80007e22:	48 fc       	lddpc	r12,80007e5c <print_pca9952_errors+0x1c8>
80007e24:	f0 1f 00 06 	mcall	80007e3c <print_pca9952_errors+0x1a8>
				electroclaveState = STATE_CHASSIS_ERROR;
80007e28:	48 b9       	lddpc	r9,80007e54 <print_pca9952_errors+0x1c0>
80007e2a:	30 88       	mov	r8,8
80007e2c:	b2 88       	st.b	r9[0x0],r8
80007e2e:	c0 28       	rjmp	80007e32 <print_pca9952_errors+0x19e>
			{
				print_ecdbg("ERROR on unused channels: PCA9952 - Controller board U7\r\n");
				electroclaveState = STATE_CHASSIS_ERROR;
			}
			
			break;
80007e30:	d7 03       	nop
				print_ecdbg("ERROR on unused channels: PCA9952 - Controller board U8\r\n");
				electroclaveState = STATE_CHASSIS_ERROR;
			}
			break;
	}
}
80007e32:	2f 9d       	sub	sp,-28
80007e34:	e3 cd 80 80 	ldm	sp++,r7,pc
80007e38:	80 00       	ld.sh	r0,r0[0x0]
80007e3a:	65 9c       	ld.w	r12,r2[0x64]
80007e3c:	80 00       	ld.sh	r0,r0[0x0]
80007e3e:	33 38       	mov	r8,51
80007e40:	80 00       	ld.sh	r0,r0[0x0]
80007e42:	73 50       	ld.w	r0,r9[0x54]
80007e44:	80 00       	ld.sh	r0,r0[0x0]
80007e46:	65 bc       	ld.w	r12,r2[0x6c]
80007e48:	00 00       	add	r0,r0
80007e4a:	0b d4       	ld.ub	r4,r5[0x5]
80007e4c:	80 00       	ld.sh	r0,r0[0x0]
80007e4e:	64 ec       	ld.w	r12,r2[0x38]
80007e50:	80 00       	ld.sh	r0,r0[0x0]
80007e52:	65 c0       	ld.w	r0,r2[0x70]
80007e54:	00 00       	add	r0,r0
80007e56:	07 b9       	ld.ub	r9,r3[0x3]
80007e58:	80 00       	ld.sh	r0,r0[0x0]
80007e5a:	65 fc       	ld.w	r12,r2[0x7c]
80007e5c:	80 00       	ld.sh	r0,r0[0x0]
80007e5e:	66 1c       	ld.w	r12,r3[0x4]

80007e60 <test_led_driver_channels>:

unsigned char topEflag0 = 0, topEflag1 = 0, botEflag0 = 0, botEflag1 = 0;

void test_led_driver_channels(void);
void test_led_driver_channels(void)
{
80007e60:	eb cd 40 8f 	pushm	r0-r3,r7,lr
80007e64:	1a 97       	mov	r7,sp
80007e66:	20 fd       	sub	sp,60
	unsigned char tmp1, tmp2, numShelvesPresent = 0;
80007e68:	30 08       	mov	r8,0
80007e6a:	ef 68 ff d3 	st.b	r7[-45],r8
	
	
	for (int i=0; i<NUM_SHELVES; i++)
80007e6e:	30 08       	mov	r8,0
80007e70:	ef 48 ff d4 	st.w	r7[-44],r8
80007e74:	c1 88       	rjmp	80007ea4 <test_led_driver_channels+0x44>
	{
		if (shelf[i].present)
80007e76:	ee f9 ff d4 	ld.w	r9,r7[-44]
80007e7a:	fe fa 03 2a 	ld.w	r10,pc[810]
80007e7e:	12 98       	mov	r8,r9
80007e80:	a3 68       	lsl	r8,0x2
80007e82:	12 08       	add	r8,r9
80007e84:	f4 08 00 08 	add	r8,r10,r8
80007e88:	2f c8       	sub	r8,-4
80007e8a:	11 88       	ld.ub	r8,r8[0x0]
80007e8c:	58 08       	cp.w	r8,0
80007e8e:	c0 60       	breq	80007e9a <test_led_driver_channels+0x3a>
		{
			numShelvesPresent++;
80007e90:	ef 38 ff d3 	ld.ub	r8,r7[-45]
80007e94:	2f f8       	sub	r8,-1
80007e96:	ef 68 ff d3 	st.b	r7[-45],r8
void test_led_driver_channels(void)
{
	unsigned char tmp1, tmp2, numShelvesPresent = 0;
	
	
	for (int i=0; i<NUM_SHELVES; i++)
80007e9a:	ee f8 ff d4 	ld.w	r8,r7[-44]
80007e9e:	2f f8       	sub	r8,-1
80007ea0:	ef 48 ff d4 	st.w	r7[-44],r8
80007ea4:	ee f8 ff d4 	ld.w	r8,r7[-44]
80007ea8:	58 38       	cp.w	r8,3
80007eaa:	fe 9a ff e6 	brle	80007e76 <test_led_driver_channels+0x16>
		{
			numShelvesPresent++;
		}
	}
	
	if (numShelvesPresent !=0)
80007eae:	ef 39 ff d3 	ld.ub	r9,r7[-45]
80007eb2:	30 08       	mov	r8,0
80007eb4:	f0 09 18 00 	cp.b	r9,r8
80007eb8:	e0 80 01 61 	breq	8000817a <test_led_driver_channels+0x31a>
	{
		//Tone down the current so all shelves can be turned on at once
		PCA9952_write_reg(LED_TOP, PCA9952_IREFALL, LED_TEST_DRIVER_CURRENT);
80007ebc:	e0 6a 00 c8 	mov	r10,200
80007ec0:	34 3b       	mov	r11,67
80007ec2:	30 0c       	mov	r12,0
80007ec4:	f0 1f 00 b9 	mcall	800081a8 <test_led_driver_channels+0x348>
		PCA9952_write_reg(LED_BOTTOM, PCA9952_IREFALL, LED_TEST_DRIVER_CURRENT);
80007ec8:	e0 6a 00 c8 	mov	r10,200
80007ecc:	34 3b       	mov	r11,67
80007ece:	30 1c       	mov	r12,1
80007ed0:	f0 1f 00 b6 	mcall	800081a8 <test_led_driver_channels+0x348>

		for (int i=0; i<NUM_SHELVES; i++)
80007ed4:	30 08       	mov	r8,0
80007ed6:	ef 48 ff d8 	st.w	r7[-40],r8
80007eda:	c1 a8       	rjmp	80007f0e <test_led_driver_channels+0xae>
		{
			if (shelf[i].present)
80007edc:	ee f9 ff d8 	ld.w	r9,r7[-40]
80007ee0:	fe fa 02 c4 	ld.w	r10,pc[708]
80007ee4:	12 98       	mov	r8,r9
80007ee6:	a3 68       	lsl	r8,0x2
80007ee8:	12 08       	add	r8,r9
80007eea:	f4 08 00 08 	add	r8,r10,r8
80007eee:	2f c8       	sub	r8,-4
80007ef0:	11 88       	ld.ub	r8,r8[0x0]
80007ef2:	58 08       	cp.w	r8,0
80007ef4:	c0 80       	breq	80007f04 <test_led_driver_channels+0xa4>
			{
				led_shelf(i, LED_ON);
80007ef6:	ee f8 ff d8 	ld.w	r8,r7[-40]
80007efa:	5c 58       	castu.b	r8
80007efc:	30 1b       	mov	r11,1
80007efe:	10 9c       	mov	r12,r8
80007f00:	f0 1f 00 ab 	mcall	800081ac <test_led_driver_channels+0x34c>
	{
		//Tone down the current so all shelves can be turned on at once
		PCA9952_write_reg(LED_TOP, PCA9952_IREFALL, LED_TEST_DRIVER_CURRENT);
		PCA9952_write_reg(LED_BOTTOM, PCA9952_IREFALL, LED_TEST_DRIVER_CURRENT);

		for (int i=0; i<NUM_SHELVES; i++)
80007f04:	ee f8 ff d8 	ld.w	r8,r7[-40]
80007f08:	2f f8       	sub	r8,-1
80007f0a:	ef 48 ff d8 	st.w	r7[-40],r8
80007f0e:	ee f8 ff d8 	ld.w	r8,r7[-40]
80007f12:	58 38       	cp.w	r8,3
80007f14:	fe 9a ff e4 	brle	80007edc <test_led_driver_channels+0x7c>
80007f18:	36 48       	mov	r8,100
80007f1a:	ef 48 ff e4 	st.w	r7[-28],r8
80007f1e:	e0 68 12 00 	mov	r8,4608
80007f22:	ea 18 00 7a 	orh	r8,0x7a
80007f26:	ef 48 ff e0 	st.w	r7[-32],r8
80007f2a:	ee f8 ff e4 	ld.w	r8,r7[-28]
80007f2e:	ef 48 ff ec 	st.w	r7[-20],r8
80007f32:	ee f8 ff e0 	ld.w	r8,r7[-32]
80007f36:	ef 48 ff e8 	st.w	r7[-24],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_us_2_cy(unsigned long us, unsigned long fcpu_hz)
{
  return ((unsigned long long)us * fcpu_hz + 999999) / 1000000;
80007f3a:	ee f0 ff ec 	ld.w	r0,r7[-20]
80007f3e:	30 01       	mov	r1,0
80007f40:	ee f2 ff e8 	ld.w	r2,r7[-24]
80007f44:	30 03       	mov	r3,0
80007f46:	e2 02 02 4a 	mul	r10,r1,r2
80007f4a:	e6 00 02 48 	mul	r8,r3,r0
80007f4e:	10 0a       	add	r10,r8
80007f50:	e0 02 06 48 	mulu.d	r8,r0,r2
80007f54:	12 0a       	add	r10,r9
80007f56:	14 99       	mov	r9,r10
80007f58:	ee 7a 42 3f 	mov	r10,999999
80007f5c:	30 0b       	mov	r11,0
80007f5e:	f0 0a 00 0a 	add	r10,r8,r10
80007f62:	f2 0b 00 4b 	adc	r11,r9,r11
80007f66:	ee 78 42 40 	mov	r8,1000000
80007f6a:	30 09       	mov	r9,0
80007f6c:	f0 1f 00 91 	mcall	800081b0 <test_led_driver_channels+0x350>
80007f70:	14 98       	mov	r8,r10
80007f72:	16 99       	mov	r9,r11
 * \param  fcpu_hz: CPU frequency in Hz.
 */
__always_inline static void cpu_delay_us(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_us_2_cy(delay, fcpu_hz), &timer);
80007f74:	ef 48 ff f4 	st.w	r7[-12],r8
80007f78:	ee c8 00 3c 	sub	r8,r7,60
80007f7c:	ef 48 ff f0 	st.w	r7[-16],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80007f80:	e1 b8 00 42 	mfsr	r8,0x108
80007f84:	10 99       	mov	r9,r8
80007f86:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007f8a:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80007f8c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007f90:	70 09       	ld.w	r9,r8[0x0]
80007f92:	ee f8 ff f4 	ld.w	r8,r7[-12]
80007f96:	10 09       	add	r9,r8
80007f98:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007f9c:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
80007f9e:	ee f9 ff f0 	ld.w	r9,r7[-16]
80007fa2:	30 08       	mov	r8,0
80007fa4:	f3 68 00 08 	st.b	r9[8],r8
80007fa8:	ee c8 00 3c 	sub	r8,r7,60
80007fac:	ef 48 ff f8 	st.w	r7[-8],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80007fb0:	e1 b8 00 42 	mfsr	r8,0x108
80007fb4:	ef 48 ff fc 	st.w	r7[-4],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
80007fb8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007fbc:	f1 39 00 08 	ld.ub	r9,r8[8]
80007fc0:	30 28       	mov	r8,2
80007fc2:	f0 09 18 00 	cp.b	r9,r8
80007fc6:	c0 31       	brne	80007fcc <test_led_driver_channels+0x16c>
    return false;
80007fc8:	30 08       	mov	r8,0
80007fca:	c4 38       	rjmp	80008050 <test_led_driver_channels+0x1f0>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
80007fcc:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007fd0:	f1 39 00 08 	ld.ub	r9,r8[8]
80007fd4:	30 18       	mov	r8,1
80007fd6:	f0 09 18 00 	cp.b	r9,r8
80007fda:	c0 31       	brne	80007fe0 <test_led_driver_channels+0x180>
    return true;
80007fdc:	30 18       	mov	r8,1
80007fde:	c3 98       	rjmp	80008050 <test_led_driver_channels+0x1f0>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80007fe0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007fe4:	70 09       	ld.w	r9,r8[0x0]
80007fe6:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007fea:	70 18       	ld.w	r8,r8[0x4]
80007fec:	10 39       	cp.w	r9,r8
80007fee:	e0 88 00 1a 	brls	80008022 <test_led_driver_channels+0x1c2>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80007ff2:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007ff6:	70 08       	ld.w	r8,r8[0x0]
80007ff8:	ee f9 ff fc 	ld.w	r9,r7[-4]
80007ffc:	10 39       	cp.w	r9,r8
80007ffe:	c1 02       	brcc	8000801e <test_led_driver_channels+0x1be>
80008000:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008004:	70 18       	ld.w	r8,r8[0x4]
80008006:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000800a:	10 39       	cp.w	r9,r8
8000800c:	e0 88 00 09 	brls	8000801e <test_led_driver_channels+0x1be>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80008010:	ee f9 ff f8 	ld.w	r9,r7[-8]
80008014:	30 18       	mov	r8,1
80008016:	f3 68 00 08 	st.b	r9[8],r8
      return true;
8000801a:	30 18       	mov	r8,1
8000801c:	c1 a8       	rjmp	80008050 <test_led_driver_channels+0x1f0>
    }
    return false;
8000801e:	30 08       	mov	r8,0
80008020:	c1 88       	rjmp	80008050 <test_led_driver_channels+0x1f0>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80008022:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008026:	70 08       	ld.w	r8,r8[0x0]
80008028:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000802c:	10 39       	cp.w	r9,r8
8000802e:	c0 93       	brcs	80008040 <test_led_driver_channels+0x1e0>
80008030:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008034:	70 18       	ld.w	r8,r8[0x4]
80008036:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000803a:	10 39       	cp.w	r9,r8
8000803c:	e0 88 00 09 	brls	8000804e <test_led_driver_channels+0x1ee>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
80008040:	ee f9 ff f8 	ld.w	r9,r7[-8]
80008044:	30 18       	mov	r8,1
80008046:	f3 68 00 08 	st.b	r9[8],r8
      return true;
8000804a:	30 18       	mov	r8,1
8000804c:	c0 28       	rjmp	80008050 <test_led_driver_channels+0x1f0>
    }
    return false;
8000804e:	30 08       	mov	r8,0
 */
__always_inline static void cpu_delay_us(unsigned long delay, unsigned long fcpu_hz)
{
  t_cpu_time timer;
  cpu_set_timeout( cpu_us_2_cy(delay, fcpu_hz), &timer);
  while( !cpu_is_timeout(&timer) );
80008050:	58 08       	cp.w	r8,0
80008052:	ca b0       	breq	80007fa8 <test_led_driver_channels+0x148>
			}
		}
		
		cpu_delay_us(100,EC_CPU_CLOCK_FREQ); //maybe need this while testing LED boards with resistors in place of real LEDs 31july2015

		PCA9952_write_reg(LED_TOP, PCA9952_MODE2, 0x40); //starts fault test
80008054:	34 0a       	mov	r10,64
80008056:	30 1b       	mov	r11,1
80008058:	30 0c       	mov	r12,0
8000805a:	f0 1f 00 54 	mcall	800081a8 <test_led_driver_channels+0x348>
		PCA9952_write_reg(LED_BOTTOM, PCA9952_MODE2, 0x40); //starts fault test
8000805e:	34 0a       	mov	r10,64
80008060:	30 1b       	mov	r11,1
80008062:	30 1c       	mov	r12,1
80008064:	f0 1f 00 51 	mcall	800081a8 <test_led_driver_channels+0x348>
80008068:	c0 28       	rjmp	8000806c <test_led_driver_channels+0x20c>
				}
				
				break; //fault test for LED_TOP strings is complete
			}
			
		}
8000806a:	d7 03       	nop
		PCA9952_write_reg(LED_TOP, PCA9952_MODE2, 0x40); //starts fault test
		PCA9952_write_reg(LED_BOTTOM, PCA9952_MODE2, 0x40); //starts fault test
		
		while (1)
		{
			tmp1 = PCA9952_read_reg(LED_TOP, PCA9952_MODE2);
8000806c:	30 1b       	mov	r11,1
8000806e:	30 0c       	mov	r12,0
80008070:	f0 1f 00 51 	mcall	800081b4 <test_led_driver_channels+0x354>
80008074:	18 98       	mov	r8,r12
80008076:	ef 68 ff d1 	st.b	r7[-47],r8
			
			if ((tmp1 & 0x40) == 0)
8000807a:	ef 38 ff d1 	ld.ub	r8,r7[-47]
8000807e:	e2 18 00 40 	andl	r8,0x40,COH
80008082:	cf 41       	brne	8000806a <test_led_driver_channels+0x20a>
			{
				topEflag0 = PCA9952_read_reg(LED_TOP, PCA9952_EFLAG0);
80008084:	34 4b       	mov	r11,68
80008086:	30 0c       	mov	r12,0
80008088:	f0 1f 00 4b 	mcall	800081b4 <test_led_driver_channels+0x354>
8000808c:	18 98       	mov	r8,r12
8000808e:	4c b9       	lddpc	r9,800081b8 <test_led_driver_channels+0x358>
80008090:	b2 88       	st.b	r9[0x0],r8
				topEflag1 = PCA9952_read_reg(LED_TOP, PCA9952_EFLAG1);
80008092:	34 5b       	mov	r11,69
80008094:	30 0c       	mov	r12,0
80008096:	f0 1f 00 48 	mcall	800081b4 <test_led_driver_channels+0x354>
8000809a:	18 98       	mov	r8,r12
8000809c:	4c 89       	lddpc	r9,800081bc <test_led_driver_channels+0x35c>
8000809e:	b2 88       	st.b	r9[0x0],r8
				
				if ((topEflag0 != 0) || (topEflag1 != 0))
800080a0:	4c 68       	lddpc	r8,800081b8 <test_led_driver_channels+0x358>
800080a2:	11 88       	ld.ub	r8,r8[0x0]
800080a4:	58 08       	cp.w	r8,0
800080a6:	c0 51       	brne	800080b0 <test_led_driver_channels+0x250>
800080a8:	4c 58       	lddpc	r8,800081bc <test_led_driver_channels+0x35c>
800080aa:	11 88       	ld.ub	r8,r8[0x0]
800080ac:	58 08       	cp.w	r8,0
800080ae:	c1 00       	breq	800080ce <test_led_driver_channels+0x26e>
				{
					if (!firstTimeThroughPCA9952)
800080b0:	4c 48       	lddpc	r8,800081c0 <test_led_driver_channels+0x360>
800080b2:	11 88       	ld.ub	r8,r8[0x0]
800080b4:	58 08       	cp.w	r8,0
800080b6:	c0 e1       	brne	800080d2 <test_led_driver_channels+0x272>
					{
						print_pca9952_errors(TOP, topEflag0, topEflag1);
800080b8:	4c 18       	lddpc	r8,800081bc <test_led_driver_channels+0x35c>
800080ba:	11 88       	ld.ub	r8,r8[0x0]
800080bc:	10 99       	mov	r9,r8
800080be:	4b f8       	lddpc	r8,800081b8 <test_led_driver_channels+0x358>
800080c0:	11 88       	ld.ub	r8,r8[0x0]
800080c2:	12 9a       	mov	r10,r9
800080c4:	10 9b       	mov	r11,r8
800080c6:	30 1c       	mov	r12,1
800080c8:	f0 1f 00 3f 	mcall	800081c4 <test_led_driver_channels+0x364>
					}
				}
				
				break; //fault test for LED_TOP strings is complete
800080cc:	c0 68       	rjmp	800080d8 <test_led_driver_channels+0x278>
800080ce:	d7 03       	nop
800080d0:	c0 48       	rjmp	800080d8 <test_led_driver_channels+0x278>
800080d2:	d7 03       	nop
800080d4:	c0 28       	rjmp	800080d8 <test_led_driver_channels+0x278>
				}
				
				break; //fault test for LED_BOTTOM strings is complete
			}
			
		}
800080d6:	d7 03       	nop
			
		}
		
		while (1)
		{
			tmp2 = PCA9952_read_reg(LED_BOTTOM, PCA9952_MODE2);
800080d8:	30 1b       	mov	r11,1
800080da:	30 1c       	mov	r12,1
800080dc:	f0 1f 00 36 	mcall	800081b4 <test_led_driver_channels+0x354>
800080e0:	18 98       	mov	r8,r12
800080e2:	ef 68 ff d2 	st.b	r7[-46],r8
			
			if ((tmp2 & 0x40) == 0)
800080e6:	ef 38 ff d2 	ld.ub	r8,r7[-46]
800080ea:	e2 18 00 40 	andl	r8,0x40,COH
800080ee:	cf 41       	brne	800080d6 <test_led_driver_channels+0x276>
			{
				botEflag0 = PCA9952_read_reg(LED_BOTTOM, PCA9952_EFLAG0);
800080f0:	34 4b       	mov	r11,68
800080f2:	30 1c       	mov	r12,1
800080f4:	f0 1f 00 30 	mcall	800081b4 <test_led_driver_channels+0x354>
800080f8:	18 98       	mov	r8,r12
800080fa:	4b 49       	lddpc	r9,800081c8 <test_led_driver_channels+0x368>
800080fc:	b2 88       	st.b	r9[0x0],r8
				botEflag1 = PCA9952_read_reg(LED_BOTTOM, PCA9952_EFLAG1);
800080fe:	34 5b       	mov	r11,69
80008100:	30 1c       	mov	r12,1
80008102:	f0 1f 00 2d 	mcall	800081b4 <test_led_driver_channels+0x354>
80008106:	18 98       	mov	r8,r12
80008108:	4b 19       	lddpc	r9,800081cc <test_led_driver_channels+0x36c>
8000810a:	b2 88       	st.b	r9[0x0],r8
				
				if ((botEflag0 != 0) || (botEflag1 != 0))
8000810c:	4a f8       	lddpc	r8,800081c8 <test_led_driver_channels+0x368>
8000810e:	11 88       	ld.ub	r8,r8[0x0]
80008110:	58 08       	cp.w	r8,0
80008112:	c0 51       	brne	8000811c <test_led_driver_channels+0x2bc>
80008114:	4a e8       	lddpc	r8,800081cc <test_led_driver_channels+0x36c>
80008116:	11 88       	ld.ub	r8,r8[0x0]
80008118:	58 08       	cp.w	r8,0
8000811a:	c0 f0       	breq	80008138 <test_led_driver_channels+0x2d8>
				{
					if (!firstTimeThroughPCA9952)
8000811c:	4a 98       	lddpc	r8,800081c0 <test_led_driver_channels+0x360>
8000811e:	11 88       	ld.ub	r8,r8[0x0]
80008120:	58 08       	cp.w	r8,0
80008122:	c0 b1       	brne	80008138 <test_led_driver_channels+0x2d8>
					{
						print_pca9952_errors(BOTTOM, botEflag0, botEflag1);
80008124:	4a a8       	lddpc	r8,800081cc <test_led_driver_channels+0x36c>
80008126:	11 88       	ld.ub	r8,r8[0x0]
80008128:	10 99       	mov	r9,r8
8000812a:	4a 88       	lddpc	r8,800081c8 <test_led_driver_channels+0x368>
8000812c:	11 88       	ld.ub	r8,r8[0x0]
8000812e:	12 9a       	mov	r10,r9
80008130:	10 9b       	mov	r11,r8
80008132:	30 0c       	mov	r12,0
80008134:	f0 1f 00 24 	mcall	800081c4 <test_led_driver_channels+0x364>
				break; //fault test for LED_BOTTOM strings is complete
			}
			
		}
		
		for (int i=0; i<NUM_SHELVES; i++)
80008138:	30 08       	mov	r8,0
8000813a:	ef 48 ff dc 	st.w	r7[-36],r8
8000813e:	c0 d8       	rjmp	80008158 <test_led_driver_channels+0x2f8>
		{
			led_shelf(i, LED_OFF);
80008140:	ee f8 ff dc 	ld.w	r8,r7[-36]
80008144:	5c 58       	castu.b	r8
80008146:	30 0b       	mov	r11,0
80008148:	10 9c       	mov	r12,r8
8000814a:	f0 1f 00 19 	mcall	800081ac <test_led_driver_channels+0x34c>
				break; //fault test for LED_BOTTOM strings is complete
			}
			
		}
		
		for (int i=0; i<NUM_SHELVES; i++)
8000814e:	ee f8 ff dc 	ld.w	r8,r7[-36]
80008152:	2f f8       	sub	r8,-1
80008154:	ef 48 ff dc 	st.w	r7[-36],r8
80008158:	ee f8 ff dc 	ld.w	r8,r7[-36]
8000815c:	58 38       	cp.w	r8,3
8000815e:	fe 9a ff f1 	brle	80008140 <test_led_driver_channels+0x2e0>
		{
			led_shelf(i, LED_OFF);
		}
		
		//Put driver current back to full power
		PCA9952_write_reg(LED_TOP, PCA9952_IREFALL, LED_DRIVER_CURRENT);
80008162:	e0 6a 00 c8 	mov	r10,200
80008166:	34 3b       	mov	r11,67
80008168:	30 0c       	mov	r12,0
8000816a:	f0 1f 00 10 	mcall	800081a8 <test_led_driver_channels+0x348>
		PCA9952_write_reg(LED_BOTTOM, PCA9952_IREFALL, LED_DRIVER_CURRENT);
8000816e:	e0 6a 00 c8 	mov	r10,200
80008172:	34 3b       	mov	r11,67
80008174:	30 1c       	mov	r12,1
80008176:	f0 1f 00 0d 	mcall	800081a8 <test_led_driver_channels+0x348>
	}
	
	sysErr.topdrive = topEflag0;
8000817a:	49 08       	lddpc	r8,800081b8 <test_led_driver_channels+0x358>
8000817c:	11 88       	ld.ub	r8,r8[0x0]
8000817e:	49 59       	lddpc	r9,800081d0 <test_led_driver_channels+0x370>
80008180:	b2 88       	st.b	r9[0x0],r8
	sysErr.botdrive = (botEflag1 << 8) | botEflag0;
80008182:	49 38       	lddpc	r8,800081cc <test_led_driver_channels+0x36c>
80008184:	11 88       	ld.ub	r8,r8[0x0]
80008186:	f0 09 15 08 	lsl	r9,r8,0x8
8000818a:	49 08       	lddpc	r8,800081c8 <test_led_driver_channels+0x368>
8000818c:	11 88       	ld.ub	r8,r8[0x0]
8000818e:	f3 e8 10 08 	or	r8,r9,r8
80008192:	10 99       	mov	r9,r8
80008194:	48 f8       	lddpc	r8,800081d0 <test_led_driver_channels+0x370>
80008196:	91 19       	st.w	r8[0x4],r9
	firstTimeThroughPCA9952 = 0;
80008198:	48 a9       	lddpc	r9,800081c0 <test_led_driver_channels+0x360>
8000819a:	30 08       	mov	r8,0
8000819c:	b2 88       	st.b	r9[0x0],r8
}
8000819e:	2f 1d       	sub	sp,-60
800081a0:	e3 cd 80 8f 	ldm	sp++,r0-r3,r7,pc
800081a4:	00 00       	add	r0,r0
800081a6:	0b 91       	ld.ub	r1,r5[0x1]
800081a8:	80 00       	ld.sh	r0,r0[0x0]
800081aa:	5e 8c       	retls	r12
800081ac:	80 00       	ld.sh	r0,r0[0x0]
800081ae:	63 50       	ld.w	r0,r1[0x54]
800081b0:	80 00       	ld.sh	r0,r0[0x0]
800081b2:	ca 56       	brmi	800080fc <test_led_driver_channels+0x29c>
800081b4:	80 00       	ld.sh	r0,r0[0x0]
800081b6:	5f 10       	srne	r0
800081b8:	00 00       	add	r0,r0
800081ba:	07 d0       	ld.ub	r0,r3[0x5]
800081bc:	00 00       	add	r0,r0
800081be:	07 d1       	ld.ub	r1,r3[0x5]
800081c0:	00 00       	add	r0,r0
800081c2:	00 0d       	add	sp,r0
800081c4:	80 00       	ld.sh	r0,r0[0x0]
800081c6:	7c 94       	ld.w	r4,lr[0x24]
800081c8:	00 00       	add	r0,r0
800081ca:	07 d2       	ld.ub	r2,r3[0x5]
800081cc:	00 00       	add	r0,r0
800081ce:	07 d3       	ld.ub	r3,r3[0x5]
800081d0:	00 00       	add	r0,r0
800081d2:	0b d4       	ld.ub	r4,r5[0x5]

800081d4 <set_shelves_active_inactive>:

void set_shelves_active_inactive(void);
void set_shelves_active_inactive(void)
{
800081d4:	eb cd 40 80 	pushm	r7,lr
800081d8:	1a 97       	mov	r7,sp
800081da:	20 1d       	sub	sp,4

	test_led_driver_channels();
800081dc:	f0 1f 00 5d 	mcall	80008350 <set_shelves_active_inactive+0x17c>
	
	numActiveShelves = 0;
800081e0:	4d d9       	lddpc	r9,80008354 <set_shelves_active_inactive+0x180>
800081e2:	30 08       	mov	r8,0
800081e4:	b2 88       	st.b	r9[0x0],r8
	numPresentShelves = 0;
800081e6:	4d d9       	lddpc	r9,80008358 <set_shelves_active_inactive+0x184>
800081e8:	30 08       	mov	r8,0
800081ea:	b2 88       	st.b	r9[0x0],r8
	
	for (int i=0; i<NUM_SHELVES; i++)
800081ec:	30 08       	mov	r8,0
800081ee:	ef 48 ff fc 	st.w	r7[-4],r8
800081f2:	c1 08       	rjmp	80008212 <set_shelves_active_inactive+0x3e>
	{
		shelf[i].active = SHELF_INACTIVE;
800081f4:	ee f9 ff fc 	ld.w	r9,r7[-4]
800081f8:	4d 9a       	lddpc	r10,8000835c <set_shelves_active_inactive+0x188>
800081fa:	12 98       	mov	r8,r9
800081fc:	a3 68       	lsl	r8,0x2
800081fe:	12 08       	add	r8,r9
80008200:	f4 08 00 09 	add	r9,r10,r8
80008204:	30 08       	mov	r8,0
80008206:	b2 88       	st.b	r9[0x0],r8
	test_led_driver_channels();
	
	numActiveShelves = 0;
	numPresentShelves = 0;
	
	for (int i=0; i<NUM_SHELVES; i++)
80008208:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000820c:	2f f8       	sub	r8,-1
8000820e:	ef 48 ff fc 	st.w	r7[-4],r8
80008212:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008216:	58 38       	cp.w	r8,3
80008218:	fe 9a ff ee 	brle	800081f4 <set_shelves_active_inactive+0x20>
		shelf[i].active = SHELF_INACTIVE;
		
	}
	
	/* check shelf 0 */
	if (shelf[0].present &&
8000821c:	4d 08       	lddpc	r8,8000835c <set_shelves_active_inactive+0x188>
8000821e:	11 c8       	ld.ub	r8,r8[0x4]
80008220:	58 08       	cp.w	r8,0
80008222:	c1 f0       	breq	80008260 <set_shelves_active_inactive+0x8c>
		(!ledBrdSide[LED_BRD_0_BOT].maxUsageReached) &&
80008224:	4c f8       	lddpc	r8,80008360 <set_shelves_active_inactive+0x18c>
80008226:	11 a8       	ld.ub	r8,r8[0x2]
		shelf[i].active = SHELF_INACTIVE;
		
	}
	
	/* check shelf 0 */
	if (shelf[0].present &&
80008228:	58 08       	cp.w	r8,0
8000822a:	c1 b1       	brne	80008260 <set_shelves_active_inactive+0x8c>
		(!ledBrdSide[LED_BRD_0_BOT].maxUsageReached) &&
		(!ledBrdSide[LED_BRD_1_TOP].maxUsageReached) )
8000822c:	4c d8       	lddpc	r8,80008360 <set_shelves_active_inactive+0x18c>
8000822e:	11 f8       	ld.ub	r8,r8[0x7]
		shelf[i].active = SHELF_INACTIVE;
		
	}
	
	/* check shelf 0 */
	if (shelf[0].present &&
80008230:	58 08       	cp.w	r8,0
80008232:	c1 71       	brne	80008260 <set_shelves_active_inactive+0x8c>
		(!ledBrdSide[LED_BRD_0_BOT].maxUsageReached) &&
		(!ledBrdSide[LED_BRD_1_TOP].maxUsageReached) )
	{
		numPresentShelves++;
80008234:	4c 98       	lddpc	r8,80008358 <set_shelves_active_inactive+0x184>
80008236:	11 88       	ld.ub	r8,r8[0x0]
80008238:	2f f8       	sub	r8,-1
8000823a:	5c 58       	castu.b	r8
8000823c:	4c 79       	lddpc	r9,80008358 <set_shelves_active_inactive+0x184>
8000823e:	b2 88       	st.b	r9[0x0],r8
		
		if (shelf[0].devicesPresent)
80008240:	4c 78       	lddpc	r8,8000835c <set_shelves_active_inactive+0x188>
80008242:	11 b8       	ld.ub	r8,r8[0x3]
80008244:	58 08       	cp.w	r8,0
80008246:	c0 d0       	breq	80008260 <set_shelves_active_inactive+0x8c>
		{
			shelf[0].active = SHELF_ACTIVE;
80008248:	4c 59       	lddpc	r9,8000835c <set_shelves_active_inactive+0x188>
8000824a:	30 18       	mov	r8,1
8000824c:	b2 88       	st.b	r9[0x0],r8
			numActiveShelves++;
8000824e:	4c 28       	lddpc	r8,80008354 <set_shelves_active_inactive+0x180>
80008250:	11 88       	ld.ub	r8,r8[0x0]
80008252:	2f f8       	sub	r8,-1
80008254:	5c 58       	castu.b	r8
80008256:	4c 09       	lddpc	r9,80008354 <set_shelves_active_inactive+0x180>
80008258:	b2 88       	st.b	r9[0x0],r8
			print_ecdbg("Shelf 0 active\r\n");
8000825a:	4c 3c       	lddpc	r12,80008364 <set_shelves_active_inactive+0x190>
8000825c:	f0 1f 00 43 	mcall	80008368 <set_shelves_active_inactive+0x194>
		}
	}
	
	/* check shelf 1 */
	
	if (shelf[1].present &&
80008260:	4b f8       	lddpc	r8,8000835c <set_shelves_active_inactive+0x188>
80008262:	f1 38 00 09 	ld.ub	r8,r8[9]
80008266:	58 08       	cp.w	r8,0
80008268:	c2 20       	breq	800082ac <set_shelves_active_inactive+0xd8>
	(!ledBrdSide[LED_BRD_1_BOT].maxUsageReached) &&
8000826a:	4b e8       	lddpc	r8,80008360 <set_shelves_active_inactive+0x18c>
8000826c:	f1 38 00 0c 	ld.ub	r8,r8[12]
		}
	}
	
	/* check shelf 1 */
	
	if (shelf[1].present &&
80008270:	58 08       	cp.w	r8,0
80008272:	c1 d1       	brne	800082ac <set_shelves_active_inactive+0xd8>
	(!ledBrdSide[LED_BRD_1_BOT].maxUsageReached) &&
	(!ledBrdSide[LED_BRD_2_TOP].maxUsageReached) )
80008274:	4b b8       	lddpc	r8,80008360 <set_shelves_active_inactive+0x18c>
80008276:	f1 38 00 11 	ld.ub	r8,r8[17]
		}
	}
	
	/* check shelf 1 */
	
	if (shelf[1].present &&
8000827a:	58 08       	cp.w	r8,0
8000827c:	c1 81       	brne	800082ac <set_shelves_active_inactive+0xd8>
	(!ledBrdSide[LED_BRD_1_BOT].maxUsageReached) &&
	(!ledBrdSide[LED_BRD_2_TOP].maxUsageReached) )
	{
		numPresentShelves++;
8000827e:	4b 78       	lddpc	r8,80008358 <set_shelves_active_inactive+0x184>
80008280:	11 88       	ld.ub	r8,r8[0x0]
80008282:	2f f8       	sub	r8,-1
80008284:	5c 58       	castu.b	r8
80008286:	4b 59       	lddpc	r9,80008358 <set_shelves_active_inactive+0x184>
80008288:	b2 88       	st.b	r9[0x0],r8
		
		if (shelf[1].devicesPresent)
8000828a:	4b 58       	lddpc	r8,8000835c <set_shelves_active_inactive+0x188>
8000828c:	f1 38 00 08 	ld.ub	r8,r8[8]
80008290:	58 08       	cp.w	r8,0
80008292:	c0 d0       	breq	800082ac <set_shelves_active_inactive+0xd8>
		{
			shelf[1].active = SHELF_ACTIVE;
80008294:	4b 29       	lddpc	r9,8000835c <set_shelves_active_inactive+0x188>
80008296:	30 18       	mov	r8,1
80008298:	b2 d8       	st.b	r9[0x5],r8
			numActiveShelves++;
8000829a:	4a f8       	lddpc	r8,80008354 <set_shelves_active_inactive+0x180>
8000829c:	11 88       	ld.ub	r8,r8[0x0]
8000829e:	2f f8       	sub	r8,-1
800082a0:	5c 58       	castu.b	r8
800082a2:	4a d9       	lddpc	r9,80008354 <set_shelves_active_inactive+0x180>
800082a4:	b2 88       	st.b	r9[0x0],r8
			print_ecdbg("Shelf 1 active\r\n");
800082a6:	4b 2c       	lddpc	r12,8000836c <set_shelves_active_inactive+0x198>
800082a8:	f0 1f 00 30 	mcall	80008368 <set_shelves_active_inactive+0x194>
		}
	}
	
	/* check shelf 2 */
	
	if (shelf[2].present &&
800082ac:	4a c8       	lddpc	r8,8000835c <set_shelves_active_inactive+0x188>
800082ae:	f1 38 00 0e 	ld.ub	r8,r8[14]
800082b2:	58 08       	cp.w	r8,0
800082b4:	c2 30       	breq	800082fa <set_shelves_active_inactive+0x126>
	(!ledBrdSide[LED_BRD_2_BOT].maxUsageReached) &&
800082b6:	4a b8       	lddpc	r8,80008360 <set_shelves_active_inactive+0x18c>
800082b8:	f1 38 00 16 	ld.ub	r8,r8[22]
		}
	}
	
	/* check shelf 2 */
	
	if (shelf[2].present &&
800082bc:	58 08       	cp.w	r8,0
800082be:	c1 e1       	brne	800082fa <set_shelves_active_inactive+0x126>
	(!ledBrdSide[LED_BRD_2_BOT].maxUsageReached) &&
	(!ledBrdSide[LED_BRD_3_TOP].maxUsageReached) )
800082c0:	4a 88       	lddpc	r8,80008360 <set_shelves_active_inactive+0x18c>
800082c2:	f1 38 00 1b 	ld.ub	r8,r8[27]
		}
	}
	
	/* check shelf 2 */
	
	if (shelf[2].present &&
800082c6:	58 08       	cp.w	r8,0
800082c8:	c1 91       	brne	800082fa <set_shelves_active_inactive+0x126>
	(!ledBrdSide[LED_BRD_2_BOT].maxUsageReached) &&
	(!ledBrdSide[LED_BRD_3_TOP].maxUsageReached) )
	{
		numPresentShelves++;
800082ca:	4a 48       	lddpc	r8,80008358 <set_shelves_active_inactive+0x184>
800082cc:	11 88       	ld.ub	r8,r8[0x0]
800082ce:	2f f8       	sub	r8,-1
800082d0:	5c 58       	castu.b	r8
800082d2:	4a 29       	lddpc	r9,80008358 <set_shelves_active_inactive+0x184>
800082d4:	b2 88       	st.b	r9[0x0],r8
		
		if (shelf[2].devicesPresent)
800082d6:	4a 28       	lddpc	r8,8000835c <set_shelves_active_inactive+0x188>
800082d8:	f1 38 00 0d 	ld.ub	r8,r8[13]
800082dc:	58 08       	cp.w	r8,0
800082de:	c0 e0       	breq	800082fa <set_shelves_active_inactive+0x126>
		{
			shelf[2].active = SHELF_ACTIVE;
800082e0:	49 f9       	lddpc	r9,8000835c <set_shelves_active_inactive+0x188>
800082e2:	30 18       	mov	r8,1
800082e4:	f3 68 00 0a 	st.b	r9[10],r8
			numActiveShelves++;
800082e8:	49 b8       	lddpc	r8,80008354 <set_shelves_active_inactive+0x180>
800082ea:	11 88       	ld.ub	r8,r8[0x0]
800082ec:	2f f8       	sub	r8,-1
800082ee:	5c 58       	castu.b	r8
800082f0:	49 99       	lddpc	r9,80008354 <set_shelves_active_inactive+0x180>
800082f2:	b2 88       	st.b	r9[0x0],r8
			print_ecdbg("Shelf 2 active\r\n");
800082f4:	49 fc       	lddpc	r12,80008370 <set_shelves_active_inactive+0x19c>
800082f6:	f0 1f 00 1d 	mcall	80008368 <set_shelves_active_inactive+0x194>
		}
	}
	
	/* check shelf 3 */
	
	if (shelf[3].present &&
800082fa:	49 98       	lddpc	r8,8000835c <set_shelves_active_inactive+0x188>
800082fc:	f1 38 00 13 	ld.ub	r8,r8[19]
80008300:	58 08       	cp.w	r8,0
80008302:	c2 30       	breq	80008348 <set_shelves_active_inactive+0x174>
	(!ledBrdSide[LED_BRD_3_BOT].maxUsageReached) &&
80008304:	49 78       	lddpc	r8,80008360 <set_shelves_active_inactive+0x18c>
80008306:	f1 38 00 20 	ld.ub	r8,r8[32]
		}
	}
	
	/* check shelf 3 */
	
	if (shelf[3].present &&
8000830a:	58 08       	cp.w	r8,0
8000830c:	c1 e1       	brne	80008348 <set_shelves_active_inactive+0x174>
	(!ledBrdSide[LED_BRD_3_BOT].maxUsageReached) &&
	(!ledBrdSide[LED_BRD_4_TOP].maxUsageReached) )
8000830e:	49 58       	lddpc	r8,80008360 <set_shelves_active_inactive+0x18c>
80008310:	f1 38 00 25 	ld.ub	r8,r8[37]
		}
	}
	
	/* check shelf 3 */
	
	if (shelf[3].present &&
80008314:	58 08       	cp.w	r8,0
80008316:	c1 91       	brne	80008348 <set_shelves_active_inactive+0x174>
	(!ledBrdSide[LED_BRD_3_BOT].maxUsageReached) &&
	(!ledBrdSide[LED_BRD_4_TOP].maxUsageReached) )
	{
		numPresentShelves++;
80008318:	49 08       	lddpc	r8,80008358 <set_shelves_active_inactive+0x184>
8000831a:	11 88       	ld.ub	r8,r8[0x0]
8000831c:	2f f8       	sub	r8,-1
8000831e:	5c 58       	castu.b	r8
80008320:	48 e9       	lddpc	r9,80008358 <set_shelves_active_inactive+0x184>
80008322:	b2 88       	st.b	r9[0x0],r8
		
		if (shelf[3].devicesPresent)
80008324:	48 e8       	lddpc	r8,8000835c <set_shelves_active_inactive+0x188>
80008326:	f1 38 00 12 	ld.ub	r8,r8[18]
8000832a:	58 08       	cp.w	r8,0
8000832c:	c0 e0       	breq	80008348 <set_shelves_active_inactive+0x174>
		{
			shelf[3].active = SHELF_ACTIVE;
8000832e:	48 c9       	lddpc	r9,8000835c <set_shelves_active_inactive+0x188>
80008330:	30 18       	mov	r8,1
80008332:	f3 68 00 0f 	st.b	r9[15],r8
			numActiveShelves++;
80008336:	48 88       	lddpc	r8,80008354 <set_shelves_active_inactive+0x180>
80008338:	11 88       	ld.ub	r8,r8[0x0]
8000833a:	2f f8       	sub	r8,-1
8000833c:	5c 58       	castu.b	r8
8000833e:	48 69       	lddpc	r9,80008354 <set_shelves_active_inactive+0x180>
80008340:	b2 88       	st.b	r9[0x0],r8
			print_ecdbg("Shelf 3 active\r\n");
80008342:	48 dc       	lddpc	r12,80008374 <set_shelves_active_inactive+0x1a0>
80008344:	f0 1f 00 09 	mcall	80008368 <set_shelves_active_inactive+0x194>
		}
	}
}
80008348:	2f fd       	sub	sp,-4
8000834a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000834e:	00 00       	add	r0,r0
80008350:	80 00       	ld.sh	r0,r0[0x0]
80008352:	7e 60       	ld.w	r0,pc[0x18]
80008354:	00 00       	add	r0,r0
80008356:	0c ee       	st.h	--r6,lr
80008358:	00 00       	add	r0,r0
8000835a:	0b 90       	ld.ub	r0,r5[0x1]
8000835c:	00 00       	add	r0,r0
8000835e:	0b 91       	ld.ub	r1,r5[0x1]
80008360:	00 00       	add	r0,r0
80008362:	0b fe       	ld.ub	lr,r5[0x7]
80008364:	80 00       	ld.sh	r0,r0[0x0]
80008366:	66 58       	ld.w	r8,r3[0x14]
80008368:	80 00       	ld.sh	r0,r0[0x0]
8000836a:	33 38       	mov	r8,51
8000836c:	80 00       	ld.sh	r0,r0[0x0]
8000836e:	66 6c       	ld.w	r12,r3[0x18]
80008370:	80 00       	ld.sh	r0,r0[0x0]
80008372:	66 80       	ld.w	r0,r3[0x20]
80008374:	80 00       	ld.sh	r0,r0[0x0]
80008376:	66 94       	ld.w	r4,r3[0x24]

80008378 <num_active_shelves>:

unsigned char num_active_shelves(void);
unsigned char num_active_shelves(void)
{
80008378:	eb cd 40 80 	pushm	r7,lr
8000837c:	1a 97       	mov	r7,sp
	return numActiveShelves;
8000837e:	48 38       	lddpc	r8,80008388 <num_active_shelves+0x10>
80008380:	11 88       	ld.ub	r8,r8[0x0]
}
80008382:	10 9c       	mov	r12,r8
80008384:	e3 cd 80 80 	ldm	sp++,r7,pc
80008388:	00 00       	add	r0,r0
8000838a:	0c ee       	st.h	--r6,lr

8000838c <num_present_shelves>:

unsigned char num_present_shelves(void);
unsigned char num_present_shelves(void)
{
8000838c:	eb cd 40 80 	pushm	r7,lr
80008390:	1a 97       	mov	r7,sp
	return numPresentShelves;
80008392:	48 38       	lddpc	r8,8000839c <num_present_shelves+0x10>
80008394:	11 88       	ld.ub	r8,r8[0x0]
}
80008396:	10 9c       	mov	r12,r8
80008398:	e3 cd 80 80 	ldm	sp++,r7,pc
8000839c:	00 00       	add	r0,r0
8000839e:	0b 90       	ld.ub	r0,r5[0x1]

800083a0 <init_sys_clocks>:
/*
 * Using RC8M (internal 8MHz)
 */
void init_sys_clocks(void);
void init_sys_clocks(void)
{
800083a0:	eb cd 40 80 	pushm	r7,lr
800083a4:	1a 97       	mov	r7,sp
800083a6:	20 1d       	sub	sp,4

//this kinda works for 100MHz, problems with TWIM, but maybe we can work around that 17may15
/*
 * From CLOCK_EXAMPLE31 which changes clock sources on the fly. Trying to get a faster clock so that we can work with the serial ID chip (DS2411) which needs control to 6us. 16may15
 */
	osc_enable(OSC_ID_RC8M);
800083a8:	30 2c       	mov	r12,2
800083aa:	f0 1f 00 10 	mcall	800083e8 <init_sys_clocks+0x48>
	pll_config_init(&pcfg, PLL_SRC_RC8M, 1, EC_CPU_CLOCK_100MHZ/OSC_RC8M_NOMINAL_HZ);
800083ae:	ee c8 00 04 	sub	r8,r7,4
800083b2:	30 c9       	mov	r9,12
800083b4:	30 1a       	mov	r10,1
800083b6:	30 2b       	mov	r11,2
800083b8:	10 9c       	mov	r12,r8
800083ba:	f0 1f 00 0d 	mcall	800083ec <init_sys_clocks+0x4c>
	pll_enable(&pcfg, 0);
800083be:	ee c8 00 04 	sub	r8,r7,4
800083c2:	30 0b       	mov	r11,0
800083c4:	10 9c       	mov	r12,r8
800083c6:	f0 1f 00 0b 	mcall	800083f0 <init_sys_clocks+0x50>
	sysclk_set_prescalers(1,1,1,1);
800083ca:	30 19       	mov	r9,1
800083cc:	30 1a       	mov	r10,1
800083ce:	30 1b       	mov	r11,1
800083d0:	30 1c       	mov	r12,1
800083d2:	f0 1f 00 09 	mcall	800083f4 <init_sys_clocks+0x54>
	pll_wait_for_lock(0);
800083d6:	30 0c       	mov	r12,0
800083d8:	f0 1f 00 08 	mcall	800083f8 <init_sys_clocks+0x58>
	sysclk_set_source(SYSCLK_SRC_PLL0);	
800083dc:	30 3c       	mov	r12,3
800083de:	f0 1f 00 08 	mcall	800083fc <init_sys_clocks+0x5c>
	/* put the clock out on PC19 so we can check to make sure we set it up correctly */
	//Note this code comes from ASF example AVR32 SCIF example 3
//16may15 seems to cause problems, leave out for now	scif_start_gclk(AVR32_SCIF_GCLK_GCLK0PIN, &gclkOpt);
//16may15 seems to cause problems, leave out for now	gpio_enable_module_pin(AVR32_SCIF_GCLK_0_1_PIN, AVR32_SCIF_GCLK_0_1_FUNCTION);

}
800083e2:	2f fd       	sub	sp,-4
800083e4:	e3 cd 80 80 	ldm	sp++,r7,pc
800083e8:	80 00       	ld.sh	r0,r0[0x0]
800083ea:	6f 28       	ld.w	r8,r7[0x48]
800083ec:	80 00       	ld.sh	r0,r0[0x0]
800083ee:	70 bc       	ld.w	r12,r8[0x2c]
800083f0:	80 00       	ld.sh	r0,r0[0x0]
800083f2:	5b e0       	cp.w	r0,-2
800083f4:	80 00       	ld.sh	r0,r0[0x0]
800083f6:	5c f0       	rol	r0
800083f8:	80 00       	ld.sh	r0,r0[0x0]
800083fa:	71 cc       	ld.w	r12,r8[0x70]
800083fc:	80 00       	ld.sh	r0,r0[0x0]
800083fe:	5d f0       	*unknown*

80008400 <adc_process_init>:
 *
 */

void adc_process_init(void);
void adc_process_init(void)
{
80008400:	eb cd 40 80 	pushm	r7,lr
80008404:	1a 97       	mov	r7,sp
		{INPUT4_ADC_PIN, INPUT4_ADC_FUNCTION}
	};


	// Assign and enable GPIO pins to the ADC function.
	gpio_enable_module(ADCIFA_GPIO_MAP,
80008406:	30 6b       	mov	r11,6
80008408:	48 bc       	lddpc	r12,80008434 <adc_process_init+0x34>
8000840a:	f0 1f 00 0c 	mcall	80008438 <adc_process_init+0x38>
			sizeof(ADCIFA_GPIO_MAP) / sizeof(ADCIFA_GPIO_MAP[0]));

	// Get ADCIFA Factory Configuration
	adcifa_get_calibration_data(adcifa, &adc_config_t);
8000840e:	48 c8       	lddpc	r8,8000843c <adc_process_init+0x3c>
80008410:	70 08       	ld.w	r8,r8[0x0]
80008412:	48 cb       	lddpc	r11,80008440 <adc_process_init+0x40>
80008414:	10 9c       	mov	r12,r8
80008416:	f0 1f 00 0c 	mcall	80008444 <adc_process_init+0x44>

	// Configure ADCIFA core
	adcifa_configure(adcifa, &adc_config_t, EC_CPU_CLOCK_FREQ);
8000841a:	48 98       	lddpc	r8,8000843c <adc_process_init+0x3c>
8000841c:	70 08       	ld.w	r8,r8[0x0]
8000841e:	e0 6a 12 00 	mov	r10,4608
80008422:	ea 1a 00 7a 	orh	r10,0x7a
80008426:	48 7b       	lddpc	r11,80008440 <adc_process_init+0x40>
80008428:	10 9c       	mov	r12,r8
8000842a:	f0 1f 00 08 	mcall	80008448 <adc_process_init+0x48>

}
8000842e:	e3 cd 80 80 	ldm	sp++,r7,pc
80008432:	00 00       	add	r0,r0
80008434:	80 01       	ld.sh	r1,r0[0x0]
80008436:	26 24       	sub	r4,98
80008438:	80 00       	ld.sh	r0,r0[0x0]
8000843a:	45 3c       	lddsp	r12,sp[0x14c]
8000843c:	00 00       	add	r0,r0
8000843e:	00 b0       	st.h	r0++,r0
80008440:	00 00       	add	r0,r0
80008442:	00 88       	andn	r8,r0
80008444:	80 00       	ld.sh	r0,r0[0x0]
80008446:	33 84       	mov	r4,56
80008448:	80 00       	ld.sh	r0,r0[0x0]
8000844a:	34 18       	mov	r8,65

8000844c <twi_init>:
 *
 *
 */
static void twi_init(void);
static void twi_init(void)
{
8000844c:	eb cd 40 80 	pushm	r7,lr
80008450:	1a 97       	mov	r7,sp
80008452:	20 8d       	sub	sp,32
	const gpio_map_t PCA9952_TWI_GPIO_MAP = {
		{PCA9952_TWI_SCL_PIN, PCA9952_TWI_SCL_FUNCTION},
		{PCA9952_TWI_SDA_PIN, PCA9952_TWI_SDA_FUNCTION}
	};
80008454:	49 a9       	lddpc	r9,800084bc <twi_init+0x70>
80008456:	ee c8 00 10 	sub	r8,r7,16
8000845a:	20 08       	sub	r8,0
8000845c:	20 09       	sub	r9,0
8000845e:	72 0a       	ld.w	r10,r9[0x0]
80008460:	91 0a       	st.w	r8[0x0],r10
80008462:	72 1a       	ld.w	r10,r9[0x4]
80008464:	91 1a       	st.w	r8[0x4],r10
80008466:	72 2a       	ld.w	r10,r9[0x8]
80008468:	91 2a       	st.w	r8[0x8],r10
8000846a:	72 39       	ld.w	r9,r9[0xc]
8000846c:	91 39       	st.w	r8[0xc],r9
	twi_options_t PCA9952_TWI_OPTIONS = { //7apr15 make this *not* a const so we can change it and rerun twi_master_init() if necessary
		.pba_hz = FPBA_HZ,
		.speed = PCA9952_TWI_MASTER_SPEED,
		.chip = PCA9952_U7_TOPDRIVE_TWI_ADDRESS, //7apr15
		.smbus        = false,
	};
8000846e:	49 59       	lddpc	r9,800084c0 <twi_init+0x74>
80008470:	ee c8 00 20 	sub	r8,r7,32
80008474:	20 08       	sub	r8,0
80008476:	20 09       	sub	r9,0
80008478:	72 0a       	ld.w	r10,r9[0x0]
8000847a:	91 0a       	st.w	r8[0x0],r10
8000847c:	72 1a       	ld.w	r10,r9[0x4]
8000847e:	91 1a       	st.w	r8[0x4],r10
80008480:	72 2a       	ld.w	r10,r9[0x8]
80008482:	91 2a       	st.w	r8[0x8],r10
80008484:	72 39       	ld.w	r9,r9[0xc]
80008486:	91 39       	st.w	r8[0xc],r9

	// Assign I/Os to TWI.
	gpio_enable_module(PCA9952_TWI_GPIO_MAP,
80008488:	ee c8 00 10 	sub	r8,r7,16
8000848c:	30 2b       	mov	r11,2
8000848e:	10 9c       	mov	r12,r8
80008490:	f0 1f 00 0d 	mcall	800084c4 <twi_init+0x78>
	sizeof(PCA9952_TWI_GPIO_MAP) / sizeof(PCA9952_TWI_GPIO_MAP[0]));
	// Initialize as master.
	twi_master_init(PCA9952_TWI, &PCA9952_TWI_OPTIONS);
80008494:	ee c8 00 20 	sub	r8,r7,32
80008498:	10 9b       	mov	r11,r8
8000849a:	fe 7c 38 00 	mov	r12,-51200
8000849e:	f0 1f 00 0b 	mcall	800084c8 <twi_init+0x7c>
	
	
	PCA9952_TWI_OPTIONS.chip = PCA9952_U8_BOTDRIVE_TWI_ADDRESS;
800084a2:	36 18       	mov	r8,97
800084a4:	ef 48 ff e8 	st.w	r7[-24],r8
	// Initialize as master.
	twi_master_init(PCA9952_TWI, &PCA9952_TWI_OPTIONS);
800084a8:	ee c8 00 20 	sub	r8,r7,32
800084ac:	10 9b       	mov	r11,r8
800084ae:	fe 7c 38 00 	mov	r12,-51200
800084b2:	f0 1f 00 06 	mcall	800084c8 <twi_init+0x7c>
	
	
}
800084b6:	2f 8d       	sub	sp,-32
800084b8:	e3 cd 80 80 	ldm	sp++,r7,pc
800084bc:	80 01       	ld.sh	r1,r0[0x0]
800084be:	26 04       	sub	r4,96
800084c0:	80 01       	ld.sh	r1,r0[0x0]
800084c2:	26 14       	sub	r4,97
800084c4:	80 00       	ld.sh	r0,r0[0x0]
800084c6:	45 3c       	lddsp	r12,sp[0x14c]
800084c8:	80 00       	ld.sh	r0,r0[0x0]
800084ca:	50 00       	stdsp	sp[0x0],r0

800084cc <calc_sanitize_time>:



unsigned char calc_sanitize_time(unsigned char shelfIdx);
unsigned char calc_sanitize_time(unsigned char shelfIdx)
{
800084cc:	eb cd 40 80 	pushm	r7,lr
800084d0:	1a 97       	mov	r7,sp
800084d2:	20 3d       	sub	sp,12
800084d4:	18 98       	mov	r8,r12
800084d6:	ef 68 ff f4 	st.b	r7[-12],r8
	unsigned char uSideMinutes, lSideMinutes, minutes, boardIdx, sideIdx;
	
	boardIdx = shelf[shelfIdx].tLedIdx;							//top board in the shelf
800084da:	ef 39 ff f4 	ld.ub	r9,r7[-12]
800084de:	4a da       	lddpc	r10,80008590 <calc_sanitize_time+0xc4>
800084e0:	12 98       	mov	r8,r9
800084e2:	a3 68       	lsl	r8,0x2
800084e4:	12 08       	add	r8,r9
800084e6:	f4 08 00 08 	add	r8,r10,r8
800084ea:	2f f8       	sub	r8,-1
800084ec:	11 88       	ld.ub	r8,r8[0x0]
800084ee:	ef 68 ff fe 	st.b	r7[-2],r8
	sideIdx = ledBrd[boardIdx].lSideIdx;						//lower side of the top board
800084f2:	ef 39 ff fe 	ld.ub	r9,r7[-2]
800084f6:	4a 8a       	lddpc	r10,80008594 <calc_sanitize_time+0xc8>
800084f8:	12 98       	mov	r8,r9
800084fa:	a3 78       	lsl	r8,0x3
800084fc:	12 18       	sub	r8,r9
800084fe:	a1 78       	lsl	r8,0x1
80008500:	f4 08 00 08 	add	r8,r10,r8
80008504:	2f 58       	sub	r8,-11
80008506:	11 88       	ld.ub	r8,r8[0x0]
80008508:	ef 68 ff ff 	st.b	r7[-1],r8
	lSideMinutes = ledBrdSide[sideIdx].sanitizeMinutes;
8000850c:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80008510:	4a 2a       	lddpc	r10,80008598 <calc_sanitize_time+0xcc>
80008512:	12 98       	mov	r8,r9
80008514:	a3 68       	lsl	r8,0x2
80008516:	12 08       	add	r8,r9
80008518:	f4 08 00 08 	add	r8,r10,r8
8000851c:	11 88       	ld.ub	r8,r8[0x0]
8000851e:	ef 68 ff fc 	st.b	r7[-4],r8
	

	boardIdx = shelf[shelfIdx].bLedIdx;							//bottom board in the shelf					
80008522:	ef 39 ff f4 	ld.ub	r9,r7[-12]
80008526:	49 ba       	lddpc	r10,80008590 <calc_sanitize_time+0xc4>
80008528:	12 98       	mov	r8,r9
8000852a:	a3 68       	lsl	r8,0x2
8000852c:	12 08       	add	r8,r9
8000852e:	f4 08 00 08 	add	r8,r10,r8
80008532:	2f e8       	sub	r8,-2
80008534:	11 88       	ld.ub	r8,r8[0x0]
80008536:	ef 68 ff fe 	st.b	r7[-2],r8
	sideIdx = ledBrd[boardIdx].uSideIdx;						//upper side of the bottom board
8000853a:	ef 39 ff fe 	ld.ub	r9,r7[-2]
8000853e:	49 6a       	lddpc	r10,80008594 <calc_sanitize_time+0xc8>
80008540:	12 98       	mov	r8,r9
80008542:	a3 78       	lsl	r8,0x3
80008544:	12 18       	sub	r8,r9
80008546:	a1 78       	lsl	r8,0x1
80008548:	f4 08 00 08 	add	r8,r10,r8
8000854c:	2f 68       	sub	r8,-10
8000854e:	11 88       	ld.ub	r8,r8[0x0]
80008550:	ef 68 ff ff 	st.b	r7[-1],r8
	uSideMinutes = ledBrdSide[sideIdx].sanitizeMinutes;
80008554:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80008558:	49 0a       	lddpc	r10,80008598 <calc_sanitize_time+0xcc>
8000855a:	12 98       	mov	r8,r9
8000855c:	a3 68       	lsl	r8,0x2
8000855e:	12 08       	add	r8,r9
80008560:	f4 08 00 08 	add	r8,r10,r8
80008564:	11 88       	ld.ub	r8,r8[0x0]
80008566:	ef 68 ff fb 	st.b	r7[-5],r8

	minutes = (uSideMinutes >= lSideMinutes) ? uSideMinutes : lSideMinutes; //choose the sanitize time for the more worn-out leds
8000856a:	ef 38 ff fc 	ld.ub	r8,r7[-4]
8000856e:	ef 39 ff fb 	ld.ub	r9,r7[-5]
80008572:	ef 3a ff fb 	ld.ub	r10,r7[-5]
80008576:	f0 0a 18 00 	cp.b	r10,r8
8000857a:	f2 08 17 20 	movhs	r8,r9
8000857e:	ef 68 ff fd 	st.b	r7[-3],r8
	
	return (minutes);
80008582:	ef 38 ff fd 	ld.ub	r8,r7[-3]
	
}
80008586:	10 9c       	mov	r12,r8
80008588:	2f dd       	sub	sp,-12
8000858a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000858e:	00 00       	add	r0,r0
80008590:	00 00       	add	r0,r0
80008592:	0b 91       	ld.ub	r1,r5[0x1]
80008594:	00 00       	add	r0,r0
80008596:	0b 4a       	ld.w	r10,--r5
80008598:	00 00       	add	r0,r0
8000859a:	0b fe       	ld.ub	lr,r5[0x7]

8000859c <door_latch_open_kill_all_shelves>:


void door_latch_open_kill_all_shelves(void);
void door_latch_open_kill_all_shelves(void)
{
8000859c:	eb cd 40 80 	pushm	r7,lr
800085a0:	1a 97       	mov	r7,sp
	led_shelf(0, LED_OFF);
800085a2:	30 0b       	mov	r11,0
800085a4:	30 0c       	mov	r12,0
800085a6:	f0 1f 00 0a 	mcall	800085cc <door_latch_open_kill_all_shelves+0x30>
	led_shelf(1, LED_OFF);
800085aa:	30 0b       	mov	r11,0
800085ac:	30 1c       	mov	r12,1
800085ae:	f0 1f 00 08 	mcall	800085cc <door_latch_open_kill_all_shelves+0x30>
	led_shelf(2, LED_OFF);
800085b2:	30 0b       	mov	r11,0
800085b4:	30 2c       	mov	r12,2
800085b6:	f0 1f 00 06 	mcall	800085cc <door_latch_open_kill_all_shelves+0x30>
	led_shelf(3, LED_OFF);
800085ba:	30 0b       	mov	r11,0
800085bc:	30 3c       	mov	r12,3
800085be:	f0 1f 00 04 	mcall	800085cc <door_latch_open_kill_all_shelves+0x30>
	
	print_ecdbg("Door latch opened, kill all shelves for safety.\r\n");
800085c2:	48 4c       	lddpc	r12,800085d0 <door_latch_open_kill_all_shelves+0x34>
800085c4:	f0 1f 00 04 	mcall	800085d4 <door_latch_open_kill_all_shelves+0x38>
}
800085c8:	e3 cd 80 80 	ldm	sp++,r7,pc
800085cc:	80 00       	ld.sh	r0,r0[0x0]
800085ce:	63 50       	ld.w	r0,r1[0x54]
800085d0:	80 00       	ld.sh	r0,r0[0x0]
800085d2:	66 a8       	ld.w	r8,r3[0x28]
800085d4:	80 00       	ld.sh	r0,r0[0x0]
800085d6:	33 38       	mov	r8,51

800085d8 <usage_idx>:

unsigned char usage_idx(unsigned char * idPtr, unsigned char top_botn);
unsigned char usage_idx(unsigned char * idPtr, unsigned char top_botn)

#endif //SERIAL_ID_AND_ALL_USAGE_COMBINED
{
800085d8:	eb cd 40 80 	pushm	r7,lr
800085dc:	1a 97       	mov	r7,sp
800085de:	20 4d       	sub	sp,16
800085e0:	ef 4c ff f4 	st.w	r7[-12],r12
800085e4:	16 98       	mov	r8,r11
800085e6:	ef 68 ff f0 	st.b	r7[-16],r8
	unsigned char tmpBoardId[6];
	
	for (unsigned char i=0; i<(NUM_SETS_LED_BOARD_SIDES * NUM_LED_BOARD_SIDES); i++)
800085ea:	30 08       	mov	r8,0
800085ec:	ef 68 ff ff 	st.b	r7[-1],r8
800085f0:	c8 c8       	rjmp	80008708 <usage_idx+0x130>
		} //if slotFilled (don't check against slots that haven't been assigned
	} //for each slot in usageShdw[sel]
	
#else

		if (sf[i].slotFilled)
800085f2:	ef 39 ff ff 	ld.ub	r9,r7[-1]
800085f6:	4c c8       	lddpc	r8,80008724 <usage_idx+0x14c>
800085f8:	a1 79       	lsl	r9,0x1
800085fa:	2f f9       	sub	r9,-1
800085fc:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80008600:	f1 d8 c1 a1 	bfextu	r8,r8,0xd,0x1
80008604:	5c 58       	castu.b	r8
80008606:	c7 c0       	breq	800086fe <usage_idx+0x126>
		{
			tmpBoardId[0] = *(idPtr+0);
80008608:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000860c:	11 88       	ld.ub	r8,r8[0x0]
8000860e:	ef 68 ff f8 	st.b	r7[-8],r8
			tmpBoardId[1] = *(idPtr+1);
80008612:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008616:	2f f8       	sub	r8,-1
80008618:	11 88       	ld.ub	r8,r8[0x0]
8000861a:	ef 68 ff f9 	st.b	r7[-7],r8
			tmpBoardId[2] = *(idPtr+2);
8000861e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008622:	2f e8       	sub	r8,-2
80008624:	11 88       	ld.ub	r8,r8[0x0]
80008626:	ef 68 ff fa 	st.b	r7[-6],r8
			tmpBoardId[3] = *(idPtr+3);
8000862a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000862e:	2f d8       	sub	r8,-3
80008630:	11 88       	ld.ub	r8,r8[0x0]
80008632:	ef 68 ff fb 	st.b	r7[-5],r8
			tmpBoardId[4] = *(idPtr+4);
80008636:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000863a:	2f c8       	sub	r8,-4
8000863c:	11 88       	ld.ub	r8,r8[0x0]
8000863e:	ef 68 ff fc 	st.b	r7[-4],r8
			tmpBoardId[5] = *(idPtr+5);
80008642:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008646:	2f b8       	sub	r8,-5
80008648:	11 88       	ld.ub	r8,r8[0x0]
8000864a:	ef 68 ff fd 	st.b	r7[-3],r8
			
			
			if (tmpBoardId[0] == sf[i].id[0]) {
8000864e:	ef 39 ff f8 	ld.ub	r9,r7[-8]
80008652:	ef 3a ff ff 	ld.ub	r10,r7[-1]
80008656:	4b 48       	lddpc	r8,80008724 <usage_idx+0x14c>
80008658:	f0 0a 07 38 	ld.ub	r8,r8[r10<<0x3]
8000865c:	f0 09 18 00 	cp.b	r9,r8
80008660:	c4 f1       	brne	800086fe <usage_idx+0x126>
				if (tmpBoardId[1] == sf[i].id[1]) {
80008662:	ef 39 ff f9 	ld.ub	r9,r7[-7]
80008666:	ef 38 ff ff 	ld.ub	r8,r7[-1]
8000866a:	4a fa       	lddpc	r10,80008724 <usage_idx+0x14c>
8000866c:	a3 78       	lsl	r8,0x3
8000866e:	f4 08 00 08 	add	r8,r10,r8
80008672:	11 98       	ld.ub	r8,r8[0x1]
80008674:	f0 09 18 00 	cp.b	r9,r8
80008678:	c4 31       	brne	800086fe <usage_idx+0x126>
					if (tmpBoardId[2] == sf[i].id[2]) {
8000867a:	ef 39 ff fa 	ld.ub	r9,r7[-6]
8000867e:	ef 3a ff ff 	ld.ub	r10,r7[-1]
80008682:	4a 98       	lddpc	r8,80008724 <usage_idx+0x14c>
80008684:	a3 6a       	lsl	r10,0x2
80008686:	2f fa       	sub	r10,-1
80008688:	f0 0a 07 18 	ld.ub	r8,r8[r10<<0x1]
8000868c:	f0 09 18 00 	cp.b	r9,r8
80008690:	c3 71       	brne	800086fe <usage_idx+0x126>
						if (tmpBoardId[3] == sf[i].id[3]) {
80008692:	ef 39 ff fb 	ld.ub	r9,r7[-5]
80008696:	ef 38 ff ff 	ld.ub	r8,r7[-1]
8000869a:	4a 3a       	lddpc	r10,80008724 <usage_idx+0x14c>
8000869c:	a3 78       	lsl	r8,0x3
8000869e:	f4 08 00 08 	add	r8,r10,r8
800086a2:	11 b8       	ld.ub	r8,r8[0x3]
800086a4:	f0 09 18 00 	cp.b	r9,r8
800086a8:	c2 b1       	brne	800086fe <usage_idx+0x126>
							if (tmpBoardId[4] == sf[i].id[4]) {
800086aa:	ef 39 ff fc 	ld.ub	r9,r7[-4]
800086ae:	ef 3a ff ff 	ld.ub	r10,r7[-1]
800086b2:	49 d8       	lddpc	r8,80008724 <usage_idx+0x14c>
800086b4:	a1 7a       	lsl	r10,0x1
800086b6:	2f fa       	sub	r10,-1
800086b8:	f0 0a 07 28 	ld.ub	r8,r8[r10<<0x2]
800086bc:	f0 09 18 00 	cp.b	r9,r8
800086c0:	c1 f1       	brne	800086fe <usage_idx+0x126>
								if (tmpBoardId[5] == sf[i].id[5]) {
800086c2:	ef 39 ff fd 	ld.ub	r9,r7[-3]
800086c6:	ef 38 ff ff 	ld.ub	r8,r7[-1]
800086ca:	49 7a       	lddpc	r10,80008724 <usage_idx+0x14c>
800086cc:	a3 78       	lsl	r8,0x3
800086ce:	f4 08 00 08 	add	r8,r10,r8
800086d2:	11 d8       	ld.ub	r8,r8[0x5]
800086d4:	f0 09 18 00 	cp.b	r9,r8
800086d8:	c1 31       	brne	800086fe <usage_idx+0x126>
									if (top_botn == sf[i].top_botn)
800086da:	ef 39 ff ff 	ld.ub	r9,r7[-1]
800086de:	49 28       	lddpc	r8,80008724 <usage_idx+0x14c>
800086e0:	a1 79       	lsl	r9,0x1
800086e2:	2f f9       	sub	r9,-1
800086e4:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
800086e8:	f1 d8 c1 e1 	bfextu	r8,r8,0xf,0x1
800086ec:	5c 58       	castu.b	r8
800086ee:	ef 39 ff f0 	ld.ub	r9,r7[-16]
800086f2:	f0 09 18 00 	cp.b	r9,r8
800086f6:	c0 41       	brne	800086fe <usage_idx+0x126>
									{
										return (i); //found a match!
800086f8:	ef 38 ff ff 	ld.ub	r8,r7[-1]
800086fc:	c0 f8       	rjmp	8000871a <usage_idx+0x142>

#endif //SERIAL_ID_AND_ALL_USAGE_COMBINED
{
	unsigned char tmpBoardId[6];
	
	for (unsigned char i=0; i<(NUM_SETS_LED_BOARD_SIDES * NUM_LED_BOARD_SIDES); i++)
800086fe:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80008702:	2f f8       	sub	r8,-1
80008704:	ef 68 ff ff 	st.b	r7[-1],r8
80008708:	ef 39 ff ff 	ld.ub	r9,r7[-1]
8000870c:	35 f8       	mov	r8,95
8000870e:	f0 09 18 00 	cp.b	r9,r8
80008712:	fe 98 ff 70 	brls	800085f2 <usage_idx+0x1a>
		} //if slotFilled (don't check against slots that haven't been assigned
	} //for each slot in ush
	
#endif //SERIAL_ID_AND_ALL_USAGE_COMBINED
	
	return NO_LED_BOARD_PRESENT; //no match found
80008716:	e0 68 00 ff 	mov	r8,255
}
8000871a:	10 9c       	mov	r12,r8
8000871c:	2f cd       	sub	sp,-16
8000871e:	e3 cd 80 80 	ldm	sp++,r7,pc
80008722:	00 00       	add	r0,r0
80008724:	00 00       	add	r0,r0
80008726:	08 48       	or	r8,r4

80008728 <load_usage_indeces>:
	}
}
#endif //SERIAL_ID_AND_ALL_USAGE_COMBINED

void load_usage_indeces(void)
{
80008728:	eb cd 40 c0 	pushm	r6-r7,lr
8000872c:	1a 97       	mov	r7,sp
8000872e:	20 2d       	sub	sp,8
	unsigned char top_botn, brdIdx;
	
	for (int i=0; i<NUM_LED_BOARD_SIDES; i++)
80008730:	30 08       	mov	r8,0
80008732:	ef 48 ff fc 	st.w	r7[-4],r8
80008736:	c4 78       	rjmp	800087c4 <load_usage_indeces+0x9c>
	{
		brdIdx = ledBrdSide[i].boardIdx;
80008738:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000873c:	4a 6a       	lddpc	r10,800087d4 <load_usage_indeces+0xac>
8000873e:	12 98       	mov	r8,r9
80008740:	a3 68       	lsl	r8,0x2
80008742:	12 08       	add	r8,r9
80008744:	f4 08 00 08 	add	r8,r10,r8
80008748:	2f c8       	sub	r8,-4
8000874a:	11 88       	ld.ub	r8,r8[0x0]
8000874c:	ef 68 ff fb 	st.b	r7[-5],r8
		
		if (ledBrd[brdIdx].present)
80008750:	ef 39 ff fb 	ld.ub	r9,r7[-5]
80008754:	4a 1a       	lddpc	r10,800087d8 <load_usage_indeces+0xb0>
80008756:	12 98       	mov	r8,r9
80008758:	a3 78       	lsl	r8,0x3
8000875a:	12 18       	sub	r8,r9
8000875c:	a1 78       	lsl	r8,0x1
8000875e:	f4 08 00 08 	add	r8,r10,r8
80008762:	2f 88       	sub	r8,-8
80008764:	11 88       	ld.ub	r8,r8[0x0]
80008766:	58 08       	cp.w	r8,0
80008768:	c2 30       	breq	800087ae <load_usage_indeces+0x86>
		{
			top_botn = i%2;
8000876a:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000876e:	f2 08 14 1f 	asr	r8,r9,0x1f
80008772:	bf 98       	lsr	r8,0x1f
80008774:	10 09       	add	r9,r8
80008776:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
8000877a:	f2 08 01 08 	sub	r8,r9,r8
8000877e:	ef 68 ff fa 	st.b	r7[-6],r8
			
			usageIdx[i] = usage_idx(&ledBrd[brdIdx].id[0], top_botn); //TODO: should change this nomenclature to upper/lower, we are talking about board sides here, not which board in the shelf, be consistent
80008782:	ee f6 ff fc 	ld.w	r6,r7[-4]
80008786:	ef 3a ff fa 	ld.ub	r10,r7[-6]
8000878a:	ef 39 ff fb 	ld.ub	r9,r7[-5]
8000878e:	12 98       	mov	r8,r9
80008790:	a3 78       	lsl	r8,0x3
80008792:	12 18       	sub	r8,r9
80008794:	a1 78       	lsl	r8,0x1
80008796:	49 19       	lddpc	r9,800087d8 <load_usage_indeces+0xb0>
80008798:	12 08       	add	r8,r9
8000879a:	2f f8       	sub	r8,-1
8000879c:	14 9b       	mov	r11,r10
8000879e:	10 9c       	mov	r12,r8
800087a0:	f0 1f 00 0f 	mcall	800087dc <load_usage_indeces+0xb4>
800087a4:	18 98       	mov	r8,r12
800087a6:	48 f9       	lddpc	r9,800087e0 <load_usage_indeces+0xb8>
800087a8:	f2 06 0b 08 	st.b	r9[r6],r8
800087ac:	c0 78       	rjmp	800087ba <load_usage_indeces+0x92>
		}
		else
		{
			usageIdx[i] = NO_LED_BOARD_PRESENT;
800087ae:	ee f9 ff fc 	ld.w	r9,r7[-4]
800087b2:	48 ca       	lddpc	r10,800087e0 <load_usage_indeces+0xb8>
800087b4:	3f f8       	mov	r8,-1
800087b6:	f4 09 0b 08 	st.b	r10[r9],r8

void load_usage_indeces(void)
{
	unsigned char top_botn, brdIdx;
	
	for (int i=0; i<NUM_LED_BOARD_SIDES; i++)
800087ba:	ee f8 ff fc 	ld.w	r8,r7[-4]
800087be:	2f f8       	sub	r8,-1
800087c0:	ef 48 ff fc 	st.w	r7[-4],r8
800087c4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800087c8:	58 78       	cp.w	r8,7
800087ca:	fe 9a ff b7 	brle	80008738 <load_usage_indeces+0x10>
		else
		{
			usageIdx[i] = NO_LED_BOARD_PRESENT;
		}
	}
}
800087ce:	2f ed       	sub	sp,-8
800087d0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800087d4:	00 00       	add	r0,r0
800087d6:	0b fe       	ld.ub	lr,r5[0x7]
800087d8:	00 00       	add	r0,r0
800087da:	0b 4a       	ld.w	r10,--r5
800087dc:	80 00       	ld.sh	r0,r0[0x0]
800087de:	85 d8       	st.w	r2[0x34],r8
800087e0:	00 00       	add	r0,r0
800087e2:	0b c0       	ld.ub	r0,r5[0x4]

800087e4 <test_flash>:
	return SUCCESS;
}

#else
unsigned char test_flash(unsigned char sel)
{
800087e4:	eb cd 40 80 	pushm	r7,lr
800087e8:	1a 97       	mov	r7,sp
800087ea:	20 8d       	sub	sp,32
800087ec:	18 98       	mov	r8,r12
800087ee:	ef 68 ff e0 	st.b	r7[-32],r8
	volatile void* memPtr;
	unsigned char pattern[4] = {0x00, 0xAA, 0x55, 0xFF}, ubyte; //NOTE test 0xFF pattern last to essentially erase the flash
800087f2:	4c 08       	lddpc	r8,800088f0 <test_flash+0x10c>
800087f4:	70 08       	ld.w	r8,r8[0x0]
800087f6:	ef 48 ff e4 	st.w	r7[-28],r8
	unsigned char *ubPtr;
	unsigned long memSize;
	
	switch(sel)
800087fa:	ef 38 ff e0 	ld.ub	r8,r7[-32]
800087fe:	58 18       	cp.w	r8,1
80008800:	c1 30       	breq	80008826 <test_flash+0x42>
80008802:	e0 89 00 05 	brgt	8000880c <test_flash+0x28>
80008806:	58 08       	cp.w	r8,0
80008808:	c0 70       	breq	80008816 <test_flash+0x32>
8000880a:	c2 58       	rjmp	80008854 <test_flash+0x70>
8000880c:	58 28       	cp.w	r8,2
8000880e:	c1 40       	breq	80008836 <test_flash+0x52>
80008810:	58 38       	cp.w	r8,3
80008812:	c1 a0       	breq	80008846 <test_flash+0x62>
80008814:	c2 08       	rjmp	80008854 <test_flash+0x70>
	{
		case 0:
			memPtr = &serialIdAndFlagsFlash;
80008816:	4b 88       	lddpc	r8,800088f4 <test_flash+0x110>
80008818:	ef 48 ff e8 	st.w	r7[-24],r8
			memSize = NUM_SERIAL_ID_BUFS_SECTORS * 128;
8000881c:	e0 68 06 00 	mov	r8,1536
80008820:	ef 48 ff f4 	st.w	r7[-12],r8
			break;
80008824:	c1 88       	rjmp	80008854 <test_flash+0x70>
		case 1:
			memPtr = &sanitationCyclesFlash;
80008826:	4b 58       	lddpc	r8,800088f8 <test_flash+0x114>
80008828:	ef 48 ff e8 	st.w	r7[-24],r8
			memSize = NUM_SAN_CYCLE_BUFS_SECTORS * 128;
8000882c:	e0 68 03 00 	mov	r8,768
80008830:	ef 48 ff f4 	st.w	r7[-12],r8
			break;
80008834:	c1 08       	rjmp	80008854 <test_flash+0x70>
		case 2:
			memPtr = &usageHoursFlash;
80008836:	4b 28       	lddpc	r8,800088fc <test_flash+0x118>
80008838:	ef 48 ff e8 	st.w	r7[-24],r8
			memSize = NUM_USAGE_HOURS_BUFS_SECTORS * 128;
8000883c:	e0 68 02 00 	mov	r8,512
80008840:	ef 48 ff f4 	st.w	r7[-12],r8
			break;
80008844:	c0 88       	rjmp	80008854 <test_flash+0x70>
		case 3:
			memPtr = &usageMinutesFlash;
80008846:	4a f8       	lddpc	r8,80008900 <test_flash+0x11c>
80008848:	ef 48 ff e8 	st.w	r7[-24],r8
			memSize = NUM_USAGE_MINS_BUFS_SECTORS * 128;
8000884c:	e0 68 3a 00 	mov	r8,14848
80008850:	ef 48 ff f4 	st.w	r7[-12],r8
			break;
	}

	for (unsigned char i=0; i<4; i++) //4 patterns to test
80008854:	30 08       	mov	r8,0
80008856:	ef 68 ff fb 	st.b	r7[-5],r8
8000885a:	c3 e8       	rjmp	800088d6 <test_flash+0xf2>
	{
		flashc_memset(memPtr, pattern[i], 8, memSize, true);
8000885c:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80008860:	ee 08 00 08 	add	r8,r7,r8
80008864:	f1 38 ff e4 	ld.ub	r8,r8[-28]
80008868:	30 19       	mov	r9,1
8000886a:	ee fa ff f4 	ld.w	r10,r7[-12]
8000886e:	10 9b       	mov	r11,r8
80008870:	ee fc ff e8 	ld.w	r12,r7[-24]
80008874:	f0 1f 00 24 	mcall	80008904 <test_flash+0x120>
		
		ubPtr = (unsigned char*) memPtr;
80008878:	ee f8 ff e8 	ld.w	r8,r7[-24]
8000887c:	ef 48 ff f0 	st.w	r7[-16],r8
		for (unsigned long j=0; j<memSize; j++)
80008880:	30 08       	mov	r8,0
80008882:	ef 48 ff fc 	st.w	r7[-4],r8
80008886:	c1 d8       	rjmp	800088c0 <test_flash+0xdc>
		{
			ubyte = (*ubPtr);
80008888:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000888c:	11 88       	ld.ub	r8,r8[0x0]
8000888e:	ef 68 ff ef 	st.b	r7[-17],r8
			if (ubyte != pattern[i])
80008892:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80008896:	ee 08 00 08 	add	r8,r7,r8
8000889a:	f1 38 ff e4 	ld.ub	r8,r8[-28]
8000889e:	ef 39 ff ef 	ld.ub	r9,r7[-17]
800088a2:	f0 09 18 00 	cp.b	r9,r8
800088a6:	c0 30       	breq	800088ac <test_flash+0xc8>
			{
				return ERROR;
800088a8:	30 18       	mov	r8,1
800088aa:	c1 e8       	rjmp	800088e6 <test_flash+0x102>
			}
			ubPtr++;
800088ac:	ee f8 ff f0 	ld.w	r8,r7[-16]
800088b0:	2f f8       	sub	r8,-1
800088b2:	ef 48 ff f0 	st.w	r7[-16],r8
	for (unsigned char i=0; i<4; i++) //4 patterns to test
	{
		flashc_memset(memPtr, pattern[i], 8, memSize, true);
		
		ubPtr = (unsigned char*) memPtr;
		for (unsigned long j=0; j<memSize; j++)
800088b6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800088ba:	2f f8       	sub	r8,-1
800088bc:	ef 48 ff fc 	st.w	r7[-4],r8
800088c0:	ee f9 ff fc 	ld.w	r9,r7[-4]
800088c4:	ee f8 ff f4 	ld.w	r8,r7[-12]
800088c8:	10 39       	cp.w	r9,r8
800088ca:	cd f3       	brcs	80008888 <test_flash+0xa4>
			memPtr = &usageMinutesFlash;
			memSize = NUM_USAGE_MINS_BUFS_SECTORS * 128;
			break;
	}

	for (unsigned char i=0; i<4; i++) //4 patterns to test
800088cc:	ef 38 ff fb 	ld.ub	r8,r7[-5]
800088d0:	2f f8       	sub	r8,-1
800088d2:	ef 68 ff fb 	st.b	r7[-5],r8
800088d6:	ef 39 ff fb 	ld.ub	r9,r7[-5]
800088da:	30 38       	mov	r8,3
800088dc:	f0 09 18 00 	cp.b	r9,r8
800088e0:	fe 98 ff be 	brls	8000885c <test_flash+0x78>
			}
			ubPtr++;
		}
	}
	
	return SUCCESS;
800088e4:	30 08       	mov	r8,0
}
800088e6:	10 9c       	mov	r12,r8
800088e8:	2f 8d       	sub	sp,-32
800088ea:	e3 cd 80 80 	ldm	sp++,r7,pc
800088ee:	00 00       	add	r0,r0
800088f0:	80 01       	ld.sh	r1,r0[0x0]
800088f2:	26 00       	sub	r0,96
800088f4:	80 07       	ld.sh	r7,r0[0x0]
800088f6:	fa 00       	*unknown*
800088f8:	80 07       	ld.sh	r7,r0[0x0]
800088fa:	f7 00 80 07 	ld.sh	r0,r11[-32761]
800088fe:	f5 00 80 07 	ld.sh	r0,r10[-32761]
80008902:	bb 00       	ld.d	r0,sp
80008904:	80 00       	ld.sh	r0,r0[0x0]
80008906:	3e 64       	mov	r4,-26

80008908 <calc_region_checksum>:

#ifndef SERIAL_ID_AND_ALL_USAGE_COMBINED

unsigned char calc_region_checksum(unsigned char sel);
unsigned char calc_region_checksum(unsigned char sel)
{
80008908:	eb cd 40 80 	pushm	r7,lr
8000890c:	1a 97       	mov	r7,sp
8000890e:	20 5d       	sub	sp,20
80008910:	18 98       	mov	r8,r12
80008912:	ef 68 ff ec 	st.b	r7[-20],r8
	unsigned char csum = 0;
80008916:	30 08       	mov	r8,0
80008918:	ef 68 ff f3 	st.b	r7[-13],r8

	switch(sel)
8000891c:	ef 38 ff ec 	ld.ub	r8,r7[-20]
80008920:	58 28       	cp.w	r8,2
80008922:	e0 80 00 ae 	breq	80008a7e <calc_region_checksum+0x176>
80008926:	e0 89 00 08 	brgt	80008936 <calc_region_checksum+0x2e>
8000892a:	58 08       	cp.w	r8,0
8000892c:	c0 c0       	breq	80008944 <calc_region_checksum+0x3c>
8000892e:	58 18       	cp.w	r8,1
80008930:	e0 80 00 9e 	breq	80008a6c <calc_region_checksum+0x164>
80008934:	c0 59       	rjmp	80008b3e <calc_region_checksum+0x236>
80008936:	58 38       	cp.w	r8,3
80008938:	e0 80 00 c7 	breq	80008ac6 <calc_region_checksum+0x1be>
8000893c:	58 48       	cp.w	r8,4
8000893e:	e0 80 00 f0 	breq	80008b1e <calc_region_checksum+0x216>
80008942:	cf e8       	rjmp	80008b3e <calc_region_checksum+0x236>
	{
		case 0: //serial ID and flags
			csum = 0;
80008944:	30 08       	mov	r8,0
80008946:	ef 68 ff f3 	st.b	r7[-13],r8
			for (int i=0; i<(NUM_SETS_LED_BOARD_SIDES * NUM_LED_BOARD_SIDES); i++)
8000894a:	30 08       	mov	r8,0
8000894c:	ef 48 ff f4 	st.w	r7[-12],r8
80008950:	c8 28       	rjmp	80008a54 <calc_region_checksum+0x14c>
			{
				csum += sf[i].id[0];
80008952:	ee f9 ff f4 	ld.w	r9,r7[-12]
80008956:	4f e8       	lddpc	r8,80008b4c <calc_region_checksum+0x244>
80008958:	f0 09 07 38 	ld.ub	r8,r8[r9<<0x3]
8000895c:	ef 39 ff f3 	ld.ub	r9,r7[-13]
80008960:	f2 08 00 08 	add	r8,r9,r8
80008964:	ef 68 ff f3 	st.b	r7[-13],r8
				csum += sf[i].id[1];
80008968:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000896c:	4f 89       	lddpc	r9,80008b4c <calc_region_checksum+0x244>
8000896e:	a3 78       	lsl	r8,0x3
80008970:	f2 08 00 08 	add	r8,r9,r8
80008974:	11 98       	ld.ub	r8,r8[0x1]
80008976:	ef 39 ff f3 	ld.ub	r9,r7[-13]
8000897a:	f2 08 00 08 	add	r8,r9,r8
8000897e:	ef 68 ff f3 	st.b	r7[-13],r8
				csum += sf[i].id[2];
80008982:	ee f9 ff f4 	ld.w	r9,r7[-12]
80008986:	4f 28       	lddpc	r8,80008b4c <calc_region_checksum+0x244>
80008988:	a3 69       	lsl	r9,0x2
8000898a:	2f f9       	sub	r9,-1
8000898c:	f0 09 07 18 	ld.ub	r8,r8[r9<<0x1]
80008990:	ef 39 ff f3 	ld.ub	r9,r7[-13]
80008994:	f2 08 00 08 	add	r8,r9,r8
80008998:	ef 68 ff f3 	st.b	r7[-13],r8
				csum += sf[i].id[3];
8000899c:	ee f8 ff f4 	ld.w	r8,r7[-12]
800089a0:	4e b9       	lddpc	r9,80008b4c <calc_region_checksum+0x244>
800089a2:	a3 78       	lsl	r8,0x3
800089a4:	f2 08 00 08 	add	r8,r9,r8
800089a8:	11 b8       	ld.ub	r8,r8[0x3]
800089aa:	ef 39 ff f3 	ld.ub	r9,r7[-13]
800089ae:	f2 08 00 08 	add	r8,r9,r8
800089b2:	ef 68 ff f3 	st.b	r7[-13],r8
				csum += sf[i].id[4];
800089b6:	ee f9 ff f4 	ld.w	r9,r7[-12]
800089ba:	4e 58       	lddpc	r8,80008b4c <calc_region_checksum+0x244>
800089bc:	a1 79       	lsl	r9,0x1
800089be:	2f f9       	sub	r9,-1
800089c0:	f0 09 07 28 	ld.ub	r8,r8[r9<<0x2]
800089c4:	ef 39 ff f3 	ld.ub	r9,r7[-13]
800089c8:	f2 08 00 08 	add	r8,r9,r8
800089cc:	ef 68 ff f3 	st.b	r7[-13],r8
				csum += sf[i].id[5];
800089d0:	ee f8 ff f4 	ld.w	r8,r7[-12]
800089d4:	4d e9       	lddpc	r9,80008b4c <calc_region_checksum+0x244>
800089d6:	a3 78       	lsl	r8,0x3
800089d8:	f2 08 00 08 	add	r8,r9,r8
800089dc:	11 d8       	ld.ub	r8,r8[0x5]
800089de:	ef 39 ff f3 	ld.ub	r9,r7[-13]
800089e2:	f2 08 00 08 	add	r8,r9,r8
800089e6:	ef 68 ff f3 	st.b	r7[-13],r8
				csum += sf[i].maxUsageReached;
800089ea:	ee f9 ff f4 	ld.w	r9,r7[-12]
800089ee:	4d 88       	lddpc	r8,80008b4c <calc_region_checksum+0x244>
800089f0:	a1 79       	lsl	r9,0x1
800089f2:	2f f9       	sub	r9,-1
800089f4:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
800089f8:	f1 d8 c1 c1 	bfextu	r8,r8,0xe,0x1
800089fc:	5c 58       	castu.b	r8
800089fe:	ef 39 ff f3 	ld.ub	r9,r7[-13]
80008a02:	f2 08 00 08 	add	r8,r9,r8
80008a06:	ef 68 ff f3 	st.b	r7[-13],r8
				csum += sf[i].slotFilled;
80008a0a:	ee f9 ff f4 	ld.w	r9,r7[-12]
80008a0e:	4d 08       	lddpc	r8,80008b4c <calc_region_checksum+0x244>
80008a10:	a1 79       	lsl	r9,0x1
80008a12:	2f f9       	sub	r9,-1
80008a14:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80008a18:	f1 d8 c1 a1 	bfextu	r8,r8,0xd,0x1
80008a1c:	5c 58       	castu.b	r8
80008a1e:	ef 39 ff f3 	ld.ub	r9,r7[-13]
80008a22:	f2 08 00 08 	add	r8,r9,r8
80008a26:	ef 68 ff f3 	st.b	r7[-13],r8
				csum += sf[i].top_botn;
80008a2a:	ee f9 ff f4 	ld.w	r9,r7[-12]
80008a2e:	4c 88       	lddpc	r8,80008b4c <calc_region_checksum+0x244>
80008a30:	a1 79       	lsl	r9,0x1
80008a32:	2f f9       	sub	r9,-1
80008a34:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80008a38:	f1 d8 c1 e1 	bfextu	r8,r8,0xf,0x1
80008a3c:	5c 58       	castu.b	r8
80008a3e:	ef 39 ff f3 	ld.ub	r9,r7[-13]
80008a42:	f2 08 00 08 	add	r8,r9,r8
80008a46:	ef 68 ff f3 	st.b	r7[-13],r8

	switch(sel)
	{
		case 0: //serial ID and flags
			csum = 0;
			for (int i=0; i<(NUM_SETS_LED_BOARD_SIDES * NUM_LED_BOARD_SIDES); i++)
80008a4a:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008a4e:	2f f8       	sub	r8,-1
80008a50:	ef 48 ff f4 	st.w	r7[-12],r8
80008a54:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008a58:	e0 48 00 5f 	cp.w	r8,95
80008a5c:	fe 9a ff 7b 	brle	80008952 <calc_region_checksum+0x4a>
				csum += sf[i].id[5];
				csum += sf[i].maxUsageReached;
				csum += sf[i].slotFilled;
				csum += sf[i].top_botn;
			}
			csum = ((csum ^ 0xFF) & 0xFF);
80008a60:	ef 38 ff f3 	ld.ub	r8,r7[-13]
80008a64:	5c d8       	com	r8
80008a66:	ef 68 ff f3 	st.b	r7[-13],r8
			break;
80008a6a:	c6 a8       	rjmp	80008b3e <calc_region_checksum+0x236>

		case 1: //san cycles
			csum = ((sanc.cycles ^ 0xFF) & 0xFF);
80008a6c:	4b 98       	lddpc	r8,80008b50 <calc_region_checksum+0x248>
80008a6e:	70 08       	ld.w	r8,r8[0x0]
80008a70:	f1 d8 c1 94 	bfextu	r8,r8,0xc,0x14
80008a74:	5c 58       	castu.b	r8
80008a76:	5c d8       	com	r8
80008a78:	ef 68 ff f3 	st.b	r7[-13],r8
			break;
80008a7c:	c6 18       	rjmp	80008b3e <calc_region_checksum+0x236>

		case 2: //usage hours
			csum = 0;
80008a7e:	30 08       	mov	r8,0
80008a80:	ef 68 ff f3 	st.b	r7[-13],r8
			for (int i=0; i<(NUM_SETS_LED_BOARD_SIDES * NUM_LED_BOARD_SIDES); i++)
80008a84:	30 08       	mov	r8,0
80008a86:	ef 48 ff f8 	st.w	r7[-8],r8
80008a8a:	c1 28       	rjmp	80008aae <calc_region_checksum+0x1a6>
			{
				csum += h.hrs[i];
80008a8c:	ee f9 ff f8 	ld.w	r9,r7[-8]
80008a90:	4b 18       	lddpc	r8,80008b54 <calc_region_checksum+0x24c>
80008a92:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
80008a96:	5c 58       	castu.b	r8
80008a98:	ef 39 ff f3 	ld.ub	r9,r7[-13]
80008a9c:	f2 08 00 08 	add	r8,r9,r8
80008aa0:	ef 68 ff f3 	st.b	r7[-13],r8
			csum = ((sanc.cycles ^ 0xFF) & 0xFF);
			break;

		case 2: //usage hours
			csum = 0;
			for (int i=0; i<(NUM_SETS_LED_BOARD_SIDES * NUM_LED_BOARD_SIDES); i++)
80008aa4:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008aa8:	2f f8       	sub	r8,-1
80008aaa:	ef 48 ff f8 	st.w	r7[-8],r8
80008aae:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008ab2:	e0 48 00 5f 	cp.w	r8,95
80008ab6:	fe 9a ff eb 	brle	80008a8c <calc_region_checksum+0x184>
			{
				csum += h.hrs[i];
			}
			csum = ((csum ^ 0xFF) & 0xFF);
80008aba:	ef 38 ff f3 	ld.ub	r8,r7[-13]
80008abe:	5c d8       	com	r8
80008ac0:	ef 68 ff f3 	st.b	r7[-13],r8
			break;
80008ac4:	c3 d8       	rjmp	80008b3e <calc_region_checksum+0x236>

		case 3: //usage mins
			csum = 0;
80008ac6:	30 08       	mov	r8,0
80008ac8:	ef 68 ff f3 	st.b	r7[-13],r8
			for (int i=0; i<(NUM_SETS_LED_BOARD_SIDES * NUM_LED_BOARD_SIDES); i++)
80008acc:	30 08       	mov	r8,0
80008ace:	ef 48 ff fc 	st.w	r7[-4],r8
80008ad2:	c1 18       	rjmp	80008af4 <calc_region_checksum+0x1ec>
			{
				csum += m.mins[i];
80008ad4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008ad8:	4a 09       	lddpc	r9,80008b58 <calc_region_checksum+0x250>
80008ada:	f2 08 07 08 	ld.ub	r8,r9[r8]
80008ade:	ef 39 ff f3 	ld.ub	r9,r7[-13]
80008ae2:	f2 08 00 08 	add	r8,r9,r8
80008ae6:	ef 68 ff f3 	st.b	r7[-13],r8
			csum = ((csum ^ 0xFF) & 0xFF);
			break;

		case 3: //usage mins
			csum = 0;
			for (int i=0; i<(NUM_SETS_LED_BOARD_SIDES * NUM_LED_BOARD_SIDES); i++)
80008aea:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008aee:	2f f8       	sub	r8,-1
80008af0:	ef 48 ff fc 	st.w	r7[-4],r8
80008af4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008af8:	e0 48 00 5f 	cp.w	r8,95
80008afc:	fe 9a ff ec 	brle	80008ad4 <calc_region_checksum+0x1cc>
			{
				csum += m.mins[i];
			}
			csum += m.sanMins;
80008b00:	49 68       	lddpc	r8,80008b58 <calc_region_checksum+0x250>
80008b02:	71 88       	ld.w	r8,r8[0x60]
80008b04:	5c 58       	castu.b	r8
80008b06:	ef 39 ff f3 	ld.ub	r9,r7[-13]
80008b0a:	f2 08 00 08 	add	r8,r9,r8
80008b0e:	ef 68 ff f3 	st.b	r7[-13],r8
			csum = ((csum ^ 0xFF) & 0xFF);
80008b12:	ef 38 ff f3 	ld.ub	r8,r7[-13]
80008b16:	5c d8       	com	r8
80008b18:	ef 68 ff f3 	st.b	r7[-13],r8
			break;
80008b1c:	c1 18       	rjmp	80008b3e <calc_region_checksum+0x236>
		case 4: //configuration
			csum = 0;
80008b1e:	30 08       	mov	r8,0
80008b20:	ef 68 ff f3 	st.b	r7[-13],r8
			csum += c.initialDTE;
80008b24:	48 e8       	lddpc	r8,80008b5c <calc_region_checksum+0x254>
80008b26:	11 88       	ld.ub	r8,r8[0x0]
80008b28:	ef 39 ff f3 	ld.ub	r9,r7[-13]
80008b2c:	f2 08 00 08 	add	r8,r9,r8
80008b30:	ef 68 ff f3 	st.b	r7[-13],r8
			csum = ((csum ^ 0xFF) & 0xFF);
80008b34:	ef 38 ff f3 	ld.ub	r8,r7[-13]
80008b38:	5c d8       	com	r8
80008b3a:	ef 68 ff f3 	st.b	r7[-13],r8
			break;
	}
	
	return csum;	
80008b3e:	ef 38 ff f3 	ld.ub	r8,r7[-13]
}
80008b42:	10 9c       	mov	r12,r8
80008b44:	2f bd       	sub	sp,-20
80008b46:	e3 cd 80 80 	ldm	sp++,r7,pc
80008b4a:	00 00       	add	r0,r0
80008b4c:	00 00       	add	r0,r0
80008b4e:	08 48       	or	r8,r4
80008b50:	00 00       	add	r0,r0
80008b52:	0c 28       	rsub	r8,r6
80008b54:	00 00       	add	r0,r0
80008b56:	0c 2c       	rsub	r12,r6
80008b58:	00 00       	add	r0,r0
80008b5a:	0d 08       	ld.w	r8,r6++
80008b5c:	00 00       	add	r0,r0
80008b5e:	0b fc       	ld.ub	r12,r5[0x7]

80008b60 <eval_region>:

unsigned char eval_region(unsigned char sel);
unsigned char eval_region(unsigned char sel)
{
80008b60:	eb cd 40 80 	pushm	r7,lr
80008b64:	1a 97       	mov	r7,sp
80008b66:	fa cd 04 80 	sub	sp,sp,1152
80008b6a:	18 98       	mov	r8,r12
80008b6c:	ef 68 fb 80 	st.b	r7[-1152],r8
	CONFIGURATION					tmpC;
	
	unsigned char					csum;
	long							flashOffset;
	long							tmpFlashOffset;
	unsigned char					retVal = 0; //NOT GOOD
80008b70:	30 08       	mov	r8,0
80008b72:	ef 68 ff c7 	st.b	r7[-57],r8
	

	unsigned long tmpHours, uHours, tmpMinutes, uMinutes, tmpSlotsFilled, uSlotsFilled;
	
	print_ecdbg("eval_region() ");
80008b76:	fe fc 06 06 	ld.w	r12,pc[1542]
80008b7a:	f0 1f 01 82 	mcall	80009180 <eval_region+0x620>
	
	switch (sel)
80008b7e:	ef 38 fb 80 	ld.ub	r8,r7[-1152]
80008b82:	58 28       	cp.w	r8,2
80008b84:	e0 80 01 47 	breq	80008e12 <eval_region+0x2b2>
80008b88:	e0 89 00 09 	brgt	80008b9a <eval_region+0x3a>
80008b8c:	58 08       	cp.w	r8,0
80008b8e:	c0 e0       	breq	80008baa <eval_region+0x4a>
80008b90:	58 18       	cp.w	r8,1
80008b92:	e0 80 00 c1 	breq	80008d14 <eval_region+0x1b4>
80008b96:	e0 8f 02 ec 	bral	8000916e <eval_region+0x60e>
80008b9a:	58 38       	cp.w	r8,3
80008b9c:	e0 80 01 e5 	breq	80008f66 <eval_region+0x406>
80008ba0:	58 48       	cp.w	r8,4
80008ba2:	e0 80 02 7d 	breq	8000909c <eval_region+0x53c>
80008ba6:	e0 8f 02 e4 	bral	8000916e <eval_region+0x60e>
	{
		case 0: //serial ID and flags
			
			print_ecdbg("region 0 - serial ID and flags\r\n");
80008baa:	fe fc 05 da 	ld.w	r12,pc[1498]
80008bae:	f0 1f 01 75 	mcall	80009180 <eval_region+0x620>
			
			memset(&tmpSf, 0x00, sizeof(sf));
80008bb2:	ee c8 03 48 	sub	r8,r7,840
80008bb6:	e0 6a 03 00 	mov	r10,768
80008bba:	30 0b       	mov	r11,0
80008bbc:	10 9c       	mov	r12,r8
80008bbe:	f0 1f 01 73 	mcall	80009188 <eval_region+0x628>
			
			for (unsigned int i=0; i<(NUM_SERIAL_ID_BUFS_SECTORS / NUM_SERIAL_ID_SECTORS_PER_BUF); i++)
80008bc2:	30 08       	mov	r8,0
80008bc4:	ef 48 ff e0 	st.w	r7[-32],r8
80008bc8:	c8 f8       	rjmp	80008ce6 <eval_region+0x186>
			{
				flashOffset =  (i* 128 * NUM_SERIAL_ID_SECTORS_PER_BUF);
80008bca:	ee f9 ff e0 	ld.w	r9,r7[-32]
80008bce:	12 98       	mov	r8,r9
80008bd0:	a1 78       	lsl	r8,0x1
80008bd2:	12 08       	add	r8,r9
80008bd4:	a9 68       	lsl	r8,0x8
80008bd6:	ef 48 ff bc 	st.w	r7[-68],r8
				tmpFlashOffset = flashOffset + (unsigned long)serialIdAndFlagsFlash;
80008bda:	ee f9 ff bc 	ld.w	r9,r7[-68]
80008bde:	fe f8 05 ae 	ld.w	r8,pc[1454]
80008be2:	f2 08 00 08 	add	r8,r9,r8
80008be6:	ef 48 ff c0 	st.w	r7[-64],r8
				memcpy(&sf, (const void*) tmpFlashOffset, sizeof(sf));
80008bea:	ee f8 ff c0 	ld.w	r8,r7[-64]
80008bee:	e0 6a 03 00 	mov	r10,768
80008bf2:	10 9b       	mov	r11,r8
80008bf4:	fe fc 05 9c 	ld.w	r12,pc[1436]
80008bf8:	f0 1f 01 67 	mcall	80009194 <eval_region+0x634>
				
				csum = calc_region_checksum(0);
80008bfc:	30 0c       	mov	r12,0
80008bfe:	f0 1f 01 67 	mcall	80009198 <eval_region+0x638>
80008c02:	18 98       	mov	r8,r12
80008c04:	ef 68 ff bb 	st.b	r7[-69],r8

				if (csum == sf[0].csum) //checksum is good
80008c08:	fe f8 05 88 	ld.w	r8,pc[1416]
80008c0c:	11 f8       	ld.ub	r8,r8[0x7]
80008c0e:	ef 39 ff bb 	ld.ub	r9,r7[-69]
80008c12:	f0 09 18 00 	cp.b	r9,r8
80008c16:	c6 31       	brne	80008cdc <eval_region+0x17c>
				{
					print_ecdbg("good csum\r\n");
80008c18:	fe fc 05 84 	ld.w	r12,pc[1412]
80008c1c:	f0 1f 01 59 	mcall	80009180 <eval_region+0x620>
					
					retVal = 1; //we have at least one good copy
80008c20:	30 18       	mov	r8,1
80008c22:	ef 68 ff c7 	st.b	r7[-57],r8

					tmpSlotsFilled = 0;
80008c26:	30 08       	mov	r8,0
80008c28:	ef 48 ff d8 	st.w	r7[-40],r8
					uSlotsFilled = 0;
80008c2c:	30 08       	mov	r8,0
80008c2e:	ef 48 ff dc 	st.w	r7[-36],r8
				
					for (int j=0; j<(NUM_SETS_LED_BOARD_SIDES * NUM_LED_BOARD_SIDES); j++)
80008c32:	30 08       	mov	r8,0
80008c34:	ef 48 ff e4 	st.w	r7[-28],r8
80008c38:	c2 98       	rjmp	80008c8a <eval_region+0x12a>
					{
						tmpSlotsFilled += tmpSf[j].slotFilled;
80008c3a:	ee f8 ff e4 	ld.w	r8,r7[-28]
80008c3e:	a1 78       	lsl	r8,0x1
80008c40:	2f f8       	sub	r8,-1
80008c42:	a3 68       	lsl	r8,0x2
80008c44:	ee 08 00 08 	add	r8,r7,r8
80008c48:	f0 f8 fc b8 	ld.w	r8,r8[-840]
80008c4c:	f1 d8 c1 a1 	bfextu	r8,r8,0xd,0x1
80008c50:	5c 58       	castu.b	r8
80008c52:	ee f9 ff d8 	ld.w	r9,r7[-40]
80008c56:	f2 08 00 08 	add	r8,r9,r8
80008c5a:	ef 48 ff d8 	st.w	r7[-40],r8
						uSlotsFilled += sf[j].slotFilled;
80008c5e:	ee f9 ff e4 	ld.w	r9,r7[-28]
80008c62:	fe f8 05 2e 	ld.w	r8,pc[1326]
80008c66:	a1 79       	lsl	r9,0x1
80008c68:	2f f9       	sub	r9,-1
80008c6a:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80008c6e:	f1 d8 c1 a1 	bfextu	r8,r8,0xd,0x1
80008c72:	5c 58       	castu.b	r8
80008c74:	ee f9 ff dc 	ld.w	r9,r7[-36]
80008c78:	f2 08 00 08 	add	r8,r9,r8
80008c7c:	ef 48 ff dc 	st.w	r7[-36],r8
					retVal = 1; //we have at least one good copy

					tmpSlotsFilled = 0;
					uSlotsFilled = 0;
				
					for (int j=0; j<(NUM_SETS_LED_BOARD_SIDES * NUM_LED_BOARD_SIDES); j++)
80008c80:	ee f8 ff e4 	ld.w	r8,r7[-28]
80008c84:	2f f8       	sub	r8,-1
80008c86:	ef 48 ff e4 	st.w	r7[-28],r8
80008c8a:	ee f8 ff e4 	ld.w	r8,r7[-28]
80008c8e:	e0 48 00 5f 	cp.w	r8,95
80008c92:	fe 9a ff d4 	brle	80008c3a <eval_region+0xda>
					{
						tmpSlotsFilled += tmpSf[j].slotFilled;
						uSlotsFilled += sf[j].slotFilled;
					}
				
					if (uSlotsFilled > tmpSlotsFilled)
80008c96:	ee f9 ff dc 	ld.w	r9,r7[-36]
80008c9a:	ee f8 ff d8 	ld.w	r8,r7[-40]
80008c9e:	10 39       	cp.w	r9,r8
80008ca0:	e0 88 00 1e 	brls	80008cdc <eval_region+0x17c>
					{
						memcpy(&tmpSf, &sf, sizeof(sf));
80008ca4:	ee c8 03 48 	sub	r8,r7,840
80008ca8:	e0 6a 03 00 	mov	r10,768
80008cac:	fe fb 04 e4 	ld.w	r11,pc[1252]
80008cb0:	10 9c       	mov	r12,r8
80008cb2:	f0 1f 01 39 	mcall	80009194 <eval_region+0x634>
						sfFlashIdx = i; //this is the new best copy
80008cb6:	fe f8 04 ea 	ld.w	r8,pc[1258]
80008cba:	ee f9 ff e0 	ld.w	r9,r7[-32]
80008cbe:	91 09       	st.w	r8[0x0],r9
						
						print_ecdbg("sfFlashIdx ");
80008cc0:	fe fc 04 e4 	ld.w	r12,pc[1252]
80008cc4:	f0 1f 01 2f 	mcall	80009180 <eval_region+0x620>
						print_ecdbg_num(sfFlashIdx);
80008cc8:	fe f8 04 d8 	ld.w	r8,pc[1240]
80008ccc:	70 08       	ld.w	r8,r8[0x0]
80008cce:	10 9c       	mov	r12,r8
80008cd0:	f0 1f 01 36 	mcall	800091a8 <eval_region+0x648>
						print_ecdbg("\r\n");
80008cd4:	fe fc 04 d8 	ld.w	r12,pc[1240]
80008cd8:	f0 1f 01 2a 	mcall	80009180 <eval_region+0x620>
			
			print_ecdbg("region 0 - serial ID and flags\r\n");
			
			memset(&tmpSf, 0x00, sizeof(sf));
			
			for (unsigned int i=0; i<(NUM_SERIAL_ID_BUFS_SECTORS / NUM_SERIAL_ID_SECTORS_PER_BUF); i++)
80008cdc:	ee f8 ff e0 	ld.w	r8,r7[-32]
80008ce0:	2f f8       	sub	r8,-1
80008ce2:	ef 48 ff e0 	st.w	r7[-32],r8
80008ce6:	ee f8 ff e0 	ld.w	r8,r7[-32]
80008cea:	58 18       	cp.w	r8,1
80008cec:	fe 98 ff 6f 	brls	80008bca <eval_region+0x6a>
					}

				}
			}
			
			if (retVal == 1)
80008cf0:	ef 39 ff c7 	ld.ub	r9,r7[-57]
80008cf4:	30 18       	mov	r8,1
80008cf6:	f0 09 18 00 	cp.b	r9,r8
80008cfa:	e0 81 02 33 	brne	80009160 <eval_region+0x600>
			{
				memcpy(&sf, &tmpSf, sizeof(sf));
80008cfe:	ee c8 03 48 	sub	r8,r7,840
80008d02:	e0 6a 03 00 	mov	r10,768
80008d06:	10 9b       	mov	r11,r8
80008d08:	fe fc 04 88 	ld.w	r12,pc[1160]
80008d0c:	f0 1f 01 22 	mcall	80009194 <eval_region+0x634>
			}
			break;
80008d10:	e0 8f 02 2f 	bral	8000916e <eval_region+0x60e>

		case 1: //san cycles
			memset(&tmpSanc, 0x00, sizeof(sanc));
80008d14:	ee c8 03 4c 	sub	r8,r7,844
80008d18:	30 4a       	mov	r10,4
80008d1a:	30 0b       	mov	r11,0
80008d1c:	10 9c       	mov	r12,r8
80008d1e:	f0 1f 01 1b 	mcall	80009188 <eval_region+0x628>

			print_ecdbg("region 1 - sanitation cycles\r\n");
80008d22:	fe fc 04 8e 	ld.w	r12,pc[1166]
80008d26:	f0 1f 01 17 	mcall	80009180 <eval_region+0x620>

			for (unsigned int i=0; i<(NUM_SAN_CYCLE_BUFS_PER_SECTOR * NUM_SAN_CYCLE_BUFS_SECTORS); i++)
80008d2a:	30 08       	mov	r8,0
80008d2c:	ef 48 ff e8 	st.w	r7[-24],r8
80008d30:	c5 b8       	rjmp	80008de6 <eval_region+0x286>
			{
				flashOffset = (i * 128 * NUM_SAN_CYCLE_BUFS_PER_SECTOR);
80008d32:	ee f8 ff e8 	ld.w	r8,r7[-24]
80008d36:	a7 78       	lsl	r8,0x7
80008d38:	ef 48 ff bc 	st.w	r7[-68],r8
				
				tmpFlashOffset = flashOffset + (unsigned long) sanitationCyclesFlash;
80008d3c:	ee f9 ff bc 	ld.w	r9,r7[-68]
80008d40:	fe f8 04 74 	ld.w	r8,pc[1140]
80008d44:	f2 08 00 08 	add	r8,r9,r8
80008d48:	ef 48 ff c0 	st.w	r7[-64],r8
				memcpy(&sanc, (const void*) tmpFlashOffset, sizeof(sanc));
80008d4c:	ee f8 ff c0 	ld.w	r8,r7[-64]
80008d50:	30 4a       	mov	r10,4
80008d52:	10 9b       	mov	r11,r8
80008d54:	fe fc 04 64 	ld.w	r12,pc[1124]
80008d58:	f0 1f 01 0f 	mcall	80009194 <eval_region+0x634>
				
				csum = calc_region_checksum(1);
80008d5c:	30 1c       	mov	r12,1
80008d5e:	f0 1f 01 0f 	mcall	80009198 <eval_region+0x638>
80008d62:	18 98       	mov	r8,r12
80008d64:	ef 68 ff bb 	st.b	r7[-69],r8
				
				if (csum == sanc.csum) //checksum is good
80008d68:	fe f8 04 50 	ld.w	r8,pc[1104]
80008d6c:	70 08       	ld.w	r8,r8[0x0]
80008d6e:	f1 d8 c0 88 	bfextu	r8,r8,0x4,0x8
80008d72:	5c 58       	castu.b	r8
80008d74:	ef 39 ff bb 	ld.ub	r9,r7[-69]
80008d78:	f0 09 18 00 	cp.b	r9,r8
80008d7c:	c3 01       	brne	80008ddc <eval_region+0x27c>
				{
					print_ecdbg("good csum\r\n");
80008d7e:	fe fc 04 1e 	ld.w	r12,pc[1054]
80008d82:	f0 1f 01 00 	mcall	80009180 <eval_region+0x620>

					retVal = 1; //we have at least one good copy
80008d86:	30 18       	mov	r8,1
80008d88:	ef 68 ff c7 	st.b	r7[-57],r8
					
					if (sanc.cycles > tmpSanc.cycles)
80008d8c:	fe f8 04 2c 	ld.w	r8,pc[1068]
80008d90:	70 08       	ld.w	r8,r8[0x0]
80008d92:	f1 d8 c1 94 	bfextu	r8,r8,0xc,0x14
80008d96:	10 99       	mov	r9,r8
80008d98:	ee f8 fc b4 	ld.w	r8,r7[-844]
80008d9c:	f1 d8 c1 94 	bfextu	r8,r8,0xc,0x14
80008da0:	10 39       	cp.w	r9,r8
80008da2:	e0 8a 00 1d 	brle	80008ddc <eval_region+0x27c>
					{
						memcpy(&tmpSanc, &sanc, sizeof(sanc));
80008da6:	ee c8 03 4c 	sub	r8,r7,844
80008daa:	30 4a       	mov	r10,4
80008dac:	fe fb 04 0c 	ld.w	r11,pc[1036]
80008db0:	10 9c       	mov	r12,r8
80008db2:	f0 1f 00 f9 	mcall	80009194 <eval_region+0x634>
						sanCycleFlashIdx = i; //this is the new best copy
80008db6:	fe f8 04 06 	ld.w	r8,pc[1030]
80008dba:	ee f9 ff e8 	ld.w	r9,r7[-24]
80008dbe:	91 09       	st.w	r8[0x0],r9

						print_ecdbg("sanCycleFlashIdx ");
80008dc0:	fe fc 04 00 	ld.w	r12,pc[1024]
80008dc4:	f0 1f 00 ef 	mcall	80009180 <eval_region+0x620>
						print_ecdbg_num(sanCycleFlashIdx);
80008dc8:	fe f8 03 f4 	ld.w	r8,pc[1012]
80008dcc:	70 08       	ld.w	r8,r8[0x0]
80008dce:	10 9c       	mov	r12,r8
80008dd0:	f0 1f 00 f6 	mcall	800091a8 <eval_region+0x648>
						print_ecdbg("\r\n");
80008dd4:	fe fc 03 d8 	ld.w	r12,pc[984]
80008dd8:	f0 1f 00 ea 	mcall	80009180 <eval_region+0x620>
		case 1: //san cycles
			memset(&tmpSanc, 0x00, sizeof(sanc));

			print_ecdbg("region 1 - sanitation cycles\r\n");

			for (unsigned int i=0; i<(NUM_SAN_CYCLE_BUFS_PER_SECTOR * NUM_SAN_CYCLE_BUFS_SECTORS); i++)
80008ddc:	ee f8 ff e8 	ld.w	r8,r7[-24]
80008de0:	2f f8       	sub	r8,-1
80008de2:	ef 48 ff e8 	st.w	r7[-24],r8
80008de6:	ee f8 ff e8 	ld.w	r8,r7[-24]
80008dea:	58 58       	cp.w	r8,5
80008dec:	fe 98 ff a3 	brls	80008d32 <eval_region+0x1d2>
						print_ecdbg_num(sanCycleFlashIdx);
						print_ecdbg("\r\n");
					}
				}
			}
			if (retVal == 1)
80008df0:	ef 39 ff c7 	ld.ub	r9,r7[-57]
80008df4:	30 18       	mov	r8,1
80008df6:	f0 09 18 00 	cp.b	r9,r8
80008dfa:	e0 81 01 b5 	brne	80009164 <eval_region+0x604>
			{
				memcpy(&sanc, &tmpSanc, sizeof(sanc));
80008dfe:	ee c8 03 4c 	sub	r8,r7,844
80008e02:	30 4a       	mov	r10,4
80008e04:	10 9b       	mov	r11,r8
80008e06:	fe fc 03 b2 	ld.w	r12,pc[946]
80008e0a:	f0 1f 00 e3 	mcall	80009194 <eval_region+0x634>
			}
			break;
80008e0e:	e0 8f 01 b0 	bral	8000916e <eval_region+0x60e>
			
		case 2: //usage hours
			memset(&tmpH, 0x00, sizeof(h));
80008e12:	ee c8 04 0e 	sub	r8,r7,1038
80008e16:	e0 6a 00 c2 	mov	r10,194
80008e1a:	30 0b       	mov	r11,0
80008e1c:	10 9c       	mov	r12,r8
80008e1e:	f0 1f 00 db 	mcall	80009188 <eval_region+0x628>

			print_ecdbg("region 2 - usage hours\r\n");
80008e22:	fe fc 03 a2 	ld.w	r12,pc[930]
80008e26:	f0 1f 00 d7 	mcall	80009180 <eval_region+0x620>

			for (unsigned int i=0; i<(NUM_USAGE_HOURS_BUFS_SECTORS / NUM_USAGE_HOURS_SECTORS_PER_BUF); i++)
80008e2a:	30 08       	mov	r8,0
80008e2c:	ef 48 ff ec 	st.w	r7[-20],r8
80008e30:	c8 58       	rjmp	80008f3a <eval_region+0x3da>
			{
				flashOffset = (i * 128 * NUM_USAGE_HOURS_SECTORS_PER_BUF);
80008e32:	ee f8 ff ec 	ld.w	r8,r7[-20]
80008e36:	a9 68       	lsl	r8,0x8
80008e38:	ef 48 ff bc 	st.w	r7[-68],r8
				
				tmpFlashOffset = flashOffset + (unsigned long) usageHoursFlash;
80008e3c:	ee f9 ff bc 	ld.w	r9,r7[-68]
80008e40:	fe f8 03 88 	ld.w	r8,pc[904]
80008e44:	f2 08 00 08 	add	r8,r9,r8
80008e48:	ef 48 ff c0 	st.w	r7[-64],r8
				
				memcpy(&h, (const void*) tmpFlashOffset, sizeof(h));
80008e4c:	ee f8 ff c0 	ld.w	r8,r7[-64]
80008e50:	e0 6a 00 c2 	mov	r10,194
80008e54:	10 9b       	mov	r11,r8
80008e56:	fe fc 03 76 	ld.w	r12,pc[886]
80008e5a:	f0 1f 00 cf 	mcall	80009194 <eval_region+0x634>
				
				csum = calc_region_checksum(2);
80008e5e:	30 2c       	mov	r12,2
80008e60:	f0 1f 00 ce 	mcall	80009198 <eval_region+0x638>
80008e64:	18 98       	mov	r8,r12
80008e66:	ef 68 ff bb 	st.b	r7[-69],r8
				
				if (csum == h.csum) //checksum is good
80008e6a:	fe f8 03 62 	ld.w	r8,pc[866]
80008e6e:	f1 38 00 c0 	ld.ub	r8,r8[192]
80008e72:	ef 39 ff bb 	ld.ub	r9,r7[-69]
80008e76:	f0 09 18 00 	cp.b	r9,r8
80008e7a:	c5 b1       	brne	80008f30 <eval_region+0x3d0>
				{
					print_ecdbg("good csum\r\n");
80008e7c:	fe fc 03 20 	ld.w	r12,pc[800]
80008e80:	f0 1f 00 c0 	mcall	80009180 <eval_region+0x620>

					retVal = 1; //we have at least one good copy
80008e84:	30 18       	mov	r8,1
80008e86:	ef 68 ff c7 	st.b	r7[-57],r8
					
					tmpHours = 0;
80008e8a:	30 08       	mov	r8,0
80008e8c:	ef 48 ff c8 	st.w	r7[-56],r8
					uHours = 0;
80008e90:	30 08       	mov	r8,0
80008e92:	ef 48 ff cc 	st.w	r7[-52],r8
					
					for (int i=0; i<(NUM_SETS_LED_BOARD_SIDES * NUM_LED_BOARD_SIDES); i++)
80008e96:	30 08       	mov	r8,0
80008e98:	ef 48 ff f0 	st.w	r7[-16],r8
80008e9c:	c2 18       	rjmp	80008ede <eval_region+0x37e>
					{
						tmpHours += tmpH.hrs[i];
80008e9e:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008ea2:	a1 78       	lsl	r8,0x1
80008ea4:	ee 08 00 08 	add	r8,r7,r8
80008ea8:	f1 08 fb f2 	ld.sh	r8,r8[-1038]
80008eac:	5c 78       	castu.h	r8
80008eae:	ee f9 ff c8 	ld.w	r9,r7[-56]
80008eb2:	f2 08 00 08 	add	r8,r9,r8
80008eb6:	ef 48 ff c8 	st.w	r7[-56],r8
						uHours += h.hrs[i];
80008eba:	ee f9 ff f0 	ld.w	r9,r7[-16]
80008ebe:	fe f8 03 0e 	ld.w	r8,pc[782]
80008ec2:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
80008ec6:	5c 78       	castu.h	r8
80008ec8:	ee f9 ff cc 	ld.w	r9,r7[-52]
80008ecc:	f2 08 00 08 	add	r8,r9,r8
80008ed0:	ef 48 ff cc 	st.w	r7[-52],r8
					retVal = 1; //we have at least one good copy
					
					tmpHours = 0;
					uHours = 0;
					
					for (int i=0; i<(NUM_SETS_LED_BOARD_SIDES * NUM_LED_BOARD_SIDES); i++)
80008ed4:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008ed8:	2f f8       	sub	r8,-1
80008eda:	ef 48 ff f0 	st.w	r7[-16],r8
80008ede:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008ee2:	e0 48 00 5f 	cp.w	r8,95
80008ee6:	fe 9a ff dc 	brle	80008e9e <eval_region+0x33e>
					{
						tmpHours += tmpH.hrs[i];
						uHours += h.hrs[i];
					}
					
					if (uHours > tmpHours)
80008eea:	ee f9 ff cc 	ld.w	r9,r7[-52]
80008eee:	ee f8 ff c8 	ld.w	r8,r7[-56]
80008ef2:	10 39       	cp.w	r9,r8
80008ef4:	e0 88 00 1e 	brls	80008f30 <eval_region+0x3d0>
					{
						memcpy(&tmpH, &h, sizeof(h));
80008ef8:	ee c8 04 0e 	sub	r8,r7,1038
80008efc:	e0 6a 00 c2 	mov	r10,194
80008f00:	fe fb 02 cc 	ld.w	r11,pc[716]
80008f04:	10 9c       	mov	r12,r8
80008f06:	f0 1f 00 a4 	mcall	80009194 <eval_region+0x634>
						hFlashIdx = i; //this is the new best copy
80008f0a:	fe f8 02 c6 	ld.w	r8,pc[710]
80008f0e:	ee f9 ff ec 	ld.w	r9,r7[-20]
80008f12:	91 09       	st.w	r8[0x0],r9
						
						print_ecdbg("hFlashIdx ");
80008f14:	fe fc 02 c0 	ld.w	r12,pc[704]
80008f18:	f0 1f 00 9a 	mcall	80009180 <eval_region+0x620>
						print_ecdbg_num(hFlashIdx);
80008f1c:	fe f8 02 b4 	ld.w	r8,pc[692]
80008f20:	70 08       	ld.w	r8,r8[0x0]
80008f22:	10 9c       	mov	r12,r8
80008f24:	f0 1f 00 a1 	mcall	800091a8 <eval_region+0x648>
						print_ecdbg("\r\n");
80008f28:	fe fc 02 84 	ld.w	r12,pc[644]
80008f2c:	f0 1f 00 95 	mcall	80009180 <eval_region+0x620>
		case 2: //usage hours
			memset(&tmpH, 0x00, sizeof(h));

			print_ecdbg("region 2 - usage hours\r\n");

			for (unsigned int i=0; i<(NUM_USAGE_HOURS_BUFS_SECTORS / NUM_USAGE_HOURS_SECTORS_PER_BUF); i++)
80008f30:	ee f8 ff ec 	ld.w	r8,r7[-20]
80008f34:	2f f8       	sub	r8,-1
80008f36:	ef 48 ff ec 	st.w	r7[-20],r8
80008f3a:	ee f8 ff ec 	ld.w	r8,r7[-20]
80008f3e:	58 18       	cp.w	r8,1
80008f40:	fe 98 ff 79 	brls	80008e32 <eval_region+0x2d2>
						print_ecdbg("\r\n");

					}
				}
			}
			if (retVal == 1)
80008f44:	ef 39 ff c7 	ld.ub	r9,r7[-57]
80008f48:	30 18       	mov	r8,1
80008f4a:	f0 09 18 00 	cp.b	r9,r8
80008f4e:	e0 81 01 0d 	brne	80009168 <eval_region+0x608>
			{
				memcpy(&h, &tmpH, sizeof(h));
80008f52:	ee c8 04 0e 	sub	r8,r7,1038
80008f56:	e0 6a 00 c2 	mov	r10,194
80008f5a:	10 9b       	mov	r11,r8
80008f5c:	fe fc 02 70 	ld.w	r12,pc[624]
80008f60:	f0 1f 00 8d 	mcall	80009194 <eval_region+0x634>
			}
			break;
80008f64:	c0 59       	rjmp	8000916e <eval_region+0x60e>

		case 3: //usage minutes
			memset(&tmpM, 0x00, sizeof(m));
80008f66:	ee c8 04 78 	sub	r8,r7,1144
80008f6a:	36 8a       	mov	r10,104
80008f6c:	30 0b       	mov	r11,0
80008f6e:	10 9c       	mov	r12,r8
80008f70:	f0 1f 00 86 	mcall	80009188 <eval_region+0x628>
			
			print_ecdbg("region 3 - usage minutes\r\n");
80008f74:	fe fc 02 64 	ld.w	r12,pc[612]
80008f78:	f0 1f 00 82 	mcall	80009180 <eval_region+0x620>
			
			for (unsigned int i=0; i<(NUM_USAGE_MINS_BUFS_PER_SECTOR * NUM_USAGE_MINS_BUFS_SECTORS); i++)
80008f7c:	30 08       	mov	r8,0
80008f7e:	ef 48 ff f4 	st.w	r7[-12],r8
80008f82:	c7 98       	rjmp	80009074 <eval_region+0x514>
			{
				flashOffset = (i * 128 * NUM_USAGE_MINS_BUFS_PER_SECTOR);
80008f84:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008f88:	a7 78       	lsl	r8,0x7
80008f8a:	ef 48 ff bc 	st.w	r7[-68],r8
				
				tmpFlashOffset = flashOffset + (unsigned long) usageMinutesFlash;
80008f8e:	ee f9 ff bc 	ld.w	r9,r7[-68]
80008f92:	fe f8 02 4a 	ld.w	r8,pc[586]
80008f96:	f2 08 00 08 	add	r8,r9,r8
80008f9a:	ef 48 ff c0 	st.w	r7[-64],r8
				
				memcpy(&m, (const void*) tmpFlashOffset, sizeof(m));
80008f9e:	ee f8 ff c0 	ld.w	r8,r7[-64]
80008fa2:	36 8a       	mov	r10,104
80008fa4:	10 9b       	mov	r11,r8
80008fa6:	fe fc 02 3a 	ld.w	r12,pc[570]
80008faa:	f0 1f 00 7b 	mcall	80009194 <eval_region+0x634>
				
				csum = calc_region_checksum(3);
80008fae:	30 3c       	mov	r12,3
80008fb0:	f0 1f 00 7a 	mcall	80009198 <eval_region+0x638>
80008fb4:	18 98       	mov	r8,r12
80008fb6:	ef 68 ff bb 	st.b	r7[-69],r8
				
				if (csum == m.csum) //checksum is good
80008fba:	fe f8 02 26 	ld.w	r8,pc[550]
80008fbe:	f1 38 00 64 	ld.ub	r8,r8[100]
80008fc2:	ef 39 ff bb 	ld.ub	r9,r7[-69]
80008fc6:	f0 09 18 00 	cp.b	r9,r8
80008fca:	c5 01       	brne	8000906a <eval_region+0x50a>
				{
					print_ecdbg("good csum\r\n");
80008fcc:	4f 4c       	lddpc	r12,8000919c <eval_region+0x63c>
80008fce:	f0 1f 00 6d 	mcall	80009180 <eval_region+0x620>

					retVal = 1; //we have at least one good copy
80008fd2:	30 18       	mov	r8,1
80008fd4:	ef 68 ff c7 	st.b	r7[-57],r8
					
					tmpMinutes = 0;
80008fd8:	30 08       	mov	r8,0
80008fda:	ef 48 ff d0 	st.w	r7[-48],r8
					uMinutes = 0;
80008fde:	30 08       	mov	r8,0
80008fe0:	ef 48 ff d4 	st.w	r7[-44],r8
					
					for (int i=0; i<(NUM_SETS_LED_BOARD_SIDES * NUM_LED_BOARD_SIDES); i++)
80008fe4:	30 08       	mov	r8,0
80008fe6:	ef 48 ff f8 	st.w	r7[-8],r8
80008fea:	c1 d8       	rjmp	80009024 <eval_region+0x4c4>
					{
						//TODO: I should be checking the serial ID and flags struct to see if the slot is filled, but i don't have a good way of syncing sf and m right now. In the meantime, just make sure that m.mins[i] is 0 if not used.
						tmpMinutes += tmpM.mins[i];
80008fec:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008ff0:	ee 08 00 08 	add	r8,r7,r8
80008ff4:	f1 38 fb 88 	ld.ub	r8,r8[-1144]
80008ff8:	ee f9 ff d0 	ld.w	r9,r7[-48]
80008ffc:	f2 08 00 08 	add	r8,r9,r8
80009000:	ef 48 ff d0 	st.w	r7[-48],r8
						uMinutes += m.mins[i];
80009004:	ee f8 ff f8 	ld.w	r8,r7[-8]
80009008:	4f 69       	lddpc	r9,800091e0 <eval_region+0x680>
8000900a:	f2 08 07 08 	ld.ub	r8,r9[r8]
8000900e:	ee f9 ff d4 	ld.w	r9,r7[-44]
80009012:	f2 08 00 08 	add	r8,r9,r8
80009016:	ef 48 ff d4 	st.w	r7[-44],r8
					retVal = 1; //we have at least one good copy
					
					tmpMinutes = 0;
					uMinutes = 0;
					
					for (int i=0; i<(NUM_SETS_LED_BOARD_SIDES * NUM_LED_BOARD_SIDES); i++)
8000901a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000901e:	2f f8       	sub	r8,-1
80009020:	ef 48 ff f8 	st.w	r7[-8],r8
80009024:	ee f8 ff f8 	ld.w	r8,r7[-8]
80009028:	e0 48 00 5f 	cp.w	r8,95
8000902c:	fe 9a ff e0 	brle	80008fec <eval_region+0x48c>
						//TODO: I should be checking the serial ID and flags struct to see if the slot is filled, but i don't have a good way of syncing sf and m right now. In the meantime, just make sure that m.mins[i] is 0 if not used.
						tmpMinutes += tmpM.mins[i];
						uMinutes += m.mins[i];
					}
					
					if (uMinutes > tmpMinutes)
80009030:	ee f9 ff d4 	ld.w	r9,r7[-44]
80009034:	ee f8 ff d0 	ld.w	r8,r7[-48]
80009038:	10 39       	cp.w	r9,r8
8000903a:	e0 88 00 18 	brls	8000906a <eval_region+0x50a>
					{
						memcpy(&tmpM, &m, sizeof(m));
8000903e:	ee c8 04 78 	sub	r8,r7,1144
80009042:	36 8a       	mov	r10,104
80009044:	4e 7b       	lddpc	r11,800091e0 <eval_region+0x680>
80009046:	10 9c       	mov	r12,r8
80009048:	f0 1f 00 53 	mcall	80009194 <eval_region+0x634>
						mFlashIdx = i; //this is the new best copy
8000904c:	4e 68       	lddpc	r8,800091e4 <eval_region+0x684>
8000904e:	ee f9 ff f4 	ld.w	r9,r7[-12]
80009052:	91 09       	st.w	r8[0x0],r9

						print_ecdbg("mFlashIdx ");
80009054:	4e 5c       	lddpc	r12,800091e8 <eval_region+0x688>
80009056:	f0 1f 00 4b 	mcall	80009180 <eval_region+0x620>
						print_ecdbg_num(mFlashIdx);
8000905a:	4e 38       	lddpc	r8,800091e4 <eval_region+0x684>
8000905c:	70 08       	ld.w	r8,r8[0x0]
8000905e:	10 9c       	mov	r12,r8
80009060:	f0 1f 00 52 	mcall	800091a8 <eval_region+0x648>
						print_ecdbg("\r\n");
80009064:	4d 2c       	lddpc	r12,800091ac <eval_region+0x64c>
80009066:	f0 1f 00 47 	mcall	80009180 <eval_region+0x620>
		case 3: //usage minutes
			memset(&tmpM, 0x00, sizeof(m));
			
			print_ecdbg("region 3 - usage minutes\r\n");
			
			for (unsigned int i=0; i<(NUM_USAGE_MINS_BUFS_PER_SECTOR * NUM_USAGE_MINS_BUFS_SECTORS); i++)
8000906a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000906e:	2f f8       	sub	r8,-1
80009070:	ef 48 ff f4 	st.w	r7[-12],r8
80009074:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009078:	e0 48 00 73 	cp.w	r8,115
8000907c:	fe 98 ff 84 	brls	80008f84 <eval_region+0x424>
						print_ecdbg_num(mFlashIdx);
						print_ecdbg("\r\n");
					}
				}
			}
			if (retVal == 1)
80009080:	ef 39 ff c7 	ld.ub	r9,r7[-57]
80009084:	30 18       	mov	r8,1
80009086:	f0 09 18 00 	cp.b	r9,r8
8000908a:	c7 11       	brne	8000916c <eval_region+0x60c>
			{
				memcpy(&m, &tmpM, sizeof(m));
8000908c:	ee c8 04 78 	sub	r8,r7,1144
80009090:	36 8a       	mov	r10,104
80009092:	10 9b       	mov	r11,r8
80009094:	4d 3c       	lddpc	r12,800091e0 <eval_region+0x680>
80009096:	f0 1f 00 40 	mcall	80009194 <eval_region+0x634>
			}
			break;
8000909a:	c6 a8       	rjmp	8000916e <eval_region+0x60e>
		case 4: //configuration
			memset(&tmpC, 0x00, sizeof(c));
8000909c:	ee c8 04 7a 	sub	r8,r7,1146
800090a0:	30 2a       	mov	r10,2
800090a2:	30 0b       	mov	r11,0
800090a4:	10 9c       	mov	r12,r8
800090a6:	f0 1f 00 39 	mcall	80009188 <eval_region+0x628>

			print_ecdbg("region 4 - configuration\r\n");
800090aa:	4d 1c       	lddpc	r12,800091ec <eval_region+0x68c>
800090ac:	f0 1f 00 35 	mcall	80009180 <eval_region+0x620>

			for (unsigned int i=0; i<(NUM_CONFIG_BUFS_PER_SECTOR * NUM_CONFIG_BUFS_SECTORS); i++)
800090b0:	30 08       	mov	r8,0
800090b2:	ef 48 ff fc 	st.w	r7[-4],r8
800090b6:	c4 28       	rjmp	8000913a <eval_region+0x5da>
			{
				flashOffset = (i * 128 * NUM_CONFIG_BUFS_PER_SECTOR);
800090b8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800090bc:	a7 78       	lsl	r8,0x7
800090be:	ef 48 ff bc 	st.w	r7[-68],r8
			
				tmpFlashOffset = flashOffset + (unsigned long) configFlash;
800090c2:	ee f9 ff bc 	ld.w	r9,r7[-68]
800090c6:	4c b8       	lddpc	r8,800091f0 <eval_region+0x690>
800090c8:	f2 08 00 08 	add	r8,r9,r8
800090cc:	ef 48 ff c0 	st.w	r7[-64],r8
				memcpy(&c, (const void*) tmpFlashOffset, sizeof(c));
800090d0:	ee f8 ff c0 	ld.w	r8,r7[-64]
800090d4:	30 2a       	mov	r10,2
800090d6:	10 9b       	mov	r11,r8
800090d8:	4c 7c       	lddpc	r12,800091f4 <eval_region+0x694>
800090da:	f0 1f 00 2f 	mcall	80009194 <eval_region+0x634>
			
				csum = calc_region_checksum(4);
800090de:	30 4c       	mov	r12,4
800090e0:	f0 1f 00 2e 	mcall	80009198 <eval_region+0x638>
800090e4:	18 98       	mov	r8,r12
800090e6:	ef 68 ff bb 	st.b	r7[-69],r8
			
				if (csum == c.csum) //checksum is good
800090ea:	4c 38       	lddpc	r8,800091f4 <eval_region+0x694>
800090ec:	11 98       	ld.ub	r8,r8[0x1]
800090ee:	ef 39 ff bb 	ld.ub	r9,r7[-69]
800090f2:	f0 09 18 00 	cp.b	r9,r8
800090f6:	c1 d1       	brne	80009130 <eval_region+0x5d0>
				{
					print_ecdbg("good csum\r\n");
800090f8:	4a 9c       	lddpc	r12,8000919c <eval_region+0x63c>
800090fa:	f0 1f 00 22 	mcall	80009180 <eval_region+0x620>

					retVal = 1; //we have at least one good copy
800090fe:	30 18       	mov	r8,1
80009100:	ef 68 ff c7 	st.b	r7[-57],r8
				
					memcpy(&tmpC, &c, sizeof(c));
80009104:	ee c8 04 7a 	sub	r8,r7,1146
80009108:	30 2a       	mov	r10,2
8000910a:	4b bb       	lddpc	r11,800091f4 <eval_region+0x694>
8000910c:	10 9c       	mov	r12,r8
8000910e:	f0 1f 00 22 	mcall	80009194 <eval_region+0x634>
					configFlashIdx = i; //no good eval criteria for initialDTE: user could increase or decrease it. Therefore, always store 2 copies so both copies will be the same.
80009112:	4b a8       	lddpc	r8,800091f8 <eval_region+0x698>
80009114:	ee f9 ff fc 	ld.w	r9,r7[-4]
80009118:	91 09       	st.w	r8[0x0],r9

					print_ecdbg("configFlashIdx ");
8000911a:	4b 9c       	lddpc	r12,800091fc <eval_region+0x69c>
8000911c:	f0 1f 00 19 	mcall	80009180 <eval_region+0x620>
					print_ecdbg_num(configFlashIdx);
80009120:	4b 68       	lddpc	r8,800091f8 <eval_region+0x698>
80009122:	70 08       	ld.w	r8,r8[0x0]
80009124:	10 9c       	mov	r12,r8
80009126:	f0 1f 00 21 	mcall	800091a8 <eval_region+0x648>
					print_ecdbg("\r\n");
8000912a:	4a 1c       	lddpc	r12,800091ac <eval_region+0x64c>
8000912c:	f0 1f 00 15 	mcall	80009180 <eval_region+0x620>
		case 4: //configuration
			memset(&tmpC, 0x00, sizeof(c));

			print_ecdbg("region 4 - configuration\r\n");

			for (unsigned int i=0; i<(NUM_CONFIG_BUFS_PER_SECTOR * NUM_CONFIG_BUFS_SECTORS); i++)
80009130:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009134:	2f f8       	sub	r8,-1
80009136:	ef 48 ff fc 	st.w	r7[-4],r8
8000913a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000913e:	58 18       	cp.w	r8,1
80009140:	fe 98 ff bc 	brls	800090b8 <eval_region+0x558>
					print_ecdbg("configFlashIdx ");
					print_ecdbg_num(configFlashIdx);
					print_ecdbg("\r\n");
				}
			}
			if (retVal == 1)
80009144:	ef 39 ff c7 	ld.ub	r9,r7[-57]
80009148:	30 18       	mov	r8,1
8000914a:	f0 09 18 00 	cp.b	r9,r8
8000914e:	c1 01       	brne	8000916e <eval_region+0x60e>
			{
				memcpy(&c, &tmpC, sizeof(c));
80009150:	ee c8 04 7a 	sub	r8,r7,1146
80009154:	30 2a       	mov	r10,2
80009156:	10 9b       	mov	r11,r8
80009158:	4a 7c       	lddpc	r12,800091f4 <eval_region+0x694>
8000915a:	f0 1f 00 0f 	mcall	80009194 <eval_region+0x634>
8000915e:	c0 88       	rjmp	8000916e <eval_region+0x60e>
			
			if (retVal == 1)
			{
				memcpy(&sf, &tmpSf, sizeof(sf));
			}
			break;
80009160:	d7 03       	nop
80009162:	c0 68       	rjmp	8000916e <eval_region+0x60e>
			}
			if (retVal == 1)
			{
				memcpy(&sanc, &tmpSanc, sizeof(sanc));
			}
			break;
80009164:	d7 03       	nop
80009166:	c0 48       	rjmp	8000916e <eval_region+0x60e>
			}
			if (retVal == 1)
			{
				memcpy(&h, &tmpH, sizeof(h));
			}
			break;
80009168:	d7 03       	nop
8000916a:	c0 28       	rjmp	8000916e <eval_region+0x60e>
			}
			if (retVal == 1)
			{
				memcpy(&m, &tmpM, sizeof(m));
			}
			break;
8000916c:	d7 03       	nop
			}
			break;
		
	}
	
	return retVal;
8000916e:	ef 38 ff c7 	ld.ub	r8,r7[-57]
}
80009172:	10 9c       	mov	r12,r8
80009174:	fe 3d fb 80 	sub	sp,-1152
80009178:	e3 cd 80 80 	ldm	sp++,r7,pc
8000917c:	80 00       	ld.sh	r0,r0[0x0]
8000917e:	66 dc       	ld.w	r12,r3[0x34]
80009180:	80 00       	ld.sh	r0,r0[0x0]
80009182:	33 38       	mov	r8,51
80009184:	80 00       	ld.sh	r0,r0[0x0]
80009186:	66 ec       	ld.w	r12,r3[0x38]
80009188:	80 00       	ld.sh	r0,r0[0x0]
8000918a:	ce 02       	brcc	8000914a <eval_region+0x5ea>
8000918c:	80 07       	ld.sh	r7,r0[0x0]
8000918e:	fa 00 00 00 	add	r0,sp,r0
80009192:	08 48       	or	r8,r4
80009194:	80 00       	ld.sh	r0,r0[0x0]
80009196:	cc ba       	rjmp	80008f2c <eval_region+0x3cc>
80009198:	80 00       	ld.sh	r0,r0[0x0]
8000919a:	89 08       	st.w	r4[0x0],r8
8000919c:	80 00       	ld.sh	r0,r0[0x0]
8000919e:	67 10       	ld.w	r0,r3[0x44]
800091a0:	00 00       	add	r0,r0
800091a2:	07 bc       	ld.ub	r12,r3[0x3]
800091a4:	80 00       	ld.sh	r0,r0[0x0]
800091a6:	67 1c       	ld.w	r12,r3[0x44]
800091a8:	80 00       	ld.sh	r0,r0[0x0]
800091aa:	73 50       	ld.w	r0,r9[0x54]
800091ac:	80 00       	ld.sh	r0,r0[0x0]
800091ae:	64 ec       	ld.w	r12,r2[0x38]
800091b0:	80 00       	ld.sh	r0,r0[0x0]
800091b2:	67 28       	ld.w	r8,r3[0x48]
800091b4:	80 07       	ld.sh	r7,r0[0x0]
800091b6:	f7 00 00 00 	ld.sh	r0,r11[0]
800091ba:	0c 28       	rsub	r8,r6
800091bc:	00 00       	add	r0,r0
800091be:	07 c0       	ld.ub	r0,r3[0x4]
800091c0:	80 00       	ld.sh	r0,r0[0x0]
800091c2:	67 48       	ld.w	r8,r3[0x50]
800091c4:	80 00       	ld.sh	r0,r0[0x0]
800091c6:	67 5c       	ld.w	r12,r3[0x54]
800091c8:	80 07       	ld.sh	r7,r0[0x0]
800091ca:	f5 00 00 00 	ld.sh	r0,r10[0]
800091ce:	0c 2c       	rsub	r12,r6
800091d0:	00 00       	add	r0,r0
800091d2:	07 c4       	ld.ub	r4,r3[0x4]
800091d4:	80 00       	ld.sh	r0,r0[0x0]
800091d6:	67 78       	ld.w	r8,r3[0x5c]
800091d8:	80 00       	ld.sh	r0,r0[0x0]
800091da:	67 84       	ld.w	r4,r3[0x60]
800091dc:	80 07       	ld.sh	r7,r0[0x0]
800091de:	bb 00       	ld.d	r0,sp
800091e0:	00 00       	add	r0,r0
800091e2:	0d 08       	ld.w	r8,r6++
800091e4:	00 00       	add	r0,r0
800091e6:	07 c8       	ld.ub	r8,r3[0x4]
800091e8:	80 00       	ld.sh	r0,r0[0x0]
800091ea:	67 a0       	ld.w	r0,r3[0x68]
800091ec:	80 00       	ld.sh	r0,r0[0x0]
800091ee:	67 ac       	ld.w	r12,r3[0x68]
800091f0:	80 07       	ld.sh	r7,r0[0x0]
800091f2:	ba 00       	st.h	sp[0x0],r0
800091f4:	00 00       	add	r0,r0
800091f6:	0b fc       	ld.ub	r12,r5[0x7]
800091f8:	00 00       	add	r0,r0
800091fa:	07 cc       	ld.ub	r12,r3[0x4]
800091fc:	80 00       	ld.sh	r0,r0[0x0]
800091fe:	67 c8       	ld.w	r8,r3[0x70]

80009200 <write_region_to_flash>:

unsigned char write_region_to_flash(unsigned char sel, unsigned char idx, unsigned char csum);
unsigned char write_region_to_flash(unsigned char sel, unsigned char idx, unsigned char csum)
{
80009200:	eb cd 40 80 	pushm	r7,lr
80009204:	1a 97       	mov	r7,sp
80009206:	20 6d       	sub	sp,24
80009208:	16 99       	mov	r9,r11
8000920a:	14 98       	mov	r8,r10
8000920c:	18 9a       	mov	r10,r12
8000920e:	ef 6a ff f0 	st.b	r7[-16],r10
80009212:	ef 69 ff ec 	st.b	r7[-20],r9
80009216:	ef 68 ff e8 	st.b	r7[-24],r8
	unsigned long tmpFlashOffset, flashOffset;
	unsigned char tmpIdx;
	
	if (idx == 0xFF) //use the default system index
8000921a:	ef 39 ff ec 	ld.ub	r9,r7[-20]
8000921e:	3f f8       	mov	r8,-1
80009220:	f0 09 18 00 	cp.b	r9,r8
80009224:	c2 b1       	brne	8000927a <write_region_to_flash+0x7a>
	{
		switch(sel)
80009226:	ef 38 ff f0 	ld.ub	r8,r7[-16]
8000922a:	58 28       	cp.w	r8,2
8000922c:	c1 70       	breq	8000925a <write_region_to_flash+0x5a>
8000922e:	e0 89 00 07 	brgt	8000923c <write_region_to_flash+0x3c>
80009232:	58 08       	cp.w	r8,0
80009234:	c0 90       	breq	80009246 <write_region_to_flash+0x46>
80009236:	58 18       	cp.w	r8,1
80009238:	c0 c0       	breq	80009250 <write_region_to_flash+0x50>
				break;
			case 3: //usage minutes
				tmpIdx = mFlashIdx;
				break;
			case 4: //configuration
				tmpIdx = configFlashIdx;
8000923a:	c2 48       	rjmp	80009282 <write_region_to_flash+0x82>
	unsigned long tmpFlashOffset, flashOffset;
	unsigned char tmpIdx;
	
	if (idx == 0xFF) //use the default system index
	{
		switch(sel)
8000923c:	58 38       	cp.w	r8,3
8000923e:	c1 30       	breq	80009264 <write_region_to_flash+0x64>
80009240:	58 48       	cp.w	r8,4
80009242:	c1 70       	breq	80009270 <write_region_to_flash+0x70>
				break;
			case 3: //usage minutes
				tmpIdx = mFlashIdx;
				break;
			case 4: //configuration
				tmpIdx = configFlashIdx;
80009244:	c1 f8       	rjmp	80009282 <write_region_to_flash+0x82>
	if (idx == 0xFF) //use the default system index
	{
		switch(sel)
		{
			case 0: //serial ID and flags
				tmpIdx = sfFlashIdx;
80009246:	4d d8       	lddpc	r8,800093b8 <write_region_to_flash+0x1b8>
80009248:	70 08       	ld.w	r8,r8[0x0]
8000924a:	ef 68 ff ff 	st.b	r7[-1],r8
				break;
8000924e:	c1 a8       	rjmp	80009282 <write_region_to_flash+0x82>
			case 1: //sanitation cycles
				tmpIdx = sanCycleFlashIdx;
80009250:	4d b8       	lddpc	r8,800093bc <write_region_to_flash+0x1bc>
80009252:	70 08       	ld.w	r8,r8[0x0]
80009254:	ef 68 ff ff 	st.b	r7[-1],r8
				break;
80009258:	c1 58       	rjmp	80009282 <write_region_to_flash+0x82>
			case 2: //usage hours
				tmpIdx = hFlashIdx;
8000925a:	4d a8       	lddpc	r8,800093c0 <write_region_to_flash+0x1c0>
8000925c:	70 08       	ld.w	r8,r8[0x0]
8000925e:	ef 68 ff ff 	st.b	r7[-1],r8
				break;
80009262:	c1 08       	rjmp	80009282 <write_region_to_flash+0x82>
			case 3: //usage minutes
				tmpIdx = mFlashIdx;
80009264:	4d 88       	lddpc	r8,800093c4 <write_region_to_flash+0x1c4>
80009266:	70 08       	ld.w	r8,r8[0x0]
80009268:	ef 68 ff ff 	st.b	r7[-1],r8
				break;
8000926c:	d7 03       	nop
8000926e:	c0 a8       	rjmp	80009282 <write_region_to_flash+0x82>
			case 4: //configuration
				tmpIdx = configFlashIdx;
80009270:	4d 68       	lddpc	r8,800093c8 <write_region_to_flash+0x1c8>
80009272:	70 08       	ld.w	r8,r8[0x0]
80009274:	ef 68 ff ff 	st.b	r7[-1],r8
80009278:	c0 58       	rjmp	80009282 <write_region_to_flash+0x82>
				break;
		}
	}
	else //use the specific index passed to this function
	{
		tmpIdx = idx;
8000927a:	ef 38 ff ec 	ld.ub	r8,r7[-20]
8000927e:	ef 68 ff ff 	st.b	r7[-1],r8
	}
	
	switch (sel)
80009282:	ef 38 ff f0 	ld.ub	r8,r7[-16]
80009286:	58 28       	cp.w	r8,2
80009288:	c4 60       	breq	80009314 <write_region_to_flash+0x114>
8000928a:	e0 89 00 07 	brgt	80009298 <write_region_to_flash+0x98>
8000928e:	58 08       	cp.w	r8,0
80009290:	c0 90       	breq	800092a2 <write_region_to_flash+0xa2>
80009292:	58 18       	cp.w	r8,1
80009294:	c2 40       	breq	800092dc <write_region_to_flash+0xdc>
80009296:	c8 c8       	rjmp	800093ae <write_region_to_flash+0x1ae>
80009298:	58 38       	cp.w	r8,3
8000929a:	c5 80       	breq	8000934a <write_region_to_flash+0x14a>
8000929c:	58 48       	cp.w	r8,4
8000929e:	c7 00       	breq	8000937e <write_region_to_flash+0x17e>
800092a0:	c8 78       	rjmp	800093ae <write_region_to_flash+0x1ae>
	{
		case 0: //serial ID and flags
			//NOTE: this is not as parameterized as it should be, only good for 2 sectors, but good enough for now. 
			
			sf[0].csum = csum;
800092a2:	4c b9       	lddpc	r9,800093cc <write_region_to_flash+0x1cc>
800092a4:	ef 38 ff e8 	ld.ub	r8,r7[-24]
800092a8:	b2 f8       	st.b	r9[0x7],r8
			flashOffset = tmpIdx * 128 * NUM_SERIAL_ID_SECTORS_PER_BUF;
800092aa:	ef 39 ff ff 	ld.ub	r9,r7[-1]
800092ae:	12 98       	mov	r8,r9
800092b0:	a1 78       	lsl	r8,0x1
800092b2:	12 08       	add	r8,r9
800092b4:	a9 68       	lsl	r8,0x8
800092b6:	ef 48 ff f8 	st.w	r7[-8],r8
			tmpFlashOffset = flashOffset + (unsigned long) serialIdAndFlagsFlash;
800092ba:	4c 68       	lddpc	r8,800093d0 <write_region_to_flash+0x1d0>
800092bc:	ee f9 ff f8 	ld.w	r9,r7[-8]
800092c0:	f2 08 00 08 	add	r8,r9,r8
800092c4:	ef 48 ff f4 	st.w	r7[-12],r8
			flashc_memcpy((volatile void*)tmpFlashOffset, &sf, sizeof(sf), true);
800092c8:	ee f8 ff f4 	ld.w	r8,r7[-12]
800092cc:	30 19       	mov	r9,1
800092ce:	e0 6a 03 00 	mov	r10,768
800092d2:	4b fb       	lddpc	r11,800093cc <write_region_to_flash+0x1cc>
800092d4:	10 9c       	mov	r12,r8
800092d6:	f0 1f 00 40 	mcall	800093d4 <write_region_to_flash+0x1d4>
			break;
800092da:	c6 a8       	rjmp	800093ae <write_region_to_flash+0x1ae>

		case 1: //san cycles
			//NOTE: this is not as parameterized as it should be, only good for 2 sectors, but good enough for now.
			
			sanc.csum = csum;
800092dc:	4b f9       	lddpc	r9,800093d8 <write_region_to_flash+0x1d8>
800092de:	72 08       	ld.w	r8,r9[0x0]
800092e0:	ef 3a ff e8 	ld.ub	r10,r7[-24]
800092e4:	f1 da d0 88 	bfins	r8,r10,0x4,0x8
800092e8:	93 08       	st.w	r9[0x0],r8
			flashOffset = tmpIdx * 128 * NUM_SAN_CYCLE_BUFS_PER_SECTOR; //one sector per buf
800092ea:	ef 38 ff ff 	ld.ub	r8,r7[-1]
800092ee:	a7 78       	lsl	r8,0x7
800092f0:	ef 48 ff f8 	st.w	r7[-8],r8
			tmpFlashOffset = flashOffset + (unsigned long) sanitationCyclesFlash;
800092f4:	4b a8       	lddpc	r8,800093dc <write_region_to_flash+0x1dc>
800092f6:	ee f9 ff f8 	ld.w	r9,r7[-8]
800092fa:	f2 08 00 08 	add	r8,r9,r8
800092fe:	ef 48 ff f4 	st.w	r7[-12],r8
			flashc_memcpy((volatile void*)tmpFlashOffset, &sanc, sizeof(sanc), true);
80009302:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009306:	30 19       	mov	r9,1
80009308:	30 4a       	mov	r10,4
8000930a:	4b 4b       	lddpc	r11,800093d8 <write_region_to_flash+0x1d8>
8000930c:	10 9c       	mov	r12,r8
8000930e:	f0 1f 00 32 	mcall	800093d4 <write_region_to_flash+0x1d4>
			break;
80009312:	c4 e8       	rjmp	800093ae <write_region_to_flash+0x1ae>

		case 2: //usage hours
			h.csum = csum;
80009314:	4b 39       	lddpc	r9,800093e0 <write_region_to_flash+0x1e0>
80009316:	ef 38 ff e8 	ld.ub	r8,r7[-24]
8000931a:	f3 68 00 c0 	st.b	r9[192],r8
			flashOffset = tmpIdx * 128 * NUM_USAGE_HOURS_SECTORS_PER_BUF;
8000931e:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80009322:	a9 68       	lsl	r8,0x8
80009324:	ef 48 ff f8 	st.w	r7[-8],r8
			tmpFlashOffset = flashOffset + (unsigned long) usageHoursFlash;
80009328:	4a f8       	lddpc	r8,800093e4 <write_region_to_flash+0x1e4>
8000932a:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000932e:	f2 08 00 08 	add	r8,r9,r8
80009332:	ef 48 ff f4 	st.w	r7[-12],r8
			flashc_memcpy((volatile void*)tmpFlashOffset, &h, sizeof(h), true);
80009336:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000933a:	30 19       	mov	r9,1
8000933c:	e0 6a 00 c2 	mov	r10,194
80009340:	4a 8b       	lddpc	r11,800093e0 <write_region_to_flash+0x1e0>
80009342:	10 9c       	mov	r12,r8
80009344:	f0 1f 00 24 	mcall	800093d4 <write_region_to_flash+0x1d4>
			break;
80009348:	c3 38       	rjmp	800093ae <write_region_to_flash+0x1ae>
			
		case 3: //usage minutes
			//NOTE: this is not as parameterized as it should be, but good enough for now.
			m.csum = csum;
8000934a:	4a 89       	lddpc	r9,800093e8 <write_region_to_flash+0x1e8>
8000934c:	ef 38 ff e8 	ld.ub	r8,r7[-24]
80009350:	f3 68 00 64 	st.b	r9[100],r8
			flashOffset = tmpIdx * 128 * NUM_USAGE_MINS_BUFS_PER_SECTOR;
80009354:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80009358:	a7 78       	lsl	r8,0x7
8000935a:	ef 48 ff f8 	st.w	r7[-8],r8
			tmpFlashOffset = flashOffset + (unsigned long) usageMinutesFlash;
8000935e:	4a 48       	lddpc	r8,800093ec <write_region_to_flash+0x1ec>
80009360:	ee f9 ff f8 	ld.w	r9,r7[-8]
80009364:	f2 08 00 08 	add	r8,r9,r8
80009368:	ef 48 ff f4 	st.w	r7[-12],r8
			flashc_memcpy((volatile void*)tmpFlashOffset, &m, sizeof(m), true);
8000936c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009370:	30 19       	mov	r9,1
80009372:	36 8a       	mov	r10,104
80009374:	49 db       	lddpc	r11,800093e8 <write_region_to_flash+0x1e8>
80009376:	10 9c       	mov	r12,r8
80009378:	f0 1f 00 17 	mcall	800093d4 <write_region_to_flash+0x1d4>
			break;
8000937c:	c1 98       	rjmp	800093ae <write_region_to_flash+0x1ae>

		case 4: //configuration
			c.csum = csum;
8000937e:	49 d9       	lddpc	r9,800093f0 <write_region_to_flash+0x1f0>
80009380:	ef 38 ff e8 	ld.ub	r8,r7[-24]
80009384:	b2 98       	st.b	r9[0x1],r8
			flashOffset = tmpIdx * 128 * NUM_CONFIG_BUFS_PER_SECTOR; //one sector per buf
80009386:	ef 38 ff ff 	ld.ub	r8,r7[-1]
8000938a:	a7 78       	lsl	r8,0x7
8000938c:	ef 48 ff f8 	st.w	r7[-8],r8
			tmpFlashOffset = flashOffset + (unsigned long) configFlash;
80009390:	49 98       	lddpc	r8,800093f4 <write_region_to_flash+0x1f4>
80009392:	ee f9 ff f8 	ld.w	r9,r7[-8]
80009396:	f2 08 00 08 	add	r8,r9,r8
8000939a:	ef 48 ff f4 	st.w	r7[-12],r8
			flashc_memcpy((volatile void*)tmpFlashOffset, &c, sizeof(c), true);
8000939e:	ee f8 ff f4 	ld.w	r8,r7[-12]
800093a2:	30 19       	mov	r9,1
800093a4:	30 2a       	mov	r10,2
800093a6:	49 3b       	lddpc	r11,800093f0 <write_region_to_flash+0x1f0>
800093a8:	10 9c       	mov	r12,r8
800093aa:	f0 1f 00 0b 	mcall	800093d4 <write_region_to_flash+0x1d4>
			break;
	}
	
	return SUCCESS;	
800093ae:	30 08       	mov	r8,0
}
800093b0:	10 9c       	mov	r12,r8
800093b2:	2f ad       	sub	sp,-24
800093b4:	e3 cd 80 80 	ldm	sp++,r7,pc
800093b8:	00 00       	add	r0,r0
800093ba:	07 bc       	ld.ub	r12,r3[0x3]
800093bc:	00 00       	add	r0,r0
800093be:	07 c0       	ld.ub	r0,r3[0x4]
800093c0:	00 00       	add	r0,r0
800093c2:	07 c4       	ld.ub	r4,r3[0x4]
800093c4:	00 00       	add	r0,r0
800093c6:	07 c8       	ld.ub	r8,r3[0x4]
800093c8:	00 00       	add	r0,r0
800093ca:	07 cc       	ld.ub	r12,r3[0x4]
800093cc:	00 00       	add	r0,r0
800093ce:	08 48       	or	r8,r4
800093d0:	80 07       	ld.sh	r7,r0[0x0]
800093d2:	fa 00       	*unknown*
800093d4:	80 00       	ld.sh	r0,r0[0x0]
800093d6:	43 84       	lddsp	r4,sp[0xe0]
800093d8:	00 00       	add	r0,r0
800093da:	0c 28       	rsub	r8,r6
800093dc:	80 07       	ld.sh	r7,r0[0x0]
800093de:	f7 00 00 00 	ld.sh	r0,r11[0]
800093e2:	0c 2c       	rsub	r12,r6
800093e4:	80 07       	ld.sh	r7,r0[0x0]
800093e6:	f5 00 00 00 	ld.sh	r0,r10[0]
800093ea:	0d 08       	ld.w	r8,r6++
800093ec:	80 07       	ld.sh	r7,r0[0x0]
800093ee:	bb 00       	ld.d	r0,sp
800093f0:	00 00       	add	r0,r0
800093f2:	0b fc       	ld.ub	r12,r5[0x7]
800093f4:	80 07       	ld.sh	r7,r0[0x0]
800093f6:	ba 00       	st.h	sp[0x0],r0

800093f8 <write_bad_region_to_flash>:

void write_bad_region_to_flash(unsigned char sel, unsigned char idx);
void write_bad_region_to_flash(unsigned char sel, unsigned char idx)
{
800093f8:	eb cd 40 80 	pushm	r7,lr
800093fc:	1a 97       	mov	r7,sp
800093fe:	21 fd       	sub	sp,124
80009400:	18 99       	mov	r9,r12
80009402:	16 98       	mov	r8,r11
80009404:	ef 69 ff 88 	st.b	r7[-120],r9
80009408:	ef 68 ff 84 	st.b	r7[-124],r8
	unsigned long tmpFlashOffset, flashOffset;
	unsigned char tmpIdx;

	USAGE_MINS_SET tmpM;
	
	memset(&tmpM, 0x00, sizeof(m)); //just zero it out and don't give it a good checksum
8000940c:	ee c8 00 74 	sub	r8,r7,116
80009410:	36 8a       	mov	r10,104
80009412:	30 0b       	mov	r11,0
80009414:	10 9c       	mov	r12,r8
80009416:	f0 1f 00 1d 	mcall	80009488 <write_bad_region_to_flash+0x90>
	
	if (sel != 3)
8000941a:	ef 39 ff 88 	ld.ub	r9,r7[-120]
8000941e:	30 38       	mov	r8,3
80009420:	f0 09 18 00 	cp.b	r9,r8
80009424:	c2 e1       	brne	80009480 <write_bad_region_to_flash+0x88>
	{
		return; //we only do this for the minutes region
	}
	
	if (idx == 0xFF) //use the default system index
80009426:	ef 39 ff 84 	ld.ub	r9,r7[-124]
8000942a:	3f f8       	mov	r8,-1
8000942c:	f0 09 18 00 	cp.b	r9,r8
80009430:	c0 a1       	brne	80009444 <write_bad_region_to_flash+0x4c>
	{
		switch(sel)
80009432:	ef 38 ff 88 	ld.ub	r8,r7[-120]
80009436:	58 38       	cp.w	r8,3
80009438:	c0 a1       	brne	8000944c <write_bad_region_to_flash+0x54>
		{
			case 3: //usage minutes
				tmpIdx = mFlashIdx;
8000943a:	49 58       	lddpc	r8,8000948c <write_bad_region_to_flash+0x94>
8000943c:	70 08       	ld.w	r8,r8[0x0]
8000943e:	ef 68 ff ff 	st.b	r7[-1],r8
80009442:	c0 58       	rjmp	8000944c <write_bad_region_to_flash+0x54>
				break;
		}
	}
	else //use the specific index passed to this function
	{
		tmpIdx = idx;
80009444:	ef 38 ff 84 	ld.ub	r8,r7[-124]
80009448:	ef 68 ff ff 	st.b	r7[-1],r8
	}
	
	switch (sel)
8000944c:	ef 38 ff 88 	ld.ub	r8,r7[-120]
80009450:	58 38       	cp.w	r8,3
80009452:	c1 81       	brne	80009482 <write_bad_region_to_flash+0x8a>
	{
		case 3: //usage minutes
			flashOffset = tmpIdx * 128 * NUM_USAGE_MINS_BUFS_PER_SECTOR;
80009454:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80009458:	a7 78       	lsl	r8,0x7
8000945a:	ef 48 ff f8 	st.w	r7[-8],r8
			tmpFlashOffset = flashOffset + (unsigned long) usageMinutesFlash;
8000945e:	48 d8       	lddpc	r8,80009490 <write_bad_region_to_flash+0x98>
80009460:	ee f9 ff f8 	ld.w	r9,r7[-8]
80009464:	f2 08 00 08 	add	r8,r9,r8
80009468:	ef 48 ff f4 	st.w	r7[-12],r8
			flashc_memcpy((volatile void*)tmpFlashOffset, &tmpM, sizeof(m), false); //don't erase, it would just cause the flash to wear out twice as fast
8000946c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009470:	ee cb 00 74 	sub	r11,r7,116
80009474:	30 09       	mov	r9,0
80009476:	36 8a       	mov	r10,104
80009478:	10 9c       	mov	r12,r8
8000947a:	f0 1f 00 07 	mcall	80009494 <write_bad_region_to_flash+0x9c>
8000947e:	c0 28       	rjmp	80009482 <write_bad_region_to_flash+0x8a>
	
	memset(&tmpM, 0x00, sizeof(m)); //just zero it out and don't give it a good checksum
	
	if (sel != 3)
	{
		return; //we only do this for the minutes region
80009480:	d7 03       	nop
			tmpFlashOffset = flashOffset + (unsigned long) usageMinutesFlash;
			flashc_memcpy((volatile void*)tmpFlashOffset, &tmpM, sizeof(m), false); //don't erase, it would just cause the flash to wear out twice as fast
			break;
	}
	
}
80009482:	2e 1d       	sub	sp,-124
80009484:	e3 cd 80 80 	ldm	sp++,r7,pc
80009488:	80 00       	ld.sh	r0,r0[0x0]
8000948a:	ce 02       	brcc	8000944a <write_bad_region_to_flash+0x52>
8000948c:	00 00       	add	r0,r0
8000948e:	07 c8       	ld.ub	r8,r3[0x4]
80009490:	80 07       	ld.sh	r7,r0[0x0]
80009492:	bb 00       	ld.d	r0,sp
80009494:	80 00       	ld.sh	r0,r0[0x0]
80009496:	43 84       	lddsp	r4,sp[0xe0]

80009498 <copy_region_to_another_sector>:


void copy_region_to_another_sector(unsigned char sel);
void copy_region_to_another_sector(unsigned char sel)
{
80009498:	eb cd 40 80 	pushm	r7,lr
8000949c:	1a 97       	mov	r7,sp
8000949e:	20 2d       	sub	sp,8
800094a0:	18 98       	mov	r8,r12
800094a2:	ef 68 ff f8 	st.b	r7[-8],r8
	unsigned char tmpIdx, csum;
	
	switch (sel)
800094a6:	ef 38 ff f8 	ld.ub	r8,r7[-8]
800094aa:	58 28       	cp.w	r8,2
800094ac:	c5 10       	breq	8000954e <copy_region_to_another_sector+0xb6>
800094ae:	e0 89 00 07 	brgt	800094bc <copy_region_to_another_sector+0x24>
800094b2:	58 08       	cp.w	r8,0
800094b4:	c0 a0       	breq	800094c8 <copy_region_to_another_sector+0x30>
800094b6:	58 18       	cp.w	r8,1
800094b8:	c2 90       	breq	8000950a <copy_region_to_another_sector+0x72>
800094ba:	cb 38       	rjmp	80009620 <copy_region_to_another_sector+0x188>
800094bc:	58 38       	cp.w	r8,3
800094be:	c6 90       	breq	80009590 <copy_region_to_another_sector+0xf8>
800094c0:	58 48       	cp.w	r8,4
800094c2:	e0 80 00 8f 	breq	800095e0 <copy_region_to_another_sector+0x148>
800094c6:	ca d8       	rjmp	80009620 <copy_region_to_another_sector+0x188>
	{
		case 0: //serial ID and flags
			if (sfFlashIdx < ((NUM_SERIAL_ID_BUFS_SECTORS/NUM_SERIAL_ID_SECTORS_PER_BUF)/2))
800094c8:	4d 88       	lddpc	r8,80009628 <copy_region_to_another_sector+0x190>
800094ca:	70 08       	ld.w	r8,r8[0x0]
800094cc:	58 08       	cp.w	r8,0
800094ce:	c0 81       	brne	800094de <copy_region_to_another_sector+0x46>
			{
				tmpIdx = sfFlashIdx + ((NUM_SERIAL_ID_BUFS_SECTORS/NUM_SERIAL_ID_SECTORS_PER_BUF)/2);
800094d0:	4d 68       	lddpc	r8,80009628 <copy_region_to_another_sector+0x190>
800094d2:	70 08       	ld.w	r8,r8[0x0]
800094d4:	5c 58       	castu.b	r8
800094d6:	2f f8       	sub	r8,-1
800094d8:	ef 68 ff fe 	st.b	r7[-2],r8
800094dc:	c0 78       	rjmp	800094ea <copy_region_to_another_sector+0x52>
			}
			else
			{
				tmpIdx = sfFlashIdx - ((NUM_SERIAL_ID_BUFS_SECTORS/NUM_SERIAL_ID_SECTORS_PER_BUF)/2);
800094de:	4d 38       	lddpc	r8,80009628 <copy_region_to_another_sector+0x190>
800094e0:	70 08       	ld.w	r8,r8[0x0]
800094e2:	5c 58       	castu.b	r8
800094e4:	20 18       	sub	r8,1
800094e6:	ef 68 ff fe 	st.b	r7[-2],r8
			}
			
			csum = calc_region_checksum(0);
800094ea:	30 0c       	mov	r12,0
800094ec:	f0 1f 00 50 	mcall	8000962c <copy_region_to_another_sector+0x194>
800094f0:	18 98       	mov	r8,r12
800094f2:	ef 68 ff ff 	st.b	r7[-1],r8
			write_region_to_flash(0, tmpIdx, csum);
800094f6:	ef 39 ff ff 	ld.ub	r9,r7[-1]
800094fa:	ef 38 ff fe 	ld.ub	r8,r7[-2]
800094fe:	12 9a       	mov	r10,r9
80009500:	10 9b       	mov	r11,r8
80009502:	30 0c       	mov	r12,0
80009504:	f0 1f 00 4b 	mcall	80009630 <copy_region_to_another_sector+0x198>
			break;
80009508:	c8 c8       	rjmp	80009620 <copy_region_to_another_sector+0x188>

		case 1: //san cycles
			if (sanCycleFlashIdx < ((NUM_SAN_CYCLE_BUFS_PER_SECTOR * NUM_SAN_CYCLE_BUFS_SECTORS)/2))
8000950a:	4c b8       	lddpc	r8,80009634 <copy_region_to_another_sector+0x19c>
8000950c:	70 08       	ld.w	r8,r8[0x0]
8000950e:	58 28       	cp.w	r8,2
80009510:	e0 8b 00 09 	brhi	80009522 <copy_region_to_another_sector+0x8a>
			{
				tmpIdx = sanCycleFlashIdx + ((NUM_SAN_CYCLE_BUFS_PER_SECTOR * NUM_SAN_CYCLE_BUFS_SECTORS)/2);
80009514:	4c 88       	lddpc	r8,80009634 <copy_region_to_another_sector+0x19c>
80009516:	70 08       	ld.w	r8,r8[0x0]
80009518:	5c 58       	castu.b	r8
8000951a:	2f d8       	sub	r8,-3
8000951c:	ef 68 ff fe 	st.b	r7[-2],r8
80009520:	c0 78       	rjmp	8000952e <copy_region_to_another_sector+0x96>
			}
			else
			{
				tmpIdx = sanCycleFlashIdx - ((NUM_SAN_CYCLE_BUFS_PER_SECTOR * NUM_SAN_CYCLE_BUFS_SECTORS)/2);
80009522:	4c 58       	lddpc	r8,80009634 <copy_region_to_another_sector+0x19c>
80009524:	70 08       	ld.w	r8,r8[0x0]
80009526:	5c 58       	castu.b	r8
80009528:	20 38       	sub	r8,3
8000952a:	ef 68 ff fe 	st.b	r7[-2],r8
			}
			csum = calc_region_checksum(1);
8000952e:	30 1c       	mov	r12,1
80009530:	f0 1f 00 3f 	mcall	8000962c <copy_region_to_another_sector+0x194>
80009534:	18 98       	mov	r8,r12
80009536:	ef 68 ff ff 	st.b	r7[-1],r8
			write_region_to_flash(1, tmpIdx, csum);
8000953a:	ef 39 ff ff 	ld.ub	r9,r7[-1]
8000953e:	ef 38 ff fe 	ld.ub	r8,r7[-2]
80009542:	12 9a       	mov	r10,r9
80009544:	10 9b       	mov	r11,r8
80009546:	30 1c       	mov	r12,1
80009548:	f0 1f 00 3a 	mcall	80009630 <copy_region_to_another_sector+0x198>
			break;
8000954c:	c6 a8       	rjmp	80009620 <copy_region_to_another_sector+0x188>

		case 2: //usage hours
			if (hFlashIdx < ((NUM_USAGE_HOURS_BUFS_SECTORS/NUM_USAGE_HOURS_SECTORS_PER_BUF)/2))
8000954e:	4b b8       	lddpc	r8,80009638 <copy_region_to_another_sector+0x1a0>
80009550:	70 08       	ld.w	r8,r8[0x0]
80009552:	58 08       	cp.w	r8,0
80009554:	c0 81       	brne	80009564 <copy_region_to_another_sector+0xcc>
			{
				tmpIdx = hFlashIdx + ((NUM_USAGE_HOURS_BUFS_SECTORS/NUM_USAGE_HOURS_SECTORS_PER_BUF)/2);
80009556:	4b 98       	lddpc	r8,80009638 <copy_region_to_another_sector+0x1a0>
80009558:	70 08       	ld.w	r8,r8[0x0]
8000955a:	5c 58       	castu.b	r8
8000955c:	2f f8       	sub	r8,-1
8000955e:	ef 68 ff fe 	st.b	r7[-2],r8
80009562:	c0 78       	rjmp	80009570 <copy_region_to_another_sector+0xd8>
			}
			else
			{
				tmpIdx = hFlashIdx - ((NUM_USAGE_HOURS_BUFS_SECTORS/NUM_USAGE_HOURS_SECTORS_PER_BUF)/2);
80009564:	4b 58       	lddpc	r8,80009638 <copy_region_to_another_sector+0x1a0>
80009566:	70 08       	ld.w	r8,r8[0x0]
80009568:	5c 58       	castu.b	r8
8000956a:	20 18       	sub	r8,1
8000956c:	ef 68 ff fe 	st.b	r7[-2],r8
			}
			csum = calc_region_checksum(2);
80009570:	30 2c       	mov	r12,2
80009572:	f0 1f 00 2f 	mcall	8000962c <copy_region_to_another_sector+0x194>
80009576:	18 98       	mov	r8,r12
80009578:	ef 68 ff ff 	st.b	r7[-1],r8
			write_region_to_flash(2, tmpIdx, csum);
8000957c:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80009580:	ef 38 ff fe 	ld.ub	r8,r7[-2]
80009584:	12 9a       	mov	r10,r9
80009586:	10 9b       	mov	r11,r8
80009588:	30 2c       	mov	r12,2
8000958a:	f0 1f 00 2a 	mcall	80009630 <copy_region_to_another_sector+0x198>
			break;
8000958e:	c4 98       	rjmp	80009620 <copy_region_to_another_sector+0x188>

		case 3: //usage minutes
			tmpIdx = mFlashIdx + (NUM_USAGE_MINS_BUFS_SECTORS/2);
80009590:	4a b8       	lddpc	r8,8000963c <copy_region_to_another_sector+0x1a4>
80009592:	70 08       	ld.w	r8,r8[0x0]
80009594:	5c 58       	castu.b	r8
80009596:	2c 68       	sub	r8,-58
80009598:	ef 68 ff fe 	st.b	r7[-2],r8
			if (tmpIdx < (NUM_USAGE_MINS_BUFS_SECTORS/2))
8000959c:	ef 39 ff fe 	ld.ub	r9,r7[-2]
800095a0:	33 98       	mov	r8,57
800095a2:	f0 09 18 00 	cp.b	r9,r8
800095a6:	e0 8b 00 08 	brhi	800095b6 <copy_region_to_another_sector+0x11e>
			{
				tmpIdx += (NUM_USAGE_MINS_BUFS_SECTORS/2); //wrap if necessary
800095aa:	ef 38 ff fe 	ld.ub	r8,r7[-2]
800095ae:	2c 68       	sub	r8,-58
800095b0:	ef 68 ff fe 	st.b	r7[-2],r8
800095b4:	c0 68       	rjmp	800095c0 <copy_region_to_another_sector+0x128>
			}
			else
			{
				tmpIdx -= (NUM_USAGE_MINS_BUFS_SECTORS/2); //wrap if necessary
800095b6:	ef 38 ff fe 	ld.ub	r8,r7[-2]
800095ba:	23 a8       	sub	r8,58
800095bc:	ef 68 ff fe 	st.b	r7[-2],r8
			}
			csum = calc_region_checksum(3);
800095c0:	30 3c       	mov	r12,3
800095c2:	f0 1f 00 1b 	mcall	8000962c <copy_region_to_another_sector+0x194>
800095c6:	18 98       	mov	r8,r12
800095c8:	ef 68 ff ff 	st.b	r7[-1],r8
			write_region_to_flash(3, tmpIdx, csum);
800095cc:	ef 39 ff ff 	ld.ub	r9,r7[-1]
800095d0:	ef 38 ff fe 	ld.ub	r8,r7[-2]
800095d4:	12 9a       	mov	r10,r9
800095d6:	10 9b       	mov	r11,r8
800095d8:	30 3c       	mov	r12,3
800095da:	f0 1f 00 16 	mcall	80009630 <copy_region_to_another_sector+0x198>
			break;
800095de:	c2 18       	rjmp	80009620 <copy_region_to_another_sector+0x188>

		case 4: //configuration
			if (configFlashIdx < ((NUM_CONFIG_BUFS_PER_SECTOR * NUM_CONFIG_BUFS_SECTORS)/2))
800095e0:	49 88       	lddpc	r8,80009640 <copy_region_to_another_sector+0x1a8>
800095e2:	70 08       	ld.w	r8,r8[0x0]
800095e4:	58 08       	cp.w	r8,0
800095e6:	c0 81       	brne	800095f6 <copy_region_to_another_sector+0x15e>
			{
				tmpIdx = configFlashIdx + ((NUM_CONFIG_BUFS_PER_SECTOR * NUM_CONFIG_BUFS_SECTORS)/2);
800095e8:	49 68       	lddpc	r8,80009640 <copy_region_to_another_sector+0x1a8>
800095ea:	70 08       	ld.w	r8,r8[0x0]
800095ec:	5c 58       	castu.b	r8
800095ee:	2f f8       	sub	r8,-1
800095f0:	ef 68 ff fe 	st.b	r7[-2],r8
800095f4:	c0 78       	rjmp	80009602 <copy_region_to_another_sector+0x16a>
			}
			else
			{
				tmpIdx = configFlashIdx - ((NUM_CONFIG_BUFS_PER_SECTOR * NUM_CONFIG_BUFS_SECTORS)/2);
800095f6:	49 38       	lddpc	r8,80009640 <copy_region_to_another_sector+0x1a8>
800095f8:	70 08       	ld.w	r8,r8[0x0]
800095fa:	5c 58       	castu.b	r8
800095fc:	20 18       	sub	r8,1
800095fe:	ef 68 ff fe 	st.b	r7[-2],r8
			}
			csum = calc_region_checksum(4);
80009602:	30 4c       	mov	r12,4
80009604:	f0 1f 00 0a 	mcall	8000962c <copy_region_to_another_sector+0x194>
80009608:	18 98       	mov	r8,r12
8000960a:	ef 68 ff ff 	st.b	r7[-1],r8
			write_region_to_flash(4, tmpIdx, csum);
8000960e:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80009612:	ef 38 ff fe 	ld.ub	r8,r7[-2]
80009616:	12 9a       	mov	r10,r9
80009618:	10 9b       	mov	r11,r8
8000961a:	30 4c       	mov	r12,4
8000961c:	f0 1f 00 05 	mcall	80009630 <copy_region_to_another_sector+0x198>
			break;
	}
	
}
80009620:	2f ed       	sub	sp,-8
80009622:	e3 cd 80 80 	ldm	sp++,r7,pc
80009626:	00 00       	add	r0,r0
80009628:	00 00       	add	r0,r0
8000962a:	07 bc       	ld.ub	r12,r3[0x3]
8000962c:	80 00       	ld.sh	r0,r0[0x0]
8000962e:	89 08       	st.w	r4[0x0],r8
80009630:	80 00       	ld.sh	r0,r0[0x0]
80009632:	92 00       	ld.sh	r0,r9[0x0]
80009634:	00 00       	add	r0,r0
80009636:	07 c0       	ld.ub	r0,r3[0x4]
80009638:	00 00       	add	r0,r0
8000963a:	07 c4       	ld.ub	r4,r3[0x4]
8000963c:	00 00       	add	r0,r0
8000963e:	07 c8       	ld.ub	r8,r3[0x4]
80009640:	00 00       	add	r0,r0
80009642:	07 cc       	ld.ub	r12,r3[0x4]

80009644 <disrupt_prior_m_sector>:
 * determining the optimum minutes sector (picking the highest value) so we have to do something to disrupt prior
 * entries which is intentionally write a bad checksum to flash. 
 */
void disrupt_prior_m_sector(void);
void disrupt_prior_m_sector(void)
{
80009644:	eb cd 40 80 	pushm	r7,lr
80009648:	1a 97       	mov	r7,sp
8000964a:	20 1d       	sub	sp,4
	unsigned char tmpIdx;

	if (mFlashIdx > 0)
8000964c:	48 c8       	lddpc	r8,8000967c <disrupt_prior_m_sector+0x38>
8000964e:	70 08       	ld.w	r8,r8[0x0]
80009650:	58 08       	cp.w	r8,0
80009652:	c0 80       	breq	80009662 <disrupt_prior_m_sector+0x1e>
	{
		tmpIdx = mFlashIdx - 1;
80009654:	48 a8       	lddpc	r8,8000967c <disrupt_prior_m_sector+0x38>
80009656:	70 08       	ld.w	r8,r8[0x0]
80009658:	5c 58       	castu.b	r8
8000965a:	20 18       	sub	r8,1
8000965c:	ef 68 ff ff 	st.b	r7[-1],r8
80009660:	c0 48       	rjmp	80009668 <disrupt_prior_m_sector+0x24>
	}
	else
	{
		tmpIdx = NUM_USAGE_MINS_BUFS_SECTORS - 1; //backwards wrap if necessary
80009662:	37 38       	mov	r8,115
80009664:	ef 68 ff ff 	st.b	r7[-1],r8
	}

	write_bad_region_to_flash(3, tmpIdx);
80009668:	ef 38 ff ff 	ld.ub	r8,r7[-1]
8000966c:	10 9b       	mov	r11,r8
8000966e:	30 3c       	mov	r12,3
80009670:	f0 1f 00 04 	mcall	80009680 <disrupt_prior_m_sector+0x3c>
	
}
80009674:	2f fd       	sub	sp,-4
80009676:	e3 cd 80 80 	ldm	sp++,r7,pc
8000967a:	00 00       	add	r0,r0
8000967c:	00 00       	add	r0,r0
8000967e:	07 c8       	ld.ub	r8,r3[0x4]
80009680:	80 00       	ld.sh	r0,r0[0x0]
80009682:	93 f8       	st.w	r9[0x3c],r8

80009684 <find_first_open_usage_slot>:
unsigned char find_first_open_usage_slot(unsigned char sel)
#else
unsigned char find_first_open_usage_slot(void);
unsigned char find_first_open_usage_slot(void)
#endif
{
80009684:	eb cd 40 80 	pushm	r7,lr
80009688:	1a 97       	mov	r7,sp
8000968a:	20 1d       	sub	sp,4
	for (unsigned int i=0; i<(NUM_SETS_LED_BOARD_SIDES * NUM_LED_BOARD_SIDES); i++)
8000968c:	30 08       	mov	r8,0
8000968e:	ef 48 ff fc 	st.w	r7[-4],r8
80009692:	c1 58       	rjmp	800096bc <find_first_open_usage_slot+0x38>
	{
		
#ifdef SERIAL_ID_AND_ALL_USAGE_COMBINED		
		if (!usageShdw[sel].u[i].slotFilled)
#else
		if (!sf[i].slotFilled)
80009694:	ee f9 ff fc 	ld.w	r9,r7[-4]
80009698:	49 48       	lddpc	r8,800096e8 <find_first_open_usage_slot+0x64>
8000969a:	a1 79       	lsl	r9,0x1
8000969c:	2f f9       	sub	r9,-1
8000969e:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
800096a2:	f1 d8 c1 a1 	bfextu	r8,r8,0xd,0x1
800096a6:	5c 58       	castu.b	r8
800096a8:	c0 51       	brne	800096b2 <find_first_open_usage_slot+0x2e>
#endif //SERIAL_ID_AND_ALL_USAGE_COMBINED
		{
			return i;
800096aa:	ee f8 ff fc 	ld.w	r8,r7[-4]
800096ae:	5c 58       	castu.b	r8
800096b0:	c1 88       	rjmp	800096e0 <find_first_open_usage_slot+0x5c>
#else
unsigned char find_first_open_usage_slot(void);
unsigned char find_first_open_usage_slot(void)
#endif
{
	for (unsigned int i=0; i<(NUM_SETS_LED_BOARD_SIDES * NUM_LED_BOARD_SIDES); i++)
800096b2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800096b6:	2f f8       	sub	r8,-1
800096b8:	ef 48 ff fc 	st.w	r7[-4],r8
800096bc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800096c0:	e0 48 00 5f 	cp.w	r8,95
800096c4:	fe 98 ff e8 	brls	80009694 <find_first_open_usage_slot+0x10>
		{
			return i;
		}
	}
	
	print_ecdbg("No more room for LED board info. Cannot track minute usage for additional boards.\r\n");
800096c8:	48 9c       	lddpc	r12,800096ec <find_first_open_usage_slot+0x68>
800096ca:	f0 1f 00 0a 	mcall	800096f0 <find_first_open_usage_slot+0x6c>
	
	sysErr.usageStructsFull = FAIL;
800096ce:	48 a9       	lddpc	r9,800096f4 <find_first_open_usage_slot+0x70>
800096d0:	30 18       	mov	r8,1
800096d2:	f3 68 00 0e 	st.b	r9[14],r8
	electroclaveState = STATE_CHASSIS_ERROR;
800096d6:	48 99       	lddpc	r9,800096f8 <find_first_open_usage_slot+0x74>
800096d8:	30 88       	mov	r8,8
800096da:	b2 88       	st.b	r9[0x0],r8

	
	return USAGE_FULL; //Error, no open slots
800096dc:	e0 68 00 ff 	mov	r8,255
}
800096e0:	10 9c       	mov	r12,r8
800096e2:	2f fd       	sub	sp,-4
800096e4:	e3 cd 80 80 	ldm	sp++,r7,pc
800096e8:	00 00       	add	r0,r0
800096ea:	08 48       	or	r8,r4
800096ec:	80 00       	ld.sh	r0,r0[0x0]
800096ee:	67 d8       	ld.w	r8,r3[0x74]
800096f0:	80 00       	ld.sh	r0,r0[0x0]
800096f2:	33 38       	mov	r8,51
800096f4:	00 00       	add	r0,r0
800096f6:	0b d4       	ld.ub	r4,r5[0x5]
800096f8:	00 00       	add	r0,r0
800096fa:	07 b9       	ld.ub	r9,r3[0x3]

800096fc <add_new_led_board_sides_to_usage>:
#if 0 //SERIAL_ID_AND_ALL_USAGE_COMBINED
void add_new_led_board_sides_to_usage(unsigned char sel)
#endif
void add_new_led_board_sides_to_usage(void)

{
800096fc:	eb cd 40 80 	pushm	r7,lr
80009700:	1a 97       	mov	r7,sp
80009702:	20 2d       	sub	sp,8
			usageShdw[sel].u[slotAssignment].slotFilled = 1;

			usageIdx[sel][i] = slotAssignment++;
#else

	firstOpenSlot = find_first_open_usage_slot();
80009704:	f0 1f 00 43 	mcall	80009810 <add_new_led_board_sides_to_usage+0x114>
80009708:	18 98       	mov	r8,r12
8000970a:	ef 68 ff fb 	st.b	r7[-5],r8
	
	slotAssignment = firstOpenSlot;
8000970e:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80009712:	ef 68 ff fc 	st.b	r7[-4],r8
	
	for (unsigned char i=0; i<NUM_LED_BOARD_SIDES; i++)
80009716:	30 08       	mov	r8,0
80009718:	ef 68 ff ff 	st.b	r7[-1],r8
8000971c:	c7 08       	rjmp	800097fc <add_new_led_board_sides_to_usage+0x100>
	{
		brdIdx = ledBrdSide[i].boardIdx;
8000971e:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80009722:	4b da       	lddpc	r10,80009814 <add_new_led_board_sides_to_usage+0x118>
80009724:	12 98       	mov	r8,r9
80009726:	a3 68       	lsl	r8,0x2
80009728:	12 08       	add	r8,r9
8000972a:	f4 08 00 08 	add	r8,r10,r8
8000972e:	2f c8       	sub	r8,-4
80009730:	11 88       	ld.ub	r8,r8[0x0]
80009732:	ef 68 ff fd 	st.b	r7[-3],r8
		
		top_botn = (i%2) ? TOP : BOTTOM; //odd sides are top, even sides are bottom
80009736:	ef 38 ff ff 	ld.ub	r8,r7[-1]
8000973a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000973e:	ef 68 ff fe 	st.b	r7[-2],r8
		
		if ((ledBrd[brdIdx].present) && (usageIdx[i] == NO_LED_BOARD_PRESENT)) //TODO: do I need the NO_LED_BOARD_PRESENT check? this should always be open at this point
80009742:	ef 39 ff fd 	ld.ub	r9,r7[-3]
80009746:	4b 5a       	lddpc	r10,80009818 <add_new_led_board_sides_to_usage+0x11c>
80009748:	12 98       	mov	r8,r9
8000974a:	a3 78       	lsl	r8,0x3
8000974c:	12 18       	sub	r8,r9
8000974e:	a1 78       	lsl	r8,0x1
80009750:	f4 08 00 08 	add	r8,r10,r8
80009754:	2f 88       	sub	r8,-8
80009756:	11 88       	ld.ub	r8,r8[0x0]
80009758:	58 08       	cp.w	r8,0
8000975a:	c4 c0       	breq	800097f2 <add_new_led_board_sides_to_usage+0xf6>
8000975c:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80009760:	4a f9       	lddpc	r9,8000981c <add_new_led_board_sides_to_usage+0x120>
80009762:	f2 08 07 09 	ld.ub	r9,r9[r8]
80009766:	3f f8       	mov	r8,-1
80009768:	f0 09 18 00 	cp.b	r9,r8
8000976c:	c4 31       	brne	800097f2 <add_new_led_board_sides_to_usage+0xf6>
		{
			strncpy((char*)&sf[slotAssignment].id[0], (char*)&ledBrd[brdIdx].id[0],6);
8000976e:	ef 39 ff fd 	ld.ub	r9,r7[-3]
80009772:	12 98       	mov	r8,r9
80009774:	a3 78       	lsl	r8,0x3
80009776:	12 18       	sub	r8,r9
80009778:	a1 78       	lsl	r8,0x1
8000977a:	4a 89       	lddpc	r9,80009818 <add_new_led_board_sides_to_usage+0x11c>
8000977c:	12 08       	add	r8,r9
8000977e:	f0 c9 ff ff 	sub	r9,r8,-1
80009782:	ef 38 ff fc 	ld.ub	r8,r7[-4]
80009786:	f0 0a 15 03 	lsl	r10,r8,0x3
8000978a:	4a 68       	lddpc	r8,80009820 <add_new_led_board_sides_to_usage+0x124>
8000978c:	f4 08 00 08 	add	r8,r10,r8
80009790:	30 6a       	mov	r10,6
80009792:	12 9b       	mov	r11,r9
80009794:	10 9c       	mov	r12,r8
80009796:	f0 1f 00 24 	mcall	80009824 <add_new_led_board_sides_to_usage+0x128>
			
			sf[slotAssignment].top_botn = top_botn;
8000979a:	ef 3a ff fc 	ld.ub	r10,r7[-4]
8000979e:	ef 38 ff fe 	ld.ub	r8,r7[-2]
800097a2:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800097a6:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
800097aa:	49 e9       	lddpc	r9,80009820 <add_new_led_board_sides_to_usage+0x124>
800097ac:	f4 08 15 01 	lsl	r8,r10,0x1
800097b0:	f0 ca ff ff 	sub	r10,r8,-1
800097b4:	f2 0a 03 28 	ld.w	r8,r9[r10<<0x2]
800097b8:	f1 db d1 e1 	bfins	r8,r11,0xf,0x1
800097bc:	f2 0a 09 28 	st.w	r9[r10<<0x2],r8
			
			sf[slotAssignment].slotFilled = 1;
800097c0:	ef 38 ff fc 	ld.ub	r8,r7[-4]
800097c4:	49 79       	lddpc	r9,80009820 <add_new_led_board_sides_to_usage+0x124>
800097c6:	a1 78       	lsl	r8,0x1
800097c8:	f0 ca ff ff 	sub	r10,r8,-1
800097cc:	f2 0a 03 28 	ld.w	r8,r9[r10<<0x2]
800097d0:	30 1b       	mov	r11,1
800097d2:	f1 db d1 a1 	bfins	r8,r11,0xd,0x1
800097d6:	f2 0a 09 28 	st.w	r9[r10<<0x2],r8

			usageIdx[i] = slotAssignment++;
800097da:	ef 39 ff ff 	ld.ub	r9,r7[-1]
800097de:	49 0a       	lddpc	r10,8000981c <add_new_led_board_sides_to_usage+0x120>
800097e0:	ef 38 ff fc 	ld.ub	r8,r7[-4]
800097e4:	f4 09 0b 08 	st.b	r10[r9],r8
800097e8:	ef 38 ff fc 	ld.ub	r8,r7[-4]
800097ec:	2f f8       	sub	r8,-1
800097ee:	ef 68 ff fc 	st.b	r7[-4],r8

	firstOpenSlot = find_first_open_usage_slot();
	
	slotAssignment = firstOpenSlot;
	
	for (unsigned char i=0; i<NUM_LED_BOARD_SIDES; i++)
800097f2:	ef 38 ff ff 	ld.ub	r8,r7[-1]
800097f6:	2f f8       	sub	r8,-1
800097f8:	ef 68 ff ff 	st.b	r7[-1],r8
800097fc:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80009800:	30 78       	mov	r8,7
80009802:	f0 09 18 00 	cp.b	r9,r8
80009806:	fe 98 ff 8c 	brls	8000971e <add_new_led_board_sides_to_usage+0x22>
			usageIdx[i] = slotAssignment++;

#endif //SERIAL_ID_AND_ALL_USAGE_COMBINED			
		}
	}
}
8000980a:	2f ed       	sub	sp,-8
8000980c:	e3 cd 80 80 	ldm	sp++,r7,pc
80009810:	80 00       	ld.sh	r0,r0[0x0]
80009812:	96 84       	ld.uh	r4,r11[0x0]
80009814:	00 00       	add	r0,r0
80009816:	0b fe       	ld.ub	lr,r5[0x7]
80009818:	00 00       	add	r0,r0
8000981a:	0b 4a       	ld.w	r10,--r5
8000981c:	00 00       	add	r0,r0
8000981e:	0b c0       	ld.ub	r0,r5[0x4]
80009820:	00 00       	add	r0,r0
80009822:	08 48       	or	r8,r4
80009824:	80 00       	ld.sh	r0,r0[0x0]
80009826:	ce 68       	rjmp	800099f2 <increment_ledBoard_usage_min+0xde>

80009828 <inc_sanMins>:

#else

void inc_sanMins(void);
void inc_sanMins(void)
{
80009828:	eb cd 40 80 	pushm	r7,lr
8000982c:	1a 97       	mov	r7,sp
	m.sanMins++;
8000982e:	48 58       	lddpc	r8,80009840 <inc_sanMins+0x18>
80009830:	71 88       	ld.w	r8,r8[0x60]
80009832:	f0 c9 ff ff 	sub	r9,r8,-1
80009836:	48 38       	lddpc	r8,80009840 <inc_sanMins+0x18>
80009838:	f1 49 00 60 	st.w	r8[96],r9
	
	//the rest of the update of the struct, calc'ing the csum, writing to flash etc will happen when the usage minutes get updated
}
8000983c:	e3 cd 80 80 	ldm	sp++,r7,pc
80009840:	00 00       	add	r0,r0
80009842:	0d 08       	ld.w	r8,r6++

80009844 <inc_sanCycles>:

void inc_sanCycles(void);
void inc_sanCycles(void)
{
80009844:	eb cd 40 80 	pushm	r7,lr
80009848:	1a 97       	mov	r7,sp
	sanc.cycles++;
8000984a:	49 a8       	lddpc	r8,800098b0 <inc_sanCycles+0x6c>
8000984c:	70 08       	ld.w	r8,r8[0x0]
8000984e:	f1 d8 c1 94 	bfextu	r8,r8,0xc,0x14
80009852:	f0 c9 ff ff 	sub	r9,r8,-1
80009856:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000985a:	49 6a       	lddpc	r10,800098b0 <inc_sanCycles+0x6c>
8000985c:	74 08       	ld.w	r8,r10[0x0]
8000985e:	f1 d9 d1 94 	bfins	r8,r9,0xc,0x14
80009862:	95 08       	st.w	r10[0x0],r8
	sanCycleFlashIdx++;
80009864:	49 48       	lddpc	r8,800098b4 <inc_sanCycles+0x70>
80009866:	70 08       	ld.w	r8,r8[0x0]
80009868:	f0 c9 ff ff 	sub	r9,r8,-1
8000986c:	49 28       	lddpc	r8,800098b4 <inc_sanCycles+0x70>
8000986e:	91 09       	st.w	r8[0x0],r9
	if (sanCycleFlashIdx >= (NUM_SAN_CYCLE_BUFS_PER_SECTOR * NUM_SAN_CYCLE_BUFS_SECTORS))
80009870:	49 18       	lddpc	r8,800098b4 <inc_sanCycles+0x70>
80009872:	70 08       	ld.w	r8,r8[0x0]
80009874:	58 58       	cp.w	r8,5
80009876:	e0 88 00 05 	brls	80009880 <inc_sanCycles+0x3c>
	{
		sanCycleFlashIdx = 0;
8000987a:	48 f8       	lddpc	r8,800098b4 <inc_sanCycles+0x70>
8000987c:	30 09       	mov	r9,0
8000987e:	91 09       	st.w	r8[0x0],r9
	}
	sanc.csum = calc_region_checksum(1);
80009880:	30 1c       	mov	r12,1
80009882:	f0 1f 00 0e 	mcall	800098b8 <inc_sanCycles+0x74>
80009886:	18 98       	mov	r8,r12
80009888:	10 9a       	mov	r10,r8
8000988a:	48 a9       	lddpc	r9,800098b0 <inc_sanCycles+0x6c>
8000988c:	72 08       	ld.w	r8,r9[0x0]
8000988e:	f1 da d0 88 	bfins	r8,r10,0x4,0x8
80009892:	93 08       	st.w	r9[0x0],r8
	write_region_to_flash(1, 0xFF, sanc.csum);
80009894:	48 78       	lddpc	r8,800098b0 <inc_sanCycles+0x6c>
80009896:	70 08       	ld.w	r8,r8[0x0]
80009898:	f1 d8 c0 88 	bfextu	r8,r8,0x4,0x8
8000989c:	5c 58       	castu.b	r8
8000989e:	10 9a       	mov	r10,r8
800098a0:	e0 6b 00 ff 	mov	r11,255
800098a4:	30 1c       	mov	r12,1
800098a6:	f0 1f 00 06 	mcall	800098bc <inc_sanCycles+0x78>
}
800098aa:	e3 cd 80 80 	ldm	sp++,r7,pc
800098ae:	00 00       	add	r0,r0
800098b0:	00 00       	add	r0,r0
800098b2:	0c 28       	rsub	r8,r6
800098b4:	00 00       	add	r0,r0
800098b6:	07 c0       	ld.ub	r0,r3[0x4]
800098b8:	80 00       	ld.sh	r0,r0[0x0]
800098ba:	89 08       	st.w	r4[0x0],r8
800098bc:	80 00       	ld.sh	r0,r0[0x0]
800098be:	92 00       	ld.sh	r0,r9[0x0]

800098c0 <store_config>:

void store_config(void);
void store_config(void)
{
800098c0:	eb cd 40 80 	pushm	r7,lr
800098c4:	1a 97       	mov	r7,sp
	/* initialDTE set in the serial user interface */
	configFlashIdx++;
800098c6:	49 08       	lddpc	r8,80009904 <store_config+0x44>
800098c8:	70 08       	ld.w	r8,r8[0x0]
800098ca:	f0 c9 ff ff 	sub	r9,r8,-1
800098ce:	48 e8       	lddpc	r8,80009904 <store_config+0x44>
800098d0:	91 09       	st.w	r8[0x0],r9
	if (configFlashIdx >= (NUM_CONFIG_BUFS_PER_SECTOR * NUM_CONFIG_BUFS_SECTORS))
800098d2:	48 d8       	lddpc	r8,80009904 <store_config+0x44>
800098d4:	70 08       	ld.w	r8,r8[0x0]
800098d6:	58 18       	cp.w	r8,1
800098d8:	e0 88 00 05 	brls	800098e2 <store_config+0x22>
	{
		configFlashIdx = 0;
800098dc:	48 a8       	lddpc	r8,80009904 <store_config+0x44>
800098de:	30 09       	mov	r9,0
800098e0:	91 09       	st.w	r8[0x0],r9
	}
	c.csum = calc_region_checksum(4);
800098e2:	30 4c       	mov	r12,4
800098e4:	f0 1f 00 09 	mcall	80009908 <store_config+0x48>
800098e8:	18 98       	mov	r8,r12
800098ea:	48 99       	lddpc	r9,8000990c <store_config+0x4c>
800098ec:	b2 98       	st.b	r9[0x1],r8
	write_region_to_flash(4, 0xFF, c.csum);
800098ee:	48 88       	lddpc	r8,8000990c <store_config+0x4c>
800098f0:	11 98       	ld.ub	r8,r8[0x1]
800098f2:	10 9a       	mov	r10,r8
800098f4:	e0 6b 00 ff 	mov	r11,255
800098f8:	30 4c       	mov	r12,4
800098fa:	f0 1f 00 06 	mcall	80009910 <store_config+0x50>
}
800098fe:	e3 cd 80 80 	ldm	sp++,r7,pc
80009902:	00 00       	add	r0,r0
80009904:	00 00       	add	r0,r0
80009906:	07 cc       	ld.ub	r12,r3[0x4]
80009908:	80 00       	ld.sh	r0,r0[0x0]
8000990a:	89 08       	st.w	r4[0x0],r8
8000990c:	00 00       	add	r0,r0
8000990e:	0b fc       	ld.ub	r12,r5[0x7]
80009910:	80 00       	ld.sh	r0,r0[0x0]
80009912:	92 00       	ld.sh	r0,r9[0x0]

80009914 <increment_ledBoard_usage_min>:

void increment_ledBoard_usage_min(void)
{
80009914:	eb cd 40 80 	pushm	r7,lr
80009918:	1a 97       	mov	r7,sp
8000991a:	20 2d       	sub	sp,8
	unsigned char idx;
	unsigned char topLEDboardLowerSideIdx;
	unsigned char bottomLEDboardUpperSideIdx;
	unsigned char topUIdx;
	unsigned char bottomUIdx;
	unsigned char hourRollover = 0;
8000991c:	30 08       	mov	r8,0
8000991e:	ef 68 ff fd 	st.b	r7[-3],r8
	
	inc_sanMins();
80009922:	f0 1f 00 8d 	mcall	80009b54 <increment_ledBoard_usage_min+0x240>

	for (unsigned char i=0; i<NUM_SHELVES; i++) //check every active shelf
80009926:	30 08       	mov	r8,0
80009928:	ef 68 ff fe 	st.b	r7[-2],r8
8000992c:	cb f8       	rjmp	80009aaa <increment_ledBoard_usage_min+0x196>
	{
		if (shelf[i].active == SHELF_ACTIVE)
8000992e:	ef 39 ff fe 	ld.ub	r9,r7[-2]
80009932:	fe fa 02 26 	ld.w	r10,pc[550]
80009936:	12 98       	mov	r8,r9
80009938:	a3 68       	lsl	r8,0x2
8000993a:	12 08       	add	r8,r9
8000993c:	f4 08 00 08 	add	r8,r10,r8
80009940:	11 89       	ld.ub	r9,r8[0x0]
80009942:	30 18       	mov	r8,1
80009944:	f0 09 18 00 	cp.b	r9,r8
80009948:	e0 81 00 ac 	brne	80009aa0 <increment_ledBoard_usage_min+0x18c>
		{
			topLEDboardLowerSideIdx = ledBrd[shelf[i].tLedIdx].lSideIdx;
8000994c:	ef 39 ff fe 	ld.ub	r9,r7[-2]
80009950:	fe fa 02 08 	ld.w	r10,pc[520]
80009954:	12 98       	mov	r8,r9
80009956:	a3 68       	lsl	r8,0x2
80009958:	12 08       	add	r8,r9
8000995a:	f4 08 00 08 	add	r8,r10,r8
8000995e:	2f f8       	sub	r8,-1
80009960:	11 88       	ld.ub	r8,r8[0x0]
80009962:	10 99       	mov	r9,r8
80009964:	4f ea       	lddpc	r10,80009b5c <increment_ledBoard_usage_min+0x248>
80009966:	12 98       	mov	r8,r9
80009968:	a3 78       	lsl	r8,0x3
8000996a:	12 18       	sub	r8,r9
8000996c:	a1 78       	lsl	r8,0x1
8000996e:	f4 08 00 08 	add	r8,r10,r8
80009972:	2f 58       	sub	r8,-11
80009974:	11 88       	ld.ub	r8,r8[0x0]
80009976:	ef 68 ff f9 	st.b	r7[-7],r8
			bottomLEDboardUpperSideIdx = ledBrd[shelf[i].bLedIdx].uSideIdx;
8000997a:	ef 39 ff fe 	ld.ub	r9,r7[-2]
8000997e:	4f 7a       	lddpc	r10,80009b58 <increment_ledBoard_usage_min+0x244>
80009980:	12 98       	mov	r8,r9
80009982:	a3 68       	lsl	r8,0x2
80009984:	12 08       	add	r8,r9
80009986:	f4 08 00 08 	add	r8,r10,r8
8000998a:	2f e8       	sub	r8,-2
8000998c:	11 88       	ld.ub	r8,r8[0x0]
8000998e:	10 99       	mov	r9,r8
80009990:	4f 3a       	lddpc	r10,80009b5c <increment_ledBoard_usage_min+0x248>
80009992:	12 98       	mov	r8,r9
80009994:	a3 78       	lsl	r8,0x3
80009996:	12 18       	sub	r8,r9
80009998:	a1 78       	lsl	r8,0x1
8000999a:	f4 08 00 08 	add	r8,r10,r8
8000999e:	2f 68       	sub	r8,-10
800099a0:	11 88       	ld.ub	r8,r8[0x0]
800099a2:	ef 68 ff fa 	st.b	r7[-6],r8
			
			topUIdx = ledBrdSide[topLEDboardLowerSideIdx].ushdwIdx;
800099a6:	ef 39 ff f9 	ld.ub	r9,r7[-7]
800099aa:	4e ea       	lddpc	r10,80009b60 <increment_ledBoard_usage_min+0x24c>
800099ac:	12 98       	mov	r8,r9
800099ae:	a3 68       	lsl	r8,0x2
800099b0:	12 08       	add	r8,r9
800099b2:	f4 08 00 08 	add	r8,r10,r8
800099b6:	2f f8       	sub	r8,-1
800099b8:	11 88       	ld.ub	r8,r8[0x0]
800099ba:	ef 68 ff fb 	st.b	r7[-5],r8
			bottomUIdx = ledBrdSide[bottomLEDboardUpperSideIdx].ushdwIdx;
800099be:	ef 39 ff fa 	ld.ub	r9,r7[-6]
800099c2:	4e 8a       	lddpc	r10,80009b60 <increment_ledBoard_usage_min+0x24c>
800099c4:	12 98       	mov	r8,r9
800099c6:	a3 68       	lsl	r8,0x2
800099c8:	12 08       	add	r8,r9
800099ca:	f4 08 00 08 	add	r8,r10,r8
800099ce:	2f f8       	sub	r8,-1
800099d0:	11 88       	ld.ub	r8,r8[0x0]
800099d2:	ef 68 ff fc 	st.b	r7[-4],r8
			
			for (unsigned char k=0; k<2; k++) //for each board side in the shelf
800099d6:	30 08       	mov	r8,0
800099d8:	ef 68 ff ff 	st.b	r7[-1],r8
800099dc:	c5 b8       	rjmp	80009a92 <increment_ledBoard_usage_min+0x17e>
			{
				switch (k)
800099de:	ef 38 ff ff 	ld.ub	r8,r7[-1]
800099e2:	58 08       	cp.w	r8,0
800099e4:	c0 40       	breq	800099ec <increment_ledBoard_usage_min+0xd8>
800099e6:	58 18       	cp.w	r8,1
800099e8:	c0 70       	breq	800099f6 <increment_ledBoard_usage_min+0xe2>
800099ea:	c0 a8       	rjmp	800099fe <increment_ledBoard_usage_min+0xea>
				{
					case 0:
						idx = topUIdx;
800099ec:	ef 38 ff fb 	ld.ub	r8,r7[-5]
800099f0:	ef 68 ff f8 	st.b	r7[-8],r8
						break;
800099f4:	c0 58       	rjmp	800099fe <increment_ledBoard_usage_min+0xea>
					case 1:
						idx = bottomUIdx;
800099f6:	ef 38 ff fc 	ld.ub	r8,r7[-4]
800099fa:	ef 68 ff f8 	st.b	r7[-8],r8
						break;

				}

				m.mins[idx] = m.mins[idx] + 1;
800099fe:	ef 39 ff f8 	ld.ub	r9,r7[-8]
80009a02:	ef 38 ff f8 	ld.ub	r8,r7[-8]
80009a06:	4d 8a       	lddpc	r10,80009b64 <increment_ledBoard_usage_min+0x250>
80009a08:	f4 08 07 08 	ld.ub	r8,r10[r8]
80009a0c:	2f f8       	sub	r8,-1
80009a0e:	5c 58       	castu.b	r8
80009a10:	4d 5a       	lddpc	r10,80009b64 <increment_ledBoard_usage_min+0x250>
80009a12:	f4 09 0b 08 	st.b	r10[r9],r8
				if (m.mins[idx] > 59)
80009a16:	ef 38 ff f8 	ld.ub	r8,r7[-8]
80009a1a:	4d 39       	lddpc	r9,80009b64 <increment_ledBoard_usage_min+0x250>
80009a1c:	f2 08 07 09 	ld.ub	r9,r9[r8]
80009a20:	33 b8       	mov	r8,59
80009a22:	f0 09 18 00 	cp.b	r9,r8
80009a26:	e0 88 00 31 	brls	80009a88 <increment_ledBoard_usage_min+0x174>
				{
					m.mins[idx] = 0;
80009a2a:	ef 39 ff f8 	ld.ub	r9,r7[-8]
80009a2e:	4c ea       	lddpc	r10,80009b64 <increment_ledBoard_usage_min+0x250>
80009a30:	30 08       	mov	r8,0
80009a32:	f4 09 0b 08 	st.b	r10[r9],r8
					hourRollover++; //count number of board sides that had hours rollover this pass for the current hourPingPong selection
80009a36:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80009a3a:	2f f8       	sub	r8,-1
80009a3c:	ef 68 ff fd 	st.b	r7[-3],r8
					h.hrs[idx] = h.hrs[idx] + 1;
80009a40:	ef 3a ff f8 	ld.ub	r10,r7[-8]
80009a44:	ef 39 ff f8 	ld.ub	r9,r7[-8]
80009a48:	4c 88       	lddpc	r8,80009b68 <increment_ledBoard_usage_min+0x254>
80009a4a:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
80009a4e:	2f f8       	sub	r8,-1
80009a50:	5c 88       	casts.h	r8
80009a52:	4c 69       	lddpc	r9,80009b68 <increment_ledBoard_usage_min+0x254>
80009a54:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
						
					if ((h.hrs[idx]) >= 2000) //2000 hours * 60 minutes per hour
80009a58:	ef 39 ff f8 	ld.ub	r9,r7[-8]
80009a5c:	4c 38       	lddpc	r8,80009b68 <increment_ledBoard_usage_min+0x254>
80009a5e:	f0 09 04 19 	ld.sh	r9,r8[r9<<0x1]
80009a62:	e0 68 07 cf 	mov	r8,1999
80009a66:	f0 09 19 00 	cp.h	r9,r8
80009a6a:	e0 88 00 0f 	brls	80009a88 <increment_ledBoard_usage_min+0x174>
					{
						sf[idx].maxUsageReached = 1; //And...we're done. Reached 2000 hours.
80009a6e:	ef 38 ff f8 	ld.ub	r8,r7[-8]
80009a72:	4b f9       	lddpc	r9,80009b6c <increment_ledBoard_usage_min+0x258>
80009a74:	a1 78       	lsl	r8,0x1
80009a76:	f0 ca ff ff 	sub	r10,r8,-1
80009a7a:	f2 0a 03 28 	ld.w	r8,r9[r10<<0x2]
80009a7e:	30 1b       	mov	r11,1
80009a80:	f1 db d1 c1 	bfins	r8,r11,0xe,0x1
80009a84:	f2 0a 09 28 	st.w	r9[r10<<0x2],r8
			bottomLEDboardUpperSideIdx = ledBrd[shelf[i].bLedIdx].uSideIdx;
			
			topUIdx = ledBrdSide[topLEDboardLowerSideIdx].ushdwIdx;
			bottomUIdx = ledBrdSide[bottomLEDboardUpperSideIdx].ushdwIdx;
			
			for (unsigned char k=0; k<2; k++) //for each board side in the shelf
80009a88:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80009a8c:	2f f8       	sub	r8,-1
80009a8e:	ef 68 ff ff 	st.b	r7[-1],r8
80009a92:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80009a96:	30 18       	mov	r8,1
80009a98:	f0 09 18 00 	cp.b	r9,r8
80009a9c:	fe 98 ff a1 	brls	800099de <increment_ledBoard_usage_min+0xca>
	unsigned char bottomUIdx;
	unsigned char hourRollover = 0;
	
	inc_sanMins();

	for (unsigned char i=0; i<NUM_SHELVES; i++) //check every active shelf
80009aa0:	ef 38 ff fe 	ld.ub	r8,r7[-2]
80009aa4:	2f f8       	sub	r8,-1
80009aa6:	ef 68 ff fe 	st.b	r7[-2],r8
80009aaa:	ef 39 ff fe 	ld.ub	r9,r7[-2]
80009aae:	30 38       	mov	r8,3
80009ab0:	f0 09 18 00 	cp.b	r9,r8
80009ab4:	fe 98 ff 3d 	brls	8000992e <increment_ledBoard_usage_min+0x1a>
				}//if ((minutes %60) == 0)
			} //for each board side in the shelf (k)
		} //if (shelf[i].active)
	} //for (i=0; i<NUM_SHELVES; i++)
	
	mFlashIdx++;
80009ab8:	4a e8       	lddpc	r8,80009b70 <increment_ledBoard_usage_min+0x25c>
80009aba:	70 08       	ld.w	r8,r8[0x0]
80009abc:	f0 c9 ff ff 	sub	r9,r8,-1
80009ac0:	4a c8       	lddpc	r8,80009b70 <increment_ledBoard_usage_min+0x25c>
80009ac2:	91 09       	st.w	r8[0x0],r9
	if (mFlashIdx >= NUM_USAGE_MINS_BUFS_SECTORS)
80009ac4:	4a b8       	lddpc	r8,80009b70 <increment_ledBoard_usage_min+0x25c>
80009ac6:	70 08       	ld.w	r8,r8[0x0]
80009ac8:	e0 48 00 73 	cp.w	r8,115
80009acc:	e0 88 00 05 	brls	80009ad6 <increment_ledBoard_usage_min+0x1c2>
	{
		mFlashIdx = 0;
80009ad0:	4a 88       	lddpc	r8,80009b70 <increment_ledBoard_usage_min+0x25c>
80009ad2:	30 09       	mov	r9,0
80009ad4:	91 09       	st.w	r8[0x0],r9
	}
	m.csum = calc_region_checksum(3);
80009ad6:	30 3c       	mov	r12,3
80009ad8:	f0 1f 00 27 	mcall	80009b74 <increment_ledBoard_usage_min+0x260>
80009adc:	18 98       	mov	r8,r12
80009ade:	4a 29       	lddpc	r9,80009b64 <increment_ledBoard_usage_min+0x250>
80009ae0:	f3 68 00 64 	st.b	r9[100],r8
	write_region_to_flash(3, 0xFF, m.csum);
80009ae4:	4a 08       	lddpc	r8,80009b64 <increment_ledBoard_usage_min+0x250>
80009ae6:	f1 38 00 64 	ld.ub	r8,r8[100]
80009aea:	10 9a       	mov	r10,r8
80009aec:	e0 6b 00 ff 	mov	r11,255
80009af0:	30 3c       	mov	r12,3
80009af2:	f0 1f 00 22 	mcall	80009b78 <increment_ledBoard_usage_min+0x264>
	copy_region_to_another_sector(3);
80009af6:	30 3c       	mov	r12,3
80009af8:	f0 1f 00 21 	mcall	80009b7c <increment_ledBoard_usage_min+0x268>
	disrupt_prior_m_sector();
80009afc:	f0 1f 00 21 	mcall	80009b80 <increment_ledBoard_usage_min+0x26c>

	if (hourRollover)
80009b00:	ef 39 ff fd 	ld.ub	r9,r7[-3]
80009b04:	30 08       	mov	r8,0
80009b06:	f0 09 18 00 	cp.b	r9,r8
80009b0a:	c2 20       	breq	80009b4e <increment_ledBoard_usage_min+0x23a>
	{
		hFlashIdx++;
80009b0c:	49 e8       	lddpc	r8,80009b84 <increment_ledBoard_usage_min+0x270>
80009b0e:	70 08       	ld.w	r8,r8[0x0]
80009b10:	f0 c9 ff ff 	sub	r9,r8,-1
80009b14:	49 c8       	lddpc	r8,80009b84 <increment_ledBoard_usage_min+0x270>
80009b16:	91 09       	st.w	r8[0x0],r9
		if (hFlashIdx >= (NUM_USAGE_HOURS_BUFS_SECTORS/NUM_USAGE_HOURS_SECTORS_PER_BUF))
80009b18:	49 b8       	lddpc	r8,80009b84 <increment_ledBoard_usage_min+0x270>
80009b1a:	70 08       	ld.w	r8,r8[0x0]
80009b1c:	58 18       	cp.w	r8,1
80009b1e:	e0 88 00 05 	brls	80009b28 <increment_ledBoard_usage_min+0x214>
		{
			hFlashIdx = 0;
80009b22:	49 98       	lddpc	r8,80009b84 <increment_ledBoard_usage_min+0x270>
80009b24:	30 09       	mov	r9,0
80009b26:	91 09       	st.w	r8[0x0],r9
		}
		h.csum = calc_region_checksum(2);
80009b28:	30 2c       	mov	r12,2
80009b2a:	f0 1f 00 13 	mcall	80009b74 <increment_ledBoard_usage_min+0x260>
80009b2e:	18 98       	mov	r8,r12
80009b30:	48 e9       	lddpc	r9,80009b68 <increment_ledBoard_usage_min+0x254>
80009b32:	f3 68 00 c0 	st.b	r9[192],r8
		write_region_to_flash(2, 0xFF, h.csum);
80009b36:	48 d8       	lddpc	r8,80009b68 <increment_ledBoard_usage_min+0x254>
80009b38:	f1 38 00 c0 	ld.ub	r8,r8[192]
80009b3c:	10 9a       	mov	r10,r8
80009b3e:	e0 6b 00 ff 	mov	r11,255
80009b42:	30 2c       	mov	r12,2
80009b44:	f0 1f 00 0d 	mcall	80009b78 <increment_ledBoard_usage_min+0x264>

		hourRollover = 0; //reset for next pass
80009b48:	30 08       	mov	r8,0
80009b4a:	ef 68 ff fd 	st.b	r7[-3],r8
	}
}
80009b4e:	2f ed       	sub	sp,-8
80009b50:	e3 cd 80 80 	ldm	sp++,r7,pc
80009b54:	80 00       	ld.sh	r0,r0[0x0]
80009b56:	98 28       	ld.sh	r8,r12[0x4]
80009b58:	00 00       	add	r0,r0
80009b5a:	0b 91       	ld.ub	r1,r5[0x1]
80009b5c:	00 00       	add	r0,r0
80009b5e:	0b 4a       	ld.w	r10,--r5
80009b60:	00 00       	add	r0,r0
80009b62:	0b fe       	ld.ub	lr,r5[0x7]
80009b64:	00 00       	add	r0,r0
80009b66:	0d 08       	ld.w	r8,r6++
80009b68:	00 00       	add	r0,r0
80009b6a:	0c 2c       	rsub	r12,r6
80009b6c:	00 00       	add	r0,r0
80009b6e:	08 48       	or	r8,r4
80009b70:	00 00       	add	r0,r0
80009b72:	07 c8       	ld.ub	r8,r3[0x4]
80009b74:	80 00       	ld.sh	r0,r0[0x0]
80009b76:	89 08       	st.w	r4[0x0],r8
80009b78:	80 00       	ld.sh	r0,r0[0x0]
80009b7a:	92 00       	ld.sh	r0,r9[0x0]
80009b7c:	80 00       	ld.sh	r0,r0[0x0]
80009b7e:	94 98       	ld.uh	r8,r10[0x2]
80009b80:	80 00       	ld.sh	r0,r0[0x0]
80009b82:	96 44       	ld.sh	r4,r11[0x8]
80009b84:	00 00       	add	r0,r0
80009b86:	07 c4       	ld.ub	r4,r3[0x4]

80009b88 <init_shelf_n_ledBrd_structs>:
#endif //SERIAL_ID_AND_ALL_USAGE_COMBINED


void init_shelf_n_ledBrd_structs(void);
void init_shelf_n_ledBrd_structs(void)
{
80009b88:	eb cd 40 80 	pushm	r7,lr
80009b8c:	1a 97       	mov	r7,sp
80009b8e:	20 4d       	sub	sp,16
	
	for (int i=0; i<NUM_SHELVES; i++)
80009b90:	30 08       	mov	r8,0
80009b92:	ef 48 ff f0 	st.w	r7[-16],r8
80009b96:	c2 b8       	rjmp	80009bec <init_shelf_n_ledBrd_structs+0x64>
	{
		shelf[i].present = 0;
80009b98:	ee f9 ff f0 	ld.w	r9,r7[-16]
80009b9c:	fe fa 02 7c 	ld.w	r10,pc[636]
80009ba0:	12 98       	mov	r8,r9
80009ba2:	a3 68       	lsl	r8,0x2
80009ba4:	12 08       	add	r8,r9
80009ba6:	f4 08 00 08 	add	r8,r10,r8
80009baa:	f0 c9 ff fc 	sub	r9,r8,-4
80009bae:	30 08       	mov	r8,0
80009bb0:	b2 88       	st.b	r9[0x0],r8
		shelf[i].devicesPresent = 0;
80009bb2:	ee f9 ff f0 	ld.w	r9,r7[-16]
80009bb6:	fe fa 02 62 	ld.w	r10,pc[610]
80009bba:	12 98       	mov	r8,r9
80009bbc:	a3 68       	lsl	r8,0x2
80009bbe:	12 08       	add	r8,r9
80009bc0:	f4 08 00 08 	add	r8,r10,r8
80009bc4:	f0 c9 ff fd 	sub	r9,r8,-3
80009bc8:	30 08       	mov	r8,0
80009bca:	b2 88       	st.b	r9[0x0],r8
		shelf[i].active = 0;
80009bcc:	ee f9 ff f0 	ld.w	r9,r7[-16]
80009bd0:	fe fa 02 48 	ld.w	r10,pc[584]
80009bd4:	12 98       	mov	r8,r9
80009bd6:	a3 68       	lsl	r8,0x2
80009bd8:	12 08       	add	r8,r9
80009bda:	f4 08 00 09 	add	r9,r10,r8
80009bde:	30 08       	mov	r8,0
80009be0:	b2 88       	st.b	r9[0x0],r8

void init_shelf_n_ledBrd_structs(void);
void init_shelf_n_ledBrd_structs(void)
{
	
	for (int i=0; i<NUM_SHELVES; i++)
80009be2:	ee f8 ff f0 	ld.w	r8,r7[-16]
80009be6:	2f f8       	sub	r8,-1
80009be8:	ef 48 ff f0 	st.w	r7[-16],r8
80009bec:	ee f8 ff f0 	ld.w	r8,r7[-16]
80009bf0:	58 38       	cp.w	r8,3
80009bf2:	fe 9a ff d3 	brle	80009b98 <init_shelf_n_ledBrd_structs+0x10>
		shelf[i].present = 0;
		shelf[i].devicesPresent = 0;
		shelf[i].active = 0;
	}
	
	shelf[0].tLedIdx = 0;
80009bf6:	fe f9 02 22 	ld.w	r9,pc[546]
80009bfa:	30 08       	mov	r8,0
80009bfc:	b2 98       	st.b	r9[0x1],r8
	shelf[0].bLedIdx = 1;
80009bfe:	fe f9 02 1a 	ld.w	r9,pc[538]
80009c02:	30 18       	mov	r8,1
80009c04:	b2 a8       	st.b	r9[0x2],r8
	shelf[1].tLedIdx = 1;
80009c06:	fe f9 02 12 	ld.w	r9,pc[530]
80009c0a:	30 18       	mov	r8,1
80009c0c:	b2 e8       	st.b	r9[0x6],r8
	shelf[1].bLedIdx = 2;
80009c0e:	fe f9 02 0a 	ld.w	r9,pc[522]
80009c12:	30 28       	mov	r8,2
80009c14:	b2 f8       	st.b	r9[0x7],r8
	shelf[2].tLedIdx = 2;
80009c16:	fe f9 02 02 	ld.w	r9,pc[514]
80009c1a:	30 28       	mov	r8,2
80009c1c:	f3 68 00 0b 	st.b	r9[11],r8
	shelf[2].bLedIdx = 3;
80009c20:	4f e9       	lddpc	r9,80009e18 <init_shelf_n_ledBrd_structs+0x290>
80009c22:	30 38       	mov	r8,3
80009c24:	f3 68 00 0c 	st.b	r9[12],r8
	shelf[3].tLedIdx = 3;
80009c28:	4f c9       	lddpc	r9,80009e18 <init_shelf_n_ledBrd_structs+0x290>
80009c2a:	30 38       	mov	r8,3
80009c2c:	f3 68 00 10 	st.b	r9[16],r8
	shelf[3].bLedIdx = 4;
80009c30:	4f a9       	lddpc	r9,80009e18 <init_shelf_n_ledBrd_structs+0x290>
80009c32:	30 48       	mov	r8,4
80009c34:	f3 68 00 11 	st.b	r9[17],r8
	
	for (int i=0; i<NUM_LED_BOARDS; i++)
80009c38:	30 08       	mov	r8,0
80009c3a:	ef 48 ff f4 	st.w	r7[-12],r8
80009c3e:	c1 38       	rjmp	80009c64 <init_shelf_n_ledBrd_structs+0xdc>
	{
		ledBrd[i].present = 0;
80009c40:	ee f9 ff f4 	ld.w	r9,r7[-12]
80009c44:	4f 6a       	lddpc	r10,80009e1c <init_shelf_n_ledBrd_structs+0x294>
80009c46:	12 98       	mov	r8,r9
80009c48:	a3 78       	lsl	r8,0x3
80009c4a:	12 18       	sub	r8,r9
80009c4c:	a1 78       	lsl	r8,0x1
80009c4e:	f4 08 00 08 	add	r8,r10,r8
80009c52:	f0 c9 ff f8 	sub	r9,r8,-8
80009c56:	30 08       	mov	r8,0
80009c58:	b2 88       	st.b	r9[0x0],r8
	shelf[2].tLedIdx = 2;
	shelf[2].bLedIdx = 3;
	shelf[3].tLedIdx = 3;
	shelf[3].bLedIdx = 4;
	
	for (int i=0; i<NUM_LED_BOARDS; i++)
80009c5a:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009c5e:	2f f8       	sub	r8,-1
80009c60:	ef 48 ff f4 	st.w	r7[-12],r8
80009c64:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009c68:	58 48       	cp.w	r8,4
80009c6a:	fe 9a ff eb 	brle	80009c40 <init_shelf_n_ledBrd_structs+0xb8>
	{
		ledBrd[i].present = 0;
	}
	
	ledBrd[0].uSideIdx = 0xFF;
80009c6e:	4e c9       	lddpc	r9,80009e1c <init_shelf_n_ledBrd_structs+0x294>
80009c70:	3f f8       	mov	r8,-1
80009c72:	f3 68 00 0a 	st.b	r9[10],r8
	ledBrd[0].lSideIdx = 0;
80009c76:	4e a9       	lddpc	r9,80009e1c <init_shelf_n_ledBrd_structs+0x294>
80009c78:	30 08       	mov	r8,0
80009c7a:	f3 68 00 0b 	st.b	r9[11],r8
	ledBrd[1].uSideIdx = 1;
80009c7e:	4e 89       	lddpc	r9,80009e1c <init_shelf_n_ledBrd_structs+0x294>
80009c80:	30 18       	mov	r8,1
80009c82:	f3 68 00 18 	st.b	r9[24],r8
	ledBrd[1].lSideIdx = 2;
80009c86:	4e 69       	lddpc	r9,80009e1c <init_shelf_n_ledBrd_structs+0x294>
80009c88:	30 28       	mov	r8,2
80009c8a:	f3 68 00 19 	st.b	r9[25],r8
	ledBrd[2].uSideIdx = 3;
80009c8e:	4e 49       	lddpc	r9,80009e1c <init_shelf_n_ledBrd_structs+0x294>
80009c90:	30 38       	mov	r8,3
80009c92:	f3 68 00 26 	st.b	r9[38],r8
	ledBrd[2].lSideIdx = 4;
80009c96:	4e 29       	lddpc	r9,80009e1c <init_shelf_n_ledBrd_structs+0x294>
80009c98:	30 48       	mov	r8,4
80009c9a:	f3 68 00 27 	st.b	r9[39],r8
	ledBrd[3].uSideIdx = 5;
80009c9e:	4e 09       	lddpc	r9,80009e1c <init_shelf_n_ledBrd_structs+0x294>
80009ca0:	30 58       	mov	r8,5
80009ca2:	f3 68 00 34 	st.b	r9[52],r8
	ledBrd[3].lSideIdx = 6;
80009ca6:	4d e9       	lddpc	r9,80009e1c <init_shelf_n_ledBrd_structs+0x294>
80009ca8:	30 68       	mov	r8,6
80009caa:	f3 68 00 35 	st.b	r9[53],r8
	ledBrd[4].uSideIdx = 7;
80009cae:	4d c9       	lddpc	r9,80009e1c <init_shelf_n_ledBrd_structs+0x294>
80009cb0:	30 78       	mov	r8,7
80009cb2:	f3 68 00 42 	st.b	r9[66],r8
	ledBrd[4].lSideIdx = 0xFF;
80009cb6:	4d a9       	lddpc	r9,80009e1c <init_shelf_n_ledBrd_structs+0x294>
80009cb8:	3f f8       	mov	r8,-1
80009cba:	f3 68 00 43 	st.b	r9[67],r8

	ledBrd[0].uSideShelfIdx = 0xFF;
80009cbe:	4d 89       	lddpc	r9,80009e1c <init_shelf_n_ledBrd_structs+0x294>
80009cc0:	3f f8       	mov	r8,-1
80009cc2:	f3 68 00 0c 	st.b	r9[12],r8
	ledBrd[1].uSideShelfIdx = 0;
80009cc6:	4d 69       	lddpc	r9,80009e1c <init_shelf_n_ledBrd_structs+0x294>
80009cc8:	30 08       	mov	r8,0
80009cca:	f3 68 00 1a 	st.b	r9[26],r8
	ledBrd[2].uSideShelfIdx = 1;
80009cce:	4d 49       	lddpc	r9,80009e1c <init_shelf_n_ledBrd_structs+0x294>
80009cd0:	30 18       	mov	r8,1
80009cd2:	f3 68 00 28 	st.b	r9[40],r8
	ledBrd[3].uSideShelfIdx = 2;
80009cd6:	4d 29       	lddpc	r9,80009e1c <init_shelf_n_ledBrd_structs+0x294>
80009cd8:	30 28       	mov	r8,2
80009cda:	f3 68 00 36 	st.b	r9[54],r8
	ledBrd[4].uSideShelfIdx = 3;
80009cde:	4d 09       	lddpc	r9,80009e1c <init_shelf_n_ledBrd_structs+0x294>
80009ce0:	30 38       	mov	r8,3
80009ce2:	f3 68 00 44 	st.b	r9[68],r8
 
	ledBrd[0].lSideShelfIdx = 0;
80009ce6:	4c e9       	lddpc	r9,80009e1c <init_shelf_n_ledBrd_structs+0x294>
80009ce8:	30 08       	mov	r8,0
80009cea:	f3 68 00 0d 	st.b	r9[13],r8
	ledBrd[1].lSideShelfIdx = 1;
80009cee:	4c c9       	lddpc	r9,80009e1c <init_shelf_n_ledBrd_structs+0x294>
80009cf0:	30 18       	mov	r8,1
80009cf2:	f3 68 00 1b 	st.b	r9[27],r8
	ledBrd[2].lSideShelfIdx = 2;
80009cf6:	4c a9       	lddpc	r9,80009e1c <init_shelf_n_ledBrd_structs+0x294>
80009cf8:	30 28       	mov	r8,2
80009cfa:	f3 68 00 29 	st.b	r9[41],r8
	ledBrd[3].lSideShelfIdx = 3;
80009cfe:	4c 89       	lddpc	r9,80009e1c <init_shelf_n_ledBrd_structs+0x294>
80009d00:	30 38       	mov	r8,3
80009d02:	f3 68 00 37 	st.b	r9[55],r8
	ledBrd[4].lSideShelfIdx = 0xFF;
80009d06:	4c 69       	lddpc	r9,80009e1c <init_shelf_n_ledBrd_structs+0x294>
80009d08:	3f f8       	mov	r8,-1
80009d0a:	f3 68 00 45 	st.b	r9[69],r8
	

	for (int i=0; i<NUM_LED_BOARD_SIDES; i++)
80009d0e:	30 08       	mov	r8,0
80009d10:	ef 48 ff f8 	st.w	r7[-8],r8
80009d14:	c2 88       	rjmp	80009d64 <init_shelf_n_ledBrd_structs+0x1dc>
	{
		ledBrdSide[i].maxUsageReached = 0;
80009d16:	ee f9 ff f8 	ld.w	r9,r7[-8]
80009d1a:	4c 2a       	lddpc	r10,80009e20 <init_shelf_n_ledBrd_structs+0x298>
80009d1c:	12 98       	mov	r8,r9
80009d1e:	a3 68       	lsl	r8,0x2
80009d20:	12 08       	add	r8,r9
80009d22:	f4 08 00 08 	add	r8,r10,r8
80009d26:	f0 c9 ff fe 	sub	r9,r8,-2
80009d2a:	30 08       	mov	r8,0
80009d2c:	b2 88       	st.b	r9[0x0],r8
		ledBrdSide[i].sanitizeMinutes = 0;
80009d2e:	ee f9 ff f8 	ld.w	r9,r7[-8]
80009d32:	4b ca       	lddpc	r10,80009e20 <init_shelf_n_ledBrd_structs+0x298>
80009d34:	12 98       	mov	r8,r9
80009d36:	a3 68       	lsl	r8,0x2
80009d38:	12 08       	add	r8,r9
80009d3a:	f4 08 00 09 	add	r9,r10,r8
80009d3e:	30 08       	mov	r8,0
80009d40:	b2 88       	st.b	r9[0x0],r8
		ledBrdSide[i].ushdwIdx = 0xFF;
80009d42:	ee f9 ff f8 	ld.w	r9,r7[-8]
80009d46:	4b 7a       	lddpc	r10,80009e20 <init_shelf_n_ledBrd_structs+0x298>
80009d48:	12 98       	mov	r8,r9
80009d4a:	a3 68       	lsl	r8,0x2
80009d4c:	12 08       	add	r8,r9
80009d4e:	f4 08 00 08 	add	r8,r10,r8
80009d52:	f0 c9 ff ff 	sub	r9,r8,-1
80009d56:	3f f8       	mov	r8,-1
80009d58:	b2 88       	st.b	r9[0x0],r8
	ledBrd[2].lSideShelfIdx = 2;
	ledBrd[3].lSideShelfIdx = 3;
	ledBrd[4].lSideShelfIdx = 0xFF;
	

	for (int i=0; i<NUM_LED_BOARD_SIDES; i++)
80009d5a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80009d5e:	2f f8       	sub	r8,-1
80009d60:	ef 48 ff f8 	st.w	r7[-8],r8
80009d64:	ee f8 ff f8 	ld.w	r8,r7[-8]
80009d68:	58 78       	cp.w	r8,7
80009d6a:	fe 9a ff d6 	brle	80009d16 <init_shelf_n_ledBrd_structs+0x18e>
		ledBrdSide[i].maxUsageReached = 0;
		ledBrdSide[i].sanitizeMinutes = 0;
		ledBrdSide[i].ushdwIdx = 0xFF;
	}
	
	ledBrdSide[0].boardIdx = 0;
80009d6e:	4a d9       	lddpc	r9,80009e20 <init_shelf_n_ledBrd_structs+0x298>
80009d70:	30 08       	mov	r8,0
80009d72:	b2 c8       	st.b	r9[0x4],r8
	ledBrdSide[1].boardIdx = 1;
80009d74:	4a b9       	lddpc	r9,80009e20 <init_shelf_n_ledBrd_structs+0x298>
80009d76:	30 18       	mov	r8,1
80009d78:	f3 68 00 09 	st.b	r9[9],r8
	ledBrdSide[2].boardIdx = 1;
80009d7c:	4a 99       	lddpc	r9,80009e20 <init_shelf_n_ledBrd_structs+0x298>
80009d7e:	30 18       	mov	r8,1
80009d80:	f3 68 00 0e 	st.b	r9[14],r8
	ledBrdSide[3].boardIdx = 2;
80009d84:	4a 79       	lddpc	r9,80009e20 <init_shelf_n_ledBrd_structs+0x298>
80009d86:	30 28       	mov	r8,2
80009d88:	f3 68 00 13 	st.b	r9[19],r8
	ledBrdSide[4].boardIdx = 2;
80009d8c:	4a 59       	lddpc	r9,80009e20 <init_shelf_n_ledBrd_structs+0x298>
80009d8e:	30 28       	mov	r8,2
80009d90:	f3 68 00 18 	st.b	r9[24],r8
	ledBrdSide[5].boardIdx = 3;
80009d94:	4a 39       	lddpc	r9,80009e20 <init_shelf_n_ledBrd_structs+0x298>
80009d96:	30 38       	mov	r8,3
80009d98:	f3 68 00 1d 	st.b	r9[29],r8
	ledBrdSide[6].boardIdx = 3;
80009d9c:	4a 19       	lddpc	r9,80009e20 <init_shelf_n_ledBrd_structs+0x298>
80009d9e:	30 38       	mov	r8,3
80009da0:	f3 68 00 22 	st.b	r9[34],r8
	ledBrdSide[7].boardIdx = 4;
80009da4:	49 f9       	lddpc	r9,80009e20 <init_shelf_n_ledBrd_structs+0x298>
80009da6:	30 48       	mov	r8,4
80009da8:	f3 68 00 27 	st.b	r9[39],r8
	

	ledBrdSide[0].shelfIdx = 0;
80009dac:	49 d9       	lddpc	r9,80009e20 <init_shelf_n_ledBrd_structs+0x298>
80009dae:	30 08       	mov	r8,0
80009db0:	b2 b8       	st.b	r9[0x3],r8
	ledBrdSide[1].shelfIdx = 0;
80009db2:	49 c9       	lddpc	r9,80009e20 <init_shelf_n_ledBrd_structs+0x298>
80009db4:	30 08       	mov	r8,0
80009db6:	f3 68 00 08 	st.b	r9[8],r8
	ledBrdSide[2].shelfIdx = 1;
80009dba:	49 a9       	lddpc	r9,80009e20 <init_shelf_n_ledBrd_structs+0x298>
80009dbc:	30 18       	mov	r8,1
80009dbe:	f3 68 00 0d 	st.b	r9[13],r8
	ledBrdSide[3].shelfIdx = 1;
80009dc2:	49 89       	lddpc	r9,80009e20 <init_shelf_n_ledBrd_structs+0x298>
80009dc4:	30 18       	mov	r8,1
80009dc6:	f3 68 00 12 	st.b	r9[18],r8
	ledBrdSide[4].shelfIdx = 2;
80009dca:	49 69       	lddpc	r9,80009e20 <init_shelf_n_ledBrd_structs+0x298>
80009dcc:	30 28       	mov	r8,2
80009dce:	f3 68 00 17 	st.b	r9[23],r8
	ledBrdSide[5].shelfIdx = 2;
80009dd2:	49 49       	lddpc	r9,80009e20 <init_shelf_n_ledBrd_structs+0x298>
80009dd4:	30 28       	mov	r8,2
80009dd6:	f3 68 00 1c 	st.b	r9[28],r8
	ledBrdSide[6].shelfIdx = 3;
80009dda:	49 29       	lddpc	r9,80009e20 <init_shelf_n_ledBrd_structs+0x298>
80009ddc:	30 38       	mov	r8,3
80009dde:	f3 68 00 21 	st.b	r9[33],r8
	ledBrdSide[7].shelfIdx = 3;
80009de2:	49 09       	lddpc	r9,80009e20 <init_shelf_n_ledBrd_structs+0x298>
80009de4:	30 38       	mov	r8,3
80009de6:	f3 68 00 26 	st.b	r9[38],r8
		{
			usageIdx[i][j] = NO_LED_BOARD_PRESENT;
		}
	}
#else
	for (int j=0; j<NUM_LED_BOARD_SIDES; j++)
80009dea:	30 08       	mov	r8,0
80009dec:	ef 48 ff fc 	st.w	r7[-4],r8
80009df0:	c0 c8       	rjmp	80009e08 <init_shelf_n_ledBrd_structs+0x280>
	{
		usageIdx[j] = NO_LED_BOARD_PRESENT;
80009df2:	ee f9 ff fc 	ld.w	r9,r7[-4]
80009df6:	48 ca       	lddpc	r10,80009e24 <init_shelf_n_ledBrd_structs+0x29c>
80009df8:	3f f8       	mov	r8,-1
80009dfa:	f4 09 0b 08 	st.b	r10[r9],r8
		{
			usageIdx[i][j] = NO_LED_BOARD_PRESENT;
		}
	}
#else
	for (int j=0; j<NUM_LED_BOARD_SIDES; j++)
80009dfe:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009e02:	2f f8       	sub	r8,-1
80009e04:	ef 48 ff fc 	st.w	r7[-4],r8
80009e08:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009e0c:	58 78       	cp.w	r8,7
80009e0e:	fe 9a ff f2 	brle	80009df2 <init_shelf_n_ledBrd_structs+0x26a>
	{
		usageIdx[j] = NO_LED_BOARD_PRESENT;
	}
#endif

}
80009e12:	2f cd       	sub	sp,-16
80009e14:	e3 cd 80 80 	ldm	sp++,r7,pc
80009e18:	00 00       	add	r0,r0
80009e1a:	0b 91       	ld.ub	r1,r5[0x1]
80009e1c:	00 00       	add	r0,r0
80009e1e:	0b 4a       	ld.w	r10,--r5
80009e20:	00 00       	add	r0,r0
80009e22:	0b fe       	ld.ub	lr,r5[0x7]
80009e24:	00 00       	add	r0,r0
80009e26:	0b c0       	ld.ub	r0,r5[0x4]

80009e28 <load_usageIdx_to_ledBrdSide>:

#else

void load_usageIdx_to_ledBrdSide(void);
void load_usageIdx_to_ledBrdSide(void)
{
80009e28:	eb cd 40 80 	pushm	r7,lr
80009e2c:	1a 97       	mov	r7,sp
80009e2e:	20 1d       	sub	sp,4
	for (int i=0; i<NUM_LED_BOARD_SIDES; i++)
80009e30:	30 08       	mov	r8,0
80009e32:	ef 48 ff fc 	st.w	r7[-4],r8
80009e36:	c1 78       	rjmp	80009e64 <load_usageIdx_to_ledBrdSide+0x3c>
	{
		ledBrdSide[i].ushdwIdx = usageIdx[i];
80009e38:	ee f9 ff fc 	ld.w	r9,r7[-4]
80009e3c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009e40:	48 da       	lddpc	r10,80009e74 <load_usageIdx_to_ledBrdSide+0x4c>
80009e42:	f4 08 07 0a 	ld.ub	r10,r10[r8]
80009e46:	48 db       	lddpc	r11,80009e78 <load_usageIdx_to_ledBrdSide+0x50>
80009e48:	12 98       	mov	r8,r9
80009e4a:	a3 68       	lsl	r8,0x2
80009e4c:	12 08       	add	r8,r9
80009e4e:	f6 08 00 08 	add	r8,r11,r8
80009e52:	f0 c9 ff ff 	sub	r9,r8,-1
80009e56:	14 98       	mov	r8,r10
80009e58:	b2 88       	st.b	r9[0x0],r8
#else

void load_usageIdx_to_ledBrdSide(void);
void load_usageIdx_to_ledBrdSide(void)
{
	for (int i=0; i<NUM_LED_BOARD_SIDES; i++)
80009e5a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009e5e:	2f f8       	sub	r8,-1
80009e60:	ef 48 ff fc 	st.w	r7[-4],r8
80009e64:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009e68:	58 78       	cp.w	r8,7
80009e6a:	fe 9a ff e7 	brle	80009e38 <load_usageIdx_to_ledBrdSide+0x10>
	{
		ledBrdSide[i].ushdwIdx = usageIdx[i];
	}
}
80009e6e:	2f fd       	sub	sp,-4
80009e70:	e3 cd 80 80 	ldm	sp++,r7,pc
80009e74:	00 00       	add	r0,r0
80009e76:	0b c0       	ld.ub	r0,r5[0x4]
80009e78:	00 00       	add	r0,r0
80009e7a:	0b fe       	ld.ub	lr,r5[0x7]

80009e7c <init_led_board_info>:

#endif //SERIAL_ID_AND_ALL_USAGE_COMBINED

void init_led_board_info(void);
void init_led_board_info(void)
{
80009e7c:	eb cd 40 c0 	pushm	r6-r7,lr
80009e80:	1a 97       	mov	r7,sp
80009e82:	20 6d       	sub	sp,24
	unsigned char regionGood[5];
	unsigned char csum;
	
	for (int i=0; i<5; i++)
80009e84:	30 08       	mov	r8,0
80009e86:	ef 48 ff f0 	st.w	r7[-16],r8
80009e8a:	c1 38       	rjmp	80009eb0 <init_led_board_info+0x34>
	{
		regionGood[i] = eval_region(i);
80009e8c:	ee f6 ff f0 	ld.w	r6,r7[-16]
80009e90:	ee f8 ff f0 	ld.w	r8,r7[-16]
80009e94:	5c 58       	castu.b	r8
80009e96:	10 9c       	mov	r12,r8
80009e98:	f0 1f 00 81 	mcall	8000a09c <init_led_board_info+0x220>
80009e9c:	18 98       	mov	r8,r12
80009e9e:	ee 06 00 09 	add	r9,r7,r6
80009ea2:	f3 68 ff e8 	st.b	r9[-24],r8
void init_led_board_info(void)
{
	unsigned char regionGood[5];
	unsigned char csum;
	
	for (int i=0; i<5; i++)
80009ea6:	ee f8 ff f0 	ld.w	r8,r7[-16]
80009eaa:	2f f8       	sub	r8,-1
80009eac:	ef 48 ff f0 	st.w	r7[-16],r8
80009eb0:	ee f8 ff f0 	ld.w	r8,r7[-16]
80009eb4:	58 48       	cp.w	r8,4
80009eb6:	fe 9a ff eb 	brle	80009e8c <init_led_board_info+0x10>
	{
		regionGood[i] = eval_region(i);
	}
	
	if (regionGood[0] && regionGood[1] && regionGood[2] && regionGood[3] && regionGood[4])
80009eba:	ef 38 ff e8 	ld.ub	r8,r7[-24]
80009ebe:	58 08       	cp.w	r8,0
80009ec0:	c7 00       	breq	80009fa0 <init_led_board_info+0x124>
80009ec2:	ef 38 ff e9 	ld.ub	r8,r7[-23]
80009ec6:	58 08       	cp.w	r8,0
80009ec8:	c6 c0       	breq	80009fa0 <init_led_board_info+0x124>
80009eca:	ef 38 ff ea 	ld.ub	r8,r7[-22]
80009ece:	58 08       	cp.w	r8,0
80009ed0:	c6 80       	breq	80009fa0 <init_led_board_info+0x124>
80009ed2:	ef 38 ff eb 	ld.ub	r8,r7[-21]
80009ed6:	58 08       	cp.w	r8,0
80009ed8:	c6 40       	breq	80009fa0 <init_led_board_info+0x124>
80009eda:	ef 38 ff ec 	ld.ub	r8,r7[-20]
80009ede:	58 08       	cp.w	r8,0
80009ee0:	c6 00       	breq	80009fa0 <init_led_board_info+0x124>
	{
		print_ecdbg("All 5 flash regions have good data sets.\r\n");
80009ee2:	4f 0c       	lddpc	r12,8000a0a0 <init_led_board_info+0x224>
80009ee4:	f0 1f 00 70 	mcall	8000a0a4 <init_led_board_info+0x228>

		load_usage_indeces();
80009ee8:	f0 1f 00 70 	mcall	8000a0a8 <init_led_board_info+0x22c>
		
		add_new_led_board_sides_to_usage();
80009eec:	f0 1f 00 70 	mcall	8000a0ac <init_led_board_info+0x230>
		load_usageIdx_to_ledBrdSide();
80009ef0:	f0 1f 00 70 	mcall	8000a0b0 <init_led_board_info+0x234>

		//serial ID and flags
		csum = calc_region_checksum(0);
80009ef4:	30 0c       	mov	r12,0
80009ef6:	f0 1f 00 70 	mcall	8000a0b4 <init_led_board_info+0x238>
80009efa:	18 98       	mov	r8,r12
80009efc:	ef 68 ff ef 	st.b	r7[-17],r8
		write_region_to_flash(0, 0xFF, csum);
80009f00:	ef 38 ff ef 	ld.ub	r8,r7[-17]
80009f04:	10 9a       	mov	r10,r8
80009f06:	e0 6b 00 ff 	mov	r11,255
80009f0a:	30 0c       	mov	r12,0
80009f0c:	f0 1f 00 6b 	mcall	8000a0b8 <init_led_board_info+0x23c>
		copy_region_to_another_sector(0);
80009f10:	30 0c       	mov	r12,0
80009f12:	f0 1f 00 6b 	mcall	8000a0bc <init_led_board_info+0x240>

		//san cycles
		csum = calc_region_checksum(1);
80009f16:	30 1c       	mov	r12,1
80009f18:	f0 1f 00 67 	mcall	8000a0b4 <init_led_board_info+0x238>
80009f1c:	18 98       	mov	r8,r12
80009f1e:	ef 68 ff ef 	st.b	r7[-17],r8
		write_region_to_flash(1,  0xFF, csum);
80009f22:	ef 38 ff ef 	ld.ub	r8,r7[-17]
80009f26:	10 9a       	mov	r10,r8
80009f28:	e0 6b 00 ff 	mov	r11,255
80009f2c:	30 1c       	mov	r12,1
80009f2e:	f0 1f 00 63 	mcall	8000a0b8 <init_led_board_info+0x23c>
		copy_region_to_another_sector(1);
80009f32:	30 1c       	mov	r12,1
80009f34:	f0 1f 00 62 	mcall	8000a0bc <init_led_board_info+0x240>

		//usage hours
		csum = calc_region_checksum(2);
80009f38:	30 2c       	mov	r12,2
80009f3a:	f0 1f 00 5f 	mcall	8000a0b4 <init_led_board_info+0x238>
80009f3e:	18 98       	mov	r8,r12
80009f40:	ef 68 ff ef 	st.b	r7[-17],r8
		write_region_to_flash(2,  0xFF, csum);
80009f44:	ef 38 ff ef 	ld.ub	r8,r7[-17]
80009f48:	10 9a       	mov	r10,r8
80009f4a:	e0 6b 00 ff 	mov	r11,255
80009f4e:	30 2c       	mov	r12,2
80009f50:	f0 1f 00 5a 	mcall	8000a0b8 <init_led_board_info+0x23c>
		copy_region_to_another_sector(2);
80009f54:	30 2c       	mov	r12,2
80009f56:	f0 1f 00 5a 	mcall	8000a0bc <init_led_board_info+0x240>

		//usage minutes
		csum = calc_region_checksum(3);
80009f5a:	30 3c       	mov	r12,3
80009f5c:	f0 1f 00 56 	mcall	8000a0b4 <init_led_board_info+0x238>
80009f60:	18 98       	mov	r8,r12
80009f62:	ef 68 ff ef 	st.b	r7[-17],r8
		write_region_to_flash(3,  0xFF, csum);
80009f66:	ef 38 ff ef 	ld.ub	r8,r7[-17]
80009f6a:	10 9a       	mov	r10,r8
80009f6c:	e0 6b 00 ff 	mov	r11,255
80009f70:	30 3c       	mov	r12,3
80009f72:	f0 1f 00 52 	mcall	8000a0b8 <init_led_board_info+0x23c>
		copy_region_to_another_sector(3);
80009f76:	30 3c       	mov	r12,3
80009f78:	f0 1f 00 51 	mcall	8000a0bc <init_led_board_info+0x240>

		//configuration
		csum = calc_region_checksum(4);
80009f7c:	30 4c       	mov	r12,4
80009f7e:	f0 1f 00 4e 	mcall	8000a0b4 <init_led_board_info+0x238>
80009f82:	18 98       	mov	r8,r12
80009f84:	ef 68 ff ef 	st.b	r7[-17],r8
		write_region_to_flash(4,  0xFF, csum);
80009f88:	ef 38 ff ef 	ld.ub	r8,r7[-17]
80009f8c:	10 9a       	mov	r10,r8
80009f8e:	e0 6b 00 ff 	mov	r11,255
80009f92:	30 4c       	mov	r12,4
80009f94:	f0 1f 00 49 	mcall	8000a0b8 <init_led_board_info+0x23c>
		copy_region_to_another_sector(4);
80009f98:	30 4c       	mov	r12,4
80009f9a:	f0 1f 00 49 	mcall	8000a0bc <init_led_board_info+0x240>
	for (int i=0; i<5; i++)
	{
		regionGood[i] = eval_region(i);
	}
	
	if (regionGood[0] && regionGood[1] && regionGood[2] && regionGood[3] && regionGood[4])
80009f9e:	c7 c8       	rjmp	8000a096 <init_led_board_info+0x21a>
		copy_region_to_another_sector(4);

	}
	else
	{
		memset(&sf, 0x00, sizeof(sf));		//serial id's and flags
80009fa0:	e0 6a 03 00 	mov	r10,768
80009fa4:	30 0b       	mov	r11,0
80009fa6:	4c 7c       	lddpc	r12,8000a0c0 <init_led_board_info+0x244>
80009fa8:	f0 1f 00 47 	mcall	8000a0c4 <init_led_board_info+0x248>
		memset(&sanc, 0x00, sizeof(sanc));	//total chassis sanitation cycles
80009fac:	30 4a       	mov	r10,4
80009fae:	30 0b       	mov	r11,0
80009fb0:	4c 6c       	lddpc	r12,8000a0c8 <init_led_board_info+0x24c>
80009fb2:	f0 1f 00 45 	mcall	8000a0c4 <init_led_board_info+0x248>
		memset(&h, 0x00, sizeof(h));		//usage hours
80009fb6:	e0 6a 00 c2 	mov	r10,194
80009fba:	30 0b       	mov	r11,0
80009fbc:	4c 4c       	lddpc	r12,8000a0cc <init_led_board_info+0x250>
80009fbe:	f0 1f 00 42 	mcall	8000a0c4 <init_led_board_info+0x248>
		memset(&m, 0x00, sizeof(m));		//usage minutes
80009fc2:	36 8a       	mov	r10,104
80009fc4:	30 0b       	mov	r11,0
80009fc6:	4c 3c       	lddpc	r12,8000a0d0 <init_led_board_info+0x254>
80009fc8:	f0 1f 00 3f 	mcall	8000a0c4 <init_led_board_info+0x248>
		memset(&c, 0x00, sizeof(c));		//configuration
80009fcc:	30 2a       	mov	r10,2
80009fce:	30 0b       	mov	r11,0
80009fd0:	4c 1c       	lddpc	r12,8000a0d4 <init_led_board_info+0x258>
80009fd2:	f0 1f 00 3d 	mcall	8000a0c4 <init_led_board_info+0x248>
		c.initialDTE = 30; //changed to 30 minutes for a sanitation test for new LEDs 16jan16
80009fd6:	4c 09       	lddpc	r9,8000a0d4 <init_led_board_info+0x258>
80009fd8:	31 e8       	mov	r8,30
80009fda:	b2 88       	st.b	r9[0x0],r8

		for (int i=0; i<5; i++)
80009fdc:	30 08       	mov	r8,0
80009fde:	ef 48 ff f4 	st.w	r7[-12],r8
80009fe2:	c2 98       	rjmp	8000a034 <init_led_board_info+0x1b8>
		{
			if (test_flash(i) == ERROR)
80009fe4:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009fe8:	5c 58       	castu.b	r8
80009fea:	10 9c       	mov	r12,r8
80009fec:	f0 1f 00 3b 	mcall	8000a0d8 <init_led_board_info+0x25c>
80009ff0:	18 98       	mov	r8,r12
80009ff2:	10 99       	mov	r9,r8
80009ff4:	30 18       	mov	r8,1
80009ff6:	f0 09 18 00 	cp.b	r9,r8
80009ffa:	c1 81       	brne	8000a02a <init_led_board_info+0x1ae>
			{
				print_ecdbg("Flash area ERROR: region ");
80009ffc:	4b 8c       	lddpc	r12,8000a0dc <init_led_board_info+0x260>
80009ffe:	f0 1f 00 2a 	mcall	8000a0a4 <init_led_board_info+0x228>
				print_ecdbg_num(i);
8000a002:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000a006:	10 9c       	mov	r12,r8
8000a008:	f0 1f 00 36 	mcall	8000a0e0 <init_led_board_info+0x264>
				print_ecdbg("\r\n");
8000a00c:	4b 6c       	lddpc	r12,8000a0e4 <init_led_board_info+0x268>
8000a00e:	f0 1f 00 26 	mcall	8000a0a4 <init_led_board_info+0x228>
				sysErr.flashArea |= BIT(i); //SE_FAIL;
8000a012:	4b 68       	lddpc	r8,8000a0e8 <init_led_board_info+0x26c>
8000a014:	70 29       	ld.w	r9,r8[0x8]
8000a016:	30 1a       	mov	r10,1
8000a018:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000a01c:	f4 08 09 48 	lsl	r8,r10,r8
8000a020:	10 49       	or	r9,r8
8000a022:	4b 28       	lddpc	r8,8000a0e8 <init_led_board_info+0x26c>
8000a024:	91 29       	st.w	r8[0x8],r9
				chassis_error();
8000a026:	f0 1f 00 32 	mcall	8000a0ec <init_led_board_info+0x270>
		memset(&h, 0x00, sizeof(h));		//usage hours
		memset(&m, 0x00, sizeof(m));		//usage minutes
		memset(&c, 0x00, sizeof(c));		//configuration
		c.initialDTE = 30; //changed to 30 minutes for a sanitation test for new LEDs 16jan16

		for (int i=0; i<5; i++)
8000a02a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000a02e:	2f f8       	sub	r8,-1
8000a030:	ef 48 ff f4 	st.w	r7[-12],r8
8000a034:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000a038:	58 48       	cp.w	r8,4
8000a03a:	fe 9a ff d5 	brle	80009fe4 <init_led_board_info+0x168>
				sysErr.flashArea |= BIT(i); //SE_FAIL;
				chassis_error();
			}

		}
		add_new_led_board_sides_to_usage();
8000a03e:	f0 1f 00 1c 	mcall	8000a0ac <init_led_board_info+0x230>
		load_usageIdx_to_ledBrdSide();
8000a042:	f0 1f 00 1c 	mcall	8000a0b0 <init_led_board_info+0x234>

		for (int i=0; i<5; i++)
8000a046:	30 08       	mov	r8,0
8000a048:	ef 48 ff f8 	st.w	r7[-8],r8
8000a04c:	c2 08       	rjmp	8000a08c <init_led_board_info+0x210>
		{
			unsigned char csum;
			csum = calc_region_checksum(i);
8000a04e:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000a052:	5c 58       	castu.b	r8
8000a054:	10 9c       	mov	r12,r8
8000a056:	f0 1f 00 18 	mcall	8000a0b4 <init_led_board_info+0x238>
8000a05a:	18 98       	mov	r8,r12
8000a05c:	ef 68 ff ff 	st.b	r7[-1],r8
			write_region_to_flash(i,  0xFF, csum);
8000a060:	ef 39 ff ff 	ld.ub	r9,r7[-1]
8000a064:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000a068:	5c 58       	castu.b	r8
8000a06a:	12 9a       	mov	r10,r9
8000a06c:	e0 6b 00 ff 	mov	r11,255
8000a070:	10 9c       	mov	r12,r8
8000a072:	f0 1f 00 12 	mcall	8000a0b8 <init_led_board_info+0x23c>
			copy_region_to_another_sector(i);
8000a076:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000a07a:	5c 58       	castu.b	r8
8000a07c:	10 9c       	mov	r12,r8
8000a07e:	f0 1f 00 10 	mcall	8000a0bc <init_led_board_info+0x240>

		}
		add_new_led_board_sides_to_usage();
		load_usageIdx_to_ledBrdSide();

		for (int i=0; i<5; i++)
8000a082:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000a086:	2f f8       	sub	r8,-1
8000a088:	ef 48 ff f8 	st.w	r7[-8],r8
8000a08c:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000a090:	58 48       	cp.w	r8,4
8000a092:	fe 9a ff de 	brle	8000a04e <init_led_board_info+0x1d2>
			csum = calc_region_checksum(i);
			write_region_to_flash(i,  0xFF, csum);
			copy_region_to_another_sector(i);
		}
	}
}
8000a096:	2f ad       	sub	sp,-24
8000a098:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000a09c:	80 00       	ld.sh	r0,r0[0x0]
8000a09e:	8b 60       	st.w	r5[0x18],r0
8000a0a0:	80 00       	ld.sh	r0,r0[0x0]
8000a0a2:	68 2c       	ld.w	r12,r4[0x8]
8000a0a4:	80 00       	ld.sh	r0,r0[0x0]
8000a0a6:	33 38       	mov	r8,51
8000a0a8:	80 00       	ld.sh	r0,r0[0x0]
8000a0aa:	87 28       	st.w	r3[0x8],r8
8000a0ac:	80 00       	ld.sh	r0,r0[0x0]
8000a0ae:	96 fc       	ld.uh	r12,r11[0xe]
8000a0b0:	80 00       	ld.sh	r0,r0[0x0]
8000a0b2:	9e 28       	ld.sh	r8,pc[0x4]
8000a0b4:	80 00       	ld.sh	r0,r0[0x0]
8000a0b6:	89 08       	st.w	r4[0x0],r8
8000a0b8:	80 00       	ld.sh	r0,r0[0x0]
8000a0ba:	92 00       	ld.sh	r0,r9[0x0]
8000a0bc:	80 00       	ld.sh	r0,r0[0x0]
8000a0be:	94 98       	ld.uh	r8,r10[0x2]
8000a0c0:	00 00       	add	r0,r0
8000a0c2:	08 48       	or	r8,r4
8000a0c4:	80 00       	ld.sh	r0,r0[0x0]
8000a0c6:	ce 02       	brcc	8000a086 <init_led_board_info+0x20a>
8000a0c8:	00 00       	add	r0,r0
8000a0ca:	0c 28       	rsub	r8,r6
8000a0cc:	00 00       	add	r0,r0
8000a0ce:	0c 2c       	rsub	r12,r6
8000a0d0:	00 00       	add	r0,r0
8000a0d2:	0d 08       	ld.w	r8,r6++
8000a0d4:	00 00       	add	r0,r0
8000a0d6:	0b fc       	ld.ub	r12,r5[0x7]
8000a0d8:	80 00       	ld.sh	r0,r0[0x0]
8000a0da:	87 e4       	st.w	r3[0x38],r4
8000a0dc:	80 00       	ld.sh	r0,r0[0x0]
8000a0de:	68 58       	ld.w	r8,r4[0x14]
8000a0e0:	80 00       	ld.sh	r0,r0[0x0]
8000a0e2:	73 50       	ld.w	r0,r9[0x54]
8000a0e4:	80 00       	ld.sh	r0,r0[0x0]
8000a0e6:	64 ec       	ld.w	r12,r2[0x38]
8000a0e8:	00 00       	add	r0,r0
8000a0ea:	0b d4       	ld.ub	r4,r5[0x5]
8000a0ec:	80 00       	ld.sh	r0,r0[0x0]
8000a0ee:	72 6c       	ld.w	r12,r9[0x18]

8000a0f0 <show_sw_version>:


void show_sw_version(void);
void show_sw_version(void)
{
8000a0f0:	eb cd 40 80 	pushm	r7,lr
8000a0f4:	1a 97       	mov	r7,sp
	print_ecdbg("\r\n*---------------------------------------------------*\r\n");
8000a0f6:	48 6c       	lddpc	r12,8000a10c <show_sw_version+0x1c>
8000a0f8:	f0 1f 00 06 	mcall	8000a110 <show_sw_version+0x20>
	print_ecdbg(    "ELECTROCLAVE\r\nCopyright (c) 2016 Seal Shield, Inc. \r\n");
8000a0fc:	48 6c       	lddpc	r12,8000a114 <show_sw_version+0x24>
8000a0fe:	f0 1f 00 05 	mcall	8000a110 <show_sw_version+0x20>
	print_ecdbg(    "Hardware Version: Classic +++ Software Version: 0.077\r\n");
8000a102:	48 6c       	lddpc	r12,8000a118 <show_sw_version+0x28>
8000a104:	f0 1f 00 03 	mcall	8000a110 <show_sw_version+0x20>

}
8000a108:	e3 cd 80 80 	ldm	sp++,r7,pc
8000a10c:	80 00       	ld.sh	r0,r0[0x0]
8000a10e:	68 74       	ld.w	r4,r4[0x1c]
8000a110:	80 00       	ld.sh	r0,r0[0x0]
8000a112:	33 38       	mov	r8,51
8000a114:	80 00       	ld.sh	r0,r0[0x0]
8000a116:	68 b0       	ld.w	r0,r4[0x2c]
8000a118:	80 00       	ld.sh	r0,r0[0x0]
8000a11a:	68 e8       	ld.w	r8,r4[0x38]

8000a11c <show_chassis_status_info>:

void show_chassis_status_info(void);
void show_chassis_status_info(void)
{
8000a11c:	eb cd 40 ef 	pushm	r0-r3,r5-r7,lr
8000a120:	1a 97       	mov	r7,sp
8000a122:	21 ad       	sub	sp,104
	char pStr[80];
	unsigned char uSideIdx, lSideIdx, uSideUsageIdx, lSideUsageIdx;
	unsigned char sanMinutesMax = 0, sanMinutesMin = 0xFF, sanMinutesUpper, sanMinutesLower, uMins, lMins;
8000a124:	30 08       	mov	r8,0
8000a126:	ef 68 ff ee 	st.b	r7[-18],r8
8000a12a:	3f f8       	mov	r8,-1
8000a12c:	ef 68 ff ef 	st.b	r7[-17],r8
	unsigned int uHrs, lHrs;
	
	print_ecdbg("\r\n***INSTALLED LED BOARDS***\r\n\r\n");
8000a130:	fe fc 04 18 	ld.w	r12,pc[1048]
8000a134:	f0 1f 01 06 	mcall	8000a54c <show_chassis_status_info+0x430>
	
	print_ecdbg(" LED | LED BOARD    |   UPPER SIDE     |   LOWER SIDE    \r\n");
8000a138:	fe fc 04 18 	ld.w	r12,pc[1048]
8000a13c:	f0 1f 01 04 	mcall	8000a54c <show_chassis_status_info+0x430>
	print_ecdbg("SLOT |    ID        | HRS:MIN    DTE   | HRS:MIN    DTE   \r\n");
8000a140:	fe fc 04 14 	ld.w	r12,pc[1044]
8000a144:	f0 1f 01 02 	mcall	8000a54c <show_chassis_status_info+0x430>
	print_ecdbg("----------------------------------------------------------\r\n");
8000a148:	fe fc 04 10 	ld.w	r12,pc[1040]
8000a14c:	f0 1f 01 00 	mcall	8000a54c <show_chassis_status_info+0x430>
	
	for (int i=0; i<NUM_LED_BOARDS; i++)
8000a150:	30 08       	mov	r8,0
8000a152:	ef 48 ff fc 	st.w	r7[-4],r8
8000a156:	c8 e9       	rjmp	8000a472 <show_chassis_status_info+0x356>
	{
		if (ledBrd[i].present)
8000a158:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000a15c:	fe fa 04 00 	ld.w	r10,pc[1024]
8000a160:	12 98       	mov	r8,r9
8000a162:	a3 78       	lsl	r8,0x3
8000a164:	12 18       	sub	r8,r9
8000a166:	a1 78       	lsl	r8,0x1
8000a168:	f4 08 00 08 	add	r8,r10,r8
8000a16c:	2f 88       	sub	r8,-8
8000a16e:	11 88       	ld.ub	r8,r8[0x0]
8000a170:	58 08       	cp.w	r8,0
8000a172:	e0 80 01 7b 	breq	8000a468 <show_chassis_status_info+0x34c>
		{
			uSideIdx = ledBrd[i].uSideIdx;
8000a176:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000a17a:	fe fa 03 e2 	ld.w	r10,pc[994]
8000a17e:	12 98       	mov	r8,r9
8000a180:	a3 78       	lsl	r8,0x3
8000a182:	12 18       	sub	r8,r9
8000a184:	a1 78       	lsl	r8,0x1
8000a186:	f4 08 00 08 	add	r8,r10,r8
8000a18a:	2f 68       	sub	r8,-10
8000a18c:	11 88       	ld.ub	r8,r8[0x0]
8000a18e:	ef 68 ff ea 	st.b	r7[-22],r8
			lSideIdx = ledBrd[i].lSideIdx;
8000a192:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000a196:	fe fa 03 c6 	ld.w	r10,pc[966]
8000a19a:	12 98       	mov	r8,r9
8000a19c:	a3 78       	lsl	r8,0x3
8000a19e:	12 18       	sub	r8,r9
8000a1a0:	a1 78       	lsl	r8,0x1
8000a1a2:	f4 08 00 08 	add	r8,r10,r8
8000a1a6:	2f 58       	sub	r8,-11
8000a1a8:	11 88       	ld.ub	r8,r8[0x0]
8000a1aa:	ef 68 ff eb 	st.b	r7[-21],r8
			
			if (uSideIdx != NO_LED_BOARD_PRESENT)
8000a1ae:	ef 39 ff ea 	ld.ub	r9,r7[-22]
8000a1b2:	3f f8       	mov	r8,-1
8000a1b4:	f0 09 18 00 	cp.b	r9,r8
8000a1b8:	c4 40       	breq	8000a240 <show_chassis_status_info+0x124>
			{
				uSideUsageIdx = ledBrdSide[uSideIdx].ushdwIdx;	
8000a1ba:	ef 39 ff ea 	ld.ub	r9,r7[-22]
8000a1be:	fe fa 03 a2 	ld.w	r10,pc[930]
8000a1c2:	12 98       	mov	r8,r9
8000a1c4:	a3 68       	lsl	r8,0x2
8000a1c6:	12 08       	add	r8,r9
8000a1c8:	f4 08 00 08 	add	r8,r10,r8
8000a1cc:	2f f8       	sub	r8,-1
8000a1ce:	11 88       	ld.ub	r8,r8[0x0]
8000a1d0:	ef 68 ff ec 	st.b	r7[-20],r8
				ledBrdSide[uSideIdx].maxUsageReached = !check_led_brd_side_lifetime(uSideIdx);
8000a1d4:	ef 36 ff ea 	ld.ub	r6,r7[-22]
8000a1d8:	ef 38 ff ea 	ld.ub	r8,r7[-22]
8000a1dc:	10 9c       	mov	r12,r8
8000a1de:	f0 1f 00 e2 	mcall	8000a564 <show_chassis_status_info+0x448>
8000a1e2:	18 98       	mov	r8,r12
8000a1e4:	10 99       	mov	r9,r8
8000a1e6:	30 08       	mov	r8,0
8000a1e8:	f0 09 18 00 	cp.b	r9,r8
8000a1ec:	5f 09       	sreq	r9
8000a1ee:	fe fa 03 72 	ld.w	r10,pc[882]
8000a1f2:	0c 98       	mov	r8,r6
8000a1f4:	a3 68       	lsl	r8,0x2
8000a1f6:	0c 08       	add	r8,r6
8000a1f8:	f4 08 00 08 	add	r8,r10,r8
8000a1fc:	f0 ca ff fe 	sub	r10,r8,-2
8000a200:	12 98       	mov	r8,r9
8000a202:	b4 88       	st.b	r10[0x0],r8
				sanMinutesUpper = ledBrdSide[uSideIdx].sanitizeMinutes;
8000a204:	ef 39 ff ea 	ld.ub	r9,r7[-22]
8000a208:	fe fa 03 58 	ld.w	r10,pc[856]
8000a20c:	12 98       	mov	r8,r9
8000a20e:	a3 68       	lsl	r8,0x2
8000a210:	12 08       	add	r8,r9
8000a212:	f4 08 00 08 	add	r8,r10,r8
8000a216:	11 88       	ld.ub	r8,r8[0x0]
8000a218:	ef 68 ff f0 	st.b	r7[-16],r8
#ifdef SERIAL_ID_AND_ALL_USAGE_COMBINED
				uHrs = usageShdw[0].u[uSideUsageIdx].minutes/60;
				uMins = usageShdw[0].u[uSideUsageIdx].minutes%60;
#else
				uHrs = h.hrs[uSideUsageIdx];
8000a21c:	ef 39 ff ec 	ld.ub	r9,r7[-20]
8000a220:	fe f8 03 48 	ld.w	r8,pc[840]
8000a224:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
8000a228:	5c 78       	castu.h	r8
8000a22a:	ef 48 ff f4 	st.w	r7[-12],r8
				uMins = m.mins[uSideUsageIdx];
8000a22e:	ef 38 ff ec 	ld.ub	r8,r7[-20]
8000a232:	fe f9 03 3a 	ld.w	r9,pc[826]
8000a236:	f2 08 07 08 	ld.ub	r8,r9[r8]
8000a23a:	ef 68 ff f2 	st.b	r7[-14],r8
8000a23e:	c0 a8       	rjmp	8000a252 <show_chassis_status_info+0x136>
#endif				
			}
			else
			{
				uHrs = 0;
8000a240:	30 08       	mov	r8,0
8000a242:	ef 48 ff f4 	st.w	r7[-12],r8
				uMins = 0;
8000a246:	30 08       	mov	r8,0
8000a248:	ef 68 ff f2 	st.b	r7[-14],r8
				sanMinutesUpper = 0;
8000a24c:	30 08       	mov	r8,0
8000a24e:	ef 68 ff f0 	st.b	r7[-16],r8
			}
			
			if (lSideIdx != NO_LED_BOARD_PRESENT)
8000a252:	ef 39 ff eb 	ld.ub	r9,r7[-21]
8000a256:	3f f8       	mov	r8,-1
8000a258:	f0 09 18 00 	cp.b	r9,r8
8000a25c:	c4 40       	breq	8000a2e4 <show_chassis_status_info+0x1c8>
			{
				lSideUsageIdx = ledBrdSide[lSideIdx].ushdwIdx;	
8000a25e:	ef 39 ff eb 	ld.ub	r9,r7[-21]
8000a262:	fe fa 02 fe 	ld.w	r10,pc[766]
8000a266:	12 98       	mov	r8,r9
8000a268:	a3 68       	lsl	r8,0x2
8000a26a:	12 08       	add	r8,r9
8000a26c:	f4 08 00 08 	add	r8,r10,r8
8000a270:	2f f8       	sub	r8,-1
8000a272:	11 88       	ld.ub	r8,r8[0x0]
8000a274:	ef 68 ff ed 	st.b	r7[-19],r8
				ledBrdSide[lSideIdx].maxUsageReached = !check_led_brd_side_lifetime(lSideIdx);
8000a278:	ef 36 ff eb 	ld.ub	r6,r7[-21]
8000a27c:	ef 38 ff eb 	ld.ub	r8,r7[-21]
8000a280:	10 9c       	mov	r12,r8
8000a282:	f0 1f 00 b9 	mcall	8000a564 <show_chassis_status_info+0x448>
8000a286:	18 98       	mov	r8,r12
8000a288:	10 99       	mov	r9,r8
8000a28a:	30 08       	mov	r8,0
8000a28c:	f0 09 18 00 	cp.b	r9,r8
8000a290:	5f 09       	sreq	r9
8000a292:	fe fa 02 ce 	ld.w	r10,pc[718]
8000a296:	0c 98       	mov	r8,r6
8000a298:	a3 68       	lsl	r8,0x2
8000a29a:	0c 08       	add	r8,r6
8000a29c:	f4 08 00 08 	add	r8,r10,r8
8000a2a0:	f0 ca ff fe 	sub	r10,r8,-2
8000a2a4:	12 98       	mov	r8,r9
8000a2a6:	b4 88       	st.b	r10[0x0],r8
				sanMinutesLower = ledBrdSide[lSideIdx].sanitizeMinutes;
8000a2a8:	ef 39 ff eb 	ld.ub	r9,r7[-21]
8000a2ac:	fe fa 02 b4 	ld.w	r10,pc[692]
8000a2b0:	12 98       	mov	r8,r9
8000a2b2:	a3 68       	lsl	r8,0x2
8000a2b4:	12 08       	add	r8,r9
8000a2b6:	f4 08 00 08 	add	r8,r10,r8
8000a2ba:	11 88       	ld.ub	r8,r8[0x0]
8000a2bc:	ef 68 ff f1 	st.b	r7[-15],r8
#ifdef SERIAL_ID_AND_ALL_USAGE_COMBINED
				lHrs = usageShdw[0].u[lSideUsageIdx].minutes/60;
				lMins = usageShdw[0].u[lSideUsageIdx].minutes%60;
#else
				lHrs = h.hrs[lSideUsageIdx];
8000a2c0:	ef 39 ff ed 	ld.ub	r9,r7[-19]
8000a2c4:	fe f8 02 a4 	ld.w	r8,pc[676]
8000a2c8:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
8000a2cc:	5c 78       	castu.h	r8
8000a2ce:	ef 48 ff f8 	st.w	r7[-8],r8
				lMins = m.mins[lSideUsageIdx];
8000a2d2:	ef 38 ff ed 	ld.ub	r8,r7[-19]
8000a2d6:	fe f9 02 96 	ld.w	r9,pc[662]
8000a2da:	f2 08 07 08 	ld.ub	r8,r9[r8]
8000a2de:	ef 68 ff f3 	st.b	r7[-13],r8
8000a2e2:	c0 a8       	rjmp	8000a2f6 <show_chassis_status_info+0x1da>
#endif
			}
			else
			{
				lHrs = 0;
8000a2e4:	30 08       	mov	r8,0
8000a2e6:	ef 48 ff f8 	st.w	r7[-8],r8
				lMins = 0;
8000a2ea:	30 08       	mov	r8,0
8000a2ec:	ef 68 ff f3 	st.b	r7[-13],r8
				sanMinutesLower = 0;
8000a2f0:	30 08       	mov	r8,0
8000a2f2:	ef 68 ff f1 	st.b	r7[-15],r8
			} 
			
			
			sprintf(pStr, "%2d     %02X%02X%02X%02X%02X%02X  %04d:%02d     %02d     %04d:%02d     %02d\r\n", 
8000a2f6:	ef 31 ff f1 	ld.ub	r1,r7[-15]
8000a2fa:	ef 32 ff f3 	ld.ub	r2,r7[-13]
8000a2fe:	ef 33 ff f0 	ld.ub	r3,r7[-16]
8000a302:	ef 35 ff f2 	ld.ub	r5,r7[-14]
				i, 
				ledBrd[i].id[0], ledBrd[i].id[1], ledBrd[i].id[2], ledBrd[i].id[3], ledBrd[i].id[4], ledBrd[i].id[5],
8000a306:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000a30a:	fe fa 02 52 	ld.w	r10,pc[594]
8000a30e:	12 98       	mov	r8,r9
8000a310:	a3 78       	lsl	r8,0x3
8000a312:	12 18       	sub	r8,r9
8000a314:	a1 78       	lsl	r8,0x1
8000a316:	f4 08 00 08 	add	r8,r10,r8
8000a31a:	2f a8       	sub	r8,-6
8000a31c:	11 88       	ld.ub	r8,r8[0x0]
				lMins = 0;
				sanMinutesLower = 0;
			} 
			
			
			sprintf(pStr, "%2d     %02X%02X%02X%02X%02X%02X  %04d:%02d     %02d     %04d:%02d     %02d\r\n", 
8000a31e:	10 96       	mov	r6,r8
				i, 
				ledBrd[i].id[0], ledBrd[i].id[1], ledBrd[i].id[2], ledBrd[i].id[3], ledBrd[i].id[4], ledBrd[i].id[5],
8000a320:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000a324:	fe fa 02 38 	ld.w	r10,pc[568]
8000a328:	12 98       	mov	r8,r9
8000a32a:	a3 78       	lsl	r8,0x3
8000a32c:	12 18       	sub	r8,r9
8000a32e:	a1 78       	lsl	r8,0x1
8000a330:	f4 08 00 08 	add	r8,r10,r8
8000a334:	2f b8       	sub	r8,-5
8000a336:	11 88       	ld.ub	r8,r8[0x0]
				lMins = 0;
				sanMinutesLower = 0;
			} 
			
			
			sprintf(pStr, "%2d     %02X%02X%02X%02X%02X%02X  %04d:%02d     %02d     %04d:%02d     %02d\r\n", 
8000a338:	10 9e       	mov	lr,r8
				i, 
				ledBrd[i].id[0], ledBrd[i].id[1], ledBrd[i].id[2], ledBrd[i].id[3], ledBrd[i].id[4], ledBrd[i].id[5],
8000a33a:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000a33e:	fe fa 02 1e 	ld.w	r10,pc[542]
8000a342:	12 98       	mov	r8,r9
8000a344:	a3 78       	lsl	r8,0x3
8000a346:	12 18       	sub	r8,r9
8000a348:	a1 78       	lsl	r8,0x1
8000a34a:	f4 08 00 08 	add	r8,r10,r8
8000a34e:	2f c8       	sub	r8,-4
8000a350:	11 88       	ld.ub	r8,r8[0x0]
				lMins = 0;
				sanMinutesLower = 0;
			} 
			
			
			sprintf(pStr, "%2d     %02X%02X%02X%02X%02X%02X  %04d:%02d     %02d     %04d:%02d     %02d\r\n", 
8000a352:	10 9c       	mov	r12,r8
				i, 
				ledBrd[i].id[0], ledBrd[i].id[1], ledBrd[i].id[2], ledBrd[i].id[3], ledBrd[i].id[4], ledBrd[i].id[5],
8000a354:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000a358:	fe fa 02 04 	ld.w	r10,pc[516]
8000a35c:	12 98       	mov	r8,r9
8000a35e:	a3 78       	lsl	r8,0x3
8000a360:	12 18       	sub	r8,r9
8000a362:	2f f8       	sub	r8,-1
8000a364:	a1 78       	lsl	r8,0x1
8000a366:	f4 08 00 08 	add	r8,r10,r8
8000a36a:	11 98       	ld.ub	r8,r8[0x1]
				lMins = 0;
				sanMinutesLower = 0;
			} 
			
			
			sprintf(pStr, "%2d     %02X%02X%02X%02X%02X%02X  %04d:%02d     %02d     %04d:%02d     %02d\r\n", 
8000a36c:	10 9b       	mov	r11,r8
				i, 
				ledBrd[i].id[0], ledBrd[i].id[1], ledBrd[i].id[2], ledBrd[i].id[3], ledBrd[i].id[4], ledBrd[i].id[5],
8000a36e:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000a372:	4f ba       	lddpc	r10,8000a55c <show_chassis_status_info+0x440>
8000a374:	12 98       	mov	r8,r9
8000a376:	a3 78       	lsl	r8,0x3
8000a378:	12 18       	sub	r8,r9
8000a37a:	a1 78       	lsl	r8,0x1
8000a37c:	f4 08 00 08 	add	r8,r10,r8
8000a380:	2f e8       	sub	r8,-2
8000a382:	11 88       	ld.ub	r8,r8[0x0]
				lMins = 0;
				sanMinutesLower = 0;
			} 
			
			
			sprintf(pStr, "%2d     %02X%02X%02X%02X%02X%02X  %04d:%02d     %02d     %04d:%02d     %02d\r\n", 
8000a384:	10 9a       	mov	r10,r8
				i, 
				ledBrd[i].id[0], ledBrd[i].id[1], ledBrd[i].id[2], ledBrd[i].id[3], ledBrd[i].id[4], ledBrd[i].id[5],
8000a386:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000a38a:	4f 50       	lddpc	r0,8000a55c <show_chassis_status_info+0x440>
8000a38c:	12 98       	mov	r8,r9
8000a38e:	a3 78       	lsl	r8,0x3
8000a390:	12 18       	sub	r8,r9
8000a392:	a1 78       	lsl	r8,0x1
8000a394:	e0 08 00 08 	add	r8,r0,r8
8000a398:	2f f8       	sub	r8,-1
8000a39a:	11 88       	ld.ub	r8,r8[0x0]
				lMins = 0;
				sanMinutesLower = 0;
			} 
			
			
			sprintf(pStr, "%2d     %02X%02X%02X%02X%02X%02X  %04d:%02d     %02d     %04d:%02d     %02d\r\n", 
8000a39c:	10 99       	mov	r9,r8
8000a39e:	ee c8 00 68 	sub	r8,r7,104
8000a3a2:	1a d1       	st.w	--sp,r1
8000a3a4:	1a d2       	st.w	--sp,r2
8000a3a6:	ee f2 ff f8 	ld.w	r2,r7[-8]
8000a3aa:	1a d2       	st.w	--sp,r2
8000a3ac:	1a d3       	st.w	--sp,r3
8000a3ae:	1a d5       	st.w	--sp,r5
8000a3b0:	ee f5 ff f4 	ld.w	r5,r7[-12]
8000a3b4:	1a d5       	st.w	--sp,r5
8000a3b6:	1a d6       	st.w	--sp,r6
8000a3b8:	1a de       	st.w	--sp,lr
8000a3ba:	1a dc       	st.w	--sp,r12
8000a3bc:	1a db       	st.w	--sp,r11
8000a3be:	1a da       	st.w	--sp,r10
8000a3c0:	1a d9       	st.w	--sp,r9
8000a3c2:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000a3c6:	1a d9       	st.w	--sp,r9
8000a3c8:	4e ab       	lddpc	r11,8000a570 <show_chassis_status_info+0x454>
8000a3ca:	10 9c       	mov	r12,r8
8000a3cc:	f0 1f 00 6a 	mcall	8000a574 <show_chassis_status_info+0x458>
8000a3d0:	2f 3d       	sub	sp,-52
				ledBrd[i].id[0], ledBrd[i].id[1], ledBrd[i].id[2], ledBrd[i].id[3], ledBrd[i].id[4], ledBrd[i].id[5],
				uHrs, uMins,
				sanMinutesUpper,
				lHrs, lMins,
				sanMinutesLower);
			print_ecdbg(pStr);
8000a3d2:	ee c8 00 68 	sub	r8,r7,104
8000a3d6:	10 9c       	mov	r12,r8
8000a3d8:	f0 1f 00 5d 	mcall	8000a54c <show_chassis_status_info+0x430>
			

			/* 
			 * Determine the min and max sanitize times for the LED boards that are currently installed
			 */
			if ((sanMinutesMax < sanMinutesUpper) && (sanMinutesUpper != 0))
8000a3dc:	ef 39 ff ee 	ld.ub	r9,r7[-18]
8000a3e0:	ef 38 ff f0 	ld.ub	r8,r7[-16]
8000a3e4:	f0 09 18 00 	cp.b	r9,r8
8000a3e8:	c0 b2       	brcc	8000a3fe <show_chassis_status_info+0x2e2>
8000a3ea:	ef 39 ff f0 	ld.ub	r9,r7[-16]
8000a3ee:	30 08       	mov	r8,0
8000a3f0:	f0 09 18 00 	cp.b	r9,r8
8000a3f4:	c0 50       	breq	8000a3fe <show_chassis_status_info+0x2e2>
			{
				sanMinutesMax = sanMinutesUpper;
8000a3f6:	ef 38 ff f0 	ld.ub	r8,r7[-16]
8000a3fa:	ef 68 ff ee 	st.b	r7[-18],r8
			}
			if ((sanMinutesMax < sanMinutesLower) && (sanMinutesLower != 0))
8000a3fe:	ef 39 ff ee 	ld.ub	r9,r7[-18]
8000a402:	ef 38 ff f1 	ld.ub	r8,r7[-15]
8000a406:	f0 09 18 00 	cp.b	r9,r8
8000a40a:	c0 b2       	brcc	8000a420 <show_chassis_status_info+0x304>
8000a40c:	ef 39 ff f1 	ld.ub	r9,r7[-15]
8000a410:	30 08       	mov	r8,0
8000a412:	f0 09 18 00 	cp.b	r9,r8
8000a416:	c0 50       	breq	8000a420 <show_chassis_status_info+0x304>
			{
				sanMinutesMax = sanMinutesLower;
8000a418:	ef 38 ff f1 	ld.ub	r8,r7[-15]
8000a41c:	ef 68 ff ee 	st.b	r7[-18],r8
			}
			if ((sanMinutesMin > sanMinutesUpper) && (sanMinutesUpper != 0))
8000a420:	ef 39 ff ef 	ld.ub	r9,r7[-17]
8000a424:	ef 38 ff f0 	ld.ub	r8,r7[-16]
8000a428:	f0 09 18 00 	cp.b	r9,r8
8000a42c:	e0 88 00 0c 	brls	8000a444 <show_chassis_status_info+0x328>
8000a430:	ef 39 ff f0 	ld.ub	r9,r7[-16]
8000a434:	30 08       	mov	r8,0
8000a436:	f0 09 18 00 	cp.b	r9,r8
8000a43a:	c0 50       	breq	8000a444 <show_chassis_status_info+0x328>
			{
				sanMinutesMin = sanMinutesUpper;
8000a43c:	ef 38 ff f0 	ld.ub	r8,r7[-16]
8000a440:	ef 68 ff ef 	st.b	r7[-17],r8
			}
			if ((sanMinutesMin > sanMinutesLower) && (sanMinutesLower != 0))
8000a444:	ef 39 ff ef 	ld.ub	r9,r7[-17]
8000a448:	ef 38 ff f1 	ld.ub	r8,r7[-15]
8000a44c:	f0 09 18 00 	cp.b	r9,r8
8000a450:	e0 88 00 0c 	brls	8000a468 <show_chassis_status_info+0x34c>
8000a454:	ef 39 ff f1 	ld.ub	r9,r7[-15]
8000a458:	30 08       	mov	r8,0
8000a45a:	f0 09 18 00 	cp.b	r9,r8
8000a45e:	c0 50       	breq	8000a468 <show_chassis_status_info+0x34c>
			{
				sanMinutesMin = sanMinutesLower;
8000a460:	ef 38 ff f1 	ld.ub	r8,r7[-15]
8000a464:	ef 68 ff ef 	st.b	r7[-17],r8
	
	print_ecdbg(" LED | LED BOARD    |   UPPER SIDE     |   LOWER SIDE    \r\n");
	print_ecdbg("SLOT |    ID        | HRS:MIN    DTE   | HRS:MIN    DTE   \r\n");
	print_ecdbg("----------------------------------------------------------\r\n");
	
	for (int i=0; i<NUM_LED_BOARDS; i++)
8000a468:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a46c:	2f f8       	sub	r8,-1
8000a46e:	ef 48 ff fc 	st.w	r7[-4],r8
8000a472:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a476:	58 48       	cp.w	r8,4
8000a478:	fe 9a fe 70 	brle	8000a158 <show_chassis_status_info+0x3c>
				sanMinutesMin = sanMinutesLower;
			}
		}
	}
	
	print_ecdbg("MAX DTE: ");
8000a47c:	4b fc       	lddpc	r12,8000a578 <show_chassis_status_info+0x45c>
8000a47e:	f0 1f 00 34 	mcall	8000a54c <show_chassis_status_info+0x430>
	print_ecdbg_num(sanMinutesMax);
8000a482:	ef 38 ff ee 	ld.ub	r8,r7[-18]
8000a486:	10 9c       	mov	r12,r8
8000a488:	f0 1f 00 3d 	mcall	8000a57c <show_chassis_status_info+0x460>
	print_ecdbg(" MIN DTE: ");
8000a48c:	4b dc       	lddpc	r12,8000a580 <show_chassis_status_info+0x464>
8000a48e:	f0 1f 00 30 	mcall	8000a54c <show_chassis_status_info+0x430>
	print_ecdbg_num(sanMinutesMin);
8000a492:	ef 38 ff ef 	ld.ub	r8,r7[-17]
8000a496:	10 9c       	mov	r12,r8
8000a498:	f0 1f 00 39 	mcall	8000a57c <show_chassis_status_info+0x460>
	print_ecdbg("\r\n");
8000a49c:	4b ac       	lddpc	r12,8000a584 <show_chassis_status_info+0x468>
8000a49e:	f0 1f 00 2c 	mcall	8000a54c <show_chassis_status_info+0x430>
	
	print_ecdbg("TOTAL SANITIZE TIME: ");
8000a4a2:	4b ac       	lddpc	r12,8000a588 <show_chassis_status_info+0x46c>
8000a4a4:	f0 1f 00 2a 	mcall	8000a54c <show_chassis_status_info+0x430>
		print_ecdbg_num(usageShdw[0].totalSanitationMinutes/60);
	}
	print_ecdbg(" TOTAL SANITIZE CYCLES: ");
	print_ecdbg_num(usageShdw[0].totalSanitationCycles);
#else
	if ((m.sanMins/60) < 10)
8000a4a8:	4b 18       	lddpc	r8,8000a56c <show_chassis_status_info+0x450>
8000a4aa:	71 88       	ld.w	r8,r8[0x60]
8000a4ac:	e0 48 02 57 	cp.w	r8,599
8000a4b0:	e0 8b 00 05 	brhi	8000a4ba <show_chassis_status_info+0x39e>
	{
		print_ecdbg("0"); //print leading 0 if we need it
8000a4b4:	4b 6c       	lddpc	r12,8000a58c <show_chassis_status_info+0x470>
8000a4b6:	f0 1f 00 26 	mcall	8000a54c <show_chassis_status_info+0x430>
	}
	print_ecdbg_num((m.sanMins/60));
8000a4ba:	4a d8       	lddpc	r8,8000a56c <show_chassis_status_info+0x450>
8000a4bc:	71 89       	ld.w	r9,r8[0x60]
8000a4be:	e0 68 88 89 	mov	r8,34953
8000a4c2:	ea 18 88 88 	orh	r8,0x8888
8000a4c6:	f2 08 06 48 	mulu.d	r8,r9,r8
8000a4ca:	f2 08 16 05 	lsr	r8,r9,0x5
8000a4ce:	10 9c       	mov	r12,r8
8000a4d0:	f0 1f 00 2b 	mcall	8000a57c <show_chassis_status_info+0x460>
	print_ecdbg(":");
8000a4d4:	4a fc       	lddpc	r12,8000a590 <show_chassis_status_info+0x474>
8000a4d6:	f0 1f 00 1e 	mcall	8000a54c <show_chassis_status_info+0x430>

	if ((m.sanMins%60) < 10)
8000a4da:	4a 58       	lddpc	r8,8000a56c <show_chassis_status_info+0x450>
8000a4dc:	71 8a       	ld.w	r10,r8[0x60]
8000a4de:	e0 68 88 89 	mov	r8,34953
8000a4e2:	ea 18 88 88 	orh	r8,0x8888
8000a4e6:	f4 08 06 48 	mulu.d	r8,r10,r8
8000a4ea:	a5 99       	lsr	r9,0x5
8000a4ec:	12 98       	mov	r8,r9
8000a4ee:	a5 68       	lsl	r8,0x4
8000a4f0:	12 18       	sub	r8,r9
8000a4f2:	a3 68       	lsl	r8,0x2
8000a4f4:	f4 08 01 09 	sub	r9,r10,r8
8000a4f8:	58 99       	cp.w	r9,9
8000a4fa:	e0 8b 00 05 	brhi	8000a504 <show_chassis_status_info+0x3e8>
	{
		print_ecdbg("0"); //print leading 0 if we need it
8000a4fe:	4a 4c       	lddpc	r12,8000a58c <show_chassis_status_info+0x470>
8000a500:	f0 1f 00 13 	mcall	8000a54c <show_chassis_status_info+0x430>
	}
	print_ecdbg_num((m.sanMins%60));
8000a504:	49 a8       	lddpc	r8,8000a56c <show_chassis_status_info+0x450>
8000a506:	71 8a       	ld.w	r10,r8[0x60]
8000a508:	e0 68 88 89 	mov	r8,34953
8000a50c:	ea 18 88 88 	orh	r8,0x8888
8000a510:	f4 08 06 48 	mulu.d	r8,r10,r8
8000a514:	a5 99       	lsr	r9,0x5
8000a516:	12 98       	mov	r8,r9
8000a518:	a5 68       	lsl	r8,0x4
8000a51a:	12 18       	sub	r8,r9
8000a51c:	a3 68       	lsl	r8,0x2
8000a51e:	f4 08 01 09 	sub	r9,r10,r8
8000a522:	12 9c       	mov	r12,r9
8000a524:	f0 1f 00 16 	mcall	8000a57c <show_chassis_status_info+0x460>

	print_ecdbg("  TOTAL SANITIZE CYCLES: ");
8000a528:	49 bc       	lddpc	r12,8000a594 <show_chassis_status_info+0x478>
8000a52a:	f0 1f 00 09 	mcall	8000a54c <show_chassis_status_info+0x430>
	print_ecdbg_num(sanc.cycles);
8000a52e:	49 b8       	lddpc	r8,8000a598 <show_chassis_status_info+0x47c>
8000a530:	70 08       	ld.w	r8,r8[0x0]
8000a532:	f1 d8 c1 94 	bfextu	r8,r8,0xc,0x14
8000a536:	10 9c       	mov	r12,r8
8000a538:	f0 1f 00 11 	mcall	8000a57c <show_chassis_status_info+0x460>

#endif //SERIAL_ID_AND_ALL_USAGE_COMBINED	
	print_ecdbg("\r\n");
8000a53c:	49 2c       	lddpc	r12,8000a584 <show_chassis_status_info+0x468>
8000a53e:	f0 1f 00 04 	mcall	8000a54c <show_chassis_status_info+0x430>
	
}
8000a542:	2e 6d       	sub	sp,-104
8000a544:	e3 cd 80 ef 	ldm	sp++,r0-r3,r5-r7,pc
8000a548:	80 00       	ld.sh	r0,r0[0x0]
8000a54a:	69 20       	ld.w	r0,r4[0x48]
8000a54c:	80 00       	ld.sh	r0,r0[0x0]
8000a54e:	33 38       	mov	r8,51
8000a550:	80 00       	ld.sh	r0,r0[0x0]
8000a552:	69 44       	ld.w	r4,r4[0x50]
8000a554:	80 00       	ld.sh	r0,r0[0x0]
8000a556:	69 80       	ld.w	r0,r4[0x60]
8000a558:	80 00       	ld.sh	r0,r0[0x0]
8000a55a:	69 c0       	ld.w	r0,r4[0x70]
8000a55c:	00 00       	add	r0,r0
8000a55e:	0b 4a       	ld.w	r10,--r5
8000a560:	00 00       	add	r0,r0
8000a562:	0b fe       	ld.ub	lr,r5[0x7]
8000a564:	80 00       	ld.sh	r0,r0[0x0]
8000a566:	76 ac       	ld.w	r12,r11[0x28]
8000a568:	00 00       	add	r0,r0
8000a56a:	0c 2c       	rsub	r12,r6
8000a56c:	00 00       	add	r0,r0
8000a56e:	0d 08       	ld.w	r8,r6++
8000a570:	80 00       	ld.sh	r0,r0[0x0]
8000a572:	6a 00       	ld.w	r0,r5[0x0]
8000a574:	80 00       	ld.sh	r0,r0[0x0]
8000a576:	ce 10       	breq	8000a538 <show_chassis_status_info+0x41c>
8000a578:	80 00       	ld.sh	r0,r0[0x0]
8000a57a:	6a 50       	ld.w	r0,r5[0x14]
8000a57c:	80 00       	ld.sh	r0,r0[0x0]
8000a57e:	73 50       	ld.w	r0,r9[0x54]
8000a580:	80 00       	ld.sh	r0,r0[0x0]
8000a582:	6a 5c       	ld.w	r12,r5[0x14]
8000a584:	80 00       	ld.sh	r0,r0[0x0]
8000a586:	64 ec       	ld.w	r12,r2[0x38]
8000a588:	80 00       	ld.sh	r0,r0[0x0]
8000a58a:	6a 68       	ld.w	r8,r5[0x18]
8000a58c:	80 00       	ld.sh	r0,r0[0x0]
8000a58e:	6a 80       	ld.w	r0,r5[0x20]
8000a590:	80 00       	ld.sh	r0,r0[0x0]
8000a592:	6a 84       	ld.w	r4,r5[0x20]
8000a594:	80 00       	ld.sh	r0,r0[0x0]
8000a596:	6a 88       	ld.w	r8,r5[0x20]
8000a598:	00 00       	add	r0,r0
8000a59a:	0c 28       	rsub	r8,r6

8000a59c <show_chassis_sysErr>:


void show_chassis_sysErr(void);
void show_chassis_sysErr(void)
{
8000a59c:	eb cd 40 c0 	pushm	r6-r7,lr
8000a5a0:	1a 97       	mov	r7,sp
8000a5a2:	21 9d       	sub	sp,100
	char str[80];
	

	print_ecdbg("\r\n***SYSTEM TESTS***\r\n\r\n");
8000a5a4:	fe fc 03 70 	ld.w	r12,pc[880]
8000a5a8:	f0 1f 00 dc 	mcall	8000a918 <show_chassis_sysErr+0x37c>


/*
 *	LED Driver: Top
 */
	sprintf(str, "LED Driver: TOP (0..7)                 ");
8000a5ac:	ee c8 00 64 	sub	r8,r7,100
8000a5b0:	32 8a       	mov	r10,40
8000a5b2:	fe fb 03 6a 	ld.w	r11,pc[874]
8000a5b6:	10 9c       	mov	r12,r8
8000a5b8:	f0 1f 00 da 	mcall	8000a920 <show_chassis_sysErr+0x384>
	
	for (int i=0; i<8; i++)
8000a5bc:	30 08       	mov	r8,0
8000a5be:	ef 48 ff ec 	st.w	r7[-20],r8
8000a5c2:	c3 38       	rjmp	8000a628 <show_chassis_sysErr+0x8c>
	{
		if ((sysErr.topdrive & BIT(i)))
8000a5c4:	fe f8 03 60 	ld.w	r8,pc[864]
8000a5c8:	11 88       	ld.ub	r8,r8[0x0]
8000a5ca:	10 99       	mov	r9,r8
8000a5cc:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000a5d0:	f2 08 08 48 	asr	r8,r9,r8
8000a5d4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000a5d8:	5c 58       	castu.b	r8
8000a5da:	c1 20       	breq	8000a5fe <show_chassis_sysErr+0x62>
		{
			strcat(str,"F ");			
8000a5dc:	ee c6 00 64 	sub	r6,r7,100
8000a5e0:	ee c8 00 64 	sub	r8,r7,100
8000a5e4:	10 9c       	mov	r12,r8
8000a5e6:	f0 1f 00 d1 	mcall	8000a928 <show_chassis_sysErr+0x38c>
8000a5ea:	18 98       	mov	r8,r12
8000a5ec:	ec 08 00 08 	add	r8,r6,r8
8000a5f0:	30 3a       	mov	r10,3
8000a5f2:	fe fb 03 3a 	ld.w	r11,pc[826]
8000a5f6:	10 9c       	mov	r12,r8
8000a5f8:	f0 1f 00 ca 	mcall	8000a920 <show_chassis_sysErr+0x384>
8000a5fc:	c1 18       	rjmp	8000a61e <show_chassis_sysErr+0x82>
//DEBUG 24jun15 need to function even with these errors for demo purposes			electroclaveState = STATE_CHASSIS_ERROR;
		}
		else
		{
			strcat(str,"P ");
8000a5fe:	ee c6 00 64 	sub	r6,r7,100
8000a602:	ee c8 00 64 	sub	r8,r7,100
8000a606:	10 9c       	mov	r12,r8
8000a608:	f0 1f 00 c8 	mcall	8000a928 <show_chassis_sysErr+0x38c>
8000a60c:	18 98       	mov	r8,r12
8000a60e:	ec 08 00 08 	add	r8,r6,r8
8000a612:	30 3a       	mov	r10,3
8000a614:	fe fb 03 1c 	ld.w	r11,pc[796]
8000a618:	10 9c       	mov	r12,r8
8000a61a:	f0 1f 00 c2 	mcall	8000a920 <show_chassis_sysErr+0x384>
/*
 *	LED Driver: Top
 */
	sprintf(str, "LED Driver: TOP (0..7)                 ");
	
	for (int i=0; i<8; i++)
8000a61e:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000a622:	2f f8       	sub	r8,-1
8000a624:	ef 48 ff ec 	st.w	r7[-20],r8
8000a628:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000a62c:	58 78       	cp.w	r8,7
8000a62e:	fe 9a ff cb 	brle	8000a5c4 <show_chassis_sysErr+0x28>
		{
			strcat(str,"P ");
		}
	}
	
	print_ecdbg(str);
8000a632:	ee c8 00 64 	sub	r8,r7,100
8000a636:	10 9c       	mov	r12,r8
8000a638:	f0 1f 00 b8 	mcall	8000a918 <show_chassis_sysErr+0x37c>
	print_ecdbg("\r\n");
8000a63c:	fe fc 02 f8 	ld.w	r12,pc[760]
8000a640:	f0 1f 00 b6 	mcall	8000a918 <show_chassis_sysErr+0x37c>
	
/*
 *	LED Driver: Bottom
 */
	sprintf(str, "LED Driver: BOTTOM (0..11)             ");
8000a644:	ee c8 00 64 	sub	r8,r7,100
8000a648:	32 8a       	mov	r10,40
8000a64a:	fe fb 02 ee 	ld.w	r11,pc[750]
8000a64e:	10 9c       	mov	r12,r8
8000a650:	f0 1f 00 b4 	mcall	8000a920 <show_chassis_sysErr+0x384>
	
	for (int i=0; i<12; i++)
8000a654:	30 08       	mov	r8,0
8000a656:	ef 48 ff f0 	st.w	r7[-16],r8
8000a65a:	c3 28       	rjmp	8000a6be <show_chassis_sysErr+0x122>
	{
		if ((sysErr.botdrive & BIT(i)))
8000a65c:	fe f8 02 c8 	ld.w	r8,pc[712]
8000a660:	70 19       	ld.w	r9,r8[0x4]
8000a662:	30 1a       	mov	r10,1
8000a664:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000a668:	f4 08 09 48 	lsl	r8,r10,r8
8000a66c:	f3 e8 00 08 	and	r8,r9,r8
8000a670:	c1 20       	breq	8000a694 <show_chassis_sysErr+0xf8>
		{
			strcat(str,"F ");			
8000a672:	ee c6 00 64 	sub	r6,r7,100
8000a676:	ee c8 00 64 	sub	r8,r7,100
8000a67a:	10 9c       	mov	r12,r8
8000a67c:	f0 1f 00 ab 	mcall	8000a928 <show_chassis_sysErr+0x38c>
8000a680:	18 98       	mov	r8,r12
8000a682:	ec 08 00 08 	add	r8,r6,r8
8000a686:	30 3a       	mov	r10,3
8000a688:	fe fb 02 a4 	ld.w	r11,pc[676]
8000a68c:	10 9c       	mov	r12,r8
8000a68e:	f0 1f 00 a5 	mcall	8000a920 <show_chassis_sysErr+0x384>
8000a692:	c1 18       	rjmp	8000a6b4 <show_chassis_sysErr+0x118>
//DEBUG 24jun15 need to function even with these errors for demo purposes			electroclaveState = STATE_CHASSIS_ERROR;
		}
		else
		{
			strcat(str,"P ");
8000a694:	ee c6 00 64 	sub	r6,r7,100
8000a698:	ee c8 00 64 	sub	r8,r7,100
8000a69c:	10 9c       	mov	r12,r8
8000a69e:	f0 1f 00 a3 	mcall	8000a928 <show_chassis_sysErr+0x38c>
8000a6a2:	18 98       	mov	r8,r12
8000a6a4:	ec 08 00 08 	add	r8,r6,r8
8000a6a8:	30 3a       	mov	r10,3
8000a6aa:	fe fb 02 86 	ld.w	r11,pc[646]
8000a6ae:	10 9c       	mov	r12,r8
8000a6b0:	f0 1f 00 9c 	mcall	8000a920 <show_chassis_sysErr+0x384>
/*
 *	LED Driver: Bottom
 */
	sprintf(str, "LED Driver: BOTTOM (0..11)             ");
	
	for (int i=0; i<12; i++)
8000a6b4:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000a6b8:	2f f8       	sub	r8,-1
8000a6ba:	ef 48 ff f0 	st.w	r7[-16],r8
8000a6be:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000a6c2:	58 b8       	cp.w	r8,11
8000a6c4:	fe 9a ff cc 	brle	8000a65c <show_chassis_sysErr+0xc0>
		{
			strcat(str,"P ");
		}
	}
	
	print_ecdbg(str);
8000a6c8:	ee c8 00 64 	sub	r8,r7,100
8000a6cc:	10 9c       	mov	r12,r8
8000a6ce:	f0 1f 00 93 	mcall	8000a918 <show_chassis_sysErr+0x37c>
	print_ecdbg("\r\n");
8000a6d2:	fe fc 02 62 	ld.w	r12,pc[610]
8000a6d6:	f0 1f 00 91 	mcall	8000a918 <show_chassis_sysErr+0x37c>
	
/*
 *	Flash
 */

	sprintf(str, "Flash (0..4)                           ");
8000a6da:	ee c8 00 64 	sub	r8,r7,100
8000a6de:	32 8a       	mov	r10,40
8000a6e0:	fe fb 02 5c 	ld.w	r11,pc[604]
8000a6e4:	10 9c       	mov	r12,r8
8000a6e6:	f0 1f 00 8f 	mcall	8000a920 <show_chassis_sysErr+0x384>
	
	for (int i=0; i<5; i++)
8000a6ea:	30 08       	mov	r8,0
8000a6ec:	ef 48 ff f4 	st.w	r7[-12],r8
8000a6f0:	c3 68       	rjmp	8000a75c <show_chassis_sysErr+0x1c0>
	{
		if ((sysErr.flashArea & BIT(i)) == SE_FAIL)
8000a6f2:	fe f8 02 32 	ld.w	r8,pc[562]
8000a6f6:	70 29       	ld.w	r9,r8[0x8]
8000a6f8:	30 1a       	mov	r10,1
8000a6fa:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000a6fe:	f4 08 09 48 	lsl	r8,r10,r8
8000a702:	f3 e8 00 08 	and	r8,r9,r8
8000a706:	58 18       	cp.w	r8,1
8000a708:	c1 61       	brne	8000a734 <show_chassis_sysErr+0x198>
		{
			strcat(str, "F ");
8000a70a:	ee c6 00 64 	sub	r6,r7,100
8000a70e:	ee c8 00 64 	sub	r8,r7,100
8000a712:	10 9c       	mov	r12,r8
8000a714:	f0 1f 00 85 	mcall	8000a928 <show_chassis_sysErr+0x38c>
8000a718:	18 98       	mov	r8,r12
8000a71a:	ec 08 00 08 	add	r8,r6,r8
8000a71e:	30 3a       	mov	r10,3
8000a720:	fe fb 02 0c 	ld.w	r11,pc[524]
8000a724:	10 9c       	mov	r12,r8
8000a726:	f0 1f 00 7f 	mcall	8000a920 <show_chassis_sysErr+0x384>
			electroclaveState = STATE_CHASSIS_ERROR;
8000a72a:	fe f9 02 16 	ld.w	r9,pc[534]
8000a72e:	30 88       	mov	r8,8
8000a730:	b2 88       	st.b	r9[0x0],r8
8000a732:	c1 08       	rjmp	8000a752 <show_chassis_sysErr+0x1b6>
		}
		else
		{
			strcat(str, "P ");
8000a734:	ee c6 00 64 	sub	r6,r7,100
8000a738:	ee c8 00 64 	sub	r8,r7,100
8000a73c:	10 9c       	mov	r12,r8
8000a73e:	f0 1f 00 7b 	mcall	8000a928 <show_chassis_sysErr+0x38c>
8000a742:	18 98       	mov	r8,r12
8000a744:	ec 08 00 08 	add	r8,r6,r8
8000a748:	30 3a       	mov	r10,3
8000a74a:	4f ab       	lddpc	r11,8000a930 <show_chassis_sysErr+0x394>
8000a74c:	10 9c       	mov	r12,r8
8000a74e:	f0 1f 00 75 	mcall	8000a920 <show_chassis_sysErr+0x384>
 *	Flash
 */

	sprintf(str, "Flash (0..4)                           ");
	
	for (int i=0; i<5; i++)
8000a752:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000a756:	2f f8       	sub	r8,-1
8000a758:	ef 48 ff f4 	st.w	r7[-12],r8
8000a75c:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000a760:	58 48       	cp.w	r8,4
8000a762:	fe 9a ff c8 	brle	8000a6f2 <show_chassis_sysErr+0x156>
		{
			strcat(str, "P ");
		}
	}
	
	print_ecdbg(str);
8000a766:	ee c8 00 64 	sub	r8,r7,100
8000a76a:	10 9c       	mov	r12,r8
8000a76c:	f0 1f 00 6b 	mcall	8000a918 <show_chassis_sysErr+0x37c>
	print_ecdbg("\r\n");
8000a770:	4f 1c       	lddpc	r12,8000a934 <show_chassis_sysErr+0x398>
8000a772:	f0 1f 00 6a 	mcall	8000a918 <show_chassis_sysErr+0x37c>
	
/*
 * LED board serial ID checksums
 */	
	sprintf(str, "LED Board Serial ID Checksums (0..4)   ");
8000a776:	ee c8 00 64 	sub	r8,r7,100
8000a77a:	32 8a       	mov	r10,40
8000a77c:	4f 2b       	lddpc	r11,8000a944 <show_chassis_sysErr+0x3a8>
8000a77e:	10 9c       	mov	r12,r8
8000a780:	f0 1f 00 68 	mcall	8000a920 <show_chassis_sysErr+0x384>
	
	for (int i=0; i<NUM_LED_BOARDS; i++)
8000a784:	30 08       	mov	r8,0
8000a786:	ef 48 ff f8 	st.w	r7[-8],r8
8000a78a:	c3 58       	rjmp	8000a7f4 <show_chassis_sysErr+0x258>
	{
		if ((sysErr.ledBrdSerialIdCsum & BIT(i)) == SE_FAIL)
8000a78c:	4e 68       	lddpc	r8,8000a924 <show_chassis_sysErr+0x388>
8000a78e:	f1 38 00 0c 	ld.ub	r8,r8[12]
8000a792:	10 99       	mov	r9,r8
8000a794:	30 1a       	mov	r10,1
8000a796:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000a79a:	f4 08 09 48 	lsl	r8,r10,r8
8000a79e:	f3 e8 00 08 	and	r8,r9,r8
8000a7a2:	58 18       	cp.w	r8,1
8000a7a4:	c1 41       	brne	8000a7cc <show_chassis_sysErr+0x230>
		{
			strcat(str, "F ");
8000a7a6:	ee c6 00 64 	sub	r6,r7,100
8000a7aa:	ee c8 00 64 	sub	r8,r7,100
8000a7ae:	10 9c       	mov	r12,r8
8000a7b0:	f0 1f 00 5e 	mcall	8000a928 <show_chassis_sysErr+0x38c>
8000a7b4:	18 98       	mov	r8,r12
8000a7b6:	ec 08 00 08 	add	r8,r6,r8
8000a7ba:	30 3a       	mov	r10,3
8000a7bc:	4d cb       	lddpc	r11,8000a92c <show_chassis_sysErr+0x390>
8000a7be:	10 9c       	mov	r12,r8
8000a7c0:	f0 1f 00 58 	mcall	8000a920 <show_chassis_sysErr+0x384>
			electroclaveState = STATE_CHASSIS_ERROR;
8000a7c4:	4d f9       	lddpc	r9,8000a940 <show_chassis_sysErr+0x3a4>
8000a7c6:	30 88       	mov	r8,8
8000a7c8:	b2 88       	st.b	r9[0x0],r8
8000a7ca:	c1 08       	rjmp	8000a7ea <show_chassis_sysErr+0x24e>
		}
		else
		{
			strcat(str, "P ");
8000a7cc:	ee c6 00 64 	sub	r6,r7,100
8000a7d0:	ee c8 00 64 	sub	r8,r7,100
8000a7d4:	10 9c       	mov	r12,r8
8000a7d6:	f0 1f 00 55 	mcall	8000a928 <show_chassis_sysErr+0x38c>
8000a7da:	18 98       	mov	r8,r12
8000a7dc:	ec 08 00 08 	add	r8,r6,r8
8000a7e0:	30 3a       	mov	r10,3
8000a7e2:	4d 4b       	lddpc	r11,8000a930 <show_chassis_sysErr+0x394>
8000a7e4:	10 9c       	mov	r12,r8
8000a7e6:	f0 1f 00 4f 	mcall	8000a920 <show_chassis_sysErr+0x384>
/*
 * LED board serial ID checksums
 */	
	sprintf(str, "LED Board Serial ID Checksums (0..4)   ");
	
	for (int i=0; i<NUM_LED_BOARDS; i++)
8000a7ea:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000a7ee:	2f f8       	sub	r8,-1
8000a7f0:	ef 48 ff f8 	st.w	r7[-8],r8
8000a7f4:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000a7f8:	58 48       	cp.w	r8,4
8000a7fa:	fe 9a ff c9 	brle	8000a78c <show_chassis_sysErr+0x1f0>
		{
			strcat(str, "P ");
		}
	}

	print_ecdbg(str);
8000a7fe:	ee c8 00 64 	sub	r8,r7,100
8000a802:	10 9c       	mov	r12,r8
8000a804:	f0 1f 00 45 	mcall	8000a918 <show_chassis_sysErr+0x37c>
	print_ecdbg("\r\n");
8000a808:	4c bc       	lddpc	r12,8000a934 <show_chassis_sysErr+0x398>
8000a80a:	f0 1f 00 44 	mcall	8000a918 <show_chassis_sysErr+0x37c>
	

/*
 * LED Board Side Max Usage Reached
 */
	sprintf(str, "LED Board Side Max Usage (0..7)        ");
8000a80e:	ee c8 00 64 	sub	r8,r7,100
8000a812:	32 8a       	mov	r10,40
8000a814:	4c db       	lddpc	r11,8000a948 <show_chassis_sysErr+0x3ac>
8000a816:	10 9c       	mov	r12,r8
8000a818:	f0 1f 00 42 	mcall	8000a920 <show_chassis_sysErr+0x384>
	
	for (int i=0; i<NUM_LED_BOARD_SIDES; i++)
8000a81c:	30 08       	mov	r8,0
8000a81e:	ef 48 ff fc 	st.w	r7[-4],r8
8000a822:	c3 18       	rjmp	8000a884 <show_chassis_sysErr+0x2e8>
	{
		if (ledBrdSide[i].maxUsageReached)
8000a824:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000a828:	4c 9a       	lddpc	r10,8000a94c <show_chassis_sysErr+0x3b0>
8000a82a:	12 98       	mov	r8,r9
8000a82c:	a3 68       	lsl	r8,0x2
8000a82e:	12 08       	add	r8,r9
8000a830:	f4 08 00 08 	add	r8,r10,r8
8000a834:	2f e8       	sub	r8,-2
8000a836:	11 88       	ld.ub	r8,r8[0x0]
8000a838:	58 08       	cp.w	r8,0
8000a83a:	c1 10       	breq	8000a85c <show_chassis_sysErr+0x2c0>
		{
			strcat(str, "F ");
8000a83c:	ee c6 00 64 	sub	r6,r7,100
8000a840:	ee c8 00 64 	sub	r8,r7,100
8000a844:	10 9c       	mov	r12,r8
8000a846:	f0 1f 00 39 	mcall	8000a928 <show_chassis_sysErr+0x38c>
8000a84a:	18 98       	mov	r8,r12
8000a84c:	ec 08 00 08 	add	r8,r6,r8
8000a850:	30 3a       	mov	r10,3
8000a852:	4b 7b       	lddpc	r11,8000a92c <show_chassis_sysErr+0x390>
8000a854:	10 9c       	mov	r12,r8
8000a856:	f0 1f 00 33 	mcall	8000a920 <show_chassis_sysErr+0x384>
8000a85a:	c1 08       	rjmp	8000a87a <show_chassis_sysErr+0x2de>
//DEBUG 24jun15 need to function even with these errors for demo purposes			electroclaveState = STATE_CHASSIS_ERROR;
		}
		else
		{
			strcat(str, "P ");
8000a85c:	ee c6 00 64 	sub	r6,r7,100
8000a860:	ee c8 00 64 	sub	r8,r7,100
8000a864:	10 9c       	mov	r12,r8
8000a866:	f0 1f 00 31 	mcall	8000a928 <show_chassis_sysErr+0x38c>
8000a86a:	18 98       	mov	r8,r12
8000a86c:	ec 08 00 08 	add	r8,r6,r8
8000a870:	30 3a       	mov	r10,3
8000a872:	4b 0b       	lddpc	r11,8000a930 <show_chassis_sysErr+0x394>
8000a874:	10 9c       	mov	r12,r8
8000a876:	f0 1f 00 2b 	mcall	8000a920 <show_chassis_sysErr+0x384>
/*
 * LED Board Side Max Usage Reached
 */
	sprintf(str, "LED Board Side Max Usage (0..7)        ");
	
	for (int i=0; i<NUM_LED_BOARD_SIDES; i++)
8000a87a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a87e:	2f f8       	sub	r8,-1
8000a880:	ef 48 ff fc 	st.w	r7[-4],r8
8000a884:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a888:	58 78       	cp.w	r8,7
8000a88a:	fe 9a ff cd 	brle	8000a824 <show_chassis_sysErr+0x288>
		{
			strcat(str, "P ");
		}
	}

	print_ecdbg(str);
8000a88e:	ee c8 00 64 	sub	r8,r7,100
8000a892:	10 9c       	mov	r12,r8
8000a894:	f0 1f 00 21 	mcall	8000a918 <show_chassis_sysErr+0x37c>
	print_ecdbg("\r\n");
8000a898:	4a 7c       	lddpc	r12,8000a934 <show_chassis_sysErr+0x398>
8000a89a:	f0 1f 00 20 	mcall	8000a918 <show_chassis_sysErr+0x37c>

/*
 * Usage Struct Full
 */

	sprintf(str, "Usage Struct Open Slots                ");
8000a89e:	ee c8 00 64 	sub	r8,r7,100
8000a8a2:	32 8a       	mov	r10,40
8000a8a4:	4a bb       	lddpc	r11,8000a950 <show_chassis_sysErr+0x3b4>
8000a8a6:	10 9c       	mov	r12,r8
8000a8a8:	f0 1f 00 1e 	mcall	8000a920 <show_chassis_sysErr+0x384>
	if (sysErr.usageStructsFull == SE_FAIL)
8000a8ac:	49 e8       	lddpc	r8,8000a924 <show_chassis_sysErr+0x388>
8000a8ae:	f1 39 00 0e 	ld.ub	r9,r8[14]
8000a8b2:	30 18       	mov	r8,1
8000a8b4:	f0 09 18 00 	cp.b	r9,r8
8000a8b8:	c1 41       	brne	8000a8e0 <show_chassis_sysErr+0x344>
	{
		strcat(str, "F \r\n");
8000a8ba:	ee c6 00 64 	sub	r6,r7,100
8000a8be:	ee c8 00 64 	sub	r8,r7,100
8000a8c2:	10 9c       	mov	r12,r8
8000a8c4:	f0 1f 00 19 	mcall	8000a928 <show_chassis_sysErr+0x38c>
8000a8c8:	18 98       	mov	r8,r12
8000a8ca:	ec 08 00 08 	add	r8,r6,r8
8000a8ce:	30 5a       	mov	r10,5
8000a8d0:	4a 1b       	lddpc	r11,8000a954 <show_chassis_sysErr+0x3b8>
8000a8d2:	10 9c       	mov	r12,r8
8000a8d4:	f0 1f 00 13 	mcall	8000a920 <show_chassis_sysErr+0x384>
		electroclaveState = STATE_CHASSIS_ERROR;
8000a8d8:	49 a9       	lddpc	r9,8000a940 <show_chassis_sysErr+0x3a4>
8000a8da:	30 88       	mov	r8,8
8000a8dc:	b2 88       	st.b	r9[0x0],r8
8000a8de:	c1 08       	rjmp	8000a8fe <show_chassis_sysErr+0x362>
	}
	else
	{
		strcat(str, "P \r\n");
8000a8e0:	ee c6 00 64 	sub	r6,r7,100
8000a8e4:	ee c8 00 64 	sub	r8,r7,100
8000a8e8:	10 9c       	mov	r12,r8
8000a8ea:	f0 1f 00 10 	mcall	8000a928 <show_chassis_sysErr+0x38c>
8000a8ee:	18 98       	mov	r8,r12
8000a8f0:	ec 08 00 08 	add	r8,r6,r8
8000a8f4:	30 5a       	mov	r10,5
8000a8f6:	49 9b       	lddpc	r11,8000a958 <show_chassis_sysErr+0x3bc>
8000a8f8:	10 9c       	mov	r12,r8
8000a8fa:	f0 1f 00 0a 	mcall	8000a920 <show_chassis_sysErr+0x384>
	}
	
	print_ecdbg(str);
8000a8fe:	ee c8 00 64 	sub	r8,r7,100
8000a902:	10 9c       	mov	r12,r8
8000a904:	f0 1f 00 05 	mcall	8000a918 <show_chassis_sysErr+0x37c>
	print_ecdbg("\r\n");
8000a908:	48 bc       	lddpc	r12,8000a934 <show_chassis_sysErr+0x398>
8000a90a:	f0 1f 00 04 	mcall	8000a918 <show_chassis_sysErr+0x37c>

}
8000a90e:	2e 7d       	sub	sp,-100
8000a910:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000a914:	80 00       	ld.sh	r0,r0[0x0]
8000a916:	6a a4       	ld.w	r4,r5[0x28]
8000a918:	80 00       	ld.sh	r0,r0[0x0]
8000a91a:	33 38       	mov	r8,51
8000a91c:	80 00       	ld.sh	r0,r0[0x0]
8000a91e:	6a c0       	ld.w	r0,r5[0x30]
8000a920:	80 00       	ld.sh	r0,r0[0x0]
8000a922:	cc ba       	rjmp	8000a6b8 <show_chassis_sysErr+0x11c>
8000a924:	00 00       	add	r0,r0
8000a926:	0b d4       	ld.ub	r4,r5[0x5]
8000a928:	80 00       	ld.sh	r0,r0[0x0]
8000a92a:	ce 50       	breq	8000a8f4 <show_chassis_sysErr+0x358>
8000a92c:	80 00       	ld.sh	r0,r0[0x0]
8000a92e:	6a e8       	ld.w	r8,r5[0x38]
8000a930:	80 00       	ld.sh	r0,r0[0x0]
8000a932:	6a ec       	ld.w	r12,r5[0x38]
8000a934:	80 00       	ld.sh	r0,r0[0x0]
8000a936:	64 ec       	ld.w	r12,r2[0x38]
8000a938:	80 00       	ld.sh	r0,r0[0x0]
8000a93a:	6a f0       	ld.w	r0,r5[0x3c]
8000a93c:	80 00       	ld.sh	r0,r0[0x0]
8000a93e:	6b 18       	ld.w	r8,r5[0x44]
8000a940:	00 00       	add	r0,r0
8000a942:	07 b9       	ld.ub	r9,r3[0x3]
8000a944:	80 00       	ld.sh	r0,r0[0x0]
8000a946:	6b 40       	ld.w	r0,r5[0x50]
8000a948:	80 00       	ld.sh	r0,r0[0x0]
8000a94a:	6b 68       	ld.w	r8,r5[0x58]
8000a94c:	00 00       	add	r0,r0
8000a94e:	0b fe       	ld.ub	lr,r5[0x7]
8000a950:	80 00       	ld.sh	r0,r0[0x0]
8000a952:	6b 90       	ld.w	r0,r5[0x64]
8000a954:	80 00       	ld.sh	r0,r0[0x0]
8000a956:	6b b8       	ld.w	r8,r5[0x6c]
8000a958:	80 00       	ld.sh	r0,r0[0x0]
8000a95a:	6b c0       	ld.w	r0,r5[0x70]

8000a95c <show_chassis_all_LED_boards>:

void show_chassis_all_LED_boards(void);
void show_chassis_all_LED_boards(void)
{
8000a95c:	eb cd 40 c0 	pushm	r6-r7,lr
8000a960:	1a 97       	mov	r7,sp
8000a962:	21 5d       	sub	sp,84
	char str[80];
	int i = 0;
8000a964:	30 08       	mov	r8,0
8000a966:	ef 48 ff fc 	st.w	r7[-4],r8

	print_ecdbg("\r\n***LED BOARDS MASTER LIST***\r\n\r\n");
8000a96a:	4c 4c       	lddpc	r12,8000aa78 <show_chassis_all_LED_boards+0x11c>
8000a96c:	f0 1f 00 44 	mcall	8000aa7c <show_chassis_all_LED_boards+0x120>
			sprintf(str, "%2d) %02X%02X%02X%02X%02X%02X ", i,
				usageShdw[0].u[i].id[0],usageShdw[0].u[i].id[1],usageShdw[0].u[i].id[2],usageShdw[0].u[i].id[3],usageShdw[0].u[i].id[4],usageShdw[0].u[i].id[5]);
			
			if (usageShdw[0].u[i].top_botn)
#else
		if (sf[i].slotFilled)
8000a970:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000a974:	4c 38       	lddpc	r8,8000aa80 <show_chassis_all_LED_boards+0x124>
8000a976:	a1 79       	lsl	r9,0x1
8000a978:	2f f9       	sub	r9,-1
8000a97a:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
8000a97e:	f1 d8 c1 a1 	bfextu	r8,r8,0xd,0x1
8000a982:	5c 58       	castu.b	r8
8000a984:	c7 40       	breq	8000aa6c <show_chassis_all_LED_boards+0x110>
		{
			sprintf(str, "%2d) %02X%02X%02X%02X%02X%02X ", i,
			sf[i].id[0],sf[i].id[1],sf[i].id[2],sf[i].id[3],sf[i].id[4],sf[i].id[5]);
8000a986:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a98a:	4b e9       	lddpc	r9,8000aa80 <show_chassis_all_LED_boards+0x124>
8000a98c:	a3 78       	lsl	r8,0x3
8000a98e:	f2 08 00 08 	add	r8,r9,r8
8000a992:	11 d8       	ld.ub	r8,r8[0x5]
			
			if (usageShdw[0].u[i].top_botn)
#else
		if (sf[i].slotFilled)
		{
			sprintf(str, "%2d) %02X%02X%02X%02X%02X%02X ", i,
8000a994:	10 96       	mov	r6,r8
			sf[i].id[0],sf[i].id[1],sf[i].id[2],sf[i].id[3],sf[i].id[4],sf[i].id[5]);
8000a996:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000a99a:	4b a8       	lddpc	r8,8000aa80 <show_chassis_all_LED_boards+0x124>
8000a99c:	a1 79       	lsl	r9,0x1
8000a99e:	2f f9       	sub	r9,-1
8000a9a0:	f0 09 07 28 	ld.ub	r8,r8[r9<<0x2]
			
			if (usageShdw[0].u[i].top_botn)
#else
		if (sf[i].slotFilled)
		{
			sprintf(str, "%2d) %02X%02X%02X%02X%02X%02X ", i,
8000a9a4:	10 9e       	mov	lr,r8
			sf[i].id[0],sf[i].id[1],sf[i].id[2],sf[i].id[3],sf[i].id[4],sf[i].id[5]);
8000a9a6:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a9aa:	4b 69       	lddpc	r9,8000aa80 <show_chassis_all_LED_boards+0x124>
8000a9ac:	a3 78       	lsl	r8,0x3
8000a9ae:	f2 08 00 08 	add	r8,r9,r8
8000a9b2:	11 b8       	ld.ub	r8,r8[0x3]
			
			if (usageShdw[0].u[i].top_botn)
#else
		if (sf[i].slotFilled)
		{
			sprintf(str, "%2d) %02X%02X%02X%02X%02X%02X ", i,
8000a9b4:	10 9c       	mov	r12,r8
			sf[i].id[0],sf[i].id[1],sf[i].id[2],sf[i].id[3],sf[i].id[4],sf[i].id[5]);
8000a9b6:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000a9ba:	4b 28       	lddpc	r8,8000aa80 <show_chassis_all_LED_boards+0x124>
8000a9bc:	a3 69       	lsl	r9,0x2
8000a9be:	2f f9       	sub	r9,-1
8000a9c0:	f0 09 07 18 	ld.ub	r8,r8[r9<<0x1]
			
			if (usageShdw[0].u[i].top_botn)
#else
		if (sf[i].slotFilled)
		{
			sprintf(str, "%2d) %02X%02X%02X%02X%02X%02X ", i,
8000a9c4:	10 9b       	mov	r11,r8
			sf[i].id[0],sf[i].id[1],sf[i].id[2],sf[i].id[3],sf[i].id[4],sf[i].id[5]);
8000a9c6:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a9ca:	4a e9       	lddpc	r9,8000aa80 <show_chassis_all_LED_boards+0x124>
8000a9cc:	a3 78       	lsl	r8,0x3
8000a9ce:	f2 08 00 08 	add	r8,r9,r8
8000a9d2:	11 98       	ld.ub	r8,r8[0x1]
			
			if (usageShdw[0].u[i].top_botn)
#else
		if (sf[i].slotFilled)
		{
			sprintf(str, "%2d) %02X%02X%02X%02X%02X%02X ", i,
8000a9d4:	10 9a       	mov	r10,r8
			sf[i].id[0],sf[i].id[1],sf[i].id[2],sf[i].id[3],sf[i].id[4],sf[i].id[5]);
8000a9d6:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000a9da:	4a a8       	lddpc	r8,8000aa80 <show_chassis_all_LED_boards+0x124>
8000a9dc:	f0 09 07 38 	ld.ub	r8,r8[r9<<0x3]
			
			if (usageShdw[0].u[i].top_botn)
#else
		if (sf[i].slotFilled)
		{
			sprintf(str, "%2d) %02X%02X%02X%02X%02X%02X ", i,
8000a9e0:	10 99       	mov	r9,r8
8000a9e2:	ee c8 00 54 	sub	r8,r7,84
8000a9e6:	1a d6       	st.w	--sp,r6
8000a9e8:	1a de       	st.w	--sp,lr
8000a9ea:	1a dc       	st.w	--sp,r12
8000a9ec:	1a db       	st.w	--sp,r11
8000a9ee:	1a da       	st.w	--sp,r10
8000a9f0:	1a d9       	st.w	--sp,r9
8000a9f2:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000a9f6:	1a d9       	st.w	--sp,r9
8000a9f8:	4a 3b       	lddpc	r11,8000aa84 <show_chassis_all_LED_boards+0x128>
8000a9fa:	10 9c       	mov	r12,r8
8000a9fc:	f0 1f 00 23 	mcall	8000aa88 <show_chassis_all_LED_boards+0x12c>
8000aa00:	2f 9d       	sub	sp,-28
			sf[i].id[0],sf[i].id[1],sf[i].id[2],sf[i].id[3],sf[i].id[4],sf[i].id[5]);
			
			if (sf[i].top_botn)
8000aa02:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000aa06:	49 f8       	lddpc	r8,8000aa80 <show_chassis_all_LED_boards+0x124>
8000aa08:	a1 79       	lsl	r9,0x1
8000aa0a:	2f f9       	sub	r9,-1
8000aa0c:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
8000aa10:	f1 d8 c1 e1 	bfextu	r8,r8,0xf,0x1
8000aa14:	5c 58       	castu.b	r8
8000aa16:	c1 10       	breq	8000aa38 <show_chassis_all_LED_boards+0xdc>

#endif //SERIAL_ID_AND_ALL_USAGE_COMBINED			
			{
				strcat(str, " TOP\r\n");
8000aa18:	ee c6 00 54 	sub	r6,r7,84
8000aa1c:	ee c8 00 54 	sub	r8,r7,84
8000aa20:	10 9c       	mov	r12,r8
8000aa22:	f0 1f 00 1b 	mcall	8000aa8c <show_chassis_all_LED_boards+0x130>
8000aa26:	18 98       	mov	r8,r12
8000aa28:	ec 08 00 08 	add	r8,r6,r8
8000aa2c:	30 7a       	mov	r10,7
8000aa2e:	49 9b       	lddpc	r11,8000aa90 <show_chassis_all_LED_boards+0x134>
8000aa30:	10 9c       	mov	r12,r8
8000aa32:	f0 1f 00 19 	mcall	8000aa94 <show_chassis_all_LED_boards+0x138>
8000aa36:	c1 08       	rjmp	8000aa56 <show_chassis_all_LED_boards+0xfa>
			}
			else
			{
				strcat(str, " BOT\r\n");
8000aa38:	ee c6 00 54 	sub	r6,r7,84
8000aa3c:	ee c8 00 54 	sub	r8,r7,84
8000aa40:	10 9c       	mov	r12,r8
8000aa42:	f0 1f 00 13 	mcall	8000aa8c <show_chassis_all_LED_boards+0x130>
8000aa46:	18 98       	mov	r8,r12
8000aa48:	ec 08 00 08 	add	r8,r6,r8
8000aa4c:	30 7a       	mov	r10,7
8000aa4e:	49 3b       	lddpc	r11,8000aa98 <show_chassis_all_LED_boards+0x13c>
8000aa50:	10 9c       	mov	r12,r8
8000aa52:	f0 1f 00 11 	mcall	8000aa94 <show_chassis_all_LED_boards+0x138>
			}
			
			print_ecdbg(str);
8000aa56:	ee c8 00 54 	sub	r8,r7,84
8000aa5a:	10 9c       	mov	r12,r8
8000aa5c:	f0 1f 00 08 	mcall	8000aa7c <show_chassis_all_LED_boards+0x120>
		}
		else
		{
			break; //LED boards are stored contiguously, so if we hit a blank spot we are done with the entries in the list
		}
		i++;
8000aa60:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000aa64:	2f f8       	sub	r8,-1
8000aa66:	ef 48 ff fc 	st.w	r7[-4],r8
		
	}
8000aa6a:	c8 3b       	rjmp	8000a970 <show_chassis_all_LED_boards+0x14>
	
	print_ecdbg("\r\n\r\n");
8000aa6c:	48 cc       	lddpc	r12,8000aa9c <show_chassis_all_LED_boards+0x140>
8000aa6e:	f0 1f 00 04 	mcall	8000aa7c <show_chassis_all_LED_boards+0x120>

}
8000aa72:	2e bd       	sub	sp,-84
8000aa74:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000aa78:	80 00       	ld.sh	r0,r0[0x0]
8000aa7a:	6b c8       	ld.w	r8,r5[0x70]
8000aa7c:	80 00       	ld.sh	r0,r0[0x0]
8000aa7e:	33 38       	mov	r8,51
8000aa80:	00 00       	add	r0,r0
8000aa82:	08 48       	or	r8,r4
8000aa84:	80 00       	ld.sh	r0,r0[0x0]
8000aa86:	6b ec       	ld.w	r12,r5[0x78]
8000aa88:	80 00       	ld.sh	r0,r0[0x0]
8000aa8a:	ce 10       	breq	8000aa4c <show_chassis_all_LED_boards+0xf0>
8000aa8c:	80 00       	ld.sh	r0,r0[0x0]
8000aa8e:	ce 50       	breq	8000aa58 <show_chassis_all_LED_boards+0xfc>
8000aa90:	80 00       	ld.sh	r0,r0[0x0]
8000aa92:	6c 0c       	ld.w	r12,r6[0x0]
8000aa94:	80 00       	ld.sh	r0,r0[0x0]
8000aa96:	cc ba       	rjmp	8000a82c <show_chassis_sysErr+0x290>
8000aa98:	80 00       	ld.sh	r0,r0[0x0]
8000aa9a:	6c 14       	ld.w	r4,r6[0x4]
8000aa9c:	80 00       	ld.sh	r0,r0[0x0]
8000aa9e:	6c 1c       	ld.w	r12,r6[0x4]

8000aaa0 <show_help_and_prompt>:

void show_help_and_prompt(void);
void show_help_and_prompt(void)
{
8000aaa0:	eb cd 40 80 	pushm	r7,lr
8000aaa4:	1a 97       	mov	r7,sp
	print_ecdbg("Type 'H' for help.\r\n\r\n");
8000aaa6:	48 3c       	lddpc	r12,8000aab0 <show_help_and_prompt+0x10>
8000aaa8:	f0 1f 00 03 	mcall	8000aab4 <show_help_and_prompt+0x14>
}
8000aaac:	e3 cd 80 80 	ldm	sp++,r7,pc
8000aab0:	80 00       	ld.sh	r0,r0[0x0]
8000aab2:	6c 24       	ld.w	r4,r6[0x8]
8000aab4:	80 00       	ld.sh	r0,r0[0x0]
8000aab6:	33 38       	mov	r8,51

8000aab8 <service_ecdbg_input>:
char cmd[20];
unsigned char cmdIdx = 0;

void service_ecdbg_input(void);
void service_ecdbg_input(void)
{
8000aab8:	eb cd 40 80 	pushm	r7,lr
8000aabc:	1a 97       	mov	r7,sp
8000aabe:	20 3d       	sub	sp,12
	int rx_char;
	unsigned int tmpNewDte;
	unsigned char tryToChangeDte = 0;
8000aac0:	30 08       	mov	r8,0
8000aac2:	ef 68 ff ff 	st.b	r7[-1],r8

	if (usart_read_char(ECDBG_USART, &rx_char) != USART_SUCCESS)
8000aac6:	ee c8 00 0c 	sub	r8,r7,12
8000aaca:	10 9b       	mov	r11,r8
8000aacc:	fe 7c 28 00 	mov	r12,-55296
8000aad0:	f0 1f 00 b2 	mcall	8000ad98 <service_ecdbg_input+0x2e0>
8000aad4:	18 98       	mov	r8,r12
8000aad6:	58 08       	cp.w	r8,0
8000aad8:	e0 81 01 4d 	brne	8000ad72 <service_ecdbg_input+0x2ba>
	{
		return;
	}

	if (rx_char == USART_FAILURE)
8000aadc:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000aae0:	5b f8       	cp.w	r8,-1
8000aae2:	e0 80 01 4a 	breq	8000ad76 <service_ecdbg_input+0x2be>
	{
//26may15 why are we getting this? ignore for now		usart_write_line(ECDBG_USART, "UART error\r\n");
		return;
	}
	if (rx_char == '\x03')
8000aae6:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000aaea:	58 38       	cp.w	r8,3
8000aaec:	e0 80 01 47 	breq	8000ad7a <service_ecdbg_input+0x2c2>
	{
		return;
	}
	
	if ((rx_char < 0x0a) || (rx_char > 0x7a))
8000aaf0:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000aaf4:	58 98       	cp.w	r8,9
8000aaf6:	e0 8a 01 44 	brle	8000ad7e <service_ecdbg_input+0x2c6>
8000aafa:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000aafe:	e0 48 00 7a 	cp.w	r8,122
8000ab02:	e0 89 01 40 	brgt	8000ad82 <service_ecdbg_input+0x2ca>
	{
		return; //completely out of range, ignore
	}
	
	
	if ((rx_char == 0x0d) ||							//carriage return
8000ab06:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000ab0a:	58 d8       	cp.w	r8,13
8000ab0c:	c2 e0       	breq	8000ab68 <service_ecdbg_input+0xb0>
		(rx_char == 0x0a) ||							//line feed
8000ab0e:	ee f8 ff f4 	ld.w	r8,r7[-12]
	{
		return; //completely out of range, ignore
	}
	
	
	if ((rx_char == 0x0d) ||							//carriage return
8000ab12:	58 a8       	cp.w	r8,10
8000ab14:	c2 a0       	breq	8000ab68 <service_ecdbg_input+0xb0>
		(rx_char == 0x0a) ||							//line feed
		(rx_char == 0x20) ||							//space
8000ab16:	ee f8 ff f4 	ld.w	r8,r7[-12]
	{
		return; //completely out of range, ignore
	}
	
	
	if ((rx_char == 0x0d) ||							//carriage return
8000ab1a:	e0 48 00 20 	cp.w	r8,32
8000ab1e:	c2 50       	breq	8000ab68 <service_ecdbg_input+0xb0>
		(rx_char == 0x0a) ||							//line feed
		(rx_char == 0x20) ||							//space
		((rx_char >= 0x30) && (rx_char <= 0x39)) ||		//decimal number
8000ab20:	ee f8 ff f4 	ld.w	r8,r7[-12]
	{
		return; //completely out of range, ignore
	}
	
	
	if ((rx_char == 0x0d) ||							//carriage return
8000ab24:	e0 48 00 2f 	cp.w	r8,47
8000ab28:	e0 8a 00 08 	brle	8000ab38 <service_ecdbg_input+0x80>
		(rx_char == 0x0a) ||							//line feed
		(rx_char == 0x20) ||							//space
		((rx_char >= 0x30) && (rx_char <= 0x39)) ||		//decimal number
8000ab2c:	ee f8 ff f4 	ld.w	r8,r7[-12]
	{
		return; //completely out of range, ignore
	}
	
	
	if ((rx_char == 0x0d) ||							//carriage return
8000ab30:	e0 48 00 39 	cp.w	r8,57
8000ab34:	e0 8a 00 1a 	brle	8000ab68 <service_ecdbg_input+0xb0>
		(rx_char == 0x0a) ||							//line feed
		(rx_char == 0x20) ||							//space
		((rx_char >= 0x30) && (rx_char <= 0x39)) ||		//decimal number
		((rx_char >= 0x41) && (rx_char <= 0x5a)) ||		//upper case alpha
8000ab38:	ee f8 ff f4 	ld.w	r8,r7[-12]
	{
		return; //completely out of range, ignore
	}
	
	
	if ((rx_char == 0x0d) ||							//carriage return
8000ab3c:	e0 48 00 40 	cp.w	r8,64
8000ab40:	e0 8a 00 08 	brle	8000ab50 <service_ecdbg_input+0x98>
		(rx_char == 0x0a) ||							//line feed
		(rx_char == 0x20) ||							//space
		((rx_char >= 0x30) && (rx_char <= 0x39)) ||		//decimal number
		((rx_char >= 0x41) && (rx_char <= 0x5a)) ||		//upper case alpha
8000ab44:	ee f8 ff f4 	ld.w	r8,r7[-12]
	{
		return; //completely out of range, ignore
	}
	
	
	if ((rx_char == 0x0d) ||							//carriage return
8000ab48:	e0 48 00 5a 	cp.w	r8,90
8000ab4c:	e0 8a 00 0e 	brle	8000ab68 <service_ecdbg_input+0xb0>
		(rx_char == 0x0a) ||							//line feed
		(rx_char == 0x20) ||							//space
		((rx_char >= 0x30) && (rx_char <= 0x39)) ||		//decimal number
		((rx_char >= 0x41) && (rx_char <= 0x5a)) ||		//upper case alpha
		((rx_char >= 0x61) && (rx_char <= 0x7a)))		//lower case alpha
8000ab50:	ee f8 ff f4 	ld.w	r8,r7[-12]
	{
		return; //completely out of range, ignore
	}
	
	
	if ((rx_char == 0x0d) ||							//carriage return
8000ab54:	e0 48 00 60 	cp.w	r8,96
8000ab58:	e0 8a 01 17 	brle	8000ad86 <service_ecdbg_input+0x2ce>
		(rx_char == 0x0a) ||							//line feed
		(rx_char == 0x20) ||							//space
		((rx_char >= 0x30) && (rx_char <= 0x39)) ||		//decimal number
		((rx_char >= 0x41) && (rx_char <= 0x5a)) ||		//upper case alpha
		((rx_char >= 0x61) && (rx_char <= 0x7a)))		//lower case alpha
8000ab5c:	ee f8 ff f4 	ld.w	r8,r7[-12]
	{
		return; //completely out of range, ignore
	}
	
	
	if ((rx_char == 0x0d) ||							//carriage return
8000ab60:	e0 48 00 7a 	cp.w	r8,122
8000ab64:	e0 89 01 13 	brgt	8000ad8a <service_ecdbg_input+0x2d2>
		(rx_char == 0x20) ||							//space
		((rx_char >= 0x30) && (rx_char <= 0x39)) ||		//decimal number
		((rx_char >= 0x41) && (rx_char <= 0x5a)) ||		//upper case alpha
		((rx_char >= 0x61) && (rx_char <= 0x7a)))		//lower case alpha
	{
		if (rx_char == 0x50)
8000ab68:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000ab6c:	e0 48 00 50 	cp.w	r8,80
8000ab70:	e0 80 01 0f 	breq	8000ad8e <service_ecdbg_input+0x2d6>
	{
		return;
	}


	cmd[cmdIdx++] = rx_char;
8000ab74:	fe f8 02 28 	ld.w	r8,pc[552]
8000ab78:	11 88       	ld.ub	r8,r8[0x0]
8000ab7a:	10 9a       	mov	r10,r8
8000ab7c:	ee f9 ff f4 	ld.w	r9,r7[-12]
8000ab80:	5c 59       	castu.b	r9
8000ab82:	fe fb 02 1e 	ld.w	r11,pc[542]
8000ab86:	f6 0a 0b 09 	st.b	r11[r10],r9
8000ab8a:	2f f8       	sub	r8,-1
8000ab8c:	5c 58       	castu.b	r8
8000ab8e:	fe f9 02 0e 	ld.w	r9,pc[526]
8000ab92:	b2 88       	st.b	r9[0x0],r8
	
	usart_putchar(ECDBG_USART, rx_char);
8000ab94:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000ab98:	10 9b       	mov	r11,r8
8000ab9a:	fe 7c 28 00 	mov	r12,-55296
8000ab9e:	f0 1f 00 82 	mcall	8000ada4 <service_ecdbg_input+0x2ec>
	if (rx_char == '\r')
8000aba2:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000aba6:	58 d8       	cp.w	r8,13
8000aba8:	e0 81 00 f4 	brne	8000ad90 <service_ecdbg_input+0x2d8>
	{ 
		if (cmdIdx == 2)
8000abac:	4f c8       	lddpc	r8,8000ad9c <service_ecdbg_input+0x2e4>
8000abae:	11 89       	ld.ub	r9,r8[0x0]
8000abb0:	30 28       	mov	r8,2
8000abb2:	f0 09 18 00 	cp.b	r9,r8
8000abb6:	c4 d1       	brne	8000ac50 <service_ecdbg_input+0x198>
		{
			switch(cmd[0])
8000abb8:	4f a8       	lddpc	r8,8000ada0 <service_ecdbg_input+0x2e8>
8000abba:	11 88       	ld.ub	r8,r8[0x0]
8000abbc:	e0 48 00 53 	cp.w	r8,83
8000abc0:	c3 d0       	breq	8000ac3a <service_ecdbg_input+0x182>
8000abc2:	e0 89 00 09 	brgt	8000abd4 <service_ecdbg_input+0x11c>
8000abc6:	e0 48 00 44 	cp.w	r8,68
8000abca:	c2 b0       	breq	8000ac20 <service_ecdbg_input+0x168>
8000abcc:	e0 48 00 48 	cp.w	r8,72
8000abd0:	c0 c0       	breq	8000abe8 <service_ecdbg_input+0x130>
				case 's':
					show_sw_version();
					show_chassis_status_info();
					show_chassis_sysErr();
					show_chassis_all_LED_boards();
					show_help_and_prompt();
8000abd2:	cc 88       	rjmp	8000ad62 <service_ecdbg_input+0x2aa>
	usart_putchar(ECDBG_USART, rx_char);
	if (rx_char == '\r')
	{ 
		if (cmdIdx == 2)
		{
			switch(cmd[0])
8000abd4:	e0 48 00 68 	cp.w	r8,104
8000abd8:	c0 80       	breq	8000abe8 <service_ecdbg_input+0x130>
8000abda:	e0 48 00 73 	cp.w	r8,115
8000abde:	c2 e0       	breq	8000ac3a <service_ecdbg_input+0x182>
8000abe0:	e0 48 00 64 	cp.w	r8,100
8000abe4:	c1 e0       	breq	8000ac20 <service_ecdbg_input+0x168>
				case 's':
					show_sw_version();
					show_chassis_status_info();
					show_chassis_sysErr();
					show_chassis_all_LED_boards();
					show_help_and_prompt();
8000abe6:	cb e8       	rjmp	8000ad62 <service_ecdbg_input+0x2aa>
		{
			switch(cmd[0])
			{
				case 'H':
				case 'h':
					print_ecdbg("\r\n**-----------------**\r\n");
8000abe8:	4f 0c       	lddpc	r12,8000ada8 <service_ecdbg_input+0x2f0>
8000abea:	f0 1f 00 71 	mcall	8000adac <service_ecdbg_input+0x2f4>
					print_ecdbg("  Electroclave HELP\r\n");
8000abee:	4f 1c       	lddpc	r12,8000adb0 <service_ecdbg_input+0x2f8>
8000abf0:	f0 1f 00 6f 	mcall	8000adac <service_ecdbg_input+0x2f4>
					print_ecdbg("**-----------------**\r\n");
8000abf4:	4f 0c       	lddpc	r12,8000adb4 <service_ecdbg_input+0x2fc>
8000abf6:	f0 1f 00 6e 	mcall	8000adac <service_ecdbg_input+0x2f4>
					print_ecdbg("    H        - This help menu\r\n");
8000abfa:	4f 0c       	lddpc	r12,8000adb8 <service_ecdbg_input+0x300>
8000abfc:	f0 1f 00 6c 	mcall	8000adac <service_ecdbg_input+0x2f4>
					print_ecdbg("    D        - Show current DTE setting\r\n");
8000ac00:	4e fc       	lddpc	r12,8000adbc <service_ecdbg_input+0x304>
8000ac02:	f0 1f 00 6b 	mcall	8000adac <service_ecdbg_input+0x2f4>
					print_ecdbg("    D  xx    - Change initial DTE to xx minutes where 2 >= xx >= 59.\r\n");
8000ac06:	4e fc       	lddpc	r12,8000adc0 <service_ecdbg_input+0x308>
8000ac08:	f0 1f 00 69 	mcall	8000adac <service_ecdbg_input+0x2f4>
					print_ecdbg("    S        - System status\r\n");
8000ac0c:	4e ec       	lddpc	r12,8000adc4 <service_ecdbg_input+0x30c>
8000ac0e:	f0 1f 00 68 	mcall	8000adac <service_ecdbg_input+0x2f4>
					print_ecdbg("**-----------------**\r\n");
8000ac12:	4e 9c       	lddpc	r12,8000adb4 <service_ecdbg_input+0x2fc>
8000ac14:	f0 1f 00 66 	mcall	8000adac <service_ecdbg_input+0x2f4>
					print_ecdbg(">");
8000ac18:	4e cc       	lddpc	r12,8000adc8 <service_ecdbg_input+0x310>
8000ac1a:	f0 1f 00 65 	mcall	8000adac <service_ecdbg_input+0x2f4>
					break;
8000ac1e:	ca 28       	rjmp	8000ad62 <service_ecdbg_input+0x2aa>
				case 'D':
				case 'd':
					print_ecdbg("Initial DTE set to: ");
8000ac20:	4e bc       	lddpc	r12,8000adcc <service_ecdbg_input+0x314>
8000ac22:	f0 1f 00 63 	mcall	8000adac <service_ecdbg_input+0x2f4>
					print_ecdbg_num(c.initialDTE);
8000ac26:	4e b8       	lddpc	r8,8000add0 <service_ecdbg_input+0x318>
8000ac28:	11 88       	ld.ub	r8,r8[0x0]
8000ac2a:	10 9c       	mov	r12,r8
8000ac2c:	f0 1f 00 6a 	mcall	8000add4 <service_ecdbg_input+0x31c>
					print_ecdbg(" minutes.\r\n>");
8000ac30:	4e ac       	lddpc	r12,8000add8 <service_ecdbg_input+0x320>
8000ac32:	f0 1f 00 5f 	mcall	8000adac <service_ecdbg_input+0x2f4>
					break;
8000ac36:	d7 03       	nop
8000ac38:	c9 58       	rjmp	8000ad62 <service_ecdbg_input+0x2aa>
				case 'S':
				case 's':
					show_sw_version();
8000ac3a:	f0 1f 00 69 	mcall	8000addc <service_ecdbg_input+0x324>
					show_chassis_status_info();
8000ac3e:	f0 1f 00 69 	mcall	8000ade0 <service_ecdbg_input+0x328>
					show_chassis_sysErr();
8000ac42:	f0 1f 00 69 	mcall	8000ade4 <service_ecdbg_input+0x32c>
					show_chassis_all_LED_boards();
8000ac46:	f0 1f 00 69 	mcall	8000ade8 <service_ecdbg_input+0x330>
					show_help_and_prompt();
8000ac4a:	f0 1f 00 69 	mcall	8000adec <service_ecdbg_input+0x334>
8000ac4e:	c8 a8       	rjmp	8000ad62 <service_ecdbg_input+0x2aa>
					break;
			}
		}
		else if (cmd[1] == ' ')
8000ac50:	4d 48       	lddpc	r8,8000ada0 <service_ecdbg_input+0x2e8>
8000ac52:	11 99       	ld.ub	r9,r8[0x1]
8000ac54:	32 08       	mov	r8,32
8000ac56:	f0 09 18 00 	cp.b	r9,r8
8000ac5a:	e0 81 00 84 	brne	8000ad62 <service_ecdbg_input+0x2aa>
		{
			if ((cmd[0] == 'D') || (cmd[0] == 'd'))
8000ac5e:	4d 18       	lddpc	r8,8000ada0 <service_ecdbg_input+0x2e8>
8000ac60:	11 89       	ld.ub	r9,r8[0x0]
8000ac62:	34 48       	mov	r8,68
8000ac64:	f0 09 18 00 	cp.b	r9,r8
8000ac68:	c0 70       	breq	8000ac76 <service_ecdbg_input+0x1be>
8000ac6a:	4c e8       	lddpc	r8,8000ada0 <service_ecdbg_input+0x2e8>
8000ac6c:	11 89       	ld.ub	r9,r8[0x0]
8000ac6e:	36 48       	mov	r8,100
8000ac70:	f0 09 18 00 	cp.b	r9,r8
8000ac74:	c7 71       	brne	8000ad62 <service_ecdbg_input+0x2aa>
			{
				if (cmdIdx == 4)
8000ac76:	4c a8       	lddpc	r8,8000ad9c <service_ecdbg_input+0x2e4>
8000ac78:	11 89       	ld.ub	r9,r8[0x0]
8000ac7a:	30 48       	mov	r8,4
8000ac7c:	f0 09 18 00 	cp.b	r9,r8
8000ac80:	c1 41       	brne	8000aca8 <service_ecdbg_input+0x1f0>
				{
					if (isdigit(cmd[2]))
8000ac82:	4d c8       	lddpc	r8,8000adf0 <service_ecdbg_input+0x338>
8000ac84:	70 09       	ld.w	r9,r8[0x0]
8000ac86:	4c 78       	lddpc	r8,8000ada0 <service_ecdbg_input+0x2e8>
8000ac88:	11 a8       	ld.ub	r8,r8[0x2]
8000ac8a:	f2 08 00 08 	add	r8,r9,r8
8000ac8e:	11 88       	ld.ub	r8,r8[0x0]
8000ac90:	e2 18 00 04 	andl	r8,0x4,COH
8000ac94:	c3 c0       	breq	8000ad0c <service_ecdbg_input+0x254>
					{
						tmpNewDte = cmd[2] - 0x30;
8000ac96:	4c 38       	lddpc	r8,8000ada0 <service_ecdbg_input+0x2e8>
8000ac98:	11 a8       	ld.ub	r8,r8[0x2]
8000ac9a:	23 08       	sub	r8,48
8000ac9c:	ef 48 ff f8 	st.w	r7[-8],r8
						tryToChangeDte = 1;
8000aca0:	30 18       	mov	r8,1
8000aca2:	ef 68 ff ff 	st.b	r7[-1],r8
8000aca6:	c3 38       	rjmp	8000ad0c <service_ecdbg_input+0x254>
					}					
				}
				else if (cmdIdx == 5)
8000aca8:	4b d8       	lddpc	r8,8000ad9c <service_ecdbg_input+0x2e4>
8000acaa:	11 89       	ld.ub	r9,r8[0x0]
8000acac:	30 58       	mov	r8,5
8000acae:	f0 09 18 00 	cp.b	r9,r8
8000acb2:	c2 d1       	brne	8000ad0c <service_ecdbg_input+0x254>
				{
					if (isdigit(cmd[2]) && (isdigit(cmd[3])))
8000acb4:	4c f8       	lddpc	r8,8000adf0 <service_ecdbg_input+0x338>
8000acb6:	70 09       	ld.w	r9,r8[0x0]
8000acb8:	4b a8       	lddpc	r8,8000ada0 <service_ecdbg_input+0x2e8>
8000acba:	11 a8       	ld.ub	r8,r8[0x2]
8000acbc:	f2 08 00 08 	add	r8,r9,r8
8000acc0:	11 88       	ld.ub	r8,r8[0x0]
8000acc2:	e2 18 00 04 	andl	r8,0x4,COH
8000acc6:	c2 30       	breq	8000ad0c <service_ecdbg_input+0x254>
8000acc8:	4c a8       	lddpc	r8,8000adf0 <service_ecdbg_input+0x338>
8000acca:	70 09       	ld.w	r9,r8[0x0]
8000accc:	4b 58       	lddpc	r8,8000ada0 <service_ecdbg_input+0x2e8>
8000acce:	11 b8       	ld.ub	r8,r8[0x3]
8000acd0:	f2 08 00 08 	add	r8,r9,r8
8000acd4:	11 88       	ld.ub	r8,r8[0x0]
8000acd6:	e2 18 00 04 	andl	r8,0x4,COH
8000acda:	c1 90       	breq	8000ad0c <service_ecdbg_input+0x254>
					{
						tmpNewDte = (cmd[2]-0x30) * 10;
8000acdc:	4b 18       	lddpc	r8,8000ada0 <service_ecdbg_input+0x2e8>
8000acde:	11 a8       	ld.ub	r8,r8[0x2]
8000ace0:	10 99       	mov	r9,r8
8000ace2:	12 98       	mov	r8,r9
8000ace4:	a3 68       	lsl	r8,0x2
8000ace6:	12 08       	add	r8,r9
8000ace8:	a1 78       	lsl	r8,0x1
8000acea:	f0 c8 01 e0 	sub	r8,r8,480
8000acee:	ef 48 ff f8 	st.w	r7[-8],r8
						tmpNewDte += (cmd[3] - 0x30);
8000acf2:	4a c8       	lddpc	r8,8000ada0 <service_ecdbg_input+0x2e8>
8000acf4:	11 b8       	ld.ub	r8,r8[0x3]
8000acf6:	10 99       	mov	r9,r8
8000acf8:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000acfc:	f2 08 00 08 	add	r8,r9,r8
8000ad00:	23 08       	sub	r8,48
8000ad02:	ef 48 ff f8 	st.w	r7[-8],r8
						tryToChangeDte = 1;
8000ad06:	30 18       	mov	r8,1
8000ad08:	ef 68 ff ff 	st.b	r7[-1],r8
					}
				}
				if (tryToChangeDte)
8000ad0c:	ef 39 ff ff 	ld.ub	r9,r7[-1]
8000ad10:	30 08       	mov	r8,0
8000ad12:	f0 09 18 00 	cp.b	r9,r8
8000ad16:	c2 60       	breq	8000ad62 <service_ecdbg_input+0x2aa>
				{
					if ((tmpNewDte < 60) && (tmpNewDte > 1))
8000ad18:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000ad1c:	e0 48 00 3b 	cp.w	r8,59
8000ad20:	e0 8b 00 1b 	brhi	8000ad56 <service_ecdbg_input+0x29e>
8000ad24:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000ad28:	58 18       	cp.w	r8,1
8000ad2a:	e0 88 00 16 	brls	8000ad56 <service_ecdbg_input+0x29e>
					{
						print_ecdbg("Initial DTE now set to: ");
8000ad2e:	4b 2c       	lddpc	r12,8000adf4 <service_ecdbg_input+0x33c>
8000ad30:	f0 1f 00 1f 	mcall	8000adac <service_ecdbg_input+0x2f4>
						print_ecdbg_num(tmpNewDte);
8000ad34:	ee fc ff f8 	ld.w	r12,r7[-8]
8000ad38:	f0 1f 00 27 	mcall	8000add4 <service_ecdbg_input+0x31c>
						print_ecdbg("\r\n>");
8000ad3c:	4a fc       	lddpc	r12,8000adf8 <service_ecdbg_input+0x340>
8000ad3e:	f0 1f 00 1c 	mcall	8000adac <service_ecdbg_input+0x2f4>
						
						c.initialDTE = tmpNewDte;
8000ad42:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000ad46:	5c 58       	castu.b	r8
8000ad48:	4a 29       	lddpc	r9,8000add0 <service_ecdbg_input+0x318>
8000ad4a:	b2 88       	st.b	r9[0x0],r8
						
						store_config();
8000ad4c:	f0 1f 00 2c 	mcall	8000adfc <service_ecdbg_input+0x344>
						store_config(); //do this twice to store it in both buffers to make extra sure we got it
8000ad50:	f0 1f 00 2b 	mcall	8000adfc <service_ecdbg_input+0x344>
						tryToChangeDte = 1;
					}
				}
				if (tryToChangeDte)
				{
					if ((tmpNewDte < 60) && (tmpNewDte > 1))
8000ad54:	c0 78       	rjmp	8000ad62 <service_ecdbg_input+0x2aa>
						store_config(); //do this twice to store it in both buffers to make extra sure we got it
						
					}
					else
					{
						print_ecdbg("Error. Initial DTE not modified. \r\n");
8000ad56:	4a bc       	lddpc	r12,8000ae00 <service_ecdbg_input+0x348>
8000ad58:	f0 1f 00 15 	mcall	8000adac <service_ecdbg_input+0x2f4>
						print_ecdbg("Must be a value between 2 and 59.\r\n>");
8000ad5c:	4a ac       	lddpc	r12,8000ae04 <service_ecdbg_input+0x34c>
8000ad5e:	f0 1f 00 14 	mcall	8000adac <service_ecdbg_input+0x2f4>
				}
			}
		}
		
		// Add a LF and consider this as the end of the line.
		print_ecdbg("\r\n>");
8000ad62:	4a 6c       	lddpc	r12,8000adf8 <service_ecdbg_input+0x340>
8000ad64:	f0 1f 00 12 	mcall	8000adac <service_ecdbg_input+0x2f4>
		cmdIdx = 0;
8000ad68:	48 d9       	lddpc	r9,8000ad9c <service_ecdbg_input+0x2e4>
8000ad6a:	30 08       	mov	r8,0
8000ad6c:	b2 88       	st.b	r9[0x0],r8
		return;
8000ad6e:	d7 03       	nop
8000ad70:	c1 08       	rjmp	8000ad90 <service_ecdbg_input+0x2d8>
	unsigned int tmpNewDte;
	unsigned char tryToChangeDte = 0;

	if (usart_read_char(ECDBG_USART, &rx_char) != USART_SUCCESS)
	{
		return;
8000ad72:	d7 03       	nop
8000ad74:	c0 e8       	rjmp	8000ad90 <service_ecdbg_input+0x2d8>
	}

	if (rx_char == USART_FAILURE)
	{
//26may15 why are we getting this? ignore for now		usart_write_line(ECDBG_USART, "UART error\r\n");
		return;
8000ad76:	d7 03       	nop
8000ad78:	c0 c8       	rjmp	8000ad90 <service_ecdbg_input+0x2d8>
	}
	if (rx_char == '\x03')
	{
		return;
8000ad7a:	d7 03       	nop
8000ad7c:	c0 a8       	rjmp	8000ad90 <service_ecdbg_input+0x2d8>
	}
	
	if ((rx_char < 0x0a) || (rx_char > 0x7a))
	{
		return; //completely out of range, ignore
8000ad7e:	d7 03       	nop
8000ad80:	c0 88       	rjmp	8000ad90 <service_ecdbg_input+0x2d8>
8000ad82:	d7 03       	nop
8000ad84:	c0 68       	rjmp	8000ad90 <service_ecdbg_input+0x2d8>
			return; //TODO: this is kludgey...whenever we print to the debug port we rx a 'P' (0x50), just ignore them for now.
		}
	}
	else
	{
		return;
8000ad86:	d7 03       	nop
8000ad88:	c0 48       	rjmp	8000ad90 <service_ecdbg_input+0x2d8>
8000ad8a:	d7 03       	nop
8000ad8c:	c0 28       	rjmp	8000ad90 <service_ecdbg_input+0x2d8>
		((rx_char >= 0x41) && (rx_char <= 0x5a)) ||		//upper case alpha
		((rx_char >= 0x61) && (rx_char <= 0x7a)))		//lower case alpha
	{
		if (rx_char == 0x50)
		{
			return; //TODO: this is kludgey...whenever we print to the debug port we rx a 'P' (0x50), just ignore them for now.
8000ad8e:	d7 03       	nop
		// Add a LF and consider this as the end of the line.
		print_ecdbg("\r\n>");
		cmdIdx = 0;
		return;
	}
}
8000ad90:	2f dd       	sub	sp,-12
8000ad92:	e3 cd 80 80 	ldm	sp++,r7,pc
8000ad96:	00 00       	add	r0,r0
8000ad98:	80 00       	ld.sh	r0,r0[0x0]
8000ad9a:	58 e8       	cp.w	r8,14
8000ad9c:	00 00       	add	r0,r0
8000ad9e:	07 d4       	ld.ub	r4,r3[0x5]
8000ada0:	00 00       	add	r0,r0
8000ada2:	0d 80       	ld.ub	r0,r6[0x0]
8000ada4:	80 00       	ld.sh	r0,r0[0x0]
8000ada6:	58 94       	cp.w	r4,9
8000ada8:	80 00       	ld.sh	r0,r0[0x0]
8000adaa:	6c 3c       	ld.w	r12,r6[0xc]
8000adac:	80 00       	ld.sh	r0,r0[0x0]
8000adae:	33 38       	mov	r8,51
8000adb0:	80 00       	ld.sh	r0,r0[0x0]
8000adb2:	6c 58       	ld.w	r8,r6[0x14]
8000adb4:	80 00       	ld.sh	r0,r0[0x0]
8000adb6:	6c 70       	ld.w	r0,r6[0x1c]
8000adb8:	80 00       	ld.sh	r0,r0[0x0]
8000adba:	6c 88       	ld.w	r8,r6[0x20]
8000adbc:	80 00       	ld.sh	r0,r0[0x0]
8000adbe:	6c a8       	ld.w	r8,r6[0x28]
8000adc0:	80 00       	ld.sh	r0,r0[0x0]
8000adc2:	6c d4       	ld.w	r4,r6[0x34]
8000adc4:	80 00       	ld.sh	r0,r0[0x0]
8000adc6:	6d 1c       	ld.w	r12,r6[0x44]
8000adc8:	80 00       	ld.sh	r0,r0[0x0]
8000adca:	6d 3c       	ld.w	r12,r6[0x4c]
8000adcc:	80 00       	ld.sh	r0,r0[0x0]
8000adce:	6d 40       	ld.w	r0,r6[0x50]
8000add0:	00 00       	add	r0,r0
8000add2:	0b fc       	ld.ub	r12,r5[0x7]
8000add4:	80 00       	ld.sh	r0,r0[0x0]
8000add6:	73 50       	ld.w	r0,r9[0x54]
8000add8:	80 00       	ld.sh	r0,r0[0x0]
8000adda:	6d 58       	ld.w	r8,r6[0x54]
8000addc:	80 00       	ld.sh	r0,r0[0x0]
8000adde:	a0 f0       	st.b	r0[0x7],r0
8000ade0:	80 00       	ld.sh	r0,r0[0x0]
8000ade2:	a1 1c       	ld.d	r12,--r0
8000ade4:	80 00       	ld.sh	r0,r0[0x0]
8000ade6:	a5 9c       	lsr	r12,0x5
8000ade8:	80 00       	ld.sh	r0,r0[0x0]
8000adea:	a9 5c       	asr	r12,0x9
8000adec:	80 00       	ld.sh	r0,r0[0x0]
8000adee:	aa a0       	st.b	r5[0x2],r0
8000adf0:	00 00       	add	r0,r0
8000adf2:	00 b4       	st.h	r0++,r4
8000adf4:	80 00       	ld.sh	r0,r0[0x0]
8000adf6:	6d 68       	ld.w	r8,r6[0x58]
8000adf8:	80 00       	ld.sh	r0,r0[0x0]
8000adfa:	6d 84       	ld.w	r4,r6[0x60]
8000adfc:	80 00       	ld.sh	r0,r0[0x0]
8000adfe:	98 c0       	ld.uh	r0,r12[0x8]
8000ae00:	80 00       	ld.sh	r0,r0[0x0]
8000ae02:	6d 88       	ld.w	r8,r6[0x60]
8000ae04:	80 00       	ld.sh	r0,r0[0x0]
8000ae06:	6d ac       	ld.w	r12,r6[0x68]

8000ae08 <main>:


/*! \brief Main File Section:
 *          - Initialization (CPU, TWI, Usart,...)
 */
int main(void){
8000ae08:	eb cd 40 8f 	pushm	r0-r3,r7,lr
8000ae0c:	1a 97       	mov	r7,sp
8000ae0e:	fa cd 02 40 	sub	sp,sp,576
	static unsigned char displayIdx = 0;
	char mainStr[80];
	
	// Initialize System Clock
	init_sys_clocks();
8000ae12:	f0 1f 04 f5 	mcall	8000c1e4 <main+0x13dc>

	init_io();
8000ae16:	f0 1f 04 f5 	mcall	8000c1e8 <main+0x13e0>
	
	init_sysErr();
8000ae1a:	f0 1f 04 f5 	mcall	8000c1ec <main+0x13e4>
	
	init_shelf_n_ledBrd_structs();
8000ae1e:	f0 1f 04 f5 	mcall	8000c1f0 <main+0x13e8>
	read_led_board_serial_ids();
8000ae22:	f0 1f 04 f5 	mcall	8000c1f4 <main+0x13ec>
		


	//Set clock to 8MHz. We start at 100MHz to get through the DS2411 LED board serial ID detection. But we don't need to run that fast for remaining operations.
	osc_enable(OSC_ID_RC8M);
8000ae26:	30 2c       	mov	r12,2
8000ae28:	f0 1f 04 f4 	mcall	8000c1f8 <main+0x13f0>
	osc_wait_ready(OSC_ID_RC8M);
8000ae2c:	30 2c       	mov	r12,2
8000ae2e:	f0 1f 04 f4 	mcall	8000c1fc <main+0x13f4>
	sysclk_set_source(SYSCLK_SRC_RC8M);
8000ae32:	30 5c       	mov	r12,5
8000ae34:	f0 1f 04 f3 	mcall	8000c200 <main+0x13f8>
	sysclk_set_prescalers(0,0,0,0);
8000ae38:	30 09       	mov	r9,0
8000ae3a:	30 0a       	mov	r10,0
8000ae3c:	30 0b       	mov	r11,0
8000ae3e:	30 0c       	mov	r12,0
8000ae40:	f0 1f 04 f1 	mcall	8000c204 <main+0x13fc>
	pll_disable(0);
8000ae44:	30 0c       	mov	r12,0
8000ae46:	f0 1f 04 f1 	mcall	8000c208 <main+0x1400>



	// Initialize USART again after changing the system clock
	init_ecdbg_rs232(FPBA_HZ);
8000ae4a:	e0 6c 12 00 	mov	r12,4608
8000ae4e:	ea 1c 00 7a 	orh	r12,0x7a
8000ae52:	f0 1f 04 ef 	mcall	8000c20c <main+0x1404>
//30may15	init_display_rs232(FPBA_HZ);
	init_display_rs232(FOSC0);//experiment to see if this fixes the display, haven't tested the code with the display in a month and it doesn't work now 30may15
8000ae56:	e0 6c 24 00 	mov	r12,9216
8000ae5a:	ea 1c 00 f4 	orh	r12,0xf4
8000ae5e:	f0 1f 04 ed 	mcall	8000c210 <main+0x1408>
	
	show_sw_version();
8000ae62:	f0 1f 04 ed 	mcall	8000c214 <main+0x140c>

	// Print Startup Message
	display_text(IDX_READY);
8000ae66:	30 0c       	mov	r12,0
8000ae68:	f0 1f 04 ec 	mcall	8000c218 <main+0x1410>
	
	// Initialize ADC for bluesense channels which are used to see if there are any devices (phones, tablets, etc.) on the shelves
	adc_process_init();
8000ae6c:	f0 1f 04 ec 	mcall	8000c21c <main+0x1414>

	
	// Initialize Interrupts
	irq_initialize_vectors(); //TODO: probably remove 5apr15
8000ae70:	f0 1f 04 ec 	mcall	8000c220 <main+0x1418>

	cpu_irq_enable();
8000ae74:	d5 03       	csrf	0x10


	
	// Initialize TWI Interface
	twi_init();
8000ae76:	f0 1f 04 ec 	mcall	8000c224 <main+0x141c>

	gpio_set_pin_high(ECLAVE_LED_OEn); //make sure outputs are disabled at the chip level
8000ae7a:	31 6c       	mov	r12,22
8000ae7c:	f0 1f 04 eb 	mcall	8000c228 <main+0x1420>

	PCA9952_init();
8000ae80:	f0 1f 04 eb 	mcall	8000c22c <main+0x1424>
	test_led_driver_channels();
8000ae84:	f0 1f 04 eb 	mcall	8000c230 <main+0x1428>
	
	
	init_led_board_info();
8000ae88:	f0 1f 04 eb 	mcall	8000c234 <main+0x142c>

	show_chassis_status_info();
8000ae8c:	f0 1f 04 eb 	mcall	8000c238 <main+0x1430>
	show_chassis_sysErr();
8000ae90:	f0 1f 04 eb 	mcall	8000c23c <main+0x1434>
	show_chassis_all_LED_boards();
8000ae94:	f0 1f 04 eb 	mcall	8000c240 <main+0x1438>
	show_help_and_prompt();
8000ae98:	f0 1f 04 eb 	mcall	8000c244 <main+0x143c>
	
	gpio_set_pin_low(ECLAVE_LED_OEn); //...and we are live!
8000ae9c:	31 6c       	mov	r12,22
8000ae9e:	f0 1f 04 eb 	mcall	8000c248 <main+0x1440>
	gpio_set_pin_low(ECLAVE_PSUPPLY_ONn); //turn the leds on first and then the power supply
8000aea2:	31 7c       	mov	r12,23
8000aea4:	f0 1f 04 e9 	mcall	8000c248 <main+0x1440>
8000aea8:	e0 68 03 e8 	mov	r8,1000
8000aeac:	ef 48 fe e4 	st.w	r7[-284],r8
8000aeb0:	e0 68 12 00 	mov	r8,4608
8000aeb4:	ea 18 00 7a 	orh	r8,0x7a
8000aeb8:	ef 48 fe e0 	st.w	r7[-288],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
8000aebc:	ee f0 fe e4 	ld.w	r0,r7[-284]
8000aec0:	30 01       	mov	r1,0
8000aec2:	ee f2 fe e0 	ld.w	r2,r7[-288]
8000aec6:	30 03       	mov	r3,0
8000aec8:	e2 02 02 49 	mul	r9,r1,r2
8000aecc:	e6 00 02 48 	mul	r8,r3,r0
8000aed0:	10 09       	add	r9,r8
8000aed2:	e0 02 06 4a 	mulu.d	r10,r0,r2
8000aed6:	16 09       	add	r9,r11
8000aed8:	12 9b       	mov	r11,r9
8000aeda:	e0 68 03 e7 	mov	r8,999
8000aede:	30 09       	mov	r9,0
8000aee0:	10 0a       	add	r10,r8
8000aee2:	f6 09 00 4b 	adc	r11,r11,r9
8000aee6:	e0 68 03 e8 	mov	r8,1000
8000aeea:	30 09       	mov	r9,0
8000aeec:	f0 1f 04 d8 	mcall	8000c24c <main+0x1444>
8000aef0:	14 98       	mov	r8,r10
8000aef2:	16 99       	mov	r9,r11
	
	cpu_set_timeout(EC_ONE_SECOND/2, &debugTimer);
8000aef4:	a1 98       	lsr	r8,0x1
8000aef6:	ef 48 fe ec 	st.w	r7[-276],r8
8000aefa:	fe f8 13 56 	ld.w	r8,pc[4950]
8000aefe:	ef 48 fe e8 	st.w	r7[-280],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000af02:	e1 b8 00 42 	mfsr	r8,0x108
8000af06:	10 99       	mov	r9,r8
8000af08:	ee f8 fe e8 	ld.w	r8,r7[-280]
8000af0c:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000af0e:	ee f8 fe e8 	ld.w	r8,r7[-280]
8000af12:	70 09       	ld.w	r9,r8[0x0]
8000af14:	ee f8 fe ec 	ld.w	r8,r7[-276]
8000af18:	10 09       	add	r9,r8
8000af1a:	ee f8 fe e8 	ld.w	r8,r7[-280]
8000af1e:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
8000af20:	ee f9 fe e8 	ld.w	r9,r7[-280]
8000af24:	30 08       	mov	r8,0
8000af26:	f3 68 00 08 	st.b	r9[8],r8
8000af2a:	e0 68 03 e8 	mov	r8,1000
8000af2e:	ef 48 fe f4 	st.w	r7[-268],r8
8000af32:	e0 68 12 00 	mov	r8,4608
8000af36:	ea 18 00 7a 	orh	r8,0x7a
8000af3a:	ef 48 fe f0 	st.w	r7[-272],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
8000af3e:	ee fc fe f4 	ld.w	r12,r7[-268]
8000af42:	ef 4c fd cc 	st.w	r7[-564],r12
8000af46:	30 0a       	mov	r10,0
8000af48:	ef 4a fd c8 	st.w	r7[-568],r10
8000af4c:	ee f8 fe f0 	ld.w	r8,r7[-272]
8000af50:	ef 48 fd c4 	st.w	r7[-572],r8
8000af54:	30 0c       	mov	r12,0
8000af56:	ef 4c fd c0 	st.w	r7[-576],r12
8000af5a:	ee f9 fd c8 	ld.w	r9,r7[-568]
8000af5e:	ee fa fd c4 	ld.w	r10,r7[-572]
8000af62:	b5 39       	mul	r9,r10
8000af64:	ee f8 fd c0 	ld.w	r8,r7[-576]
8000af68:	ee fc fd cc 	ld.w	r12,r7[-564]
8000af6c:	b9 38       	mul	r8,r12
8000af6e:	10 09       	add	r9,r8
8000af70:	ee f8 fd cc 	ld.w	r8,r7[-564]
8000af74:	ee fc fd c4 	ld.w	r12,r7[-572]
8000af78:	f0 0c 06 4a 	mulu.d	r10,r8,r12
8000af7c:	16 09       	add	r9,r11
8000af7e:	12 9b       	mov	r11,r9
8000af80:	e0 68 03 e7 	mov	r8,999
8000af84:	30 09       	mov	r9,0
8000af86:	10 0a       	add	r10,r8
8000af88:	f6 09 00 4b 	adc	r11,r11,r9
8000af8c:	e0 68 03 e8 	mov	r8,1000
8000af90:	30 09       	mov	r9,0
8000af92:	f0 1f 04 af 	mcall	8000c24c <main+0x1444>
8000af96:	14 98       	mov	r8,r10
8000af98:	16 99       	mov	r9,r11
	cpu_set_timeout((5 * EC_ONE_SECOND), &mfpExperimentTimer); //experiment 31may15
8000af9a:	10 99       	mov	r9,r8
8000af9c:	12 98       	mov	r8,r9
8000af9e:	a3 68       	lsl	r8,0x2
8000afa0:	12 08       	add	r8,r9
8000afa2:	ef 48 fe fc 	st.w	r7[-260],r8
8000afa6:	fe f8 12 ae 	ld.w	r8,pc[4782]
8000afaa:	ef 48 fe f8 	st.w	r7[-264],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000afae:	e1 b8 00 42 	mfsr	r8,0x108
8000afb2:	10 99       	mov	r9,r8
8000afb4:	ee f8 fe f8 	ld.w	r8,r7[-264]
8000afb8:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000afba:	ee f8 fe f8 	ld.w	r8,r7[-264]
8000afbe:	70 09       	ld.w	r9,r8[0x0]
8000afc0:	ee f8 fe fc 	ld.w	r8,r7[-260]
8000afc4:	10 09       	add	r9,r8
8000afc6:	ee f8 fe f8 	ld.w	r8,r7[-264]
8000afca:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
8000afcc:	ee f9 fe f8 	ld.w	r9,r7[-264]
8000afd0:	30 08       	mov	r8,0
8000afd2:	f3 68 00 08 	st.b	r9[8],r8
			}
			cpu_set_timeout((5 * EC_ONE_SECOND), &mfpExperimentTimer);			
		}
#endif

		switch(electroclaveState)
8000afd6:	fe f8 12 82 	ld.w	r8,pc[4738]
8000afda:	11 88       	ld.ub	r8,r8[0x0]
8000afdc:	10 99       	mov	r9,r8
8000afde:	58 99       	cp.w	r9,9
8000afe0:	e0 8b 08 06 	brhi	8000bfec <main+0x11e4>
8000afe4:	fe f8 12 78 	ld.w	r8,pc[4728]
8000afe8:	f0 09 03 2f 	ld.w	pc,r8[r9<<0x2]
		{
			case STATE_EC_IDLE:
				if (EC_DOOR_LATCHED) {
8000afec:	33 ec       	mov	r12,62
8000afee:	f0 1f 04 9d 	mcall	8000c260 <main+0x1458>
8000aff2:	18 98       	mov	r8,r12
8000aff4:	ec 18 00 01 	eorl	r8,0x1
8000aff8:	5c 58       	castu.b	r8
8000affa:	e0 80 07 ee 	breq	8000bfd6 <main+0x11ce>
					gpio_set_pin_low(ECLAVE_DEBUG_LED);
8000affe:	37 cc       	mov	r12,124
8000b000:	f0 1f 04 92 	mcall	8000c248 <main+0x1440>
					print_ecdbg("Door latch detected\r\n");
8000b004:	fe fc 12 60 	ld.w	r12,pc[4704]
8000b008:	f0 1f 04 98 	mcall	8000c268 <main+0x1460>
					firstTimeSinceDoorLatched = 1;
8000b00c:	fe f9 12 60 	ld.w	r9,pc[4704]
8000b010:	30 18       	mov	r8,1
8000b012:	b2 88       	st.b	r9[0x0],r8
//					display_text(IDX_CLEAR);
					display_text(IDX_READY);
8000b014:	30 0c       	mov	r12,0
8000b016:	f0 1f 04 81 	mcall	8000c218 <main+0x1410>
					electroclaveState = STATE_DOOR_LATCHED;
8000b01a:	fe f9 12 3e 	ld.w	r9,pc[4670]
8000b01e:	30 18       	mov	r8,1
8000b020:	b2 88       	st.b	r9[0x0],r8
					firstDoorOpenSinceIdle = 1;
8000b022:	fe f9 12 4e 	ld.w	r9,pc[4686]
8000b026:	30 18       	mov	r8,1
8000b028:	b2 88       	st.b	r9[0x0],r8
				}
				break;
8000b02a:	e0 8f 07 e1 	bral	8000bfec <main+0x11e4>
				
			case STATE_DOOR_LATCHED:
				if (!EC_ACTION_PB) {
8000b02e:	33 fc       	mov	r12,63
8000b030:	f0 1f 04 8c 	mcall	8000c260 <main+0x1458>
8000b034:	18 98       	mov	r8,r12
8000b036:	58 08       	cp.w	r8,0
8000b038:	e0 80 07 d1 	breq	8000bfda <main+0x11d2>
					print_ecdbg("Action push button press detected\r\n");
8000b03c:	fe fc 12 38 	ld.w	r12,pc[4664]
8000b040:	f0 1f 04 8a 	mcall	8000c268 <main+0x1460>
					electroclaveState = STATE_ACTION_PB_PRESSED;
8000b044:	fe f9 12 14 	ld.w	r9,pc[4628]
8000b048:	30 28       	mov	r8,2
8000b04a:	b2 88       	st.b	r9[0x0],r8
				}
				break;
8000b04c:	e0 8f 07 d0 	bral	8000bfec <main+0x11e4>
				
			case STATE_ACTION_PB_PRESSED:
				if (EC_ACTION_PB)
8000b050:	33 fc       	mov	r12,63
8000b052:	f0 1f 04 84 	mcall	8000c260 <main+0x1458>
8000b056:	18 98       	mov	r8,r12
8000b058:	ec 18 00 01 	eorl	r8,0x1
8000b05c:	5c 58       	castu.b	r8
8000b05e:	e0 80 07 c0 	breq	8000bfde <main+0x11d6>
				{
					print_ecdbg("Action push button release detected\r\n");
8000b062:	fe fc 12 16 	ld.w	r12,pc[4630]
8000b066:	f0 1f 04 81 	mcall	8000c268 <main+0x1460>
					electroclaveState = STATE_ACTION_PB_RELEASED;	
8000b06a:	fe f9 11 ee 	ld.w	r9,pc[4590]
8000b06e:	30 38       	mov	r8,3
8000b070:	b2 88       	st.b	r9[0x0],r8
				}
				break;
8000b072:	e0 8f 07 bd 	bral	8000bfec <main+0x11e4>
				
			case STATE_ACTION_PB_RELEASED:

				if (firstTimeSinceDoorLatched)
8000b076:	fe f8 11 f6 	ld.w	r8,pc[4598]
8000b07a:	11 88       	ld.ub	r8,r8[0x0]
8000b07c:	58 08       	cp.w	r8,0
8000b07e:	c0 b0       	breq	8000b094 <main+0x28c>
				{
					check_led_brd_side_lifetimes();
8000b080:	f0 1f 04 7f 	mcall	8000c27c <main+0x1474>
					check_shelves_for_devices();
8000b084:	f0 1f 04 7f 	mcall	8000c280 <main+0x1478>
					set_shelves_active_inactive();
8000b088:	f0 1f 04 7f 	mcall	8000c284 <main+0x147c>
					
					firstTimeSinceDoorLatched = 0;
8000b08c:	fe f9 11 e0 	ld.w	r9,pc[4576]
8000b090:	30 08       	mov	r8,0
8000b092:	b2 88       	st.b	r9[0x0],r8
				}

				if (num_active_shelves() != 0) {
8000b094:	f0 1f 04 7d 	mcall	8000c288 <main+0x1480>
8000b098:	18 98       	mov	r8,r12
8000b09a:	58 08       	cp.w	r8,0
8000b09c:	c6 70       	breq	8000b16a <main+0x362>
					electroclaveState = STATE_START_SANITIZE;
8000b09e:	fe f9 11 ba 	ld.w	r9,pc[4538]
8000b0a2:	30 48       	mov	r8,4
8000b0a4:	b2 88       	st.b	r9[0x0],r8
					print_ecdbg("Sanitizing\r\n");
8000b0a6:	fe fc 11 e6 	ld.w	r12,pc[4582]
8000b0aa:	f0 1f 04 70 	mcall	8000c268 <main+0x1460>
//13jun15					display_text(IDX_CLEAR);
//13jun15					cpu_delay_ms(500, EC_CPU_CLOCK_FREQ);
					display_text(IDX_CLEANING);
8000b0ae:	30 2c       	mov	r12,2
8000b0b0:	f0 1f 04 5a 	mcall	8000c218 <main+0x1410>
8000b0b4:	e0 68 1f 40 	mov	r8,8000
8000b0b8:	ef 48 ff 04 	st.w	r7[-252],r8
8000b0bc:	e0 68 12 00 	mov	r8,4608
8000b0c0:	ea 18 00 7a 	orh	r8,0x7a
8000b0c4:	ef 48 ff 00 	st.w	r7[-256],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
8000b0c8:	ee fa ff 04 	ld.w	r10,r7[-252]
8000b0cc:	ef 4a fd dc 	st.w	r7[-548],r10
8000b0d0:	30 08       	mov	r8,0
8000b0d2:	ef 48 fd d8 	st.w	r7[-552],r8
8000b0d6:	ee fc ff 00 	ld.w	r12,r7[-256]
8000b0da:	ef 4c fd d4 	st.w	r7[-556],r12
8000b0de:	30 0a       	mov	r10,0
8000b0e0:	ef 4a fd d0 	st.w	r7[-560],r10
8000b0e4:	ee f9 fd d8 	ld.w	r9,r7[-552]
8000b0e8:	ee f8 fd d4 	ld.w	r8,r7[-556]
8000b0ec:	b1 39       	mul	r9,r8
8000b0ee:	ee f8 fd d0 	ld.w	r8,r7[-560]
8000b0f2:	ee fc fd dc 	ld.w	r12,r7[-548]
8000b0f6:	b9 38       	mul	r8,r12
8000b0f8:	10 09       	add	r9,r8
8000b0fa:	ee f8 fd dc 	ld.w	r8,r7[-548]
8000b0fe:	ee fc fd d4 	ld.w	r12,r7[-556]
8000b102:	f0 0c 06 4a 	mulu.d	r10,r8,r12
8000b106:	16 09       	add	r9,r11
8000b108:	12 9b       	mov	r11,r9
8000b10a:	e0 68 03 e7 	mov	r8,999
8000b10e:	30 09       	mov	r9,0
8000b110:	10 0a       	add	r10,r8
8000b112:	f6 09 00 4b 	adc	r11,r11,r9
8000b116:	e0 68 03 e8 	mov	r8,1000
8000b11a:	30 09       	mov	r9,0
8000b11c:	f0 1f 04 4c 	mcall	8000c24c <main+0x1444>
8000b120:	14 98       	mov	r8,r10
8000b122:	16 99       	mov	r9,r11
					displayTimerSeconds = cpu_ms_2_cy(8000, EC_CPU_CLOCK_FREQ); //8 seconds per "shelf" display is enough time for the text to scroll twice
8000b124:	10 99       	mov	r9,r8
8000b126:	fe f8 11 6a 	ld.w	r8,pc[4458]
8000b12a:	91 09       	st.w	r8[0x0],r9
					cpu_set_timeout(displayTimerSeconds, &displayTimer);
8000b12c:	fe f8 11 64 	ld.w	r8,pc[4452]
8000b130:	70 08       	ld.w	r8,r8[0x0]
8000b132:	ef 48 ff 0c 	st.w	r7[-244],r8
8000b136:	fe f8 11 5e 	ld.w	r8,pc[4446]
8000b13a:	ef 48 ff 08 	st.w	r7[-248],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000b13e:	e1 b8 00 42 	mfsr	r8,0x108
8000b142:	10 99       	mov	r9,r8
8000b144:	ee f8 ff 08 	ld.w	r8,r7[-248]
8000b148:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000b14a:	ee f8 ff 08 	ld.w	r8,r7[-248]
8000b14e:	70 09       	ld.w	r9,r8[0x0]
8000b150:	ee f8 ff 0c 	ld.w	r8,r7[-244]
8000b154:	10 09       	add	r9,r8
8000b156:	ee f8 ff 08 	ld.w	r8,r7[-248]
8000b15a:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
8000b15c:	ee f9 ff 08 	ld.w	r9,r7[-248]
8000b160:	30 08       	mov	r8,0
8000b162:	f3 68 00 08 	st.b	r9[8],r8
				{
//DEBUG 24jun15 need to function even with these errors for demo purposes					electroclaveState = STATE_CHASSIS_ERROR;
					print_ecdbg("No shelves, or shelves are past lifetime\r\n");
					display_text(IDX_ERROR);
				}
				break;
8000b166:	e0 8f 07 43 	bral	8000bfec <main+0x11e4>
//13jun15					cpu_delay_ms(500, EC_CPU_CLOCK_FREQ);
					display_text(IDX_CLEANING);
					displayTimerSeconds = cpu_ms_2_cy(8000, EC_CPU_CLOCK_FREQ); //8 seconds per "shelf" display is enough time for the text to scroll twice
					cpu_set_timeout(displayTimerSeconds, &displayTimer);
				}
				else if (num_present_shelves() != 0){
8000b16a:	f0 1f 04 4c 	mcall	8000c298 <main+0x1490>
8000b16e:	18 98       	mov	r8,r12
8000b170:	58 08       	cp.w	r8,0
8000b172:	c0 e0       	breq	8000b18e <main+0x386>
					electroclaveState = STATE_EC_IDLE;
8000b174:	fe f9 10 e4 	ld.w	r9,pc[4324]
8000b178:	30 08       	mov	r8,0
8000b17a:	b2 88       	st.b	r9[0x0],r8
					print_ecdbg("At least one shelf is present, but no devices to be cleaned.\r\n");
8000b17c:	fe fc 11 20 	ld.w	r12,pc[4384]
8000b180:	f0 1f 04 3a 	mcall	8000c268 <main+0x1460>
					display_text(IDX_READY);
8000b184:	30 0c       	mov	r12,0
8000b186:	f0 1f 04 25 	mcall	8000c218 <main+0x1410>
				{
//DEBUG 24jun15 need to function even with these errors for demo purposes					electroclaveState = STATE_CHASSIS_ERROR;
					print_ecdbg("No shelves, or shelves are past lifetime\r\n");
					display_text(IDX_ERROR);
				}
				break;
8000b18a:	e0 8f 07 31 	bral	8000bfec <main+0x11e4>
					display_text(IDX_READY);
				}
				else
				{
//DEBUG 24jun15 need to function even with these errors for demo purposes					electroclaveState = STATE_CHASSIS_ERROR;
					print_ecdbg("No shelves, or shelves are past lifetime\r\n");
8000b18e:	fe fc 11 12 	ld.w	r12,pc[4370]
8000b192:	f0 1f 04 36 	mcall	8000c268 <main+0x1460>
					display_text(IDX_ERROR);
8000b196:	30 4c       	mov	r12,4
8000b198:	f0 1f 04 20 	mcall	8000c218 <main+0x1410>
				}
				break;
8000b19c:	e0 8f 07 28 	bral	8000bfec <main+0x11e4>
				
			case STATE_START_SANITIZE:
//13jun15				display_text(IDX_CLEAR);
//13jun15				cpu_delay_ms(500, EC_CPU_CLOCK_FREQ); //half second TODO: figure out why this is here and get rid of it, don't like to just hang for no reason, especially when we need to be monitoring the door latch
				
				displayIdx = 0xFF; //this means not assigned yet
8000b1a0:	fe f9 11 04 	ld.w	r9,pc[4356]
8000b1a4:	3f f8       	mov	r8,-1
8000b1a6:	b2 88       	st.b	r9[0x0],r8
				sanitizeMinutes = 0;
8000b1a8:	fe f9 11 00 	ld.w	r9,pc[4352]
8000b1ac:	30 08       	mov	r8,0
8000b1ae:	93 08       	st.w	r9[0x0],r8
				for (int i = 0; i<NUM_SHELVES; i++) {
8000b1b0:	30 08       	mov	r8,0
8000b1b2:	ef 48 fe d0 	st.w	r7[-304],r8
8000b1b6:	c4 28       	rjmp	8000b23a <main+0x432>
					if (shelf[i].active == SHELF_ACTIVE) {
8000b1b8:	ee f9 fe d0 	ld.w	r9,r7[-304]
8000b1bc:	fe fa 10 f0 	ld.w	r10,pc[4336]
8000b1c0:	12 98       	mov	r8,r9
8000b1c2:	a3 68       	lsl	r8,0x2
8000b1c4:	12 08       	add	r8,r9
8000b1c6:	f4 08 00 08 	add	r8,r10,r8
8000b1ca:	11 89       	ld.ub	r9,r8[0x0]
8000b1cc:	30 18       	mov	r8,1
8000b1ce:	f0 09 18 00 	cp.b	r9,r8
8000b1d2:	c2 f1       	brne	8000b230 <main+0x428>
						tmpSanitizeMinutes = calc_sanitize_time(i);
8000b1d4:	ee f8 fe d0 	ld.w	r8,r7[-304]
8000b1d8:	5c 58       	castu.b	r8
8000b1da:	10 9c       	mov	r12,r8
8000b1dc:	f0 1f 04 35 	mcall	8000c2b0 <main+0x14a8>
8000b1e0:	18 98       	mov	r8,r12
8000b1e2:	10 99       	mov	r9,r8
8000b1e4:	fe f8 10 d0 	ld.w	r8,pc[4304]
8000b1e8:	91 09       	st.w	r8[0x0],r9
						
						if (tmpSanitizeMinutes > sanitizeMinutes)
8000b1ea:	fe f8 10 ca 	ld.w	r8,pc[4298]
8000b1ee:	70 09       	ld.w	r9,r8[0x0]
8000b1f0:	fe f8 10 b8 	ld.w	r8,pc[4280]
8000b1f4:	70 08       	ld.w	r8,r8[0x0]
8000b1f6:	10 39       	cp.w	r9,r8
8000b1f8:	e0 88 00 08 	brls	8000b208 <main+0x400>
						{
							sanitizeMinutes = tmpSanitizeMinutes;
8000b1fc:	fe f8 10 b8 	ld.w	r8,pc[4280]
8000b200:	70 09       	ld.w	r9,r8[0x0]
8000b202:	fe f8 10 a6 	ld.w	r8,pc[4262]
8000b206:	91 09       	st.w	r8[0x0],r9
						}
						
						led_shelf(i, LED_ON);
8000b208:	ee f8 fe d0 	ld.w	r8,r7[-304]
8000b20c:	5c 58       	castu.b	r8
8000b20e:	30 1b       	mov	r11,1
8000b210:	10 9c       	mov	r12,r8
8000b212:	f0 1f 04 2a 	mcall	8000c2b8 <main+0x14b0>
						
						if (displayIdx == 0xFF)
8000b216:	fe f8 10 8e 	ld.w	r8,pc[4238]
8000b21a:	11 89       	ld.ub	r9,r8[0x0]
8000b21c:	3f f8       	mov	r8,-1
8000b21e:	f0 09 18 00 	cp.b	r9,r8
8000b222:	c0 71       	brne	8000b230 <main+0x428>
						{
							displayIdx = i; //set this to the first active shelf if this is the first active shelf encountered
8000b224:	ee f8 fe d0 	ld.w	r8,r7[-304]
8000b228:	5c 58       	castu.b	r8
8000b22a:	fe f9 10 7a 	ld.w	r9,pc[4218]
8000b22e:	b2 88       	st.b	r9[0x0],r8
//13jun15				display_text(IDX_CLEAR);
//13jun15				cpu_delay_ms(500, EC_CPU_CLOCK_FREQ); //half second TODO: figure out why this is here and get rid of it, don't like to just hang for no reason, especially when we need to be monitoring the door latch
				
				displayIdx = 0xFF; //this means not assigned yet
				sanitizeMinutes = 0;
				for (int i = 0; i<NUM_SHELVES; i++) {
8000b230:	ee f8 fe d0 	ld.w	r8,r7[-304]
8000b234:	2f f8       	sub	r8,-1
8000b236:	ef 48 fe d0 	st.w	r7[-304],r8
8000b23a:	ee f8 fe d0 	ld.w	r8,r7[-304]
8000b23e:	58 38       	cp.w	r8,3
8000b240:	fe 9a ff bc 	brle	8000b1b8 <main+0x3b0>
8000b244:	e0 68 03 e8 	mov	r8,1000
8000b248:	ef 48 ff 14 	st.w	r7[-236],r8
8000b24c:	e0 68 12 00 	mov	r8,4608
8000b250:	ea 18 00 7a 	orh	r8,0x7a
8000b254:	ef 48 ff 10 	st.w	r7[-240],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
8000b258:	ee fa ff 14 	ld.w	r10,r7[-236]
8000b25c:	ef 4a fd ec 	st.w	r7[-532],r10
8000b260:	30 08       	mov	r8,0
8000b262:	ef 48 fd e8 	st.w	r7[-536],r8
8000b266:	ee fc ff 10 	ld.w	r12,r7[-240]
8000b26a:	ef 4c fd e4 	st.w	r7[-540],r12
8000b26e:	30 0a       	mov	r10,0
8000b270:	ef 4a fd e0 	st.w	r7[-544],r10
8000b274:	ee f9 fd e8 	ld.w	r9,r7[-536]
8000b278:	ee f8 fd e4 	ld.w	r8,r7[-540]
8000b27c:	b1 39       	mul	r9,r8
8000b27e:	ee f8 fd e0 	ld.w	r8,r7[-544]
8000b282:	ee fc fd ec 	ld.w	r12,r7[-532]
8000b286:	b9 38       	mul	r8,r12
8000b288:	10 09       	add	r9,r8
8000b28a:	ee f8 fd ec 	ld.w	r8,r7[-532]
8000b28e:	ee fc fd e4 	ld.w	r12,r7[-540]
8000b292:	f0 0c 06 4a 	mulu.d	r10,r8,r12
8000b296:	16 09       	add	r9,r11
8000b298:	12 9b       	mov	r11,r9
8000b29a:	e0 68 03 e7 	mov	r8,999
8000b29e:	30 09       	mov	r9,0
8000b2a0:	10 0a       	add	r10,r8
8000b2a2:	f6 09 00 4b 	adc	r11,r11,r9
8000b2a6:	e0 68 03 e8 	mov	r8,1000
8000b2aa:	30 09       	mov	r9,0
8000b2ac:	f0 1f 03 e8 	mcall	8000c24c <main+0x1444>
8000b2b0:	14 98       	mov	r8,r10
8000b2b2:	16 99       	mov	r9,r11
					}
				}
				
				
//16jan16 #if 0 //DEBUG: set this to seconds not minutes so we can debug this logic faster 11may15
				tmpSanitizeMinutes = cpu_ms_2_cy(1000,EC_CPU_CLOCK_FREQ);
8000b2b4:	10 99       	mov	r9,r8
8000b2b6:	fe f8 0f fe 	ld.w	r8,pc[4094]
8000b2ba:	91 09       	st.w	r8[0x0],r9
				tmpSanitizeMinutes *= 60;
8000b2bc:	fe f8 0f f8 	ld.w	r8,pc[4088]
8000b2c0:	70 09       	ld.w	r9,r8[0x0]
8000b2c2:	12 98       	mov	r8,r9
8000b2c4:	a5 68       	lsl	r8,0x4
8000b2c6:	12 18       	sub	r8,r9
8000b2c8:	a3 68       	lsl	r8,0x2
8000b2ca:	10 99       	mov	r9,r8
8000b2cc:	fe f8 0f e8 	ld.w	r8,pc[4072]
8000b2d0:	91 09       	st.w	r8[0x0],r9
				tmpSanitizeMinutes *= sanitizeMinutes;
8000b2d2:	fe f8 0f e2 	ld.w	r8,pc[4066]
8000b2d6:	70 09       	ld.w	r9,r8[0x0]
8000b2d8:	fe f8 0f d0 	ld.w	r8,pc[4048]
8000b2dc:	70 08       	ld.w	r8,r8[0x0]
8000b2de:	b1 39       	mul	r9,r8
8000b2e0:	fe f8 0f d4 	ld.w	r8,pc[4052]
8000b2e4:	91 09       	st.w	r8[0x0],r9
				cpu_set_timeout(tmpSanitizeMinutes, &sanitizeTimer); //16jan16 above calcs broken out to debug why this doesn't actually wind up being 30 minutes
8000b2e6:	fe f8 0f ce 	ld.w	r8,pc[4046]
8000b2ea:	70 08       	ld.w	r8,r8[0x0]
8000b2ec:	ef 48 ff 1c 	st.w	r7[-228],r8
8000b2f0:	fe f8 0f cc 	ld.w	r8,pc[4044]
8000b2f4:	ef 48 ff 18 	st.w	r7[-232],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000b2f8:	e1 b8 00 42 	mfsr	r8,0x108
8000b2fc:	10 99       	mov	r9,r8
8000b2fe:	ee f8 ff 18 	ld.w	r8,r7[-232]
8000b302:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000b304:	ee f8 ff 18 	ld.w	r8,r7[-232]
8000b308:	70 09       	ld.w	r9,r8[0x0]
8000b30a:	ee f8 ff 1c 	ld.w	r8,r7[-228]
8000b30e:	10 09       	add	r9,r8
8000b310:	ee f8 ff 18 	ld.w	r8,r7[-232]
8000b314:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
8000b316:	ee f9 ff 18 	ld.w	r9,r7[-232]
8000b31a:	30 08       	mov	r8,0
8000b31c:	f3 68 00 08 	st.b	r9[8],r8
//16jan16 #endif
//16jan16 we really want minutes right now				cpu_set_timeout((sanitizeMinutes * cpu_ms_2_cy(1000, EC_CPU_CLOCK_FREQ)), &sanitizeTimer); //DEBUG take this out when done debugging logic, put it back to minutes 11may15
				
				sprintf(mainStr, "sanitizeMinutes: %ld tmpSanitizeMinutes: %ld\r\n", sanitizeMinutes, tmpSanitizeMinutes);
8000b320:	fe f8 0f 94 	ld.w	r8,pc[3988]
8000b324:	70 0a       	ld.w	r10,r8[0x0]
8000b326:	fe f8 0f 82 	ld.w	r8,pc[3970]
8000b32a:	70 08       	ld.w	r8,r8[0x0]
8000b32c:	ee c9 01 80 	sub	r9,r7,384
8000b330:	1a da       	st.w	--sp,r10
8000b332:	1a d8       	st.w	--sp,r8
8000b334:	fe fb 0f 8c 	ld.w	r11,pc[3980]
8000b338:	12 9c       	mov	r12,r9
8000b33a:	f0 1f 03 e3 	mcall	8000c2c4 <main+0x14bc>
8000b33e:	2f ed       	sub	sp,-8
				print_ecdbg(mainStr);
8000b340:	ee c8 01 80 	sub	r8,r7,384
8000b344:	10 9c       	mov	r12,r8
8000b346:	f0 1f 03 c9 	mcall	8000c268 <main+0x1460>
#ifdef SERIAL_ID_AND_ALL_USAGE_COMBINED
				usageShdw[0].totalSanitationCycles++;
				usageShdw[1].totalSanitationCycles++;
#else

				inc_sanCycles();
8000b34a:	f0 1f 03 e0 	mcall	8000c2c8 <main+0x14c0>
8000b34e:	e0 68 03 e8 	mov	r8,1000
8000b352:	ef 48 ff 24 	st.w	r7[-220],r8
8000b356:	e0 68 12 00 	mov	r8,4608
8000b35a:	ea 18 00 7a 	orh	r8,0x7a
8000b35e:	ef 48 ff 20 	st.w	r7[-224],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
8000b362:	ee fa ff 24 	ld.w	r10,r7[-220]
8000b366:	ef 4a fd fc 	st.w	r7[-516],r10
8000b36a:	30 08       	mov	r8,0
8000b36c:	ef 48 fd f8 	st.w	r7[-520],r8
8000b370:	ee fc ff 20 	ld.w	r12,r7[-224]
8000b374:	ef 4c fd f4 	st.w	r7[-524],r12
8000b378:	30 0a       	mov	r10,0
8000b37a:	ef 4a fd f0 	st.w	r7[-528],r10
8000b37e:	ee f9 fd f8 	ld.w	r9,r7[-520]
8000b382:	ee f8 fd f4 	ld.w	r8,r7[-524]
8000b386:	b1 39       	mul	r9,r8
8000b388:	ee f8 fd f0 	ld.w	r8,r7[-528]
8000b38c:	ee fc fd fc 	ld.w	r12,r7[-516]
8000b390:	b9 38       	mul	r8,r12
8000b392:	10 09       	add	r9,r8
8000b394:	ee f8 fd fc 	ld.w	r8,r7[-516]
8000b398:	ee fc fd f4 	ld.w	r12,r7[-524]
8000b39c:	f0 0c 06 4a 	mulu.d	r10,r8,r12
8000b3a0:	16 09       	add	r9,r11
8000b3a2:	12 9b       	mov	r11,r9
8000b3a4:	e0 68 03 e7 	mov	r8,999
8000b3a8:	30 09       	mov	r9,0
8000b3aa:	10 0a       	add	r10,r8
8000b3ac:	f6 09 00 4b 	adc	r11,r11,r9
8000b3b0:	e0 68 03 e8 	mov	r8,1000
8000b3b4:	30 09       	mov	r9,0
8000b3b6:	f0 1f 03 a6 	mcall	8000c24c <main+0x1444>
8000b3ba:	14 98       	mov	r8,r10
8000b3bc:	16 99       	mov	r9,r11

#endif //SERIAL_ID_AND_ALL_USAGE_COMBINED
				
//DEBUG 11may15 do this once per second for debug				cpu_set_timeout((60 * cpu_ms_2_cy(1000,EC_CPU_CLOCK_FREQ)), &oneMinuteTimer); //one minute for the usage statistics
				cpu_set_timeout((cpu_ms_2_cy(1000,EC_CPU_CLOCK_FREQ)), &oneMinuteTimer); //one minute for the usage statistics DEBUG 11may15
8000b3be:	ef 48 ff 2c 	st.w	r7[-212],r8
8000b3c2:	fe f8 0f 0a 	ld.w	r8,pc[3850]
8000b3c6:	ef 48 ff 28 	st.w	r7[-216],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000b3ca:	e1 b8 00 42 	mfsr	r8,0x108
8000b3ce:	10 99       	mov	r9,r8
8000b3d0:	ee f8 ff 28 	ld.w	r8,r7[-216]
8000b3d4:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000b3d6:	ee f8 ff 28 	ld.w	r8,r7[-216]
8000b3da:	70 09       	ld.w	r9,r8[0x0]
8000b3dc:	ee f8 ff 2c 	ld.w	r8,r7[-212]
8000b3e0:	10 09       	add	r9,r8
8000b3e2:	ee f8 ff 28 	ld.w	r8,r7[-216]
8000b3e6:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
8000b3e8:	ee f9 ff 28 	ld.w	r9,r7[-216]
8000b3ec:	30 08       	mov	r8,0
8000b3ee:	f3 68 00 08 	st.b	r9[8],r8

				electroclaveState = STATE_SANITIZE;
8000b3f2:	fe f9 0e 66 	ld.w	r9,pc[3686]
8000b3f6:	30 58       	mov	r8,5
8000b3f8:	b2 88       	st.b	r9[0x0],r8
				
				break;
8000b3fa:	e0 8f 05 f9 	bral	8000bfec <main+0x11e4>
8000b3fe:	fe f8 0e 96 	ld.w	r8,pc[3734]
8000b402:	ef 48 ff 30 	st.w	r7[-208],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000b406:	e1 b8 00 42 	mfsr	r8,0x108
8000b40a:	ef 48 ff 34 	st.w	r7[-204],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
8000b40e:	ee f8 ff 30 	ld.w	r8,r7[-208]
8000b412:	f1 39 00 08 	ld.ub	r9,r8[8]
8000b416:	30 28       	mov	r8,2
8000b418:	f0 09 18 00 	cp.b	r9,r8
8000b41c:	c0 31       	brne	8000b422 <main+0x61a>
    return false;
8000b41e:	30 08       	mov	r8,0
8000b420:	c4 38       	rjmp	8000b4a6 <main+0x69e>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
8000b422:	ee f8 ff 30 	ld.w	r8,r7[-208]
8000b426:	f1 39 00 08 	ld.ub	r9,r8[8]
8000b42a:	30 18       	mov	r8,1
8000b42c:	f0 09 18 00 	cp.b	r9,r8
8000b430:	c0 31       	brne	8000b436 <main+0x62e>
    return true;
8000b432:	30 18       	mov	r8,1
8000b434:	c3 98       	rjmp	8000b4a6 <main+0x69e>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000b436:	ee f8 ff 30 	ld.w	r8,r7[-208]
8000b43a:	70 09       	ld.w	r9,r8[0x0]
8000b43c:	ee f8 ff 30 	ld.w	r8,r7[-208]
8000b440:	70 18       	ld.w	r8,r8[0x4]
8000b442:	10 39       	cp.w	r9,r8
8000b444:	e0 88 00 1a 	brls	8000b478 <main+0x670>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000b448:	ee f8 ff 30 	ld.w	r8,r7[-208]
8000b44c:	70 09       	ld.w	r9,r8[0x0]
8000b44e:	ee f8 ff 34 	ld.w	r8,r7[-204]
8000b452:	12 38       	cp.w	r8,r9
8000b454:	c1 02       	brcc	8000b474 <main+0x66c>
8000b456:	ee f8 ff 30 	ld.w	r8,r7[-208]
8000b45a:	70 19       	ld.w	r9,r8[0x4]
8000b45c:	ee f8 ff 34 	ld.w	r8,r7[-204]
8000b460:	12 38       	cp.w	r8,r9
8000b462:	e0 88 00 09 	brls	8000b474 <main+0x66c>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
8000b466:	ee f9 ff 30 	ld.w	r9,r7[-208]
8000b46a:	30 18       	mov	r8,1
8000b46c:	f3 68 00 08 	st.b	r9[8],r8
      return true;
8000b470:	30 18       	mov	r8,1
8000b472:	c1 a8       	rjmp	8000b4a6 <main+0x69e>
    }
    return false;
8000b474:	30 08       	mov	r8,0
8000b476:	c1 88       	rjmp	8000b4a6 <main+0x69e>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000b478:	ee f8 ff 30 	ld.w	r8,r7[-208]
8000b47c:	70 09       	ld.w	r9,r8[0x0]
8000b47e:	ee f8 ff 34 	ld.w	r8,r7[-204]
8000b482:	12 38       	cp.w	r8,r9
8000b484:	c0 93       	brcs	8000b496 <main+0x68e>
8000b486:	ee f8 ff 30 	ld.w	r8,r7[-208]
8000b48a:	70 19       	ld.w	r9,r8[0x4]
8000b48c:	ee f8 ff 34 	ld.w	r8,r7[-204]
8000b490:	12 38       	cp.w	r8,r9
8000b492:	e0 88 00 09 	brls	8000b4a4 <main+0x69c>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
8000b496:	ee f9 ff 30 	ld.w	r9,r7[-208]
8000b49a:	30 18       	mov	r8,1
8000b49c:	f3 68 00 08 	st.b	r9[8],r8
      return true;
8000b4a0:	30 18       	mov	r8,1
8000b4a2:	c0 28       	rjmp	8000b4a6 <main+0x69e>
    }
    return false;
8000b4a4:	30 08       	mov	r8,0
				
			case STATE_SANITIZE:
				/*
    			 * Manage the display
				 */
				if (cpu_is_timeout(&displayTimer))
8000b4a6:	58 08       	cp.w	r8,0
8000b4a8:	c6 90       	breq	8000b57a <main+0x772>
8000b4aa:	fe f8 0d ea 	ld.w	r8,pc[3562]
8000b4ae:	ef 48 ff 38 	st.w	r7[-200],r8
 *
 * \param  cpu_time:   (input) internal information used by the timer API.
 */
__always_inline static void cpu_stop_timeout(t_cpu_time *cpu_time)
{
  cpu_time->timer_state = CPU_TIMER_STATE_STOPPED;
8000b4b2:	ee f9 ff 38 	ld.w	r9,r7[-200]
8000b4b6:	30 28       	mov	r8,2
8000b4b8:	f3 68 00 08 	st.b	r9[8],r8
				{
					cpu_stop_timeout(&displayTimer);
					switch (displayIdx)
8000b4bc:	fe f8 0d e8 	ld.w	r8,pc[3560]
8000b4c0:	11 88       	ld.ub	r8,r8[0x0]
8000b4c2:	58 18       	cp.w	r8,1
8000b4c4:	c0 f0       	breq	8000b4e2 <main+0x6da>
8000b4c6:	e0 89 00 05 	brgt	8000b4d0 <main+0x6c8>
8000b4ca:	58 08       	cp.w	r8,0
8000b4cc:	c0 70       	breq	8000b4da <main+0x6d2>
8000b4ce:	c1 78       	rjmp	8000b4fc <main+0x6f4>
8000b4d0:	58 28       	cp.w	r8,2
8000b4d2:	c0 c0       	breq	8000b4ea <main+0x6e2>
8000b4d4:	58 38       	cp.w	r8,3
8000b4d6:	c0 e0       	breq	8000b4f2 <main+0x6ea>
8000b4d8:	c1 28       	rjmp	8000b4fc <main+0x6f4>
					{
						case 0:
							//								display_text(IDX_CLEAR);
							display_text(IDX_SHELF1);
8000b4da:	30 5c       	mov	r12,5
8000b4dc:	f0 1f 03 4f 	mcall	8000c218 <main+0x1410>
							break;
8000b4e0:	c0 e8       	rjmp	8000b4fc <main+0x6f4>
						case 1:
							//								display_text(IDX_CLEAR);
							display_text(IDX_SHELF2);
8000b4e2:	30 6c       	mov	r12,6
8000b4e4:	f0 1f 03 4d 	mcall	8000c218 <main+0x1410>
							break;
8000b4e8:	c0 a8       	rjmp	8000b4fc <main+0x6f4>
						case 2:
							//								display_text(IDX_CLEAR);
							display_text(IDX_SHELF3);
8000b4ea:	30 7c       	mov	r12,7
8000b4ec:	f0 1f 03 4b 	mcall	8000c218 <main+0x1410>
							break;
8000b4f0:	c0 68       	rjmp	8000b4fc <main+0x6f4>
						case 3:
							//								display_text(IDX_CLEAR);
							display_text(IDX_SHELF4);
8000b4f2:	30 8c       	mov	r12,8
8000b4f4:	f0 1f 03 49 	mcall	8000c218 <main+0x1410>
8000b4f8:	c0 28       	rjmp	8000b4fc <main+0x6f4>
						if (shelf[displayIdx].active)
						{
							break; //this shelf is active, we don't need to look for another one
						}
						
					}
8000b4fa:	d7 03       	nop
							break;
					}
					
					while (1)
					{
						if (++displayIdx >= NUM_SHELVES)
8000b4fc:	fe f8 0d a8 	ld.w	r8,pc[3496]
8000b500:	11 88       	ld.ub	r8,r8[0x0]
8000b502:	2f f8       	sub	r8,-1
8000b504:	5c 58       	castu.b	r8
8000b506:	fe f9 0d 9e 	ld.w	r9,pc[3486]
8000b50a:	b2 88       	st.b	r9[0x0],r8
8000b50c:	fe f8 0d 98 	ld.w	r8,pc[3480]
8000b510:	11 89       	ld.ub	r9,r8[0x0]
8000b512:	30 38       	mov	r8,3
8000b514:	f0 09 18 00 	cp.b	r9,r8
8000b518:	e0 88 00 06 	brls	8000b524 <main+0x71c>
						{
							displayIdx = 0; //12apr15 wrap around
8000b51c:	fe f9 0d 88 	ld.w	r9,pc[3464]
8000b520:	30 08       	mov	r8,0
8000b522:	b2 88       	st.b	r9[0x0],r8
						}
						
						if (shelf[displayIdx].active)
8000b524:	fe f8 0d 80 	ld.w	r8,pc[3456]
8000b528:	11 88       	ld.ub	r8,r8[0x0]
8000b52a:	10 99       	mov	r9,r8
8000b52c:	fe fa 0d 80 	ld.w	r10,pc[3456]
8000b530:	12 98       	mov	r8,r9
8000b532:	a3 68       	lsl	r8,0x2
8000b534:	12 08       	add	r8,r9
8000b536:	f4 08 00 08 	add	r8,r10,r8
8000b53a:	11 88       	ld.ub	r8,r8[0x0]
8000b53c:	58 08       	cp.w	r8,0
8000b53e:	cd e0       	breq	8000b4fa <main+0x6f2>
							break; //this shelf is active, we don't need to look for another one
						}
						
					}

					cpu_set_timeout(displayTimerSeconds, &displayTimer); //8 seconds per shelf
8000b540:	fe f8 0d 50 	ld.w	r8,pc[3408]
8000b544:	70 08       	ld.w	r8,r8[0x0]
8000b546:	ef 48 ff 40 	st.w	r7[-192],r8
8000b54a:	fe f8 0d 4a 	ld.w	r8,pc[3402]
8000b54e:	ef 48 ff 3c 	st.w	r7[-196],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000b552:	e1 b8 00 42 	mfsr	r8,0x108
8000b556:	10 99       	mov	r9,r8
8000b558:	ee f8 ff 3c 	ld.w	r8,r7[-196]
8000b55c:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000b55e:	ee f8 ff 3c 	ld.w	r8,r7[-196]
8000b562:	70 09       	ld.w	r9,r8[0x0]
8000b564:	ee f8 ff 40 	ld.w	r8,r7[-192]
8000b568:	10 09       	add	r9,r8
8000b56a:	ee f8 ff 3c 	ld.w	r8,r7[-196]
8000b56e:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
8000b570:	ee f9 ff 3c 	ld.w	r9,r7[-196]
8000b574:	30 08       	mov	r8,0
8000b576:	f3 68 00 08 	st.b	r9[8],r8
						if (shelf[displayIdx].active)
						{
							break; //this shelf is active, we don't need to look for another one
						}
						
					}
8000b57a:	fe f8 0d 52 	ld.w	r8,pc[3410]
8000b57e:	ef 48 ff 44 	st.w	r7[-188],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000b582:	e1 b8 00 42 	mfsr	r8,0x108
8000b586:	ef 48 ff 48 	st.w	r7[-184],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
8000b58a:	ee f8 ff 44 	ld.w	r8,r7[-188]
8000b58e:	f1 39 00 08 	ld.ub	r9,r8[8]
8000b592:	30 28       	mov	r8,2
8000b594:	f0 09 18 00 	cp.b	r9,r8
8000b598:	c0 31       	brne	8000b59e <main+0x796>
    return false;
8000b59a:	30 08       	mov	r8,0
8000b59c:	c4 38       	rjmp	8000b622 <main+0x81a>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
8000b59e:	ee f8 ff 44 	ld.w	r8,r7[-188]
8000b5a2:	f1 39 00 08 	ld.ub	r9,r8[8]
8000b5a6:	30 18       	mov	r8,1
8000b5a8:	f0 09 18 00 	cp.b	r9,r8
8000b5ac:	c0 31       	brne	8000b5b2 <main+0x7aa>
    return true;
8000b5ae:	30 18       	mov	r8,1
8000b5b0:	c3 98       	rjmp	8000b622 <main+0x81a>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000b5b2:	ee f8 ff 44 	ld.w	r8,r7[-188]
8000b5b6:	70 09       	ld.w	r9,r8[0x0]
8000b5b8:	ee f8 ff 44 	ld.w	r8,r7[-188]
8000b5bc:	70 18       	ld.w	r8,r8[0x4]
8000b5be:	10 39       	cp.w	r9,r8
8000b5c0:	e0 88 00 1a 	brls	8000b5f4 <main+0x7ec>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000b5c4:	ee f8 ff 44 	ld.w	r8,r7[-188]
8000b5c8:	70 09       	ld.w	r9,r8[0x0]
8000b5ca:	ee f8 ff 48 	ld.w	r8,r7[-184]
8000b5ce:	12 38       	cp.w	r8,r9
8000b5d0:	c1 02       	brcc	8000b5f0 <main+0x7e8>
8000b5d2:	ee f8 ff 44 	ld.w	r8,r7[-188]
8000b5d6:	70 19       	ld.w	r9,r8[0x4]
8000b5d8:	ee f8 ff 48 	ld.w	r8,r7[-184]
8000b5dc:	12 38       	cp.w	r8,r9
8000b5de:	e0 88 00 09 	brls	8000b5f0 <main+0x7e8>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
8000b5e2:	ee f9 ff 44 	ld.w	r9,r7[-188]
8000b5e6:	30 18       	mov	r8,1
8000b5e8:	f3 68 00 08 	st.b	r9[8],r8
      return true;
8000b5ec:	30 18       	mov	r8,1
8000b5ee:	c1 a8       	rjmp	8000b622 <main+0x81a>
    }
    return false;
8000b5f0:	30 08       	mov	r8,0
8000b5f2:	c1 88       	rjmp	8000b622 <main+0x81a>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000b5f4:	ee f8 ff 44 	ld.w	r8,r7[-188]
8000b5f8:	70 09       	ld.w	r9,r8[0x0]
8000b5fa:	ee f8 ff 48 	ld.w	r8,r7[-184]
8000b5fe:	12 38       	cp.w	r8,r9
8000b600:	c0 93       	brcs	8000b612 <main+0x80a>
8000b602:	ee f8 ff 44 	ld.w	r8,r7[-188]
8000b606:	70 19       	ld.w	r9,r8[0x4]
8000b608:	ee f8 ff 48 	ld.w	r8,r7[-184]
8000b60c:	12 38       	cp.w	r8,r9
8000b60e:	e0 88 00 09 	brls	8000b620 <main+0x818>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
8000b612:	ee f9 ff 44 	ld.w	r9,r7[-188]
8000b616:	30 18       	mov	r8,1
8000b618:	f3 68 00 08 	st.b	r9[8],r8
      return true;
8000b61c:	30 18       	mov	r8,1
8000b61e:	c0 28       	rjmp	8000b622 <main+0x81a>
    }
    return false;
8000b620:	30 08       	mov	r8,0
				}

				/*
    			 * Manage storing usage statistics to flash
				 */
				if (cpu_is_timeout (&oneMinuteTimer))
8000b622:	58 08       	cp.w	r8,0
8000b624:	c5 e0       	breq	8000b6e0 <main+0x8d8>
8000b626:	fe f8 0c a6 	ld.w	r8,pc[3238]
8000b62a:	ef 48 ff 4c 	st.w	r7[-180],r8
 *
 * \param  cpu_time:   (input) internal information used by the timer API.
 */
__always_inline static void cpu_stop_timeout(t_cpu_time *cpu_time)
{
  cpu_time->timer_state = CPU_TIMER_STATE_STOPPED;
8000b62e:	ee f9 ff 4c 	ld.w	r9,r7[-180]
8000b632:	30 28       	mov	r8,2
8000b634:	f3 68 00 08 	st.b	r9[8],r8
				{
					cpu_stop_timeout (&oneMinuteTimer);
					
					increment_ledBoard_usage_min(); //increments usage minutes for active shelves only
8000b638:	f0 1f 03 26 	mcall	8000c2d0 <main+0x14c8>
8000b63c:	e0 68 03 e8 	mov	r8,1000
8000b640:	ef 48 ff 54 	st.w	r7[-172],r8
8000b644:	e0 68 12 00 	mov	r8,4608
8000b648:	ea 18 00 7a 	orh	r8,0x7a
8000b64c:	ef 48 ff 50 	st.w	r7[-176],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
8000b650:	ee fa ff 54 	ld.w	r10,r7[-172]
8000b654:	ef 4a fe 0c 	st.w	r7[-500],r10
8000b658:	30 08       	mov	r8,0
8000b65a:	ef 48 fe 08 	st.w	r7[-504],r8
8000b65e:	ee fc ff 50 	ld.w	r12,r7[-176]
8000b662:	ef 4c fe 04 	st.w	r7[-508],r12
8000b666:	30 0a       	mov	r10,0
8000b668:	ef 4a fe 00 	st.w	r7[-512],r10
8000b66c:	ee f9 fe 08 	ld.w	r9,r7[-504]
8000b670:	ee f8 fe 04 	ld.w	r8,r7[-508]
8000b674:	b1 39       	mul	r9,r8
8000b676:	ee f8 fe 00 	ld.w	r8,r7[-512]
8000b67a:	ee fc fe 0c 	ld.w	r12,r7[-500]
8000b67e:	b9 38       	mul	r8,r12
8000b680:	10 09       	add	r9,r8
8000b682:	ee f8 fe 0c 	ld.w	r8,r7[-500]
8000b686:	ee fc fe 04 	ld.w	r12,r7[-508]
8000b68a:	f0 0c 06 4a 	mulu.d	r10,r8,r12
8000b68e:	16 09       	add	r9,r11
8000b690:	12 9b       	mov	r11,r9
8000b692:	e0 68 03 e7 	mov	r8,999
8000b696:	30 09       	mov	r9,0
8000b698:	10 0a       	add	r10,r8
8000b69a:	f6 09 00 4b 	adc	r11,r11,r9
8000b69e:	e0 68 03 e8 	mov	r8,1000
8000b6a2:	30 09       	mov	r9,0
8000b6a4:	f0 1f 02 ea 	mcall	8000c24c <main+0x1444>
8000b6a8:	14 98       	mov	r8,r10
8000b6aa:	16 99       	mov	r9,r11
					
//DEBUG 11may15 set to one second for debug					cpu_set_timeout(cpu_ms_2_cy(60000, EC_CPU_CLOCK_FREQ), &oneMinuteTimer); //one minute for the usage statistics
					cpu_set_timeout((cpu_ms_2_cy(1000,EC_CPU_CLOCK_FREQ)), &oneMinuteTimer); //one minute for the usage statistics DEBUG 11may15 one second instead of one minute
8000b6ac:	ef 48 ff 5c 	st.w	r7[-164],r8
8000b6b0:	fe f8 0c 1c 	ld.w	r8,pc[3100]
8000b6b4:	ef 48 ff 58 	st.w	r7[-168],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000b6b8:	e1 b8 00 42 	mfsr	r8,0x108
8000b6bc:	10 99       	mov	r9,r8
8000b6be:	ee f8 ff 58 	ld.w	r8,r7[-168]
8000b6c2:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000b6c4:	ee f8 ff 58 	ld.w	r8,r7[-168]
8000b6c8:	70 09       	ld.w	r9,r8[0x0]
8000b6ca:	ee f8 ff 5c 	ld.w	r8,r7[-164]
8000b6ce:	10 09       	add	r9,r8
8000b6d0:	ee f8 ff 58 	ld.w	r8,r7[-168]
8000b6d4:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
8000b6d6:	ee f9 ff 58 	ld.w	r9,r7[-168]
8000b6da:	30 08       	mov	r8,0
8000b6dc:	f3 68 00 08 	st.b	r9[8],r8
8000b6e0:	fe f8 0b dc 	ld.w	r8,pc[3036]
8000b6e4:	ef 48 ff 60 	st.w	r7[-160],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000b6e8:	e1 b8 00 42 	mfsr	r8,0x108
8000b6ec:	ef 48 ff 64 	st.w	r7[-156],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
8000b6f0:	ee f8 ff 60 	ld.w	r8,r7[-160]
8000b6f4:	f1 39 00 08 	ld.ub	r9,r8[8]
8000b6f8:	30 28       	mov	r8,2
8000b6fa:	f0 09 18 00 	cp.b	r9,r8
8000b6fe:	c0 31       	brne	8000b704 <main+0x8fc>
    return false;
8000b700:	30 08       	mov	r8,0
8000b702:	c4 38       	rjmp	8000b788 <main+0x980>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
8000b704:	ee f8 ff 60 	ld.w	r8,r7[-160]
8000b708:	f1 39 00 08 	ld.ub	r9,r8[8]
8000b70c:	30 18       	mov	r8,1
8000b70e:	f0 09 18 00 	cp.b	r9,r8
8000b712:	c0 31       	brne	8000b718 <main+0x910>
    return true;
8000b714:	30 18       	mov	r8,1
8000b716:	c3 98       	rjmp	8000b788 <main+0x980>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000b718:	ee f8 ff 60 	ld.w	r8,r7[-160]
8000b71c:	70 09       	ld.w	r9,r8[0x0]
8000b71e:	ee f8 ff 60 	ld.w	r8,r7[-160]
8000b722:	70 18       	ld.w	r8,r8[0x4]
8000b724:	10 39       	cp.w	r9,r8
8000b726:	e0 88 00 1a 	brls	8000b75a <main+0x952>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000b72a:	ee f8 ff 60 	ld.w	r8,r7[-160]
8000b72e:	70 09       	ld.w	r9,r8[0x0]
8000b730:	ee f8 ff 64 	ld.w	r8,r7[-156]
8000b734:	12 38       	cp.w	r8,r9
8000b736:	c1 02       	brcc	8000b756 <main+0x94e>
8000b738:	ee f8 ff 60 	ld.w	r8,r7[-160]
8000b73c:	70 19       	ld.w	r9,r8[0x4]
8000b73e:	ee f8 ff 64 	ld.w	r8,r7[-156]
8000b742:	12 38       	cp.w	r8,r9
8000b744:	e0 88 00 09 	brls	8000b756 <main+0x94e>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
8000b748:	ee f9 ff 60 	ld.w	r9,r7[-160]
8000b74c:	30 18       	mov	r8,1
8000b74e:	f3 68 00 08 	st.b	r9[8],r8
      return true;
8000b752:	30 18       	mov	r8,1
8000b754:	c1 a8       	rjmp	8000b788 <main+0x980>
    }
    return false;
8000b756:	30 08       	mov	r8,0
8000b758:	c1 88       	rjmp	8000b788 <main+0x980>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000b75a:	ee f8 ff 60 	ld.w	r8,r7[-160]
8000b75e:	70 09       	ld.w	r9,r8[0x0]
8000b760:	ee f8 ff 64 	ld.w	r8,r7[-156]
8000b764:	12 38       	cp.w	r8,r9
8000b766:	c0 93       	brcs	8000b778 <main+0x970>
8000b768:	ee f8 ff 60 	ld.w	r8,r7[-160]
8000b76c:	70 19       	ld.w	r9,r8[0x4]
8000b76e:	ee f8 ff 64 	ld.w	r8,r7[-156]
8000b772:	12 38       	cp.w	r8,r9
8000b774:	e0 88 00 09 	brls	8000b786 <main+0x97e>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
8000b778:	ee f9 ff 60 	ld.w	r9,r7[-160]
8000b77c:	30 18       	mov	r8,1
8000b77e:	f3 68 00 08 	st.b	r9[8],r8
      return true;
8000b782:	30 18       	mov	r8,1
8000b784:	c0 28       	rjmp	8000b788 <main+0x980>
    }
    return false;
8000b786:	30 08       	mov	r8,0
				}
				/*
    			 * Manage the sanitizer timer
				 */
				if (cpu_is_timeout(&sanitizeTimer)) {
8000b788:	58 08       	cp.w	r8,0
8000b78a:	e0 80 04 2c 	breq	8000bfe2 <main+0x11da>
					
					for (int i=0; i< NUM_SHELVES; i++)
8000b78e:	30 08       	mov	r8,0
8000b790:	ef 48 fe d4 	st.w	r7[-300],r8
8000b794:	c0 68       	rjmp	8000b7a0 <main+0x998>
8000b796:	ee f8 fe d4 	ld.w	r8,r7[-300]
8000b79a:	2f f8       	sub	r8,-1
8000b79c:	ef 48 fe d4 	st.w	r7[-300],r8
8000b7a0:	ee f8 fe d4 	ld.w	r8,r7[-300]
8000b7a4:	58 38       	cp.w	r8,3
8000b7a6:	fe 9a ff f8 	brle	8000b796 <main+0x98e>
8000b7aa:	fe f8 0b 12 	ld.w	r8,pc[2834]
8000b7ae:	ef 48 ff 68 	st.w	r7[-152],r8
 *
 * \param  cpu_time:   (input) internal information used by the timer API.
 */
__always_inline static void cpu_stop_timeout(t_cpu_time *cpu_time)
{
  cpu_time->timer_state = CPU_TIMER_STATE_STOPPED;
8000b7b2:	ee f9 ff 68 	ld.w	r9,r7[-152]
8000b7b6:	30 28       	mov	r8,2
8000b7b8:	f3 68 00 08 	st.b	r9[8],r8
					{
//DEBUG 16jan16 THIS IS REALLY SLOPPY, WANT TO KEEP THE LEDS ON FOR 30 MINUTES BUT THE TIMER STUFF DOESN'T SEEM TO WORK THAT LONG, SO WE ARE JUST NOT GOING TO TURN THE SHELVES OFF						led_shelf(i, LED_OFF); //turn off every shelf. (doesn't hurt to make sure that even non-active shelves are off.)
					}
					cpu_stop_timeout(&sanitizeTimer);
					print_ecdbg("Shelf clean\r\n");
8000b7bc:	fe fc 0b 18 	ld.w	r12,pc[2840]
8000b7c0:	f0 1f 02 aa 	mcall	8000c268 <main+0x1460>
					electroclaveState = STATE_START_CLEAN;
8000b7c4:	fe f9 0a 94 	ld.w	r9,pc[2708]
8000b7c8:	30 68       	mov	r8,6
8000b7ca:	b2 88       	st.b	r9[0x0],r8
				}
				break;
8000b7cc:	e0 8f 04 10 	bral	8000bfec <main+0x11e4>
				
			case STATE_START_CLEAN:
				display_text(IDX_CLEAN);
8000b7d0:	30 1c       	mov	r12,1
8000b7d2:	f0 1f 02 92 	mcall	8000c218 <main+0x1410>
				electroclaveState = STATE_CLEAN;
8000b7d6:	fe f9 0a 82 	ld.w	r9,pc[2690]
8000b7da:	30 78       	mov	r8,7
8000b7dc:	b2 88       	st.b	r9[0x0],r8
8000b7de:	e0 68 03 e8 	mov	r8,1000
8000b7e2:	ef 48 ff 70 	st.w	r7[-144],r8
8000b7e6:	e0 68 12 00 	mov	r8,4608
8000b7ea:	ea 18 00 7a 	orh	r8,0x7a
8000b7ee:	ef 48 ff 6c 	st.w	r7[-148],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
8000b7f2:	ee fa ff 70 	ld.w	r10,r7[-144]
8000b7f6:	ef 4a fe 1c 	st.w	r7[-484],r10
8000b7fa:	30 08       	mov	r8,0
8000b7fc:	ef 48 fe 18 	st.w	r7[-488],r8
8000b800:	ee fc ff 6c 	ld.w	r12,r7[-148]
8000b804:	ef 4c fe 14 	st.w	r7[-492],r12
8000b808:	30 0a       	mov	r10,0
8000b80a:	ef 4a fe 10 	st.w	r7[-496],r10
8000b80e:	ee f9 fe 18 	ld.w	r9,r7[-488]
8000b812:	ee f8 fe 14 	ld.w	r8,r7[-492]
8000b816:	b1 39       	mul	r9,r8
8000b818:	ee f8 fe 10 	ld.w	r8,r7[-496]
8000b81c:	ee fc fe 1c 	ld.w	r12,r7[-484]
8000b820:	b9 38       	mul	r8,r12
8000b822:	10 09       	add	r9,r8
8000b824:	ee f8 fe 1c 	ld.w	r8,r7[-484]
8000b828:	ee fc fe 14 	ld.w	r12,r7[-492]
8000b82c:	f0 0c 06 4a 	mulu.d	r10,r8,r12
8000b830:	16 09       	add	r9,r11
8000b832:	12 9b       	mov	r11,r9
8000b834:	e0 68 03 e7 	mov	r8,999
8000b838:	30 09       	mov	r9,0
8000b83a:	10 0a       	add	r10,r8
8000b83c:	f6 09 00 4b 	adc	r11,r11,r9
8000b840:	e0 68 03 e8 	mov	r8,1000
8000b844:	30 09       	mov	r9,0
8000b846:	f0 1f 02 82 	mcall	8000c24c <main+0x1444>
8000b84a:	14 98       	mov	r8,r10
8000b84c:	16 99       	mov	r9,r11
				cpu_set_timeout((20 * 60 * cpu_ms_2_cy(1000, EC_CPU_CLOCK_FREQ)), &cleanTimer);
#endif
//DEBUG 24jun15 change to 60 seconds for demo, put this line back in later				cpu_set_timeout((20 * cpu_ms_2_cy(1000, EC_CPU_CLOCK_FREQ)), &cleanTimer); //DEBUG 11may15 

//				cpu_set_timeout((60 * cpu_ms_2_cy(1000, EC_CPU_CLOCK_FREQ)), &cleanTimer); //DEBUG 24jun15 change to 60 seconds for demo, remove later
				cpu_set_timeout((3 * cpu_ms_2_cy(1000, EC_CPU_CLOCK_FREQ)), &cleanTimer); //DEBUG 31jul15 change to 3 seconds BOTDRIVE, remove later
8000b84e:	10 99       	mov	r9,r8
8000b850:	12 98       	mov	r8,r9
8000b852:	a1 78       	lsl	r8,0x1
8000b854:	12 08       	add	r8,r9
8000b856:	ef 48 ff 78 	st.w	r7[-136],r8
8000b85a:	fe f8 0a 7e 	ld.w	r8,pc[2686]
8000b85e:	ef 48 ff 74 	st.w	r7[-140],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000b862:	e1 b8 00 42 	mfsr	r8,0x108
8000b866:	10 99       	mov	r9,r8
8000b868:	ee f8 ff 74 	ld.w	r8,r7[-140]
8000b86c:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000b86e:	ee f8 ff 74 	ld.w	r8,r7[-140]
8000b872:	70 09       	ld.w	r9,r8[0x0]
8000b874:	ee f8 ff 78 	ld.w	r8,r7[-136]
8000b878:	10 09       	add	r9,r8
8000b87a:	ee f8 ff 74 	ld.w	r8,r7[-140]
8000b87e:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
8000b880:	ee f9 ff 74 	ld.w	r9,r7[-140]
8000b884:	30 08       	mov	r8,0
8000b886:	f3 68 00 08 	st.b	r9[8],r8
				break;	
8000b88a:	e0 8f 03 b1 	bral	8000bfec <main+0x11e4>
8000b88e:	fe f8 0a 4a 	ld.w	r8,pc[2634]
8000b892:	ef 48 ff 7c 	st.w	r7[-132],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000b896:	e1 b8 00 42 	mfsr	r8,0x108
8000b89a:	ef 48 ff 80 	st.w	r7[-128],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
8000b89e:	ee f8 ff 7c 	ld.w	r8,r7[-132]
8000b8a2:	f1 39 00 08 	ld.ub	r9,r8[8]
8000b8a6:	30 28       	mov	r8,2
8000b8a8:	f0 09 18 00 	cp.b	r9,r8
8000b8ac:	c0 31       	brne	8000b8b2 <main+0xaaa>
    return false;
8000b8ae:	30 08       	mov	r8,0
8000b8b0:	c4 38       	rjmp	8000b936 <main+0xb2e>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
8000b8b2:	ee f8 ff 7c 	ld.w	r8,r7[-132]
8000b8b6:	f1 39 00 08 	ld.ub	r9,r8[8]
8000b8ba:	30 18       	mov	r8,1
8000b8bc:	f0 09 18 00 	cp.b	r9,r8
8000b8c0:	c0 31       	brne	8000b8c6 <main+0xabe>
    return true;
8000b8c2:	30 18       	mov	r8,1
8000b8c4:	c3 98       	rjmp	8000b936 <main+0xb2e>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000b8c6:	ee f8 ff 7c 	ld.w	r8,r7[-132]
8000b8ca:	70 09       	ld.w	r9,r8[0x0]
8000b8cc:	ee f8 ff 7c 	ld.w	r8,r7[-132]
8000b8d0:	70 18       	ld.w	r8,r8[0x4]
8000b8d2:	10 39       	cp.w	r9,r8
8000b8d4:	e0 88 00 1a 	brls	8000b908 <main+0xb00>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000b8d8:	ee f8 ff 7c 	ld.w	r8,r7[-132]
8000b8dc:	70 09       	ld.w	r9,r8[0x0]
8000b8de:	ee f8 ff 80 	ld.w	r8,r7[-128]
8000b8e2:	12 38       	cp.w	r8,r9
8000b8e4:	c1 02       	brcc	8000b904 <main+0xafc>
8000b8e6:	ee f8 ff 7c 	ld.w	r8,r7[-132]
8000b8ea:	70 19       	ld.w	r9,r8[0x4]
8000b8ec:	ee f8 ff 80 	ld.w	r8,r7[-128]
8000b8f0:	12 38       	cp.w	r8,r9
8000b8f2:	e0 88 00 09 	brls	8000b904 <main+0xafc>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
8000b8f6:	ee f9 ff 7c 	ld.w	r9,r7[-132]
8000b8fa:	30 18       	mov	r8,1
8000b8fc:	f3 68 00 08 	st.b	r9[8],r8
      return true;
8000b900:	30 18       	mov	r8,1
8000b902:	c1 a8       	rjmp	8000b936 <main+0xb2e>
    }
    return false;
8000b904:	30 08       	mov	r8,0
8000b906:	c1 88       	rjmp	8000b936 <main+0xb2e>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000b908:	ee f8 ff 7c 	ld.w	r8,r7[-132]
8000b90c:	70 09       	ld.w	r9,r8[0x0]
8000b90e:	ee f8 ff 80 	ld.w	r8,r7[-128]
8000b912:	12 38       	cp.w	r8,r9
8000b914:	c0 93       	brcs	8000b926 <main+0xb1e>
8000b916:	ee f8 ff 7c 	ld.w	r8,r7[-132]
8000b91a:	70 19       	ld.w	r9,r8[0x4]
8000b91c:	ee f8 ff 80 	ld.w	r8,r7[-128]
8000b920:	12 38       	cp.w	r8,r9
8000b922:	e0 88 00 09 	brls	8000b934 <main+0xb2c>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
8000b926:	ee f9 ff 7c 	ld.w	r9,r7[-132]
8000b92a:	30 18       	mov	r8,1
8000b92c:	f3 68 00 08 	st.b	r9[8],r8
      return true;
8000b930:	30 18       	mov	r8,1
8000b932:	c0 28       	rjmp	8000b936 <main+0xb2e>
    }
    return false;
8000b934:	30 08       	mov	r8,0
				
			case STATE_CLEAN:
				if (cpu_is_timeout(&cleanTimer)) {
8000b936:	58 08       	cp.w	r8,0
8000b938:	e0 80 03 57 	breq	8000bfe6 <main+0x11de>
8000b93c:	fe f8 09 9c 	ld.w	r8,pc[2460]
8000b940:	ef 48 ff 84 	st.w	r7[-124],r8
 *
 * \param  cpu_time:   (input) internal information used by the timer API.
 */
__always_inline static void cpu_stop_timeout(t_cpu_time *cpu_time)
{
  cpu_time->timer_state = CPU_TIMER_STATE_STOPPED;
8000b944:	ee f9 ff 84 	ld.w	r9,r7[-124]
8000b948:	30 28       	mov	r8,2
8000b94a:	f3 68 00 08 	st.b	r9[8],r8
					cpu_stop_timeout(&cleanTimer);
					electroclaveState = STATE_ACTION_PB_RELEASED;	
8000b94e:	fe f9 09 0a 	ld.w	r9,pc[2314]
8000b952:	30 38       	mov	r8,3
8000b954:	b2 88       	st.b	r9[0x0],r8
				}
				break;
8000b956:	e0 8f 03 4b 	bral	8000bfec <main+0x11e4>
				
			
			case STATE_CHASSIS_ERROR:
				//Shutdown all processes that could harm the user or equipment if the door is open
				for (int i=0; i< NUM_SHELVES; i++)
8000b95a:	30 08       	mov	r8,0
8000b95c:	ef 48 fe d8 	st.w	r7[-296],r8
8000b960:	c0 d8       	rjmp	8000b97a <main+0xb72>
				{
					led_shelf(i, LED_OFF); //turn off every shelf. (doesn't hurt to make sure that even non-active shelves are off.)
8000b962:	ee f8 fe d8 	ld.w	r8,r7[-296]
8000b966:	5c 58       	castu.b	r8
8000b968:	30 0b       	mov	r11,0
8000b96a:	10 9c       	mov	r12,r8
8000b96c:	f0 1f 02 53 	mcall	8000c2b8 <main+0x14b0>
				break;
				
			
			case STATE_CHASSIS_ERROR:
				//Shutdown all processes that could harm the user or equipment if the door is open
				for (int i=0; i< NUM_SHELVES; i++)
8000b970:	ee f8 fe d8 	ld.w	r8,r7[-296]
8000b974:	2f f8       	sub	r8,-1
8000b976:	ef 48 fe d8 	st.w	r7[-296],r8
8000b97a:	ee f8 fe d8 	ld.w	r8,r7[-296]
8000b97e:	58 38       	cp.w	r8,3
8000b980:	fe 9a ff f1 	brle	8000b962 <main+0xb5a>
8000b984:	fe f8 09 58 	ld.w	r8,pc[2392]
8000b988:	ef 48 ff 88 	st.w	r7[-120],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000b98c:	e1 b8 00 42 	mfsr	r8,0x108
8000b990:	ef 48 ff 8c 	st.w	r7[-116],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
8000b994:	ee f8 ff 88 	ld.w	r8,r7[-120]
8000b998:	f1 39 00 08 	ld.ub	r9,r8[8]
8000b99c:	30 28       	mov	r8,2
8000b99e:	f0 09 18 00 	cp.b	r9,r8
8000b9a2:	c0 31       	brne	8000b9a8 <main+0xba0>
    return false;
8000b9a4:	30 08       	mov	r8,0
8000b9a6:	c4 38       	rjmp	8000ba2c <main+0xc24>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
8000b9a8:	ee f8 ff 88 	ld.w	r8,r7[-120]
8000b9ac:	f1 39 00 08 	ld.ub	r9,r8[8]
8000b9b0:	30 18       	mov	r8,1
8000b9b2:	f0 09 18 00 	cp.b	r9,r8
8000b9b6:	c0 31       	brne	8000b9bc <main+0xbb4>
    return true;
8000b9b8:	30 18       	mov	r8,1
8000b9ba:	c3 98       	rjmp	8000ba2c <main+0xc24>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000b9bc:	ee f8 ff 88 	ld.w	r8,r7[-120]
8000b9c0:	70 09       	ld.w	r9,r8[0x0]
8000b9c2:	ee f8 ff 88 	ld.w	r8,r7[-120]
8000b9c6:	70 18       	ld.w	r8,r8[0x4]
8000b9c8:	10 39       	cp.w	r9,r8
8000b9ca:	e0 88 00 1a 	brls	8000b9fe <main+0xbf6>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000b9ce:	ee f8 ff 88 	ld.w	r8,r7[-120]
8000b9d2:	70 09       	ld.w	r9,r8[0x0]
8000b9d4:	ee f8 ff 8c 	ld.w	r8,r7[-116]
8000b9d8:	12 38       	cp.w	r8,r9
8000b9da:	c1 02       	brcc	8000b9fa <main+0xbf2>
8000b9dc:	ee f8 ff 88 	ld.w	r8,r7[-120]
8000b9e0:	70 19       	ld.w	r9,r8[0x4]
8000b9e2:	ee f8 ff 8c 	ld.w	r8,r7[-116]
8000b9e6:	12 38       	cp.w	r8,r9
8000b9e8:	e0 88 00 09 	brls	8000b9fa <main+0xbf2>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
8000b9ec:	ee f9 ff 88 	ld.w	r9,r7[-120]
8000b9f0:	30 18       	mov	r8,1
8000b9f2:	f3 68 00 08 	st.b	r9[8],r8
      return true;
8000b9f6:	30 18       	mov	r8,1
8000b9f8:	c1 a8       	rjmp	8000ba2c <main+0xc24>
    }
    return false;
8000b9fa:	30 08       	mov	r8,0
8000b9fc:	c1 88       	rjmp	8000ba2c <main+0xc24>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000b9fe:	ee f8 ff 88 	ld.w	r8,r7[-120]
8000ba02:	70 09       	ld.w	r9,r8[0x0]
8000ba04:	ee f8 ff 8c 	ld.w	r8,r7[-116]
8000ba08:	12 38       	cp.w	r8,r9
8000ba0a:	c0 93       	brcs	8000ba1c <main+0xc14>
8000ba0c:	ee f8 ff 88 	ld.w	r8,r7[-120]
8000ba10:	70 19       	ld.w	r9,r8[0x4]
8000ba12:	ee f8 ff 8c 	ld.w	r8,r7[-116]
8000ba16:	12 38       	cp.w	r8,r9
8000ba18:	e0 88 00 09 	brls	8000ba2a <main+0xc22>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
8000ba1c:	ee f9 ff 88 	ld.w	r9,r7[-120]
8000ba20:	30 18       	mov	r8,1
8000ba22:	f3 68 00 08 	st.b	r9[8],r8
      return true;
8000ba26:	30 18       	mov	r8,1
8000ba28:	c0 28       	rjmp	8000ba2c <main+0xc24>
    }
    return false;
8000ba2a:	30 08       	mov	r8,0
				{
					led_shelf(i, LED_OFF); //turn off every shelf. (doesn't hurt to make sure that even non-active shelves are off.)
				}
				
				
				if (cpu_is_timeout(&errorDisplayTimer))
8000ba2c:	58 08       	cp.w	r8,0
8000ba2e:	e0 80 02 de 	breq	8000bfea <main+0x11e2>
8000ba32:	fe f8 08 aa 	ld.w	r8,pc[2218]
8000ba36:	ef 48 ff 90 	st.w	r7[-112],r8
 *
 * \param  cpu_time:   (input) internal information used by the timer API.
 */
__always_inline static void cpu_stop_timeout(t_cpu_time *cpu_time)
{
  cpu_time->timer_state = CPU_TIMER_STATE_STOPPED;
8000ba3a:	ee f9 ff 90 	ld.w	r9,r7[-112]
8000ba3e:	30 28       	mov	r8,2
8000ba40:	f3 68 00 08 	st.b	r9[8],r8
8000ba44:	c0 28       	rjmp	8000ba48 <main+0xc40>
						{
							displayChanged = 0;
							break; //get out of while loop and wait until we need to update the display again
						}
						
					} //while(1)
8000ba46:	d7 03       	nop
				{
					cpu_stop_timeout(&errorDisplayTimer);

					while(1)
					{
						switch(errorDisplayState)
8000ba48:	fe f8 08 98 	ld.w	r8,pc[2200]
8000ba4c:	11 88       	ld.ub	r8,r8[0x0]
8000ba4e:	58 28       	cp.w	r8,2
8000ba50:	e0 80 00 fc 	breq	8000bc48 <main+0xe40>
8000ba54:	e0 89 00 08 	brgt	8000ba64 <main+0xc5c>
8000ba58:	58 08       	cp.w	r8,0
8000ba5a:	c0 d0       	breq	8000ba74 <main+0xc6c>
8000ba5c:	58 18       	cp.w	r8,1
8000ba5e:	c6 b0       	breq	8000bb34 <main+0xd2c>
8000ba60:	e0 8f 02 91 	bral	8000bf82 <main+0x117a>
8000ba64:	58 38       	cp.w	r8,3
8000ba66:	e0 80 01 7a 	breq	8000bd5a <main+0xf52>
8000ba6a:	58 48       	cp.w	r8,4
8000ba6c:	e0 80 02 00 	breq	8000be6c <main+0x1064>
8000ba70:	e0 8f 02 89 	bral	8000bf82 <main+0x117a>
						{
							case 0:
								display_text(IDX_ERROR);
8000ba74:	30 4c       	mov	r12,4
8000ba76:	f0 1f 01 e9 	mcall	8000c218 <main+0x1410>
								displayChanged = 1;
8000ba7a:	fe f9 08 6a 	ld.w	r9,pc[2154]
8000ba7e:	30 18       	mov	r8,1
8000ba80:	b2 88       	st.b	r9[0x0],r8
8000ba82:	e0 68 03 e8 	mov	r8,1000
8000ba86:	ef 48 ff 98 	st.w	r7[-104],r8
8000ba8a:	e0 68 12 00 	mov	r8,4608
8000ba8e:	ea 18 00 7a 	orh	r8,0x7a
8000ba92:	ef 48 ff 94 	st.w	r7[-108],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
8000ba96:	ee fa ff 98 	ld.w	r10,r7[-104]
8000ba9a:	ef 4a fe 2c 	st.w	r7[-468],r10
8000ba9e:	30 08       	mov	r8,0
8000baa0:	ef 48 fe 28 	st.w	r7[-472],r8
8000baa4:	ee fc ff 94 	ld.w	r12,r7[-108]
8000baa8:	ef 4c fe 24 	st.w	r7[-476],r12
8000baac:	30 0a       	mov	r10,0
8000baae:	ef 4a fe 20 	st.w	r7[-480],r10
8000bab2:	ee f9 fe 28 	ld.w	r9,r7[-472]
8000bab6:	ee f8 fe 24 	ld.w	r8,r7[-476]
8000baba:	b1 39       	mul	r9,r8
8000babc:	ee f8 fe 20 	ld.w	r8,r7[-480]
8000bac0:	ee fc fe 2c 	ld.w	r12,r7[-468]
8000bac4:	b9 38       	mul	r8,r12
8000bac6:	10 09       	add	r9,r8
8000bac8:	ee f8 fe 2c 	ld.w	r8,r7[-468]
8000bacc:	ee fc fe 24 	ld.w	r12,r7[-476]
8000bad0:	f0 0c 06 4a 	mulu.d	r10,r8,r12
8000bad4:	16 09       	add	r9,r11
8000bad6:	12 9b       	mov	r11,r9
8000bad8:	e0 68 03 e7 	mov	r8,999
8000badc:	30 09       	mov	r9,0
8000bade:	10 0a       	add	r10,r8
8000bae0:	f6 09 00 4b 	adc	r11,r11,r9
8000bae4:	e0 68 03 e8 	mov	r8,1000
8000bae8:	30 09       	mov	r9,0
8000baea:	f0 1f 01 d9 	mcall	8000c24c <main+0x1444>
8000baee:	14 98       	mov	r8,r10
8000baf0:	16 99       	mov	r9,r11
								cpu_set_timeout(8*EC_ONE_SECOND, &errorDisplayTimer);
8000baf2:	a3 78       	lsl	r8,0x3
8000baf4:	ef 48 ff a0 	st.w	r7[-96],r8
8000baf8:	fe f8 07 e4 	ld.w	r8,pc[2020]
8000bafc:	ef 48 ff 9c 	st.w	r7[-100],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000bb00:	e1 b8 00 42 	mfsr	r8,0x108
8000bb04:	10 99       	mov	r9,r8
8000bb06:	ee f8 ff 9c 	ld.w	r8,r7[-100]
8000bb0a:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000bb0c:	ee f8 ff 9c 	ld.w	r8,r7[-100]
8000bb10:	70 09       	ld.w	r9,r8[0x0]
8000bb12:	ee f8 ff a0 	ld.w	r8,r7[-96]
8000bb16:	10 09       	add	r9,r8
8000bb18:	ee f8 ff 9c 	ld.w	r8,r7[-100]
8000bb1c:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
8000bb1e:	ee f9 ff 9c 	ld.w	r9,r7[-100]
8000bb22:	30 08       	mov	r8,0
8000bb24:	f3 68 00 08 	st.b	r9[8],r8
								errorDisplayState = 1;
8000bb28:	fe f9 07 b8 	ld.w	r9,pc[1976]
8000bb2c:	30 18       	mov	r8,1
8000bb2e:	b2 88       	st.b	r9[0x0],r8
								break;
8000bb30:	e0 8f 02 2d 	bral	8000bf8a <main+0x1182>
							case 1:
								if ((ledBrdSide[LED_BRD_0_BOT].maxUsageReached || ledBrdSide[LED_BRD_1_TOP].maxUsageReached) ||
8000bb34:	fe f8 07 b4 	ld.w	r8,pc[1972]
8000bb38:	11 a8       	ld.ub	r8,r8[0x2]
8000bb3a:	58 08       	cp.w	r8,0
8000bb3c:	c2 61       	brne	8000bb88 <main+0xd80>
8000bb3e:	fe f8 07 aa 	ld.w	r8,pc[1962]
8000bb42:	11 f8       	ld.ub	r8,r8[0x7]
8000bb44:	58 08       	cp.w	r8,0
8000bb46:	c2 11       	brne	8000bb88 <main+0xd80>
									(sysErr.topdrive & BIT(0)) || (sysErr.topdrive & BIT(1)) ||
8000bb48:	fe f8 07 a4 	ld.w	r8,pc[1956]
8000bb4c:	11 88       	ld.ub	r8,r8[0x0]
8000bb4e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
								displayChanged = 1;
								cpu_set_timeout(8*EC_ONE_SECOND, &errorDisplayTimer);
								errorDisplayState = 1;
								break;
							case 1:
								if ((ledBrdSide[LED_BRD_0_BOT].maxUsageReached || ledBrdSide[LED_BRD_1_TOP].maxUsageReached) ||
8000bb52:	5c 58       	castu.b	r8
8000bb54:	c1 a1       	brne	8000bb88 <main+0xd80>
									(sysErr.topdrive & BIT(0)) || (sysErr.topdrive & BIT(1)) ||
8000bb56:	fe f8 07 96 	ld.w	r8,pc[1942]
8000bb5a:	11 88       	ld.ub	r8,r8[0x0]
8000bb5c:	e2 18 00 02 	andl	r8,0x2,COH
								displayChanged = 1;
								cpu_set_timeout(8*EC_ONE_SECOND, &errorDisplayTimer);
								errorDisplayState = 1;
								break;
							case 1:
								if ((ledBrdSide[LED_BRD_0_BOT].maxUsageReached || ledBrdSide[LED_BRD_1_TOP].maxUsageReached) ||
8000bb60:	c1 41       	brne	8000bb88 <main+0xd80>
									(sysErr.topdrive & BIT(0)) || (sysErr.topdrive & BIT(1)) ||
									(sysErr.botdrive & BIT(0)) || (sysErr.botdrive & BIT(1)) || (sysErr.botdrive & BIT(2)))
8000bb62:	fe f8 07 8a 	ld.w	r8,pc[1930]
8000bb66:	70 18       	ld.w	r8,r8[0x4]
8000bb68:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
								displayChanged = 1;
								cpu_set_timeout(8*EC_ONE_SECOND, &errorDisplayTimer);
								errorDisplayState = 1;
								break;
							case 1:
								if ((ledBrdSide[LED_BRD_0_BOT].maxUsageReached || ledBrdSide[LED_BRD_1_TOP].maxUsageReached) ||
8000bb6c:	5c 58       	castu.b	r8
8000bb6e:	c0 d1       	brne	8000bb88 <main+0xd80>
									(sysErr.topdrive & BIT(0)) || (sysErr.topdrive & BIT(1)) ||
									(sysErr.botdrive & BIT(0)) || (sysErr.botdrive & BIT(1)) || (sysErr.botdrive & BIT(2)))
8000bb70:	fe f8 07 7c 	ld.w	r8,pc[1916]
8000bb74:	70 18       	ld.w	r8,r8[0x4]
8000bb76:	e2 18 00 02 	andl	r8,0x2,COH
								displayChanged = 1;
								cpu_set_timeout(8*EC_ONE_SECOND, &errorDisplayTimer);
								errorDisplayState = 1;
								break;
							case 1:
								if ((ledBrdSide[LED_BRD_0_BOT].maxUsageReached || ledBrdSide[LED_BRD_1_TOP].maxUsageReached) ||
8000bb7a:	c0 71       	brne	8000bb88 <main+0xd80>
									(sysErr.topdrive & BIT(0)) || (sysErr.topdrive & BIT(1)) ||
									(sysErr.botdrive & BIT(0)) || (sysErr.botdrive & BIT(1)) || (sysErr.botdrive & BIT(2)))
8000bb7c:	fe f8 07 70 	ld.w	r8,pc[1904]
8000bb80:	70 18       	ld.w	r8,r8[0x4]
8000bb82:	e2 18 00 04 	andl	r8,0x4,COH
								displayChanged = 1;
								cpu_set_timeout(8*EC_ONE_SECOND, &errorDisplayTimer);
								errorDisplayState = 1;
								break;
							case 1:
								if ((ledBrdSide[LED_BRD_0_BOT].maxUsageReached || ledBrdSide[LED_BRD_1_TOP].maxUsageReached) ||
8000bb86:	c5 b0       	breq	8000bc3c <main+0xe34>
									(sysErr.topdrive & BIT(0)) || (sysErr.topdrive & BIT(1)) ||
									(sysErr.botdrive & BIT(0)) || (sysErr.botdrive & BIT(1)) || (sysErr.botdrive & BIT(2)))
								{
									display_text(IDX_SHELF1);
8000bb88:	30 5c       	mov	r12,5
8000bb8a:	f0 1f 01 a4 	mcall	8000c218 <main+0x1410>
									displayChanged = 1;
8000bb8e:	fe f9 07 56 	ld.w	r9,pc[1878]
8000bb92:	30 18       	mov	r8,1
8000bb94:	b2 88       	st.b	r9[0x0],r8
8000bb96:	e0 68 03 e8 	mov	r8,1000
8000bb9a:	ef 48 ff a8 	st.w	r7[-88],r8
8000bb9e:	e0 68 12 00 	mov	r8,4608
8000bba2:	ea 18 00 7a 	orh	r8,0x7a
8000bba6:	ef 48 ff a4 	st.w	r7[-92],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
8000bbaa:	ee fa ff a8 	ld.w	r10,r7[-88]
8000bbae:	ef 4a fe 3c 	st.w	r7[-452],r10
8000bbb2:	30 08       	mov	r8,0
8000bbb4:	ef 48 fe 38 	st.w	r7[-456],r8
8000bbb8:	ee fc ff a4 	ld.w	r12,r7[-92]
8000bbbc:	ef 4c fe 34 	st.w	r7[-460],r12
8000bbc0:	30 0a       	mov	r10,0
8000bbc2:	ef 4a fe 30 	st.w	r7[-464],r10
8000bbc6:	ee f9 fe 38 	ld.w	r9,r7[-456]
8000bbca:	ee f8 fe 34 	ld.w	r8,r7[-460]
8000bbce:	b1 39       	mul	r9,r8
8000bbd0:	ee f8 fe 30 	ld.w	r8,r7[-464]
8000bbd4:	ee fc fe 3c 	ld.w	r12,r7[-452]
8000bbd8:	b9 38       	mul	r8,r12
8000bbda:	10 09       	add	r9,r8
8000bbdc:	ee f8 fe 3c 	ld.w	r8,r7[-452]
8000bbe0:	ee fc fe 34 	ld.w	r12,r7[-460]
8000bbe4:	f0 0c 06 4a 	mulu.d	r10,r8,r12
8000bbe8:	16 09       	add	r9,r11
8000bbea:	12 9b       	mov	r11,r9
8000bbec:	e0 68 03 e7 	mov	r8,999
8000bbf0:	30 09       	mov	r9,0
8000bbf2:	10 0a       	add	r10,r8
8000bbf4:	f6 09 00 4b 	adc	r11,r11,r9
8000bbf8:	e0 68 03 e8 	mov	r8,1000
8000bbfc:	30 09       	mov	r9,0
8000bbfe:	f0 1f 01 94 	mcall	8000c24c <main+0x1444>
8000bc02:	14 98       	mov	r8,r10
8000bc04:	16 99       	mov	r9,r11
									cpu_set_timeout(8*EC_ONE_SECOND, &errorDisplayTimer);
8000bc06:	a3 78       	lsl	r8,0x3
8000bc08:	ef 48 ff b0 	st.w	r7[-80],r8
8000bc0c:	fe f8 06 d0 	ld.w	r8,pc[1744]
8000bc10:	ef 48 ff ac 	st.w	r7[-84],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000bc14:	e1 b8 00 42 	mfsr	r8,0x108
8000bc18:	10 99       	mov	r9,r8
8000bc1a:	ee f8 ff ac 	ld.w	r8,r7[-84]
8000bc1e:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000bc20:	ee f8 ff ac 	ld.w	r8,r7[-84]
8000bc24:	70 09       	ld.w	r9,r8[0x0]
8000bc26:	ee f8 ff b0 	ld.w	r8,r7[-80]
8000bc2a:	10 09       	add	r9,r8
8000bc2c:	ee f8 ff ac 	ld.w	r8,r7[-84]
8000bc30:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
8000bc32:	ee f9 ff ac 	ld.w	r9,r7[-84]
8000bc36:	30 08       	mov	r8,0
8000bc38:	f3 68 00 08 	st.b	r9[8],r8
								}
								errorDisplayState = 2;
8000bc3c:	fe f9 06 a4 	ld.w	r9,pc[1700]
8000bc40:	30 28       	mov	r8,2
8000bc42:	b2 88       	st.b	r9[0x0],r8
								break;
8000bc44:	e0 8f 01 a3 	bral	8000bf8a <main+0x1182>
							case 2:
								if ((ledBrdSide[LED_BRD_1_BOT].maxUsageReached || ledBrdSide[LED_BRD_2_TOP].maxUsageReached) ||
8000bc48:	fe f8 06 a0 	ld.w	r8,pc[1696]
8000bc4c:	f1 38 00 0c 	ld.ub	r8,r8[12]
8000bc50:	58 08       	cp.w	r8,0
8000bc52:	c2 51       	brne	8000bc9c <main+0xe94>
8000bc54:	fe f8 06 94 	ld.w	r8,pc[1684]
8000bc58:	f1 38 00 11 	ld.ub	r8,r8[17]
8000bc5c:	58 08       	cp.w	r8,0
8000bc5e:	c1 f1       	brne	8000bc9c <main+0xe94>
									(sysErr.topdrive & BIT(2)) || (sysErr.topdrive & BIT(3)) ||
8000bc60:	fe f8 06 8c 	ld.w	r8,pc[1676]
8000bc64:	11 88       	ld.ub	r8,r8[0x0]
8000bc66:	e2 18 00 04 	andl	r8,0x4,COH
									cpu_set_timeout(8*EC_ONE_SECOND, &errorDisplayTimer);
								}
								errorDisplayState = 2;
								break;
							case 2:
								if ((ledBrdSide[LED_BRD_1_BOT].maxUsageReached || ledBrdSide[LED_BRD_2_TOP].maxUsageReached) ||
8000bc6a:	c1 91       	brne	8000bc9c <main+0xe94>
									(sysErr.topdrive & BIT(2)) || (sysErr.topdrive & BIT(3)) ||
8000bc6c:	fe f8 06 80 	ld.w	r8,pc[1664]
8000bc70:	11 88       	ld.ub	r8,r8[0x0]
8000bc72:	e2 18 00 08 	andl	r8,0x8,COH
									cpu_set_timeout(8*EC_ONE_SECOND, &errorDisplayTimer);
								}
								errorDisplayState = 2;
								break;
							case 2:
								if ((ledBrdSide[LED_BRD_1_BOT].maxUsageReached || ledBrdSide[LED_BRD_2_TOP].maxUsageReached) ||
8000bc76:	c1 31       	brne	8000bc9c <main+0xe94>
									(sysErr.topdrive & BIT(2)) || (sysErr.topdrive & BIT(3)) ||
									(sysErr.botdrive & BIT(3)) || (sysErr.botdrive & BIT(4)) || (sysErr.botdrive & BIT(5)))
8000bc78:	fe f8 06 74 	ld.w	r8,pc[1652]
8000bc7c:	70 18       	ld.w	r8,r8[0x4]
8000bc7e:	e2 18 00 08 	andl	r8,0x8,COH
									cpu_set_timeout(8*EC_ONE_SECOND, &errorDisplayTimer);
								}
								errorDisplayState = 2;
								break;
							case 2:
								if ((ledBrdSide[LED_BRD_1_BOT].maxUsageReached || ledBrdSide[LED_BRD_2_TOP].maxUsageReached) ||
8000bc82:	c0 d1       	brne	8000bc9c <main+0xe94>
									(sysErr.topdrive & BIT(2)) || (sysErr.topdrive & BIT(3)) ||
									(sysErr.botdrive & BIT(3)) || (sysErr.botdrive & BIT(4)) || (sysErr.botdrive & BIT(5)))
8000bc84:	fe f8 06 68 	ld.w	r8,pc[1640]
8000bc88:	70 18       	ld.w	r8,r8[0x4]
8000bc8a:	e2 18 00 10 	andl	r8,0x10,COH
									cpu_set_timeout(8*EC_ONE_SECOND, &errorDisplayTimer);
								}
								errorDisplayState = 2;
								break;
							case 2:
								if ((ledBrdSide[LED_BRD_1_BOT].maxUsageReached || ledBrdSide[LED_BRD_2_TOP].maxUsageReached) ||
8000bc8e:	c0 71       	brne	8000bc9c <main+0xe94>
									(sysErr.topdrive & BIT(2)) || (sysErr.topdrive & BIT(3)) ||
									(sysErr.botdrive & BIT(3)) || (sysErr.botdrive & BIT(4)) || (sysErr.botdrive & BIT(5)))
8000bc90:	fe f8 06 5c 	ld.w	r8,pc[1628]
8000bc94:	70 18       	ld.w	r8,r8[0x4]
8000bc96:	e2 18 00 20 	andl	r8,0x20,COH
									cpu_set_timeout(8*EC_ONE_SECOND, &errorDisplayTimer);
								}
								errorDisplayState = 2;
								break;
							case 2:
								if ((ledBrdSide[LED_BRD_1_BOT].maxUsageReached || ledBrdSide[LED_BRD_2_TOP].maxUsageReached) ||
8000bc9a:	c5 b0       	breq	8000bd50 <main+0xf48>
									(sysErr.topdrive & BIT(2)) || (sysErr.topdrive & BIT(3)) ||
									(sysErr.botdrive & BIT(3)) || (sysErr.botdrive & BIT(4)) || (sysErr.botdrive & BIT(5)))
								{
									display_text(IDX_SHELF2);
8000bc9c:	30 6c       	mov	r12,6
8000bc9e:	f0 1f 01 5f 	mcall	8000c218 <main+0x1410>
									displayChanged = 1;
8000bca2:	fe f9 06 42 	ld.w	r9,pc[1602]
8000bca6:	30 18       	mov	r8,1
8000bca8:	b2 88       	st.b	r9[0x0],r8
8000bcaa:	e0 68 03 e8 	mov	r8,1000
8000bcae:	ef 48 ff b8 	st.w	r7[-72],r8
8000bcb2:	e0 68 12 00 	mov	r8,4608
8000bcb6:	ea 18 00 7a 	orh	r8,0x7a
8000bcba:	ef 48 ff b4 	st.w	r7[-76],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
8000bcbe:	ee fa ff b8 	ld.w	r10,r7[-72]
8000bcc2:	ef 4a fe 4c 	st.w	r7[-436],r10
8000bcc6:	30 08       	mov	r8,0
8000bcc8:	ef 48 fe 48 	st.w	r7[-440],r8
8000bccc:	ee fc ff b4 	ld.w	r12,r7[-76]
8000bcd0:	ef 4c fe 44 	st.w	r7[-444],r12
8000bcd4:	30 0a       	mov	r10,0
8000bcd6:	ef 4a fe 40 	st.w	r7[-448],r10
8000bcda:	ee f9 fe 48 	ld.w	r9,r7[-440]
8000bcde:	ee f8 fe 44 	ld.w	r8,r7[-444]
8000bce2:	b1 39       	mul	r9,r8
8000bce4:	ee f8 fe 40 	ld.w	r8,r7[-448]
8000bce8:	ee fc fe 4c 	ld.w	r12,r7[-436]
8000bcec:	b9 38       	mul	r8,r12
8000bcee:	10 09       	add	r9,r8
8000bcf0:	ee f8 fe 4c 	ld.w	r8,r7[-436]
8000bcf4:	ee fc fe 44 	ld.w	r12,r7[-444]
8000bcf8:	f0 0c 06 4a 	mulu.d	r10,r8,r12
8000bcfc:	16 09       	add	r9,r11
8000bcfe:	12 9b       	mov	r11,r9
8000bd00:	e0 68 03 e7 	mov	r8,999
8000bd04:	30 09       	mov	r9,0
8000bd06:	10 0a       	add	r10,r8
8000bd08:	f6 09 00 4b 	adc	r11,r11,r9
8000bd0c:	e0 68 03 e8 	mov	r8,1000
8000bd10:	30 09       	mov	r9,0
8000bd12:	f0 1f 01 4f 	mcall	8000c24c <main+0x1444>
8000bd16:	14 98       	mov	r8,r10
8000bd18:	16 99       	mov	r9,r11
									cpu_set_timeout(8*EC_ONE_SECOND, &errorDisplayTimer);
8000bd1a:	a3 78       	lsl	r8,0x3
8000bd1c:	ef 48 ff c0 	st.w	r7[-64],r8
8000bd20:	fe f8 05 bc 	ld.w	r8,pc[1468]
8000bd24:	ef 48 ff bc 	st.w	r7[-68],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000bd28:	e1 b8 00 42 	mfsr	r8,0x108
8000bd2c:	10 99       	mov	r9,r8
8000bd2e:	ee f8 ff bc 	ld.w	r8,r7[-68]
8000bd32:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000bd34:	ee f8 ff bc 	ld.w	r8,r7[-68]
8000bd38:	70 09       	ld.w	r9,r8[0x0]
8000bd3a:	ee f8 ff c0 	ld.w	r8,r7[-64]
8000bd3e:	10 09       	add	r9,r8
8000bd40:	ee f8 ff bc 	ld.w	r8,r7[-68]
8000bd44:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
8000bd46:	ee f9 ff bc 	ld.w	r9,r7[-68]
8000bd4a:	30 08       	mov	r8,0
8000bd4c:	f3 68 00 08 	st.b	r9[8],r8
								}
								errorDisplayState = 3;
8000bd50:	fe f9 05 90 	ld.w	r9,pc[1424]
8000bd54:	30 38       	mov	r8,3
8000bd56:	b2 88       	st.b	r9[0x0],r8
								break;
8000bd58:	c1 99       	rjmp	8000bf8a <main+0x1182>
							case 3:
								if ((ledBrdSide[LED_BRD_2_BOT].maxUsageReached || ledBrdSide[LED_BRD_3_TOP].maxUsageReached) ||
8000bd5a:	fe f8 05 8e 	ld.w	r8,pc[1422]
8000bd5e:	f1 38 00 16 	ld.ub	r8,r8[22]
8000bd62:	58 08       	cp.w	r8,0
8000bd64:	c2 51       	brne	8000bdae <main+0xfa6>
8000bd66:	fe f8 05 82 	ld.w	r8,pc[1410]
8000bd6a:	f1 38 00 1b 	ld.ub	r8,r8[27]
8000bd6e:	58 08       	cp.w	r8,0
8000bd70:	c1 f1       	brne	8000bdae <main+0xfa6>
									(sysErr.topdrive & BIT(4)) || (sysErr.topdrive & BIT(5)) ||
8000bd72:	fe f8 05 7a 	ld.w	r8,pc[1402]
8000bd76:	11 88       	ld.ub	r8,r8[0x0]
8000bd78:	e2 18 00 10 	andl	r8,0x10,COH
									cpu_set_timeout(8*EC_ONE_SECOND, &errorDisplayTimer);
								}
								errorDisplayState = 3;
								break;
							case 3:
								if ((ledBrdSide[LED_BRD_2_BOT].maxUsageReached || ledBrdSide[LED_BRD_3_TOP].maxUsageReached) ||
8000bd7c:	c1 91       	brne	8000bdae <main+0xfa6>
									(sysErr.topdrive & BIT(4)) || (sysErr.topdrive & BIT(5)) ||
8000bd7e:	fe f8 05 6e 	ld.w	r8,pc[1390]
8000bd82:	11 88       	ld.ub	r8,r8[0x0]
8000bd84:	e2 18 00 20 	andl	r8,0x20,COH
									cpu_set_timeout(8*EC_ONE_SECOND, &errorDisplayTimer);
								}
								errorDisplayState = 3;
								break;
							case 3:
								if ((ledBrdSide[LED_BRD_2_BOT].maxUsageReached || ledBrdSide[LED_BRD_3_TOP].maxUsageReached) ||
8000bd88:	c1 31       	brne	8000bdae <main+0xfa6>
									(sysErr.topdrive & BIT(4)) || (sysErr.topdrive & BIT(5)) ||
									(sysErr.botdrive & BIT(6)) || (sysErr.botdrive & BIT(7)) || (sysErr.botdrive & BIT(8)))
8000bd8a:	fe f8 05 62 	ld.w	r8,pc[1378]
8000bd8e:	70 18       	ld.w	r8,r8[0x4]
8000bd90:	e2 18 00 40 	andl	r8,0x40,COH
									cpu_set_timeout(8*EC_ONE_SECOND, &errorDisplayTimer);
								}
								errorDisplayState = 3;
								break;
							case 3:
								if ((ledBrdSide[LED_BRD_2_BOT].maxUsageReached || ledBrdSide[LED_BRD_3_TOP].maxUsageReached) ||
8000bd94:	c0 d1       	brne	8000bdae <main+0xfa6>
									(sysErr.topdrive & BIT(4)) || (sysErr.topdrive & BIT(5)) ||
									(sysErr.botdrive & BIT(6)) || (sysErr.botdrive & BIT(7)) || (sysErr.botdrive & BIT(8)))
8000bd96:	fe f8 05 56 	ld.w	r8,pc[1366]
8000bd9a:	70 18       	ld.w	r8,r8[0x4]
8000bd9c:	e2 18 00 80 	andl	r8,0x80,COH
									cpu_set_timeout(8*EC_ONE_SECOND, &errorDisplayTimer);
								}
								errorDisplayState = 3;
								break;
							case 3:
								if ((ledBrdSide[LED_BRD_2_BOT].maxUsageReached || ledBrdSide[LED_BRD_3_TOP].maxUsageReached) ||
8000bda0:	c0 71       	brne	8000bdae <main+0xfa6>
									(sysErr.topdrive & BIT(4)) || (sysErr.topdrive & BIT(5)) ||
									(sysErr.botdrive & BIT(6)) || (sysErr.botdrive & BIT(7)) || (sysErr.botdrive & BIT(8)))
8000bda2:	fe f8 05 4a 	ld.w	r8,pc[1354]
8000bda6:	70 18       	ld.w	r8,r8[0x4]
8000bda8:	e2 18 01 00 	andl	r8,0x100,COH
									cpu_set_timeout(8*EC_ONE_SECOND, &errorDisplayTimer);
								}
								errorDisplayState = 3;
								break;
							case 3:
								if ((ledBrdSide[LED_BRD_2_BOT].maxUsageReached || ledBrdSide[LED_BRD_3_TOP].maxUsageReached) ||
8000bdac:	c5 b0       	breq	8000be62 <main+0x105a>
									(sysErr.topdrive & BIT(4)) || (sysErr.topdrive & BIT(5)) ||
									(sysErr.botdrive & BIT(6)) || (sysErr.botdrive & BIT(7)) || (sysErr.botdrive & BIT(8)))
								{
									display_text(IDX_SHELF3);
8000bdae:	30 7c       	mov	r12,7
8000bdb0:	f0 1f 01 1a 	mcall	8000c218 <main+0x1410>
									displayChanged = 1;
8000bdb4:	fe f9 05 30 	ld.w	r9,pc[1328]
8000bdb8:	30 18       	mov	r8,1
8000bdba:	b2 88       	st.b	r9[0x0],r8
8000bdbc:	e0 68 03 e8 	mov	r8,1000
8000bdc0:	ef 48 ff c8 	st.w	r7[-56],r8
8000bdc4:	e0 68 12 00 	mov	r8,4608
8000bdc8:	ea 18 00 7a 	orh	r8,0x7a
8000bdcc:	ef 48 ff c4 	st.w	r7[-60],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
8000bdd0:	ee fa ff c8 	ld.w	r10,r7[-56]
8000bdd4:	ef 4a fe 5c 	st.w	r7[-420],r10
8000bdd8:	30 08       	mov	r8,0
8000bdda:	ef 48 fe 58 	st.w	r7[-424],r8
8000bdde:	ee fc ff c4 	ld.w	r12,r7[-60]
8000bde2:	ef 4c fe 54 	st.w	r7[-428],r12
8000bde6:	30 0a       	mov	r10,0
8000bde8:	ef 4a fe 50 	st.w	r7[-432],r10
8000bdec:	ee f9 fe 58 	ld.w	r9,r7[-424]
8000bdf0:	ee f8 fe 54 	ld.w	r8,r7[-428]
8000bdf4:	b1 39       	mul	r9,r8
8000bdf6:	ee f8 fe 50 	ld.w	r8,r7[-432]
8000bdfa:	ee fc fe 5c 	ld.w	r12,r7[-420]
8000bdfe:	b9 38       	mul	r8,r12
8000be00:	10 09       	add	r9,r8
8000be02:	ee f8 fe 5c 	ld.w	r8,r7[-420]
8000be06:	ee fc fe 54 	ld.w	r12,r7[-428]
8000be0a:	f0 0c 06 4a 	mulu.d	r10,r8,r12
8000be0e:	16 09       	add	r9,r11
8000be10:	12 9b       	mov	r11,r9
8000be12:	e0 68 03 e7 	mov	r8,999
8000be16:	30 09       	mov	r9,0
8000be18:	10 0a       	add	r10,r8
8000be1a:	f6 09 00 4b 	adc	r11,r11,r9
8000be1e:	e0 68 03 e8 	mov	r8,1000
8000be22:	30 09       	mov	r9,0
8000be24:	f0 1f 01 0a 	mcall	8000c24c <main+0x1444>
8000be28:	14 98       	mov	r8,r10
8000be2a:	16 99       	mov	r9,r11
									cpu_set_timeout(8*EC_ONE_SECOND, &errorDisplayTimer);
8000be2c:	a3 78       	lsl	r8,0x3
8000be2e:	ef 48 ff d0 	st.w	r7[-48],r8
8000be32:	fe f8 04 aa 	ld.w	r8,pc[1194]
8000be36:	ef 48 ff cc 	st.w	r7[-52],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000be3a:	e1 b8 00 42 	mfsr	r8,0x108
8000be3e:	10 99       	mov	r9,r8
8000be40:	ee f8 ff cc 	ld.w	r8,r7[-52]
8000be44:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000be46:	ee f8 ff cc 	ld.w	r8,r7[-52]
8000be4a:	70 09       	ld.w	r9,r8[0x0]
8000be4c:	ee f8 ff d0 	ld.w	r8,r7[-48]
8000be50:	10 09       	add	r9,r8
8000be52:	ee f8 ff cc 	ld.w	r8,r7[-52]
8000be56:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
8000be58:	ee f9 ff cc 	ld.w	r9,r7[-52]
8000be5c:	30 08       	mov	r8,0
8000be5e:	f3 68 00 08 	st.b	r9[8],r8
								}
								errorDisplayState = 4;
8000be62:	fe f9 04 7e 	ld.w	r9,pc[1150]
8000be66:	30 48       	mov	r8,4
8000be68:	b2 88       	st.b	r9[0x0],r8
								break;
8000be6a:	c9 08       	rjmp	8000bf8a <main+0x1182>
							case 4:
								if ((ledBrdSide[LED_BRD_3_BOT].maxUsageReached || ledBrdSide[LED_BRD_4_TOP].maxUsageReached) ||
8000be6c:	fe f8 04 7c 	ld.w	r8,pc[1148]
8000be70:	f1 38 00 20 	ld.ub	r8,r8[32]
8000be74:	58 08       	cp.w	r8,0
8000be76:	c2 71       	brne	8000bec4 <main+0x10bc>
8000be78:	fe f8 04 70 	ld.w	r8,pc[1136]
8000be7c:	f1 38 00 25 	ld.ub	r8,r8[37]
8000be80:	58 08       	cp.w	r8,0
8000be82:	c2 11       	brne	8000bec4 <main+0x10bc>
									(sysErr.topdrive & BIT(6)) || (sysErr.topdrive & BIT(7)) ||
8000be84:	fe f8 04 68 	ld.w	r8,pc[1128]
8000be88:	11 88       	ld.ub	r8,r8[0x0]
8000be8a:	e2 18 00 40 	andl	r8,0x40,COH
									cpu_set_timeout(8*EC_ONE_SECOND, &errorDisplayTimer);
								}
								errorDisplayState = 4;
								break;
							case 4:
								if ((ledBrdSide[LED_BRD_3_BOT].maxUsageReached || ledBrdSide[LED_BRD_4_TOP].maxUsageReached) ||
8000be8e:	c1 b1       	brne	8000bec4 <main+0x10bc>
									(sysErr.topdrive & BIT(6)) || (sysErr.topdrive & BIT(7)) ||
8000be90:	fe f8 04 5c 	ld.w	r8,pc[1116]
8000be94:	11 88       	ld.ub	r8,r8[0x0]
8000be96:	10 99       	mov	r9,r8
									cpu_set_timeout(8*EC_ONE_SECOND, &errorDisplayTimer);
								}
								errorDisplayState = 4;
								break;
							case 4:
								if ((ledBrdSide[LED_BRD_3_BOT].maxUsageReached || ledBrdSide[LED_BRD_4_TOP].maxUsageReached) ||
8000be98:	30 08       	mov	r8,0
8000be9a:	f0 09 18 00 	cp.b	r9,r8
8000be9e:	c1 35       	brlt	8000bec4 <main+0x10bc>
									(sysErr.topdrive & BIT(6)) || (sysErr.topdrive & BIT(7)) ||
									(sysErr.botdrive & BIT(9)) || (sysErr.botdrive & BIT(10)) || (sysErr.botdrive & BIT(11)))
8000bea0:	fe f8 04 4c 	ld.w	r8,pc[1100]
8000bea4:	70 18       	ld.w	r8,r8[0x4]
8000bea6:	e2 18 02 00 	andl	r8,0x200,COH
									cpu_set_timeout(8*EC_ONE_SECOND, &errorDisplayTimer);
								}
								errorDisplayState = 4;
								break;
							case 4:
								if ((ledBrdSide[LED_BRD_3_BOT].maxUsageReached || ledBrdSide[LED_BRD_4_TOP].maxUsageReached) ||
8000beaa:	c0 d1       	brne	8000bec4 <main+0x10bc>
									(sysErr.topdrive & BIT(6)) || (sysErr.topdrive & BIT(7)) ||
									(sysErr.botdrive & BIT(9)) || (sysErr.botdrive & BIT(10)) || (sysErr.botdrive & BIT(11)))
8000beac:	fe f8 04 40 	ld.w	r8,pc[1088]
8000beb0:	70 18       	ld.w	r8,r8[0x4]
8000beb2:	e2 18 04 00 	andl	r8,0x400,COH
									cpu_set_timeout(8*EC_ONE_SECOND, &errorDisplayTimer);
								}
								errorDisplayState = 4;
								break;
							case 4:
								if ((ledBrdSide[LED_BRD_3_BOT].maxUsageReached || ledBrdSide[LED_BRD_4_TOP].maxUsageReached) ||
8000beb6:	c0 71       	brne	8000bec4 <main+0x10bc>
									(sysErr.topdrive & BIT(6)) || (sysErr.topdrive & BIT(7)) ||
									(sysErr.botdrive & BIT(9)) || (sysErr.botdrive & BIT(10)) || (sysErr.botdrive & BIT(11)))
8000beb8:	fe f8 04 34 	ld.w	r8,pc[1076]
8000bebc:	70 18       	ld.w	r8,r8[0x4]
8000bebe:	e2 18 08 00 	andl	r8,0x800,COH
									cpu_set_timeout(8*EC_ONE_SECOND, &errorDisplayTimer);
								}
								errorDisplayState = 4;
								break;
							case 4:
								if ((ledBrdSide[LED_BRD_3_BOT].maxUsageReached || ledBrdSide[LED_BRD_4_TOP].maxUsageReached) ||
8000bec2:	c5 b0       	breq	8000bf78 <main+0x1170>
									(sysErr.topdrive & BIT(6)) || (sysErr.topdrive & BIT(7)) ||
									(sysErr.botdrive & BIT(9)) || (sysErr.botdrive & BIT(10)) || (sysErr.botdrive & BIT(11)))
								{
									display_text(IDX_SHELF4);
8000bec4:	30 8c       	mov	r12,8
8000bec6:	f0 1f 00 d5 	mcall	8000c218 <main+0x1410>
									displayChanged = 1;
8000beca:	fe f9 04 1a 	ld.w	r9,pc[1050]
8000bece:	30 18       	mov	r8,1
8000bed0:	b2 88       	st.b	r9[0x0],r8
8000bed2:	e0 68 03 e8 	mov	r8,1000
8000bed6:	ef 48 ff d8 	st.w	r7[-40],r8
8000beda:	e0 68 12 00 	mov	r8,4608
8000bede:	ea 18 00 7a 	orh	r8,0x7a
8000bee2:	ef 48 ff d4 	st.w	r7[-44],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
8000bee6:	ee fa ff d8 	ld.w	r10,r7[-40]
8000beea:	ef 4a fe 6c 	st.w	r7[-404],r10
8000beee:	30 08       	mov	r8,0
8000bef0:	ef 48 fe 68 	st.w	r7[-408],r8
8000bef4:	ee fc ff d4 	ld.w	r12,r7[-44]
8000bef8:	ef 4c fe 64 	st.w	r7[-412],r12
8000befc:	30 0a       	mov	r10,0
8000befe:	ef 4a fe 60 	st.w	r7[-416],r10
8000bf02:	ee f9 fe 68 	ld.w	r9,r7[-408]
8000bf06:	ee f8 fe 64 	ld.w	r8,r7[-412]
8000bf0a:	b1 39       	mul	r9,r8
8000bf0c:	ee f8 fe 60 	ld.w	r8,r7[-416]
8000bf10:	ee fc fe 6c 	ld.w	r12,r7[-404]
8000bf14:	b9 38       	mul	r8,r12
8000bf16:	10 09       	add	r9,r8
8000bf18:	ee f8 fe 6c 	ld.w	r8,r7[-404]
8000bf1c:	ee fc fe 64 	ld.w	r12,r7[-412]
8000bf20:	f0 0c 06 4a 	mulu.d	r10,r8,r12
8000bf24:	16 09       	add	r9,r11
8000bf26:	12 9b       	mov	r11,r9
8000bf28:	e0 68 03 e7 	mov	r8,999
8000bf2c:	30 09       	mov	r9,0
8000bf2e:	10 0a       	add	r10,r8
8000bf30:	f6 09 00 4b 	adc	r11,r11,r9
8000bf34:	e0 68 03 e8 	mov	r8,1000
8000bf38:	30 09       	mov	r9,0
8000bf3a:	f0 1f 00 c5 	mcall	8000c24c <main+0x1444>
8000bf3e:	14 98       	mov	r8,r10
8000bf40:	16 99       	mov	r9,r11
									cpu_set_timeout(8*EC_ONE_SECOND, &errorDisplayTimer);
8000bf42:	a3 78       	lsl	r8,0x3
8000bf44:	ef 48 ff e0 	st.w	r7[-32],r8
8000bf48:	fe f8 03 94 	ld.w	r8,pc[916]
8000bf4c:	ef 48 ff dc 	st.w	r7[-36],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000bf50:	e1 b8 00 42 	mfsr	r8,0x108
8000bf54:	10 99       	mov	r9,r8
8000bf56:	ee f8 ff dc 	ld.w	r8,r7[-36]
8000bf5a:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000bf5c:	ee f8 ff dc 	ld.w	r8,r7[-36]
8000bf60:	70 09       	ld.w	r9,r8[0x0]
8000bf62:	ee f8 ff e0 	ld.w	r8,r7[-32]
8000bf66:	10 09       	add	r9,r8
8000bf68:	ee f8 ff dc 	ld.w	r8,r7[-36]
8000bf6c:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
8000bf6e:	ee f9 ff dc 	ld.w	r9,r7[-36]
8000bf72:	30 08       	mov	r8,0
8000bf74:	f3 68 00 08 	st.b	r9[8],r8
								}
								errorDisplayState = 0;
8000bf78:	fe f9 03 68 	ld.w	r9,pc[872]
8000bf7c:	30 08       	mov	r8,0
8000bf7e:	b2 88       	st.b	r9[0x0],r8
								break;
8000bf80:	c0 58       	rjmp	8000bf8a <main+0x1182>
							default:
								errorDisplayState = 0;
8000bf82:	fe f9 03 5e 	ld.w	r9,pc[862]
8000bf86:	30 08       	mov	r8,0
8000bf88:	b2 88       	st.b	r9[0x0],r8
								break;
						} //switch(errorDisplayState)
						
						if (displayChanged)
8000bf8a:	fe f8 03 5a 	ld.w	r8,pc[858]
8000bf8e:	11 88       	ld.ub	r8,r8[0x0]
8000bf90:	58 08       	cp.w	r8,0
8000bf92:	fe 90 fd 5a 	breq	8000ba46 <main+0xc3e>
						{
							displayChanged = 0;
8000bf96:	fe f9 03 4e 	ld.w	r9,pc[846]
8000bf9a:	30 08       	mov	r8,0
8000bf9c:	b2 88       	st.b	r9[0x0],r8
							break; //get out of while loop and wait until we need to update the display again
8000bf9e:	d7 03       	nop
						}
						
					} //while(1)

				} //if (cpu_is_timeout(&errorDisplayTimer))
				break;
8000bfa0:	c2 68       	rjmp	8000bfec <main+0x11e4>
				
			case STATE_SHUTDOWN_PROCESSES:
				//Shutdown all processes that could harm the user or equipment if the door is open
				for (int i=0; i< NUM_SHELVES; i++)
8000bfa2:	30 08       	mov	r8,0
8000bfa4:	ef 48 fe dc 	st.w	r7[-292],r8
8000bfa8:	c0 d8       	rjmp	8000bfc2 <main+0x11ba>
				{
					led_shelf(i, LED_OFF); //turn off every shelf. (doesn't hurt to make sure that even non-active shelves are off.)
8000bfaa:	ee f8 fe dc 	ld.w	r8,r7[-292]
8000bfae:	5c 58       	castu.b	r8
8000bfb0:	30 0b       	mov	r11,0
8000bfb2:	10 9c       	mov	r12,r8
8000bfb4:	f0 1f 00 c1 	mcall	8000c2b8 <main+0x14b0>
				} //if (cpu_is_timeout(&errorDisplayTimer))
				break;
				
			case STATE_SHUTDOWN_PROCESSES:
				//Shutdown all processes that could harm the user or equipment if the door is open
				for (int i=0; i< NUM_SHELVES; i++)
8000bfb8:	ee f8 fe dc 	ld.w	r8,r7[-292]
8000bfbc:	2f f8       	sub	r8,-1
8000bfbe:	ef 48 fe dc 	st.w	r7[-292],r8
8000bfc2:	ee f8 fe dc 	ld.w	r8,r7[-292]
8000bfc6:	58 38       	cp.w	r8,3
8000bfc8:	fe 9a ff f1 	brle	8000bfaa <main+0x11a2>
				{
					led_shelf(i, LED_OFF); //turn off every shelf. (doesn't hurt to make sure that even non-active shelves are off.)
				}
				electroclaveState = STATE_EC_IDLE;
8000bfcc:	fe f9 02 8c 	ld.w	r9,pc[652]
8000bfd0:	30 08       	mov	r8,0
8000bfd2:	b2 88       	st.b	r9[0x0],r8
8000bfd4:	c0 c8       	rjmp	8000bfec <main+0x11e4>
//					display_text(IDX_CLEAR);
					display_text(IDX_READY);
					electroclaveState = STATE_DOOR_LATCHED;
					firstDoorOpenSinceIdle = 1;
				}
				break;
8000bfd6:	d7 03       	nop
8000bfd8:	c0 a8       	rjmp	8000bfec <main+0x11e4>
			case STATE_DOOR_LATCHED:
				if (!EC_ACTION_PB) {
					print_ecdbg("Action push button press detected\r\n");
					electroclaveState = STATE_ACTION_PB_PRESSED;
				}
				break;
8000bfda:	d7 03       	nop
8000bfdc:	c0 88       	rjmp	8000bfec <main+0x11e4>
				if (EC_ACTION_PB)
				{
					print_ecdbg("Action push button release detected\r\n");
					electroclaveState = STATE_ACTION_PB_RELEASED;	
				}
				break;
8000bfde:	d7 03       	nop
8000bfe0:	c0 68       	rjmp	8000bfec <main+0x11e4>
					}
					cpu_stop_timeout(&sanitizeTimer);
					print_ecdbg("Shelf clean\r\n");
					electroclaveState = STATE_START_CLEAN;
				}
				break;
8000bfe2:	d7 03       	nop
8000bfe4:	c0 48       	rjmp	8000bfec <main+0x11e4>
			case STATE_CLEAN:
				if (cpu_is_timeout(&cleanTimer)) {
					cpu_stop_timeout(&cleanTimer);
					electroclaveState = STATE_ACTION_PB_RELEASED;	
				}
				break;
8000bfe6:	d7 03       	nop
8000bfe8:	c0 28       	rjmp	8000bfec <main+0x11e4>
						}
						
					} //while(1)

				} //if (cpu_is_timeout(&errorDisplayTimer))
				break;
8000bfea:	d7 03       	nop
		
		/*
		 * This check overrides everything going on in the state machine, if the user opens the door,
		 * shut down all processes for safety
		 */
		if (!EC_DOOR_LATCHED) {
8000bfec:	33 ec       	mov	r12,62
8000bfee:	f0 1f 00 9d 	mcall	8000c260 <main+0x1458>
8000bff2:	18 98       	mov	r8,r12
8000bff4:	58 08       	cp.w	r8,0
8000bff6:	c4 00       	breq	8000c076 <main+0x126e>
		
			if (firstDoorOpenSinceIdle)
8000bff8:	fe f8 02 78 	ld.w	r8,pc[632]
8000bffc:	11 88       	ld.ub	r8,r8[0x0]
8000bffe:	58 08       	cp.w	r8,0
8000c000:	c3 b0       	breq	8000c076 <main+0x126e>
			{
				door_latch_open_kill_all_shelves();
8000c002:	f0 1f 00 bc 	mcall	8000c2f0 <main+0x14e8>

//13jun15				display_text(IDX_CLEAR);
//13jun15				cpu_delay_ms(500, EC_CPU_CLOCK_FREQ);
				switch (electroclaveState)
8000c006:	fe f8 02 52 	ld.w	r8,pc[594]
8000c00a:	11 88       	ld.ub	r8,r8[0x0]
8000c00c:	58 78       	cp.w	r8,7
8000c00e:	e0 89 00 07 	brgt	8000c01c <main+0x1214>
8000c012:	58 68       	cp.w	r8,6
8000c014:	c1 34       	brge	8000c03a <main+0x1232>
8000c016:	58 48       	cp.w	r8,4
8000c018:	c2 15       	brlt	8000c05a <main+0x1252>
8000c01a:	c0 48       	rjmp	8000c022 <main+0x121a>
8000c01c:	58 88       	cp.w	r8,8
8000c01e:	c1 a0       	breq	8000c052 <main+0x124a>
8000c020:	c1 d8       	rjmp	8000c05a <main+0x1252>
				{
					case STATE_START_SANITIZE:
					case STATE_SANITIZE:
						display_text(IDX_DIRTY);
8000c022:	30 3c       	mov	r12,3
8000c024:	f0 1f 00 7d 	mcall	8000c218 <main+0x1410>
						electroclaveState = STATE_SHUTDOWN_PROCESSES;
8000c028:	fe f9 02 30 	ld.w	r9,pc[560]
8000c02c:	30 98       	mov	r8,9
8000c02e:	b2 88       	st.b	r9[0x0],r8
						print_ecdbg("Door latch opened, shutting down all processes\r\n");
8000c030:	fe fc 02 c4 	ld.w	r12,pc[708]
8000c034:	f0 1f 00 8d 	mcall	8000c268 <main+0x1460>
						break;
8000c038:	c1 b8       	rjmp	8000c06e <main+0x1266>
						
					case STATE_START_CLEAN:
					case STATE_CLEAN:
						display_text(IDX_CLEAN);
8000c03a:	30 1c       	mov	r12,1
8000c03c:	f0 1f 00 77 	mcall	8000c218 <main+0x1410>
						electroclaveState = STATE_SHUTDOWN_PROCESSES;
8000c040:	fe f9 02 18 	ld.w	r9,pc[536]
8000c044:	30 98       	mov	r8,9
8000c046:	b2 88       	st.b	r9[0x0],r8
						print_ecdbg("Door latch opened, shutting down all processes\r\n");
8000c048:	fe fc 02 ac 	ld.w	r12,pc[684]
8000c04c:	f0 1f 00 87 	mcall	8000c268 <main+0x1460>
						break;
8000c050:	c0 f8       	rjmp	8000c06e <main+0x1266>
						
					case STATE_CHASSIS_ERROR:
						display_text(IDX_ERROR);
8000c052:	30 4c       	mov	r12,4
8000c054:	f0 1f 00 71 	mcall	8000c218 <main+0x1410>
						break;
8000c058:	c0 b8       	rjmp	8000c06e <main+0x1266>
					
					default:
						display_text(IDX_READY);
8000c05a:	30 0c       	mov	r12,0
8000c05c:	f0 1f 00 6f 	mcall	8000c218 <main+0x1410>
						electroclaveState = STATE_SHUTDOWN_PROCESSES;
8000c060:	4f e9       	lddpc	r9,8000c258 <main+0x1450>
8000c062:	30 98       	mov	r8,9
8000c064:	b2 88       	st.b	r9[0x0],r8
						print_ecdbg("Door latch opened, shutting down all processes\r\n");
8000c066:	fe fc 02 8e 	ld.w	r12,pc[654]
8000c06a:	f0 1f 00 80 	mcall	8000c268 <main+0x1460>
						break;
				}

				firstDoorOpenSinceIdle = 0;
8000c06e:	fe f9 02 02 	ld.w	r9,pc[514]
8000c072:	30 08       	mov	r8,0
8000c074:	b2 88       	st.b	r9[0x0],r8
8000c076:	4f 78       	lddpc	r8,8000c250 <main+0x1448>
8000c078:	ef 48 ff e4 	st.w	r7[-28],r8
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000c07c:	e1 b8 00 42 	mfsr	r8,0x108
8000c080:	ef 48 ff e8 	st.w	r7[-24],r8

  if( cpu_time->timer_state==CPU_TIMER_STATE_STOPPED )
8000c084:	ee f8 ff e4 	ld.w	r8,r7[-28]
8000c088:	f1 39 00 08 	ld.ub	r9,r8[8]
8000c08c:	30 28       	mov	r8,2
8000c08e:	f0 09 18 00 	cp.b	r9,r8
8000c092:	c0 31       	brne	8000c098 <main+0x1290>
    return false;
8000c094:	30 08       	mov	r8,0
8000c096:	c4 38       	rjmp	8000c11c <main+0x1314>

  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
8000c098:	ee f8 ff e4 	ld.w	r8,r7[-28]
8000c09c:	f1 39 00 08 	ld.ub	r9,r8[8]
8000c0a0:	30 18       	mov	r8,1
8000c0a2:	f0 09 18 00 	cp.b	r9,r8
8000c0a6:	c0 31       	brne	8000c0ac <main+0x12a4>
    return true;
8000c0a8:	30 18       	mov	r8,1
8000c0aa:	c3 98       	rjmp	8000c11c <main+0x1314>

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000c0ac:	ee f8 ff e4 	ld.w	r8,r7[-28]
8000c0b0:	70 09       	ld.w	r9,r8[0x0]
8000c0b2:	ee f8 ff e4 	ld.w	r8,r7[-28]
8000c0b6:	70 18       	ld.w	r8,r8[0x4]
8000c0b8:	10 39       	cp.w	r9,r8
8000c0ba:	e0 88 00 1a 	brls	8000c0ee <main+0x12e6>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000c0be:	ee f8 ff e4 	ld.w	r8,r7[-28]
8000c0c2:	70 09       	ld.w	r9,r8[0x0]
8000c0c4:	ee f8 ff e8 	ld.w	r8,r7[-24]
8000c0c8:	12 38       	cp.w	r8,r9
8000c0ca:	c1 02       	brcc	8000c0ea <main+0x12e2>
8000c0cc:	ee f8 ff e4 	ld.w	r8,r7[-28]
8000c0d0:	70 19       	ld.w	r9,r8[0x4]
8000c0d2:	ee f8 ff e8 	ld.w	r8,r7[-24]
8000c0d6:	12 38       	cp.w	r8,r9
8000c0d8:	e0 88 00 09 	brls	8000c0ea <main+0x12e2>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
8000c0dc:	ee f9 ff e4 	ld.w	r9,r7[-28]
8000c0e0:	30 18       	mov	r8,1
8000c0e2:	f3 68 00 08 	st.b	r9[8],r8
      return true;
8000c0e6:	30 18       	mov	r8,1
8000c0e8:	c1 a8       	rjmp	8000c11c <main+0x1314>
    }
    return false;
8000c0ea:	30 08       	mov	r8,0
8000c0ec:	c1 88       	rjmp	8000c11c <main+0x1314>
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000c0ee:	ee f8 ff e4 	ld.w	r8,r7[-28]
8000c0f2:	70 09       	ld.w	r9,r8[0x0]
8000c0f4:	ee f8 ff e8 	ld.w	r8,r7[-24]
8000c0f8:	12 38       	cp.w	r8,r9
8000c0fa:	c0 93       	brcs	8000c10c <main+0x1304>
8000c0fc:	ee f8 ff e4 	ld.w	r8,r7[-28]
8000c100:	70 19       	ld.w	r9,r8[0x4]
8000c102:	ee f8 ff e8 	ld.w	r8,r7[-24]
8000c106:	12 38       	cp.w	r8,r9
8000c108:	e0 88 00 09 	brls	8000c11a <main+0x1312>
    {
      cpu_time->timer_state = CPU_TIMER_STATE_REACHED;
8000c10c:	ee f9 ff e4 	ld.w	r9,r7[-28]
8000c110:	30 18       	mov	r8,1
8000c112:	f3 68 00 08 	st.b	r9[8],r8
      return true;
8000c116:	30 18       	mov	r8,1
8000c118:	c0 28       	rjmp	8000c11c <main+0x1314>
    }
    return false;
8000c11a:	30 08       	mov	r8,0
				
			}
		} //if (!EC_DOOR_LATCHED)
		
		if (cpu_is_timeout(&debugTimer))
8000c11c:	58 08       	cp.w	r8,0
8000c11e:	c5 e0       	breq	8000c1da <main+0x13d2>
8000c120:	4c c8       	lddpc	r8,8000c250 <main+0x1448>
8000c122:	ef 48 ff ec 	st.w	r7[-20],r8
 *
 * \param  cpu_time:   (input) internal information used by the timer API.
 */
__always_inline static void cpu_stop_timeout(t_cpu_time *cpu_time)
{
  cpu_time->timer_state = CPU_TIMER_STATE_STOPPED;
8000c126:	ee f9 ff ec 	ld.w	r9,r7[-20]
8000c12a:	30 28       	mov	r8,2
8000c12c:	f3 68 00 08 	st.b	r9[8],r8
8000c130:	e0 68 03 e8 	mov	r8,1000
8000c134:	ef 48 ff f4 	st.w	r7[-12],r8
8000c138:	e0 68 12 00 	mov	r8,4608
8000c13c:	ea 18 00 7a 	orh	r8,0x7a
8000c140:	ef 48 ff f0 	st.w	r7[-16],r8
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
8000c144:	ee fa ff f4 	ld.w	r10,r7[-12]
8000c148:	ef 4a fe 7c 	st.w	r7[-388],r10
8000c14c:	30 08       	mov	r8,0
8000c14e:	ef 48 fe 78 	st.w	r7[-392],r8
8000c152:	ee fc ff f0 	ld.w	r12,r7[-16]
8000c156:	ef 4c fe 74 	st.w	r7[-396],r12
8000c15a:	30 0a       	mov	r10,0
8000c15c:	ef 4a fe 70 	st.w	r7[-400],r10
8000c160:	ee f9 fe 78 	ld.w	r9,r7[-392]
8000c164:	ee f8 fe 74 	ld.w	r8,r7[-396]
8000c168:	b1 39       	mul	r9,r8
8000c16a:	ee f8 fe 70 	ld.w	r8,r7[-400]
8000c16e:	ee fc fe 7c 	ld.w	r12,r7[-388]
8000c172:	b9 38       	mul	r8,r12
8000c174:	10 09       	add	r9,r8
8000c176:	ee f8 fe 7c 	ld.w	r8,r7[-388]
8000c17a:	ee fc fe 74 	ld.w	r12,r7[-396]
8000c17e:	f0 0c 06 4a 	mulu.d	r10,r8,r12
8000c182:	16 09       	add	r9,r11
8000c184:	12 9b       	mov	r11,r9
8000c186:	e0 68 03 e7 	mov	r8,999
8000c18a:	30 09       	mov	r9,0
8000c18c:	10 0a       	add	r10,r8
8000c18e:	f6 09 00 4b 	adc	r11,r11,r9
8000c192:	e0 68 03 e8 	mov	r8,1000
8000c196:	30 09       	mov	r9,0
8000c198:	f0 1f 00 2d 	mcall	8000c24c <main+0x1444>
8000c19c:	14 98       	mov	r8,r10
8000c19e:	16 99       	mov	r9,r11
		{
			cpu_stop_timeout(&debugTimer);
			cpu_set_timeout((EC_ONE_SECOND/2), &debugTimer);
8000c1a0:	a1 98       	lsr	r8,0x1
8000c1a2:	ef 48 ff fc 	st.w	r7[-4],r8
8000c1a6:	4a b8       	lddpc	r8,8000c250 <main+0x1448>
8000c1a8:	ef 48 ff f8 	st.w	r7[-8],r8
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000c1ac:	e1 b8 00 42 	mfsr	r8,0x108
8000c1b0:	10 99       	mov	r9,r8
8000c1b2:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000c1b6:	91 09       	st.w	r8[0x0],r9
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000c1b8:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000c1bc:	70 09       	ld.w	r9,r8[0x0]
8000c1be:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000c1c2:	10 09       	add	r9,r8
8000c1c4:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000c1c8:	91 19       	st.w	r8[0x4],r9
  cpu_time->timer_state       = CPU_TIMER_STATE_STARTED;
8000c1ca:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000c1ce:	30 08       	mov	r8,0
8000c1d0:	f3 68 00 08 	st.b	r9[8],r8
			gpio_toggle_pin(ECLAVE_DEBUG_LED);
8000c1d4:	37 cc       	mov	r12,124
8000c1d6:	f0 1f 00 49 	mcall	8000c2f8 <main+0x14f0>
		}
		
		service_ecdbg_input();
8000c1da:	f0 1f 00 49 	mcall	8000c2fc <main+0x14f4>

	} //while(true)
8000c1de:	fe 9f f6 fc 	bral	8000afd6 <main+0x1ce>
8000c1e2:	00 00       	add	r0,r0
8000c1e4:	80 00       	ld.sh	r0,r0[0x0]
8000c1e6:	83 a0       	st.w	r1[0x28],r0
8000c1e8:	80 00       	ld.sh	r0,r0[0x0]
8000c1ea:	72 8c       	ld.w	r12,r9[0x20]
8000c1ec:	80 00       	ld.sh	r0,r0[0x0]
8000c1ee:	71 f8       	ld.w	r8,r8[0x7c]
8000c1f0:	80 00       	ld.sh	r0,r0[0x0]
8000c1f2:	9b 88       	st.w	sp[0x20],r8
8000c1f4:	80 00       	ld.sh	r0,r0[0x0]
8000c1f6:	73 8c       	ld.w	r12,r9[0x60]
8000c1f8:	80 00       	ld.sh	r0,r0[0x0]
8000c1fa:	6f 28       	ld.w	r8,r7[0x48]
8000c1fc:	80 00       	ld.sh	r0,r0[0x0]
8000c1fe:	70 60       	ld.w	r0,r8[0x18]
8000c200:	80 00       	ld.sh	r0,r0[0x0]
8000c202:	5d f0       	*unknown*
8000c204:	80 00       	ld.sh	r0,r0[0x0]
8000c206:	5c f0       	rol	r0
8000c208:	80 00       	ld.sh	r0,r0[0x0]
8000c20a:	5c 38       	neg	r8
8000c20c:	80 00       	ld.sh	r0,r0[0x0]
8000c20e:	32 38       	mov	r8,35
8000c210:	80 00       	ld.sh	r0,r0[0x0]
8000c212:	32 5c       	mov	r12,37
8000c214:	80 00       	ld.sh	r0,r0[0x0]
8000c216:	a0 f0       	st.b	r0[0x7],r0
8000c218:	80 00       	ld.sh	r0,r0[0x0]
8000c21a:	72 14       	ld.w	r4,r9[0x4]
8000c21c:	80 00       	ld.sh	r0,r0[0x0]
8000c21e:	84 00       	ld.sh	r0,r2[0x0]
8000c220:	80 00       	ld.sh	r0,r0[0x0]
8000c222:	4c 3c       	lddpc	r12,8000c32c <__avr32_f64_mul+0x2c>
8000c224:	80 00       	ld.sh	r0,r0[0x0]
8000c226:	84 4c       	ld.sh	r12,r2[0x8]
8000c228:	80 00       	ld.sh	r0,r0[0x0]
8000c22a:	4b 02       	lddpc	r2,8000c2e8 <main+0x14e0>
8000c22c:	80 00       	ld.sh	r0,r0[0x0]
8000c22e:	60 f0       	ld.w	r0,r0[0x3c]
8000c230:	80 00       	ld.sh	r0,r0[0x0]
8000c232:	7e 60       	ld.w	r0,pc[0x18]
8000c234:	80 00       	ld.sh	r0,r0[0x0]
8000c236:	9e 7c       	ld.sh	r12,pc[0xe]
8000c238:	80 00       	ld.sh	r0,r0[0x0]
8000c23a:	a1 1c       	ld.d	r12,--r0
8000c23c:	80 00       	ld.sh	r0,r0[0x0]
8000c23e:	a5 9c       	lsr	r12,0x5
8000c240:	80 00       	ld.sh	r0,r0[0x0]
8000c242:	a9 5c       	asr	r12,0x9
8000c244:	80 00       	ld.sh	r0,r0[0x0]
8000c246:	aa a0       	st.b	r5[0x2],r0
8000c248:	80 00       	ld.sh	r0,r0[0x0]
8000c24a:	4b 3c       	lddpc	r12,8000c314 <__avr32_f64_mul+0x14>
8000c24c:	80 00       	ld.sh	r0,r0[0x0]
8000c24e:	ca 56       	brmi	8000c198 <main+0x1390>
8000c250:	00 00       	add	r0,r0
8000c252:	0b c8       	ld.ub	r8,r5[0x4]
8000c254:	00 00       	add	r0,r0
8000c256:	0d 74       	ld.ub	r4,--r6
8000c258:	00 00       	add	r0,r0
8000c25a:	07 b9       	ld.ub	r9,r3[0x3]
8000c25c:	80 01       	ld.sh	r1,r0[0x0]
8000c25e:	25 d8       	sub	r8,93
8000c260:	80 00       	ld.sh	r0,r0[0x0]
8000c262:	4a c6       	lddpc	r6,8000c310 <__avr32_f64_mul+0x10>
8000c264:	80 00       	ld.sh	r0,r0[0x0]
8000c266:	6d d4       	ld.w	r4,r6[0x74]
8000c268:	80 00       	ld.sh	r0,r0[0x0]
8000c26a:	33 38       	mov	r8,51
8000c26c:	00 00       	add	r0,r0
8000c26e:	07 b8       	ld.ub	r8,r3[0x3]
8000c270:	00 00       	add	r0,r0
8000c272:	00 0c       	add	r12,r0
8000c274:	80 00       	ld.sh	r0,r0[0x0]
8000c276:	6d ec       	ld.w	r12,r6[0x78]
8000c278:	80 00       	ld.sh	r0,r0[0x0]
8000c27a:	6e 10       	ld.w	r0,r7[0x4]
8000c27c:	80 00       	ld.sh	r0,r0[0x0]
8000c27e:	77 f8       	ld.w	r8,r11[0x7c]
8000c280:	80 00       	ld.sh	r0,r0[0x0]
8000c282:	7b e4       	ld.w	r4,sp[0x78]
8000c284:	80 00       	ld.sh	r0,r0[0x0]
8000c286:	81 d4       	st.w	r0[0x34],r4
8000c288:	80 00       	ld.sh	r0,r0[0x0]
8000c28a:	83 78       	st.w	r1[0x1c],r8
8000c28c:	80 00       	ld.sh	r0,r0[0x0]
8000c28e:	6e 38       	ld.w	r8,r7[0xc]
8000c290:	00 00       	add	r0,r0
8000c292:	08 38       	cp.w	r8,r4
8000c294:	00 00       	add	r0,r0
8000c296:	0b e4       	ld.ub	r4,r5[0x6]
8000c298:	80 00       	ld.sh	r0,r0[0x0]
8000c29a:	83 8c       	st.w	r1[0x20],r12
8000c29c:	80 00       	ld.sh	r0,r0[0x0]
8000c29e:	6e 48       	ld.w	r8,r7[0x10]
8000c2a0:	80 00       	ld.sh	r0,r0[0x0]
8000c2a2:	6e 88       	ld.w	r8,r7[0x20]
8000c2a4:	00 00       	add	r0,r0
8000c2a6:	07 d5       	ld.ub	r5,r3[0x5]
8000c2a8:	00 00       	add	r0,r0
8000c2aa:	0b b4       	ld.ub	r4,r5[0x3]
8000c2ac:	00 00       	add	r0,r0
8000c2ae:	0b 91       	ld.ub	r1,r5[0x1]
8000c2b0:	80 00       	ld.sh	r0,r0[0x0]
8000c2b2:	84 cc       	ld.uh	r12,r2[0x8]
8000c2b4:	00 00       	add	r0,r0
8000c2b6:	0b bc       	ld.ub	r12,r5[0x3]
8000c2b8:	80 00       	ld.sh	r0,r0[0x0]
8000c2ba:	63 50       	ld.w	r0,r1[0x54]
8000c2bc:	00 00       	add	r0,r0
8000c2be:	0b a8       	ld.ub	r8,r5[0x2]
8000c2c0:	80 00       	ld.sh	r0,r0[0x0]
8000c2c2:	6e b4       	ld.w	r4,r7[0x2c]
8000c2c4:	80 00       	ld.sh	r0,r0[0x0]
8000c2c6:	ce 10       	breq	8000c288 <main+0x1480>
8000c2c8:	80 00       	ld.sh	r0,r0[0x0]
8000c2ca:	98 44       	ld.sh	r4,r12[0x8]
8000c2cc:	00 00       	add	r0,r0
8000c2ce:	0c f0       	st.b	--r6,r0
8000c2d0:	80 00       	ld.sh	r0,r0[0x0]
8000c2d2:	99 14       	st.w	r12[0x4],r4
8000c2d4:	80 00       	ld.sh	r0,r0[0x0]
8000c2d6:	6e e4       	ld.w	r4,r7[0x38]
8000c2d8:	00 00       	add	r0,r0
8000c2da:	0b f0       	ld.ub	r0,r5[0x7]
8000c2dc:	00 00       	add	r0,r0
8000c2de:	0c fc       	st.b	--r6,r12
8000c2e0:	00 00       	add	r0,r0
8000c2e2:	07 ba       	ld.ub	r10,r3[0x3]
8000c2e4:	00 00       	add	r0,r0
8000c2e6:	07 bb       	ld.ub	r11,r3[0x3]
8000c2e8:	00 00       	add	r0,r0
8000c2ea:	0b fe       	ld.ub	lr,r5[0x7]
8000c2ec:	00 00       	add	r0,r0
8000c2ee:	0b d4       	ld.ub	r4,r5[0x5]
8000c2f0:	80 00       	ld.sh	r0,r0[0x0]
8000c2f2:	85 9c       	st.w	r2[0x24],r12
8000c2f4:	80 00       	ld.sh	r0,r0[0x0]
8000c2f6:	6e f4       	ld.w	r4,r7[0x3c]
8000c2f8:	80 00       	ld.sh	r0,r0[0x0]
8000c2fa:	4b 76       	lddpc	r6,8000c3d4 <__avr32_f64_mul_op1_subnormal+0x3a>
8000c2fc:	80 00       	ld.sh	r0,r0[0x0]
8000c2fe:	aa b8       	st.b	r5[0x3],r8

8000c300 <__avr32_f64_mul>:
8000c300:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000c304:	e0 80 00 dc 	breq	8000c4bc <__avr32_f64_mul_op1_zero>
8000c308:	d4 21       	pushm	r4-r7,lr
8000c30a:	f7 e9 20 0e 	eor	lr,r11,r9
8000c30e:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000c312:	30 15       	mov	r5,1
8000c314:	c4 30       	breq	8000c39a <__avr32_f64_mul_op1_subnormal>
8000c316:	ab 6b       	lsl	r11,0xa
8000c318:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000c31c:	ab 6a       	lsl	r10,0xa
8000c31e:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000c322:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000c326:	c5 c0       	breq	8000c3de <__avr32_f64_mul_op2_subnormal>
8000c328:	a1 78       	lsl	r8,0x1
8000c32a:	5c f9       	rol	r9
8000c32c:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000c330:	e0 47 07 ff 	cp.w	r7,2047
8000c334:	c7 70       	breq	8000c422 <__avr32_f64_mul_op_nan_or_inf>
8000c336:	e0 46 07 ff 	cp.w	r6,2047
8000c33a:	c7 40       	breq	8000c422 <__avr32_f64_mul_op_nan_or_inf>
8000c33c:	ee 06 00 0c 	add	r12,r7,r6
8000c340:	e0 2c 03 fe 	sub	r12,1022
8000c344:	f6 08 06 44 	mulu.d	r4,r11,r8
8000c348:	f4 09 07 44 	macu.d	r4,r10,r9
8000c34c:	f4 08 06 46 	mulu.d	r6,r10,r8
8000c350:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000c354:	08 07       	add	r7,r4
8000c356:	f4 05 00 4a 	adc	r10,r10,r5
8000c35a:	5c 0b       	acr	r11
8000c35c:	ed bb 00 14 	bld	r11,0x14
8000c360:	c0 50       	breq	8000c36a <__avr32_f64_mul+0x6a>
8000c362:	a1 77       	lsl	r7,0x1
8000c364:	5c fa       	rol	r10
8000c366:	5c fb       	rol	r11
8000c368:	20 1c       	sub	r12,1
8000c36a:	58 0c       	cp.w	r12,0
8000c36c:	e0 8a 00 6f 	brle	8000c44a <__avr32_f64_mul_res_subnormal>
8000c370:	e0 4c 07 ff 	cp.w	r12,2047
8000c374:	e0 84 00 9c 	brge	8000c4ac <__avr32_f64_mul_res_inf>
8000c378:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000c37c:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000c380:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000c384:	ee 17 80 00 	eorh	r7,0x8000
8000c388:	f1 b7 04 20 	satu	r7,0x1
8000c38c:	0e 0a       	add	r10,r7
8000c38e:	5c 0b       	acr	r11
8000c390:	ed be 00 1f 	bld	lr,0x1f
8000c394:	ef bb 00 1f 	bst	r11,0x1f
8000c398:	d8 22       	popm	r4-r7,pc

8000c39a <__avr32_f64_mul_op1_subnormal>:
8000c39a:	e4 1b 00 0f 	andh	r11,0xf
8000c39e:	f4 0c 12 00 	clz	r12,r10
8000c3a2:	f6 06 12 00 	clz	r6,r11
8000c3a6:	f7 bc 03 e1 	sublo	r12,-31
8000c3aa:	f8 06 17 30 	movlo	r6,r12
8000c3ae:	f7 b6 02 01 	subhs	r6,1
8000c3b2:	e0 46 00 20 	cp.w	r6,32
8000c3b6:	c0 d4       	brge	8000c3d0 <__avr32_f64_mul_op1_subnormal+0x36>
8000c3b8:	ec 0c 11 20 	rsub	r12,r6,32
8000c3bc:	f6 06 09 4b 	lsl	r11,r11,r6
8000c3c0:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000c3c4:	18 4b       	or	r11,r12
8000c3c6:	f4 06 09 4a 	lsl	r10,r10,r6
8000c3ca:	20 b6       	sub	r6,11
8000c3cc:	0c 17       	sub	r7,r6
8000c3ce:	ca ab       	rjmp	8000c322 <__avr32_f64_mul+0x22>
8000c3d0:	f4 06 09 4b 	lsl	r11,r10,r6
8000c3d4:	c6 40       	breq	8000c49c <__avr32_f64_mul_res_zero>
8000c3d6:	30 0a       	mov	r10,0
8000c3d8:	20 b6       	sub	r6,11
8000c3da:	0c 17       	sub	r7,r6
8000c3dc:	ca 3b       	rjmp	8000c322 <__avr32_f64_mul+0x22>

8000c3de <__avr32_f64_mul_op2_subnormal>:
8000c3de:	e4 19 00 0f 	andh	r9,0xf
8000c3e2:	f0 0c 12 00 	clz	r12,r8
8000c3e6:	f2 05 12 00 	clz	r5,r9
8000c3ea:	f7 bc 03 ea 	sublo	r12,-22
8000c3ee:	f8 05 17 30 	movlo	r5,r12
8000c3f2:	f7 b5 02 0a 	subhs	r5,10
8000c3f6:	e0 45 00 20 	cp.w	r5,32
8000c3fa:	c0 d4       	brge	8000c414 <__avr32_f64_mul_op2_subnormal+0x36>
8000c3fc:	ea 0c 11 20 	rsub	r12,r5,32
8000c400:	f2 05 09 49 	lsl	r9,r9,r5
8000c404:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000c408:	18 49       	or	r9,r12
8000c40a:	f0 05 09 48 	lsl	r8,r8,r5
8000c40e:	20 25       	sub	r5,2
8000c410:	0a 16       	sub	r6,r5
8000c412:	c8 fb       	rjmp	8000c330 <__avr32_f64_mul+0x30>
8000c414:	f0 05 09 49 	lsl	r9,r8,r5
8000c418:	c4 20       	breq	8000c49c <__avr32_f64_mul_res_zero>
8000c41a:	30 08       	mov	r8,0
8000c41c:	20 25       	sub	r5,2
8000c41e:	0a 16       	sub	r6,r5
8000c420:	c8 8b       	rjmp	8000c330 <__avr32_f64_mul+0x30>

8000c422 <__avr32_f64_mul_op_nan_or_inf>:
8000c422:	e4 19 00 0f 	andh	r9,0xf
8000c426:	e4 1b 00 0f 	andh	r11,0xf
8000c42a:	14 4b       	or	r11,r10
8000c42c:	10 49       	or	r9,r8
8000c42e:	e0 47 07 ff 	cp.w	r7,2047
8000c432:	c0 91       	brne	8000c444 <__avr32_f64_mul_op1_not_naninf>
8000c434:	58 0b       	cp.w	r11,0
8000c436:	c3 81       	brne	8000c4a6 <__avr32_f64_mul_res_nan>
8000c438:	e0 46 07 ff 	cp.w	r6,2047
8000c43c:	c3 81       	brne	8000c4ac <__avr32_f64_mul_res_inf>
8000c43e:	58 09       	cp.w	r9,0
8000c440:	c3 60       	breq	8000c4ac <__avr32_f64_mul_res_inf>
8000c442:	c3 28       	rjmp	8000c4a6 <__avr32_f64_mul_res_nan>

8000c444 <__avr32_f64_mul_op1_not_naninf>:
8000c444:	58 09       	cp.w	r9,0
8000c446:	c3 30       	breq	8000c4ac <__avr32_f64_mul_res_inf>
8000c448:	c2 f8       	rjmp	8000c4a6 <__avr32_f64_mul_res_nan>

8000c44a <__avr32_f64_mul_res_subnormal>:
8000c44a:	5c 3c       	neg	r12
8000c44c:	2f fc       	sub	r12,-1
8000c44e:	f1 bc 04 c0 	satu	r12,0x6
8000c452:	e0 4c 00 20 	cp.w	r12,32
8000c456:	c1 14       	brge	8000c478 <__avr32_f64_mul_res_subnormal+0x2e>
8000c458:	f8 08 11 20 	rsub	r8,r12,32
8000c45c:	0e 46       	or	r6,r7
8000c45e:	ee 0c 0a 47 	lsr	r7,r7,r12
8000c462:	f4 08 09 49 	lsl	r9,r10,r8
8000c466:	12 47       	or	r7,r9
8000c468:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000c46c:	f6 08 09 49 	lsl	r9,r11,r8
8000c470:	12 4a       	or	r10,r9
8000c472:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000c476:	c8 3b       	rjmp	8000c37c <__avr32_f64_mul+0x7c>
8000c478:	f8 08 11 20 	rsub	r8,r12,32
8000c47c:	f9 b9 00 00 	moveq	r9,0
8000c480:	c0 30       	breq	8000c486 <__avr32_f64_mul_res_subnormal+0x3c>
8000c482:	f6 08 09 49 	lsl	r9,r11,r8
8000c486:	0e 46       	or	r6,r7
8000c488:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000c48c:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000c490:	f3 ea 10 07 	or	r7,r9,r10
8000c494:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000c498:	30 0b       	mov	r11,0
8000c49a:	c7 1b       	rjmp	8000c37c <__avr32_f64_mul+0x7c>

8000c49c <__avr32_f64_mul_res_zero>:
8000c49c:	1c 9b       	mov	r11,lr
8000c49e:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c4a2:	30 0a       	mov	r10,0
8000c4a4:	d8 22       	popm	r4-r7,pc

8000c4a6 <__avr32_f64_mul_res_nan>:
8000c4a6:	3f fb       	mov	r11,-1
8000c4a8:	3f fa       	mov	r10,-1
8000c4aa:	d8 22       	popm	r4-r7,pc

8000c4ac <__avr32_f64_mul_res_inf>:
8000c4ac:	f0 6b 00 00 	mov	r11,-1048576
8000c4b0:	ed be 00 1f 	bld	lr,0x1f
8000c4b4:	ef bb 00 1f 	bst	r11,0x1f
8000c4b8:	30 0a       	mov	r10,0
8000c4ba:	d8 22       	popm	r4-r7,pc

8000c4bc <__avr32_f64_mul_op1_zero>:
8000c4bc:	f7 e9 20 0b 	eor	r11,r11,r9
8000c4c0:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c4c4:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000c4c8:	e0 4c 07 ff 	cp.w	r12,2047
8000c4cc:	5e 1c       	retne	r12
8000c4ce:	3f fa       	mov	r10,-1
8000c4d0:	3f fb       	mov	r11,-1
8000c4d2:	5e fc       	retal	r12

8000c4d4 <__avr32_f64_sub_from_add>:
8000c4d4:	ee 19 80 00 	eorh	r9,0x8000

8000c4d8 <__avr32_f64_sub>:
8000c4d8:	f7 e9 20 0c 	eor	r12,r11,r9
8000c4dc:	e0 86 00 ca 	brmi	8000c670 <__avr32_f64_add_from_sub>
8000c4e0:	eb cd 40 e0 	pushm	r5-r7,lr
8000c4e4:	16 9c       	mov	r12,r11
8000c4e6:	e6 1c 80 00 	andh	r12,0x8000,COH
8000c4ea:	bf db       	cbr	r11,0x1f
8000c4ec:	bf d9       	cbr	r9,0x1f
8000c4ee:	10 3a       	cp.w	r10,r8
8000c4f0:	f2 0b 13 00 	cpc	r11,r9
8000c4f4:	c0 92       	brcc	8000c506 <__avr32_f64_sub+0x2e>
8000c4f6:	16 97       	mov	r7,r11
8000c4f8:	12 9b       	mov	r11,r9
8000c4fa:	0e 99       	mov	r9,r7
8000c4fc:	14 97       	mov	r7,r10
8000c4fe:	10 9a       	mov	r10,r8
8000c500:	0e 98       	mov	r8,r7
8000c502:	ee 1c 80 00 	eorh	r12,0x8000
8000c506:	f6 07 16 14 	lsr	r7,r11,0x14
8000c50a:	ab 7b       	lsl	r11,0xb
8000c50c:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000c510:	ab 7a       	lsl	r10,0xb
8000c512:	bf bb       	sbr	r11,0x1f
8000c514:	f2 06 16 14 	lsr	r6,r9,0x14
8000c518:	c4 40       	breq	8000c5a0 <__avr32_f64_sub_opL_subnormal>
8000c51a:	ab 79       	lsl	r9,0xb
8000c51c:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000c520:	ab 78       	lsl	r8,0xb
8000c522:	bf b9       	sbr	r9,0x1f

8000c524 <__avr32_f64_sub_opL_subnormal_done>:
8000c524:	e0 47 07 ff 	cp.w	r7,2047
8000c528:	c4 f0       	breq	8000c5c6 <__avr32_f64_sub_opH_nan_or_inf>
8000c52a:	0e 26       	rsub	r6,r7
8000c52c:	c1 20       	breq	8000c550 <__avr32_f64_sub_shift_done>
8000c52e:	ec 05 11 20 	rsub	r5,r6,32
8000c532:	e0 46 00 20 	cp.w	r6,32
8000c536:	c7 c2       	brcc	8000c62e <__avr32_f64_sub_longshift>
8000c538:	f0 05 09 4e 	lsl	lr,r8,r5
8000c53c:	f2 05 09 45 	lsl	r5,r9,r5
8000c540:	f0 06 0a 48 	lsr	r8,r8,r6
8000c544:	f2 06 0a 49 	lsr	r9,r9,r6
8000c548:	0a 48       	or	r8,r5
8000c54a:	58 0e       	cp.w	lr,0
8000c54c:	5f 1e       	srne	lr
8000c54e:	1c 48       	or	r8,lr

8000c550 <__avr32_f64_sub_shift_done>:
8000c550:	10 1a       	sub	r10,r8
8000c552:	f6 09 01 4b 	sbc	r11,r11,r9
8000c556:	f6 06 12 00 	clz	r6,r11
8000c55a:	c0 e0       	breq	8000c576 <__avr32_f64_sub_longnormalize_done>
8000c55c:	c7 83       	brcs	8000c64c <__avr32_f64_sub_longnormalize>
8000c55e:	ec 0e 11 20 	rsub	lr,r6,32
8000c562:	f6 06 09 4b 	lsl	r11,r11,r6
8000c566:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000c56a:	1c 4b       	or	r11,lr
8000c56c:	f4 06 09 4a 	lsl	r10,r10,r6
8000c570:	0c 17       	sub	r7,r6
8000c572:	e0 8a 00 39 	brle	8000c5e4 <__avr32_f64_sub_subnormal_result>

8000c576 <__avr32_f64_sub_longnormalize_done>:
8000c576:	f4 09 15 15 	lsl	r9,r10,0x15
8000c57a:	ab 9a       	lsr	r10,0xb
8000c57c:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000c580:	ab 9b       	lsr	r11,0xb
8000c582:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c586:	18 4b       	or	r11,r12

8000c588 <__avr32_f64_sub_round>:
8000c588:	fc 17 80 00 	movh	r7,0x8000
8000c58c:	ed ba 00 00 	bld	r10,0x0
8000c590:	f7 b7 01 ff 	subne	r7,-1
8000c594:	0e 39       	cp.w	r9,r7
8000c596:	5f 29       	srhs	r9
8000c598:	12 0a       	add	r10,r9
8000c59a:	5c 0b       	acr	r11
8000c59c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c5a0 <__avr32_f64_sub_opL_subnormal>:
8000c5a0:	ab 79       	lsl	r9,0xb
8000c5a2:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000c5a6:	ab 78       	lsl	r8,0xb
8000c5a8:	f3 e8 10 0e 	or	lr,r9,r8
8000c5ac:	f9 b6 01 01 	movne	r6,1
8000c5b0:	ee 0e 11 00 	rsub	lr,r7,0
8000c5b4:	f9 b7 00 01 	moveq	r7,1
8000c5b8:	ef bb 00 1f 	bst	r11,0x1f
8000c5bc:	f7 ea 10 0e 	or	lr,r11,r10
8000c5c0:	f9 b7 00 00 	moveq	r7,0
8000c5c4:	cb 0b       	rjmp	8000c524 <__avr32_f64_sub_opL_subnormal_done>

8000c5c6 <__avr32_f64_sub_opH_nan_or_inf>:
8000c5c6:	bf db       	cbr	r11,0x1f
8000c5c8:	f7 ea 10 0e 	or	lr,r11,r10
8000c5cc:	c0 81       	brne	8000c5dc <__avr32_f64_sub_return_nan>
8000c5ce:	e0 46 07 ff 	cp.w	r6,2047
8000c5d2:	c0 50       	breq	8000c5dc <__avr32_f64_sub_return_nan>
8000c5d4:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000c5d8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c5dc <__avr32_f64_sub_return_nan>:
8000c5dc:	3f fa       	mov	r10,-1
8000c5de:	3f fb       	mov	r11,-1
8000c5e0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c5e4 <__avr32_f64_sub_subnormal_result>:
8000c5e4:	5c 37       	neg	r7
8000c5e6:	2f f7       	sub	r7,-1
8000c5e8:	f1 b7 04 c0 	satu	r7,0x6
8000c5ec:	e0 47 00 20 	cp.w	r7,32
8000c5f0:	c1 14       	brge	8000c612 <__avr32_f64_sub_subnormal_result+0x2e>
8000c5f2:	ee 08 11 20 	rsub	r8,r7,32
8000c5f6:	f4 08 09 49 	lsl	r9,r10,r8
8000c5fa:	5f 16       	srne	r6
8000c5fc:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c600:	0c 4a       	or	r10,r6
8000c602:	f6 08 09 49 	lsl	r9,r11,r8
8000c606:	f5 e9 10 0a 	or	r10,r10,r9
8000c60a:	f4 07 0a 4b 	lsr	r11,r10,r7
8000c60e:	30 07       	mov	r7,0
8000c610:	cb 3b       	rjmp	8000c576 <__avr32_f64_sub_longnormalize_done>
8000c612:	ee 08 11 40 	rsub	r8,r7,64
8000c616:	f6 08 09 49 	lsl	r9,r11,r8
8000c61a:	14 49       	or	r9,r10
8000c61c:	5f 16       	srne	r6
8000c61e:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c622:	0c 4a       	or	r10,r6
8000c624:	30 0b       	mov	r11,0
8000c626:	30 07       	mov	r7,0
8000c628:	ca 7b       	rjmp	8000c576 <__avr32_f64_sub_longnormalize_done>
8000c62a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c62e <__avr32_f64_sub_longshift>:
8000c62e:	f1 b6 04 c0 	satu	r6,0x6
8000c632:	f0 0e 17 00 	moveq	lr,r8
8000c636:	c0 40       	breq	8000c63e <__avr32_f64_sub_longshift+0x10>
8000c638:	f2 05 09 4e 	lsl	lr,r9,r5
8000c63c:	10 4e       	or	lr,r8
8000c63e:	f2 06 0a 48 	lsr	r8,r9,r6
8000c642:	30 09       	mov	r9,0
8000c644:	58 0e       	cp.w	lr,0
8000c646:	5f 1e       	srne	lr
8000c648:	1c 48       	or	r8,lr
8000c64a:	c8 3b       	rjmp	8000c550 <__avr32_f64_sub_shift_done>

8000c64c <__avr32_f64_sub_longnormalize>:
8000c64c:	f4 06 12 00 	clz	r6,r10
8000c650:	f9 b7 03 00 	movlo	r7,0
8000c654:	f9 b6 03 00 	movlo	r6,0
8000c658:	f9 bc 03 00 	movlo	r12,0
8000c65c:	f7 b6 02 e0 	subhs	r6,-32
8000c660:	f4 06 09 4b 	lsl	r11,r10,r6
8000c664:	30 0a       	mov	r10,0
8000c666:	0c 17       	sub	r7,r6
8000c668:	fe 9a ff be 	brle	8000c5e4 <__avr32_f64_sub_subnormal_result>
8000c66c:	c8 5b       	rjmp	8000c576 <__avr32_f64_sub_longnormalize_done>
	...

8000c670 <__avr32_f64_add_from_sub>:
8000c670:	ee 19 80 00 	eorh	r9,0x8000

8000c674 <__avr32_f64_add>:
8000c674:	f7 e9 20 0c 	eor	r12,r11,r9
8000c678:	fe 96 ff 2e 	brmi	8000c4d4 <__avr32_f64_sub_from_add>
8000c67c:	eb cd 40 e0 	pushm	r5-r7,lr
8000c680:	16 9c       	mov	r12,r11
8000c682:	e6 1c 80 00 	andh	r12,0x8000,COH
8000c686:	bf db       	cbr	r11,0x1f
8000c688:	bf d9       	cbr	r9,0x1f
8000c68a:	12 3b       	cp.w	r11,r9
8000c68c:	c0 72       	brcc	8000c69a <__avr32_f64_add+0x26>
8000c68e:	16 97       	mov	r7,r11
8000c690:	12 9b       	mov	r11,r9
8000c692:	0e 99       	mov	r9,r7
8000c694:	14 97       	mov	r7,r10
8000c696:	10 9a       	mov	r10,r8
8000c698:	0e 98       	mov	r8,r7
8000c69a:	30 0e       	mov	lr,0
8000c69c:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000c6a0:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000c6a4:	b5 ab       	sbr	r11,0x14
8000c6a6:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000c6aa:	c6 20       	breq	8000c76e <__avr32_f64_add_op2_subnormal>
8000c6ac:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000c6b0:	b5 a9       	sbr	r9,0x14
8000c6b2:	e0 47 07 ff 	cp.w	r7,2047
8000c6b6:	c2 80       	breq	8000c706 <__avr32_f64_add_opH_nan_or_inf>
8000c6b8:	0e 26       	rsub	r6,r7
8000c6ba:	c1 20       	breq	8000c6de <__avr32_f64_add_shift_done>
8000c6bc:	e0 46 00 36 	cp.w	r6,54
8000c6c0:	c1 52       	brcc	8000c6ea <__avr32_f64_add_res_of_done>
8000c6c2:	ec 05 11 20 	rsub	r5,r6,32
8000c6c6:	e0 46 00 20 	cp.w	r6,32
8000c6ca:	c3 52       	brcc	8000c734 <__avr32_f64_add_longshift>
8000c6cc:	f0 05 09 4e 	lsl	lr,r8,r5
8000c6d0:	f2 05 09 45 	lsl	r5,r9,r5
8000c6d4:	f0 06 0a 48 	lsr	r8,r8,r6
8000c6d8:	f2 06 0a 49 	lsr	r9,r9,r6
8000c6dc:	0a 48       	or	r8,r5

8000c6de <__avr32_f64_add_shift_done>:
8000c6de:	10 0a       	add	r10,r8
8000c6e0:	f6 09 00 4b 	adc	r11,r11,r9
8000c6e4:	ed bb 00 15 	bld	r11,0x15
8000c6e8:	c3 40       	breq	8000c750 <__avr32_f64_add_res_of>

8000c6ea <__avr32_f64_add_res_of_done>:
8000c6ea:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c6ee:	18 4b       	or	r11,r12

8000c6f0 <__avr32_f64_add_round>:
8000c6f0:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000c6f4:	18 4e       	or	lr,r12
8000c6f6:	ee 1e 80 00 	eorh	lr,0x8000
8000c6fa:	f1 be 04 20 	satu	lr,0x1
8000c6fe:	1c 0a       	add	r10,lr
8000c700:	5c 0b       	acr	r11
8000c702:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c706 <__avr32_f64_add_opH_nan_or_inf>:
8000c706:	b5 cb       	cbr	r11,0x14
8000c708:	f7 ea 10 0e 	or	lr,r11,r10
8000c70c:	c1 01       	brne	8000c72c <__avr32_f64_add_return_nan>
8000c70e:	e0 46 07 ff 	cp.w	r6,2047
8000c712:	c0 30       	breq	8000c718 <__avr32_f64_add_opL_nan_or_inf>
8000c714:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c718 <__avr32_f64_add_opL_nan_or_inf>:
8000c718:	b5 c9       	cbr	r9,0x14
8000c71a:	f3 e8 10 0e 	or	lr,r9,r8
8000c71e:	c0 71       	brne	8000c72c <__avr32_f64_add_return_nan>
8000c720:	30 0a       	mov	r10,0
8000c722:	fc 1b 7f f0 	movh	r11,0x7ff0
8000c726:	18 4b       	or	r11,r12
8000c728:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c72c <__avr32_f64_add_return_nan>:
8000c72c:	3f fa       	mov	r10,-1
8000c72e:	3f fb       	mov	r11,-1
8000c730:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c734 <__avr32_f64_add_longshift>:
8000c734:	f1 b6 04 c0 	satu	r6,0x6
8000c738:	f0 0e 17 00 	moveq	lr,r8
8000c73c:	c0 60       	breq	8000c748 <__avr32_f64_add_longshift+0x14>
8000c73e:	f2 05 09 4e 	lsl	lr,r9,r5
8000c742:	58 08       	cp.w	r8,0
8000c744:	5f 18       	srne	r8
8000c746:	10 4e       	or	lr,r8
8000c748:	f2 06 0a 48 	lsr	r8,r9,r6
8000c74c:	30 09       	mov	r9,0
8000c74e:	cc 8b       	rjmp	8000c6de <__avr32_f64_add_shift_done>

8000c750 <__avr32_f64_add_res_of>:
8000c750:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000c754:	a1 9b       	lsr	r11,0x1
8000c756:	5d 0a       	ror	r10
8000c758:	5d 0e       	ror	lr
8000c75a:	2f f7       	sub	r7,-1
8000c75c:	e0 47 07 ff 	cp.w	r7,2047
8000c760:	f9 ba 00 00 	moveq	r10,0
8000c764:	f9 bb 00 00 	moveq	r11,0
8000c768:	f9 be 00 00 	moveq	lr,0
8000c76c:	cb fb       	rjmp	8000c6ea <__avr32_f64_add_res_of_done>

8000c76e <__avr32_f64_add_op2_subnormal>:
8000c76e:	30 16       	mov	r6,1
8000c770:	58 07       	cp.w	r7,0
8000c772:	ca 01       	brne	8000c6b2 <__avr32_f64_add+0x3e>
8000c774:	b5 cb       	cbr	r11,0x14
8000c776:	10 0a       	add	r10,r8
8000c778:	f6 09 00 4b 	adc	r11,r11,r9
8000c77c:	18 4b       	or	r11,r12
8000c77e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	...

8000c784 <__avr32_u32_to_f64>:
8000c784:	f8 cb 00 00 	sub	r11,r12,0
8000c788:	30 0c       	mov	r12,0
8000c78a:	c0 38       	rjmp	8000c790 <__avr32_s32_to_f64+0x4>

8000c78c <__avr32_s32_to_f64>:
8000c78c:	18 9b       	mov	r11,r12
8000c78e:	5c 4b       	abs	r11
8000c790:	30 0a       	mov	r10,0
8000c792:	5e 0b       	reteq	r11
8000c794:	d4 01       	pushm	lr
8000c796:	e0 69 04 1e 	mov	r9,1054
8000c79a:	f6 08 12 00 	clz	r8,r11
8000c79e:	c1 70       	breq	8000c7cc <__avr32_s32_to_f64+0x40>
8000c7a0:	c0 c3       	brcs	8000c7b8 <__avr32_s32_to_f64+0x2c>
8000c7a2:	f0 0e 11 20 	rsub	lr,r8,32
8000c7a6:	f6 08 09 4b 	lsl	r11,r11,r8
8000c7aa:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000c7ae:	1c 4b       	or	r11,lr
8000c7b0:	f4 08 09 4a 	lsl	r10,r10,r8
8000c7b4:	10 19       	sub	r9,r8
8000c7b6:	c0 b8       	rjmp	8000c7cc <__avr32_s32_to_f64+0x40>
8000c7b8:	f4 08 12 00 	clz	r8,r10
8000c7bc:	f9 b8 03 00 	movlo	r8,0
8000c7c0:	f7 b8 02 e0 	subhs	r8,-32
8000c7c4:	f4 08 09 4b 	lsl	r11,r10,r8
8000c7c8:	30 0a       	mov	r10,0
8000c7ca:	10 19       	sub	r9,r8
8000c7cc:	58 09       	cp.w	r9,0
8000c7ce:	e0 89 00 30 	brgt	8000c82e <__avr32_s32_to_f64+0xa2>
8000c7d2:	5c 39       	neg	r9
8000c7d4:	2f f9       	sub	r9,-1
8000c7d6:	e0 49 00 36 	cp.w	r9,54
8000c7da:	c0 43       	brcs	8000c7e2 <__avr32_s32_to_f64+0x56>
8000c7dc:	30 0b       	mov	r11,0
8000c7de:	30 0a       	mov	r10,0
8000c7e0:	c2 68       	rjmp	8000c82c <__avr32_s32_to_f64+0xa0>
8000c7e2:	2f 69       	sub	r9,-10
8000c7e4:	f2 08 11 20 	rsub	r8,r9,32
8000c7e8:	e0 49 00 20 	cp.w	r9,32
8000c7ec:	c0 b2       	brcc	8000c802 <__avr32_s32_to_f64+0x76>
8000c7ee:	f4 08 09 4e 	lsl	lr,r10,r8
8000c7f2:	f6 08 09 48 	lsl	r8,r11,r8
8000c7f6:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c7fa:	f6 09 0a 4b 	lsr	r11,r11,r9
8000c7fe:	10 4b       	or	r11,r8
8000c800:	c0 88       	rjmp	8000c810 <__avr32_s32_to_f64+0x84>
8000c802:	f6 08 09 4e 	lsl	lr,r11,r8
8000c806:	14 4e       	or	lr,r10
8000c808:	16 9a       	mov	r10,r11
8000c80a:	30 0b       	mov	r11,0
8000c80c:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c810:	ed ba 00 00 	bld	r10,0x0
8000c814:	c0 92       	brcc	8000c826 <__avr32_s32_to_f64+0x9a>
8000c816:	1c 7e       	tst	lr,lr
8000c818:	c0 41       	brne	8000c820 <__avr32_s32_to_f64+0x94>
8000c81a:	ed ba 00 01 	bld	r10,0x1
8000c81e:	c0 42       	brcc	8000c826 <__avr32_s32_to_f64+0x9a>
8000c820:	2f fa       	sub	r10,-1
8000c822:	f7 bb 02 ff 	subhs	r11,-1
8000c826:	5c fc       	rol	r12
8000c828:	5d 0b       	ror	r11
8000c82a:	5d 0a       	ror	r10
8000c82c:	d8 02       	popm	pc
8000c82e:	e0 68 03 ff 	mov	r8,1023
8000c832:	ed ba 00 0b 	bld	r10,0xb
8000c836:	f7 b8 00 ff 	subeq	r8,-1
8000c83a:	10 0a       	add	r10,r8
8000c83c:	5c 0b       	acr	r11
8000c83e:	f7 b9 03 fe 	sublo	r9,-2
8000c842:	e0 49 07 ff 	cp.w	r9,2047
8000c846:	c0 55       	brlt	8000c850 <__avr32_s32_to_f64+0xc4>
8000c848:	30 0a       	mov	r10,0
8000c84a:	fc 1b ff e0 	movh	r11,0xffe0
8000c84e:	c0 c8       	rjmp	8000c866 <__floatsidf_return_op1>
8000c850:	ed bb 00 1f 	bld	r11,0x1f
8000c854:	f7 b9 01 01 	subne	r9,1
8000c858:	ab 9a       	lsr	r10,0xb
8000c85a:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000c85e:	a1 7b       	lsl	r11,0x1
8000c860:	ab 9b       	lsr	r11,0xb
8000c862:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000c866 <__floatsidf_return_op1>:
8000c866:	a1 7c       	lsl	r12,0x1
8000c868:	5d 0b       	ror	r11
8000c86a:	d8 02       	popm	pc

8000c86c <__avr32_f32_div>:
8000c86c:	f7 ec 20 08 	eor	r8,r11,r12
8000c870:	a1 7c       	lsl	r12,0x1
8000c872:	a1 7b       	lsl	r11,0x1
8000c874:	c7 a0       	breq	8000c968 <__divsf_return_op1+0x16>
8000c876:	18 7c       	tst	r12,r12
8000c878:	f9 b9 00 00 	moveq	r9,0
8000c87c:	c0 90       	breq	8000c88e <__avr32_f32_div+0x22>
8000c87e:	f8 09 16 18 	lsr	r9,r12,0x18
8000c882:	c7 e0       	breq	8000c97e <__divsf_return_op1+0x2c>
8000c884:	e0 49 00 ff 	cp.w	r9,255
8000c888:	c6 82       	brcc	8000c958 <__divsf_return_op1+0x6>
8000c88a:	a7 7c       	lsl	r12,0x7
8000c88c:	bf bc       	sbr	r12,0x1f
8000c88e:	f6 0a 16 18 	lsr	r10,r11,0x18
8000c892:	c7 e0       	breq	8000c98e <__divsf_return_op1+0x3c>
8000c894:	e0 4a 00 ff 	cp.w	r10,255
8000c898:	c6 62       	brcc	8000c964 <__divsf_return_op1+0x12>
8000c89a:	a7 7b       	lsl	r11,0x7
8000c89c:	bf bb       	sbr	r11,0x1f
8000c89e:	58 09       	cp.w	r9,0
8000c8a0:	f5 bc 00 00 	subfeq	r12,0
8000c8a4:	5e 0d       	reteq	0
8000c8a6:	1a d5       	st.w	--sp,r5
8000c8a8:	bb 27       	st.d	--sp,r6
8000c8aa:	14 19       	sub	r9,r10
8000c8ac:	28 19       	sub	r9,-127
8000c8ae:	fc 1a 80 00 	movh	r10,0x8000
8000c8b2:	a3 8c       	lsr	r12,0x2
8000c8b4:	f6 05 16 02 	lsr	r5,r11,0x2
8000c8b8:	f4 0b 16 01 	lsr	r11,r10,0x1
8000c8bc:	ed d5 c3 62 	bfextu	r6,r5,0x1b,0x2
8000c8c0:	5c d6       	com	r6
8000c8c2:	f7 d6 d3 82 	bfins	r11,r6,0x1c,0x2
8000c8c6:	f6 05 06 46 	mulu.d	r6,r11,r5
8000c8ca:	f4 07 01 27 	sub	r7,r10,r7<<0x2
8000c8ce:	f6 07 06 46 	mulu.d	r6,r11,r7
8000c8d2:	ee 0b 15 02 	lsl	r11,r7,0x2
8000c8d6:	f6 05 06 46 	mulu.d	r6,r11,r5
8000c8da:	f4 07 01 27 	sub	r7,r10,r7<<0x2
8000c8de:	f6 07 06 46 	mulu.d	r6,r11,r7
8000c8e2:	ee 0b 15 02 	lsl	r11,r7,0x2
8000c8e6:	f6 05 06 46 	mulu.d	r6,r11,r5
8000c8ea:	f4 07 01 27 	sub	r7,r10,r7<<0x2
8000c8ee:	f6 07 06 46 	mulu.d	r6,r11,r7
8000c8f2:	ee 0b 15 02 	lsl	r11,r7,0x2
8000c8f6:	f6 05 06 46 	mulu.d	r6,r11,r5
8000c8fa:	f4 07 01 27 	sub	r7,r10,r7<<0x2
8000c8fe:	f6 07 06 46 	mulu.d	r6,r11,r7
8000c902:	ee 0b 15 02 	lsl	r11,r7,0x2
8000c906:	f6 0c 06 46 	mulu.d	r6,r11,r12
8000c90a:	a5 8c       	lsr	r12,0x4
8000c90c:	ed b7 00 1c 	bld	r7,0x1c
8000c910:	c0 40       	breq	8000c918 <__avr32_f32_div+0xac>
8000c912:	a1 77       	lsl	r7,0x1
8000c914:	20 19       	sub	r9,1
8000c916:	a1 7c       	lsl	r12,0x1
8000c918:	58 09       	cp.w	r9,0
8000c91a:	e0 8a 00 42 	brle	8000c99e <__avr32_f32_div_res_subnormal>
8000c91e:	e0 17 ff e0 	andl	r7,0xffe0
8000c922:	e8 17 00 10 	orl	r7,0x10
8000c926:	ea 07 06 4a 	mulu.d	r10,r5,r7
8000c92a:	eb d7 c0 a1 	bfextu	r5,r7,0x5,0x1
8000c92e:	58 0a       	cp.w	r10,0

8000c930 <__avr32_f32_div_round_subnormal>:
8000c930:	f8 0b 13 00 	cpc	r11,r12
8000c934:	5f 3b       	srlo	r11
8000c936:	ea 0b 17 00 	moveq	r11,r5
8000c93a:	ee 0c 16 05 	lsr	r12,r7,0x5
8000c93e:	f9 d9 d2 e8 	bfins	r12,r9,0x17,0x8
8000c942:	bb 07       	ld.d	r6,sp++
8000c944:	1b 05       	ld.w	r5,sp++
8000c946:	ed b8 00 1f 	bld	r8,0x1f
8000c94a:	ef bc 00 1f 	bst	r12,0x1f
8000c94e:	16 0c       	add	r12,r11
8000c950:	5e fc       	retal	r12

8000c952 <__divsf_return_op1>:
8000c952:	a1 78       	lsl	r8,0x1
8000c954:	5d 0c       	ror	r12
8000c956:	5e fc       	retal	r12
8000c958:	5e 1e       	retne	-1
8000c95a:	fc 19 ff 00 	movh	r9,0xff00
8000c95e:	12 3b       	cp.w	r11,r9
8000c960:	cf 93       	brcs	8000c952 <__divsf_return_op1>
8000c962:	5e fe       	retal	-1
8000c964:	5e 0d       	reteq	0
8000c966:	5e fe       	retal	-1
8000c968:	18 7c       	tst	r12,r12
8000c96a:	5e 0e       	reteq	-1
8000c96c:	f8 09 16 18 	lsr	r9,r12,0x18
8000c970:	c0 70       	breq	8000c97e <__divsf_return_op1+0x2c>
8000c972:	e0 49 00 ff 	cp.w	r9,255
8000c976:	cf 12       	brcc	8000c958 <__divsf_return_op1+0x6>
8000c978:	fc 1c ff 00 	movh	r12,0xff00
8000c97c:	ce bb       	rjmp	8000c952 <__divsf_return_op1>
8000c97e:	a7 7c       	lsl	r12,0x7
8000c980:	f8 09 12 00 	clz	r9,r12
8000c984:	f8 09 09 4c 	lsl	r12,r12,r9
8000c988:	f2 09 11 01 	rsub	r9,r9,1
8000c98c:	c8 1b       	rjmp	8000c88e <__avr32_f32_div+0x22>
8000c98e:	a7 7b       	lsl	r11,0x7
8000c990:	f6 0a 12 00 	clz	r10,r11
8000c994:	f6 0a 09 4b 	lsl	r11,r11,r10
8000c998:	f4 0a 11 01 	rsub	r10,r10,1
8000c99c:	c8 5b       	rjmp	8000c8a6 <__avr32_f32_div+0x3a>

8000c99e <__avr32_f32_div_res_subnormal>:
8000c99e:	5c 39       	neg	r9
8000c9a0:	2f f9       	sub	r9,-1
8000c9a2:	f1 b9 04 a0 	satu	r9,0x5
8000c9a6:	f2 0a 11 20 	rsub	r10,r9,32
8000c9aa:	ee 09 0a 47 	lsr	r7,r7,r9
8000c9ae:	f8 0a 09 46 	lsl	r6,r12,r10
8000c9b2:	f8 09 0a 4c 	lsr	r12,r12,r9
8000c9b6:	e0 17 ff e0 	andl	r7,0xffe0
8000c9ba:	e8 17 00 10 	orl	r7,0x10
8000c9be:	ea 07 06 4a 	mulu.d	r10,r5,r7
8000c9c2:	30 09       	mov	r9,0
8000c9c4:	eb d7 c0 a1 	bfextu	r5,r7,0x5,0x1
8000c9c8:	0c 3a       	cp.w	r10,r6
8000c9ca:	cb 3b       	rjmp	8000c930 <__avr32_f32_div_round_subnormal>

8000c9cc <__avr32_f64_to_f32>:
8000c9cc:	f6 09 15 01 	lsl	r9,r11,0x1
8000c9d0:	b5 99       	lsr	r9,0x15
8000c9d2:	5e 0d       	reteq	0
8000c9d4:	f6 08 15 0a 	lsl	r8,r11,0xa
8000c9d8:	f1 ea 13 6c 	or	r12,r8,r10>>0x16
8000c9dc:	ab 6a       	lsl	r10,0xa
8000c9de:	5c 3a       	neg	r10
8000c9e0:	5c fc       	rol	r12
8000c9e2:	e0 49 07 ff 	cp.w	r9,2047
8000c9e6:	c1 a0       	breq	8000ca1a <__truncdfsf_return_op1+0x6>
8000c9e8:	e0 29 03 80 	sub	r9,896
8000c9ec:	bf bc       	sbr	r12,0x1f
8000c9ee:	58 09       	cp.w	r9,0
8000c9f0:	e0 8a 00 1a 	brle	8000ca24 <__truncdfsf_return_op1+0x10>
8000c9f4:	37 fa       	mov	r10,127
8000c9f6:	ed bc 00 08 	bld	r12,0x8
8000c9fa:	f7 ba 00 ff 	subeq	r10,-1
8000c9fe:	14 0c       	add	r12,r10
8000ca00:	f7 b9 03 fe 	sublo	r9,-2
8000ca04:	ed bc 00 1f 	bld	r12,0x1f
8000ca08:	f7 b9 01 01 	subne	r9,1
8000ca0c:	f8 0c 16 07 	lsr	r12,r12,0x7
8000ca10:	f9 d9 d3 08 	bfins	r12,r9,0x18,0x8

8000ca14 <__truncdfsf_return_op1>:
8000ca14:	a1 7b       	lsl	r11,0x1
8000ca16:	5d 0c       	ror	r12
8000ca18:	5e fc       	retal	r12
8000ca1a:	bf dc       	cbr	r12,0x1f
8000ca1c:	5e 1e       	retne	-1
8000ca1e:	fc 1c 7f 80 	movh	r12,0x7f80
8000ca22:	5e fc       	retal	r12
8000ca24:	f2 09 11 01 	rsub	r9,r9,1
8000ca28:	59 99       	cp.w	r9,25
8000ca2a:	f9 bc 02 00 	movhs	r12,0
8000ca2e:	c1 32       	brcc	8000ca54 <__truncdfsf_return_op1+0x40>
8000ca30:	f2 0a 11 20 	rsub	r10,r9,32
8000ca34:	f8 0a 09 4a 	lsl	r10,r12,r10
8000ca38:	5f 1a       	srne	r10
8000ca3a:	f8 09 0a 4c 	lsr	r12,r12,r9
8000ca3e:	14 4c       	or	r12,r10
8000ca40:	37 fa       	mov	r10,127
8000ca42:	ed bc 00 08 	bld	r12,0x8
8000ca46:	f7 ba 00 ff 	subeq	r10,-1
8000ca4a:	14 0c       	add	r12,r10
8000ca4c:	f8 0c 16 07 	lsr	r12,r12,0x7
8000ca50:	a1 7b       	lsl	r11,0x1
8000ca52:	5d 0c       	ror	r12
8000ca54:	5e fc       	retal	r12

8000ca56 <__avr32_udiv64>:
8000ca56:	d4 31       	pushm	r0-r7,lr
8000ca58:	1a 97       	mov	r7,sp
8000ca5a:	20 3d       	sub	sp,12
8000ca5c:	10 9c       	mov	r12,r8
8000ca5e:	12 9e       	mov	lr,r9
8000ca60:	14 93       	mov	r3,r10
8000ca62:	58 09       	cp.w	r9,0
8000ca64:	e0 81 00 bd 	brne	8000cbde <__avr32_udiv64+0x188>
8000ca68:	16 38       	cp.w	r8,r11
8000ca6a:	e0 88 00 40 	brls	8000caea <__avr32_udiv64+0x94>
8000ca6e:	f0 08 12 00 	clz	r8,r8
8000ca72:	c0 d0       	breq	8000ca8c <__avr32_udiv64+0x36>
8000ca74:	f6 08 09 4b 	lsl	r11,r11,r8
8000ca78:	f0 09 11 20 	rsub	r9,r8,32
8000ca7c:	f8 08 09 4c 	lsl	r12,r12,r8
8000ca80:	f4 09 0a 49 	lsr	r9,r10,r9
8000ca84:	f4 08 09 43 	lsl	r3,r10,r8
8000ca88:	f3 eb 10 0b 	or	r11,r9,r11
8000ca8c:	f8 0e 16 10 	lsr	lr,r12,0x10
8000ca90:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000ca94:	f6 0e 0d 00 	divu	r0,r11,lr
8000ca98:	e6 0b 16 10 	lsr	r11,r3,0x10
8000ca9c:	00 99       	mov	r9,r0
8000ca9e:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000caa2:	e0 0a 02 48 	mul	r8,r0,r10
8000caa6:	10 3b       	cp.w	r11,r8
8000caa8:	c0 a2       	brcc	8000cabc <__avr32_udiv64+0x66>
8000caaa:	20 19       	sub	r9,1
8000caac:	18 0b       	add	r11,r12
8000caae:	18 3b       	cp.w	r11,r12
8000cab0:	c0 63       	brcs	8000cabc <__avr32_udiv64+0x66>
8000cab2:	10 3b       	cp.w	r11,r8
8000cab4:	f7 b9 03 01 	sublo	r9,1
8000cab8:	f7 dc e3 0b 	addcs	r11,r11,r12
8000cabc:	f6 08 01 01 	sub	r1,r11,r8
8000cac0:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000cac4:	e2 0e 0d 00 	divu	r0,r1,lr
8000cac8:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000cacc:	00 98       	mov	r8,r0
8000cace:	e0 0a 02 4a 	mul	r10,r0,r10
8000cad2:	14 33       	cp.w	r3,r10
8000cad4:	c0 82       	brcc	8000cae4 <__avr32_udiv64+0x8e>
8000cad6:	20 18       	sub	r8,1
8000cad8:	18 03       	add	r3,r12
8000cada:	18 33       	cp.w	r3,r12
8000cadc:	c0 43       	brcs	8000cae4 <__avr32_udiv64+0x8e>
8000cade:	14 33       	cp.w	r3,r10
8000cae0:	f7 b8 03 01 	sublo	r8,1
8000cae4:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000cae8:	cd f8       	rjmp	8000cca6 <__avr32_udiv64+0x250>
8000caea:	58 08       	cp.w	r8,0
8000caec:	c0 51       	brne	8000caf6 <__avr32_udiv64+0xa0>
8000caee:	30 19       	mov	r9,1
8000caf0:	f2 08 0d 08 	divu	r8,r9,r8
8000caf4:	10 9c       	mov	r12,r8
8000caf6:	f8 06 12 00 	clz	r6,r12
8000cafa:	c0 41       	brne	8000cb02 <__avr32_udiv64+0xac>
8000cafc:	18 1b       	sub	r11,r12
8000cafe:	30 19       	mov	r9,1
8000cb00:	c4 08       	rjmp	8000cb80 <__avr32_udiv64+0x12a>
8000cb02:	ec 01 11 20 	rsub	r1,r6,32
8000cb06:	f4 01 0a 49 	lsr	r9,r10,r1
8000cb0a:	f8 06 09 4c 	lsl	r12,r12,r6
8000cb0e:	f6 06 09 48 	lsl	r8,r11,r6
8000cb12:	f6 01 0a 41 	lsr	r1,r11,r1
8000cb16:	f3 e8 10 08 	or	r8,r9,r8
8000cb1a:	f8 03 16 10 	lsr	r3,r12,0x10
8000cb1e:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000cb22:	e2 03 0d 00 	divu	r0,r1,r3
8000cb26:	f0 0b 16 10 	lsr	r11,r8,0x10
8000cb2a:	00 9e       	mov	lr,r0
8000cb2c:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000cb30:	e0 05 02 49 	mul	r9,r0,r5
8000cb34:	12 3b       	cp.w	r11,r9
8000cb36:	c0 a2       	brcc	8000cb4a <__avr32_udiv64+0xf4>
8000cb38:	20 1e       	sub	lr,1
8000cb3a:	18 0b       	add	r11,r12
8000cb3c:	18 3b       	cp.w	r11,r12
8000cb3e:	c0 63       	brcs	8000cb4a <__avr32_udiv64+0xf4>
8000cb40:	12 3b       	cp.w	r11,r9
8000cb42:	f7 be 03 01 	sublo	lr,1
8000cb46:	f7 dc e3 0b 	addcs	r11,r11,r12
8000cb4a:	12 1b       	sub	r11,r9
8000cb4c:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000cb50:	f6 03 0d 02 	divu	r2,r11,r3
8000cb54:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000cb58:	04 99       	mov	r9,r2
8000cb5a:	e4 05 02 4b 	mul	r11,r2,r5
8000cb5e:	16 38       	cp.w	r8,r11
8000cb60:	c0 a2       	brcc	8000cb74 <__avr32_udiv64+0x11e>
8000cb62:	20 19       	sub	r9,1
8000cb64:	18 08       	add	r8,r12
8000cb66:	18 38       	cp.w	r8,r12
8000cb68:	c0 63       	brcs	8000cb74 <__avr32_udiv64+0x11e>
8000cb6a:	16 38       	cp.w	r8,r11
8000cb6c:	f7 b9 03 01 	sublo	r9,1
8000cb70:	f1 dc e3 08 	addcs	r8,r8,r12
8000cb74:	f4 06 09 43 	lsl	r3,r10,r6
8000cb78:	f0 0b 01 0b 	sub	r11,r8,r11
8000cb7c:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000cb80:	f8 06 16 10 	lsr	r6,r12,0x10
8000cb84:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000cb88:	f6 06 0d 00 	divu	r0,r11,r6
8000cb8c:	e6 0b 16 10 	lsr	r11,r3,0x10
8000cb90:	00 9a       	mov	r10,r0
8000cb92:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000cb96:	e0 0e 02 48 	mul	r8,r0,lr
8000cb9a:	10 3b       	cp.w	r11,r8
8000cb9c:	c0 a2       	brcc	8000cbb0 <__avr32_udiv64+0x15a>
8000cb9e:	20 1a       	sub	r10,1
8000cba0:	18 0b       	add	r11,r12
8000cba2:	18 3b       	cp.w	r11,r12
8000cba4:	c0 63       	brcs	8000cbb0 <__avr32_udiv64+0x15a>
8000cba6:	10 3b       	cp.w	r11,r8
8000cba8:	f7 ba 03 01 	sublo	r10,1
8000cbac:	f7 dc e3 0b 	addcs	r11,r11,r12
8000cbb0:	f6 08 01 01 	sub	r1,r11,r8
8000cbb4:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000cbb8:	e2 06 0d 00 	divu	r0,r1,r6
8000cbbc:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000cbc0:	00 98       	mov	r8,r0
8000cbc2:	e0 0e 02 4b 	mul	r11,r0,lr
8000cbc6:	16 33       	cp.w	r3,r11
8000cbc8:	c0 82       	brcc	8000cbd8 <__avr32_udiv64+0x182>
8000cbca:	20 18       	sub	r8,1
8000cbcc:	18 03       	add	r3,r12
8000cbce:	18 33       	cp.w	r3,r12
8000cbd0:	c0 43       	brcs	8000cbd8 <__avr32_udiv64+0x182>
8000cbd2:	16 33       	cp.w	r3,r11
8000cbd4:	f7 b8 03 01 	sublo	r8,1
8000cbd8:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000cbdc:	c6 98       	rjmp	8000ccae <__avr32_udiv64+0x258>
8000cbde:	16 39       	cp.w	r9,r11
8000cbe0:	e0 8b 00 65 	brhi	8000ccaa <__avr32_udiv64+0x254>
8000cbe4:	f2 09 12 00 	clz	r9,r9
8000cbe8:	c0 b1       	brne	8000cbfe <__avr32_udiv64+0x1a8>
8000cbea:	10 3a       	cp.w	r10,r8
8000cbec:	5f 2a       	srhs	r10
8000cbee:	1c 3b       	cp.w	r11,lr
8000cbf0:	5f b8       	srhi	r8
8000cbf2:	10 4a       	or	r10,r8
8000cbf4:	f2 0a 18 00 	cp.b	r10,r9
8000cbf8:	c5 90       	breq	8000ccaa <__avr32_udiv64+0x254>
8000cbfa:	30 18       	mov	r8,1
8000cbfc:	c5 98       	rjmp	8000ccae <__avr32_udiv64+0x258>
8000cbfe:	f0 09 09 46 	lsl	r6,r8,r9
8000cc02:	f2 03 11 20 	rsub	r3,r9,32
8000cc06:	fc 09 09 4e 	lsl	lr,lr,r9
8000cc0a:	f0 03 0a 48 	lsr	r8,r8,r3
8000cc0e:	f6 09 09 4c 	lsl	r12,r11,r9
8000cc12:	f4 03 0a 42 	lsr	r2,r10,r3
8000cc16:	ef 46 ff f4 	st.w	r7[-12],r6
8000cc1a:	f6 03 0a 43 	lsr	r3,r11,r3
8000cc1e:	18 42       	or	r2,r12
8000cc20:	f1 ee 10 0c 	or	r12,r8,lr
8000cc24:	f8 01 16 10 	lsr	r1,r12,0x10
8000cc28:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000cc2c:	e6 01 0d 04 	divu	r4,r3,r1
8000cc30:	e4 03 16 10 	lsr	r3,r2,0x10
8000cc34:	08 9e       	mov	lr,r4
8000cc36:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000cc3a:	e8 06 02 48 	mul	r8,r4,r6
8000cc3e:	10 33       	cp.w	r3,r8
8000cc40:	c0 a2       	brcc	8000cc54 <__avr32_udiv64+0x1fe>
8000cc42:	20 1e       	sub	lr,1
8000cc44:	18 03       	add	r3,r12
8000cc46:	18 33       	cp.w	r3,r12
8000cc48:	c0 63       	brcs	8000cc54 <__avr32_udiv64+0x1fe>
8000cc4a:	10 33       	cp.w	r3,r8
8000cc4c:	f7 be 03 01 	sublo	lr,1
8000cc50:	e7 dc e3 03 	addcs	r3,r3,r12
8000cc54:	10 13       	sub	r3,r8
8000cc56:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000cc5a:	e6 01 0d 00 	divu	r0,r3,r1
8000cc5e:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000cc62:	00 98       	mov	r8,r0
8000cc64:	e0 06 02 46 	mul	r6,r0,r6
8000cc68:	0c 3b       	cp.w	r11,r6
8000cc6a:	c0 a2       	brcc	8000cc7e <__avr32_udiv64+0x228>
8000cc6c:	20 18       	sub	r8,1
8000cc6e:	18 0b       	add	r11,r12
8000cc70:	18 3b       	cp.w	r11,r12
8000cc72:	c0 63       	brcs	8000cc7e <__avr32_udiv64+0x228>
8000cc74:	0c 3b       	cp.w	r11,r6
8000cc76:	f7 dc e3 0b 	addcs	r11,r11,r12
8000cc7a:	f7 b8 03 01 	sublo	r8,1
8000cc7e:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000cc82:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000cc86:	0c 1b       	sub	r11,r6
8000cc88:	f0 04 06 42 	mulu.d	r2,r8,r4
8000cc8c:	06 95       	mov	r5,r3
8000cc8e:	16 35       	cp.w	r5,r11
8000cc90:	e0 8b 00 0a 	brhi	8000cca4 <__avr32_udiv64+0x24e>
8000cc94:	5f 0b       	sreq	r11
8000cc96:	f4 09 09 49 	lsl	r9,r10,r9
8000cc9a:	12 32       	cp.w	r2,r9
8000cc9c:	5f b9       	srhi	r9
8000cc9e:	f7 e9 00 09 	and	r9,r11,r9
8000cca2:	c0 60       	breq	8000ccae <__avr32_udiv64+0x258>
8000cca4:	20 18       	sub	r8,1
8000cca6:	30 09       	mov	r9,0
8000cca8:	c0 38       	rjmp	8000ccae <__avr32_udiv64+0x258>
8000ccaa:	30 09       	mov	r9,0
8000ccac:	12 98       	mov	r8,r9
8000ccae:	10 9a       	mov	r10,r8
8000ccb0:	12 93       	mov	r3,r9
8000ccb2:	10 92       	mov	r2,r8
8000ccb4:	12 9b       	mov	r11,r9
8000ccb6:	2f dd       	sub	sp,-12
8000ccb8:	d8 32       	popm	r0-r7,pc

8000ccba <memcpy>:
8000ccba:	58 8a       	cp.w	r10,8
8000ccbc:	c2 f5       	brlt	8000cd1a <memcpy+0x60>
8000ccbe:	f9 eb 10 09 	or	r9,r12,r11
8000ccc2:	e2 19 00 03 	andl	r9,0x3,COH
8000ccc6:	e0 81 00 97 	brne	8000cdf4 <memcpy+0x13a>
8000ccca:	e0 4a 00 20 	cp.w	r10,32
8000ccce:	c3 b4       	brge	8000cd44 <memcpy+0x8a>
8000ccd0:	f4 08 14 02 	asr	r8,r10,0x2
8000ccd4:	f0 09 11 08 	rsub	r9,r8,8
8000ccd8:	fe 09 00 2f 	add	pc,pc,r9<<0x2
8000ccdc:	76 69       	ld.w	r9,r11[0x18]
8000ccde:	99 69       	st.w	r12[0x18],r9
8000cce0:	76 59       	ld.w	r9,r11[0x14]
8000cce2:	99 59       	st.w	r12[0x14],r9
8000cce4:	76 49       	ld.w	r9,r11[0x10]
8000cce6:	99 49       	st.w	r12[0x10],r9
8000cce8:	76 39       	ld.w	r9,r11[0xc]
8000ccea:	99 39       	st.w	r12[0xc],r9
8000ccec:	76 29       	ld.w	r9,r11[0x8]
8000ccee:	99 29       	st.w	r12[0x8],r9
8000ccf0:	76 19       	ld.w	r9,r11[0x4]
8000ccf2:	99 19       	st.w	r12[0x4],r9
8000ccf4:	76 09       	ld.w	r9,r11[0x0]
8000ccf6:	99 09       	st.w	r12[0x0],r9
8000ccf8:	f6 08 00 2b 	add	r11,r11,r8<<0x2
8000ccfc:	f8 08 00 28 	add	r8,r12,r8<<0x2
8000cd00:	e0 1a 00 03 	andl	r10,0x3
8000cd04:	f4 0a 11 04 	rsub	r10,r10,4
8000cd08:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000cd0c:	17 a9       	ld.ub	r9,r11[0x2]
8000cd0e:	b0 a9       	st.b	r8[0x2],r9
8000cd10:	17 99       	ld.ub	r9,r11[0x1]
8000cd12:	b0 99       	st.b	r8[0x1],r9
8000cd14:	17 89       	ld.ub	r9,r11[0x0]
8000cd16:	b0 89       	st.b	r8[0x0],r9
8000cd18:	5e fc       	retal	r12
8000cd1a:	f4 0a 11 09 	rsub	r10,r10,9
8000cd1e:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000cd22:	17 f9       	ld.ub	r9,r11[0x7]
8000cd24:	b8 f9       	st.b	r12[0x7],r9
8000cd26:	17 e9       	ld.ub	r9,r11[0x6]
8000cd28:	b8 e9       	st.b	r12[0x6],r9
8000cd2a:	17 d9       	ld.ub	r9,r11[0x5]
8000cd2c:	b8 d9       	st.b	r12[0x5],r9
8000cd2e:	17 c9       	ld.ub	r9,r11[0x4]
8000cd30:	b8 c9       	st.b	r12[0x4],r9
8000cd32:	17 b9       	ld.ub	r9,r11[0x3]
8000cd34:	b8 b9       	st.b	r12[0x3],r9
8000cd36:	17 a9       	ld.ub	r9,r11[0x2]
8000cd38:	b8 a9       	st.b	r12[0x2],r9
8000cd3a:	17 99       	ld.ub	r9,r11[0x1]
8000cd3c:	b8 99       	st.b	r12[0x1],r9
8000cd3e:	17 89       	ld.ub	r9,r11[0x0]
8000cd40:	b8 89       	st.b	r12[0x0],r9
8000cd42:	5e fc       	retal	r12
8000cd44:	eb cd 40 c0 	pushm	r6-r7,lr
8000cd48:	18 99       	mov	r9,r12
8000cd4a:	22 0a       	sub	r10,32
8000cd4c:	b7 07       	ld.d	r6,r11++
8000cd4e:	b3 26       	st.d	r9++,r6
8000cd50:	b7 07       	ld.d	r6,r11++
8000cd52:	b3 26       	st.d	r9++,r6
8000cd54:	b7 07       	ld.d	r6,r11++
8000cd56:	b3 26       	st.d	r9++,r6
8000cd58:	b7 07       	ld.d	r6,r11++
8000cd5a:	b3 26       	st.d	r9++,r6
8000cd5c:	22 0a       	sub	r10,32
8000cd5e:	cf 74       	brge	8000cd4c <memcpy+0x92>
8000cd60:	2f 0a       	sub	r10,-16
8000cd62:	c0 65       	brlt	8000cd6e <memcpy+0xb4>
8000cd64:	b7 07       	ld.d	r6,r11++
8000cd66:	b3 26       	st.d	r9++,r6
8000cd68:	b7 07       	ld.d	r6,r11++
8000cd6a:	b3 26       	st.d	r9++,r6
8000cd6c:	21 0a       	sub	r10,16
8000cd6e:	5c 3a       	neg	r10
8000cd70:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
8000cd74:	d7 03       	nop
8000cd76:	d7 03       	nop
8000cd78:	f7 36 00 0e 	ld.ub	r6,r11[14]
8000cd7c:	f3 66 00 0e 	st.b	r9[14],r6
8000cd80:	f7 36 00 0d 	ld.ub	r6,r11[13]
8000cd84:	f3 66 00 0d 	st.b	r9[13],r6
8000cd88:	f7 36 00 0c 	ld.ub	r6,r11[12]
8000cd8c:	f3 66 00 0c 	st.b	r9[12],r6
8000cd90:	f7 36 00 0b 	ld.ub	r6,r11[11]
8000cd94:	f3 66 00 0b 	st.b	r9[11],r6
8000cd98:	f7 36 00 0a 	ld.ub	r6,r11[10]
8000cd9c:	f3 66 00 0a 	st.b	r9[10],r6
8000cda0:	f7 36 00 09 	ld.ub	r6,r11[9]
8000cda4:	f3 66 00 09 	st.b	r9[9],r6
8000cda8:	f7 36 00 08 	ld.ub	r6,r11[8]
8000cdac:	f3 66 00 08 	st.b	r9[8],r6
8000cdb0:	f7 36 00 07 	ld.ub	r6,r11[7]
8000cdb4:	f3 66 00 07 	st.b	r9[7],r6
8000cdb8:	f7 36 00 06 	ld.ub	r6,r11[6]
8000cdbc:	f3 66 00 06 	st.b	r9[6],r6
8000cdc0:	f7 36 00 05 	ld.ub	r6,r11[5]
8000cdc4:	f3 66 00 05 	st.b	r9[5],r6
8000cdc8:	f7 36 00 04 	ld.ub	r6,r11[4]
8000cdcc:	f3 66 00 04 	st.b	r9[4],r6
8000cdd0:	f7 36 00 03 	ld.ub	r6,r11[3]
8000cdd4:	f3 66 00 03 	st.b	r9[3],r6
8000cdd8:	f7 36 00 02 	ld.ub	r6,r11[2]
8000cddc:	f3 66 00 02 	st.b	r9[2],r6
8000cde0:	f7 36 00 01 	ld.ub	r6,r11[1]
8000cde4:	f3 66 00 01 	st.b	r9[1],r6
8000cde8:	f7 36 00 00 	ld.ub	r6,r11[0]
8000cdec:	f3 66 00 00 	st.b	r9[0],r6
8000cdf0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000cdf4:	20 1a       	sub	r10,1
8000cdf6:	f6 0a 07 09 	ld.ub	r9,r11[r10]
8000cdfa:	f8 0a 0b 09 	st.b	r12[r10],r9
8000cdfe:	cf b1       	brne	8000cdf4 <memcpy+0x13a>
8000ce00:	5e fc       	retal	r12

8000ce02 <memset>:
8000ce02:	18 98       	mov	r8,r12
8000ce04:	c0 38       	rjmp	8000ce0a <memset+0x8>
8000ce06:	10 cb       	st.b	r8++,r11
8000ce08:	20 1a       	sub	r10,1
8000ce0a:	58 0a       	cp.w	r10,0
8000ce0c:	cf d1       	brne	8000ce06 <memset+0x4>
8000ce0e:	5e fc       	retal	r12

8000ce10 <sprintf>:
8000ce10:	d4 01       	pushm	lr
8000ce12:	21 7d       	sub	sp,92
8000ce14:	e0 68 ff ff 	mov	r8,65535
8000ce18:	ea 18 7f ff 	orh	r8,0x7fff
8000ce1c:	50 58       	stdsp	sp[0x14],r8
8000ce1e:	50 28       	stdsp	sp[0x8],r8
8000ce20:	e0 68 02 08 	mov	r8,520
8000ce24:	ba 68       	st.h	sp[0xc],r8
8000ce26:	3f f8       	mov	r8,-1
8000ce28:	ba 78       	st.h	sp[0xe],r8
8000ce2a:	48 88       	lddpc	r8,8000ce48 <sprintf+0x38>
8000ce2c:	50 4c       	stdsp	sp[0x10],r12
8000ce2e:	16 9a       	mov	r10,r11
8000ce30:	50 0c       	stdsp	sp[0x0],r12
8000ce32:	fa c9 ff a0 	sub	r9,sp,-96
8000ce36:	70 0c       	ld.w	r12,r8[0x0]
8000ce38:	1a 9b       	mov	r11,sp
8000ce3a:	f0 1f 00 05 	mcall	8000ce4c <sprintf+0x3c>
8000ce3e:	30 09       	mov	r9,0
8000ce40:	40 08       	lddsp	r8,sp[0x0]
8000ce42:	b0 89       	st.b	r8[0x0],r9
8000ce44:	2e 9d       	sub	sp,-92
8000ce46:	d8 02       	popm	pc
8000ce48:	00 00       	add	r0,r0
8000ce4a:	01 a8       	ld.ub	r8,r0[0x2]
8000ce4c:	80 00       	ld.sh	r0,r0[0x0]
8000ce4e:	d1 cc       	*unknown*

8000ce50 <strlen>:
8000ce50:	30 09       	mov	r9,0
8000ce52:	18 98       	mov	r8,r12
8000ce54:	c0 28       	rjmp	8000ce58 <strlen+0x8>
8000ce56:	2f f8       	sub	r8,-1
8000ce58:	11 8a       	ld.ub	r10,r8[0x0]
8000ce5a:	f2 0a 18 00 	cp.b	r10,r9
8000ce5e:	cf c1       	brne	8000ce56 <strlen+0x6>
8000ce60:	f0 0c 01 0c 	sub	r12,r8,r12
8000ce64:	5e fc       	retal	r12
8000ce66:	d7 03       	nop

8000ce68 <strncpy>:
8000ce68:	30 08       	mov	r8,0
8000ce6a:	10 3a       	cp.w	r10,r8
8000ce6c:	5e 0c       	reteq	r12
8000ce6e:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000ce72:	f8 08 0b 09 	st.b	r12[r8],r9
8000ce76:	2f f8       	sub	r8,-1
8000ce78:	58 09       	cp.w	r9,0
8000ce7a:	cf 81       	brne	8000ce6a <strncpy+0x2>
8000ce7c:	10 3a       	cp.w	r10,r8
8000ce7e:	5e 0c       	reteq	r12
8000ce80:	f8 08 0b 09 	st.b	r12[r8],r9
8000ce84:	2f f8       	sub	r8,-1
8000ce86:	cf bb       	rjmp	8000ce7c <strncpy+0x14>

8000ce88 <get_arg>:
8000ce88:	d4 31       	pushm	r0-r7,lr
8000ce8a:	20 8d       	sub	sp,32
8000ce8c:	fa c4 ff bc 	sub	r4,sp,-68
8000ce90:	50 4b       	stdsp	sp[0x10],r11
8000ce92:	68 2e       	ld.w	lr,r4[0x8]
8000ce94:	50 58       	stdsp	sp[0x14],r8
8000ce96:	12 96       	mov	r6,r9
8000ce98:	7c 0b       	ld.w	r11,lr[0x0]
8000ce9a:	70 05       	ld.w	r5,r8[0x0]
8000ce9c:	50 6e       	stdsp	sp[0x18],lr
8000ce9e:	58 0b       	cp.w	r11,0
8000cea0:	f4 0b 17 00 	moveq	r11,r10
8000cea4:	68 03       	ld.w	r3,r4[0x0]
8000cea6:	68 11       	ld.w	r1,r4[0x4]
8000cea8:	40 49       	lddsp	r9,sp[0x10]
8000ceaa:	30 08       	mov	r8,0
8000ceac:	c2 e9       	rjmp	8000d108 <get_arg+0x280>
8000ceae:	2f fb       	sub	r11,-1
8000ceb0:	32 5c       	mov	r12,37
8000ceb2:	17 8a       	ld.ub	r10,r11[0x0]
8000ceb4:	f8 0a 18 00 	cp.b	r10,r12
8000ceb8:	5f 1e       	srne	lr
8000ceba:	f0 0a 18 00 	cp.b	r10,r8
8000cebe:	5f 1c       	srne	r12
8000cec0:	fd ec 00 0c 	and	r12,lr,r12
8000cec4:	f0 0c 18 00 	cp.b	r12,r8
8000cec8:	cf 31       	brne	8000ceae <get_arg+0x26>
8000ceca:	58 0a       	cp.w	r10,0
8000cecc:	e0 80 01 2b 	breq	8000d122 <get_arg+0x29a>
8000ced0:	30 0c       	mov	r12,0
8000ced2:	3f fa       	mov	r10,-1
8000ced4:	18 90       	mov	r0,r12
8000ced6:	50 3a       	stdsp	sp[0xc],r10
8000ced8:	18 94       	mov	r4,r12
8000ceda:	18 92       	mov	r2,r12
8000cedc:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
8000cee0:	16 97       	mov	r7,r11
8000cee2:	50 7c       	stdsp	sp[0x1c],r12
8000cee4:	4c ec       	lddpc	r12,8000d01c <get_arg+0x194>
8000cee6:	0f 3a       	ld.ub	r10,r7++
8000cee8:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
8000ceec:	40 7c       	lddsp	r12,sp[0x1c]
8000ceee:	1c 0c       	add	r12,lr
8000cef0:	4c ce       	lddpc	lr,8000d020 <get_arg+0x198>
8000cef2:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
8000cef6:	20 1e       	sub	lr,1
8000cef8:	50 0e       	stdsp	sp[0x0],lr
8000cefa:	4c be       	lddpc	lr,8000d024 <get_arg+0x19c>
8000cefc:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
8000cf00:	50 7c       	stdsp	sp[0x1c],r12
8000cf02:	40 0c       	lddsp	r12,sp[0x0]
8000cf04:	58 7c       	cp.w	r12,7
8000cf06:	e0 8b 00 fa 	brhi	8000d0fa <get_arg+0x272>
8000cf0a:	4c 8e       	lddpc	lr,8000d028 <get_arg+0x1a0>
8000cf0c:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
8000cf10:	36 8b       	mov	r11,104
8000cf12:	f6 0a 18 00 	cp.b	r10,r11
8000cf16:	e0 80 00 f2 	breq	8000d0fa <get_arg+0x272>
8000cf1a:	37 1b       	mov	r11,113
8000cf1c:	f6 0a 18 00 	cp.b	r10,r11
8000cf20:	c0 70       	breq	8000cf2e <get_arg+0xa6>
8000cf22:	34 cb       	mov	r11,76
8000cf24:	f6 0a 18 00 	cp.b	r10,r11
8000cf28:	c0 51       	brne	8000cf32 <get_arg+0xaa>
8000cf2a:	a3 b4       	sbr	r4,0x3
8000cf2c:	ce 78       	rjmp	8000d0fa <get_arg+0x272>
8000cf2e:	a5 b4       	sbr	r4,0x5
8000cf30:	ce 58       	rjmp	8000d0fa <get_arg+0x272>
8000cf32:	08 9a       	mov	r10,r4
8000cf34:	0e 9b       	mov	r11,r7
8000cf36:	a5 aa       	sbr	r10,0x4
8000cf38:	17 3c       	ld.ub	r12,r11++
8000cf3a:	a5 b4       	sbr	r4,0x5
8000cf3c:	36 ce       	mov	lr,108
8000cf3e:	fc 0c 18 00 	cp.b	r12,lr
8000cf42:	e0 80 00 dd 	breq	8000d0fc <get_arg+0x274>
8000cf46:	14 94       	mov	r4,r10
8000cf48:	cd 98       	rjmp	8000d0fa <get_arg+0x272>
8000cf4a:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
8000cf4e:	36 7c       	mov	r12,103
8000cf50:	f8 0a 18 00 	cp.b	r10,r12
8000cf54:	e0 8b 00 27 	brhi	8000cfa2 <get_arg+0x11a>
8000cf58:	36 5b       	mov	r11,101
8000cf5a:	f6 0a 18 00 	cp.b	r10,r11
8000cf5e:	c4 82       	brcc	8000cfee <get_arg+0x166>
8000cf60:	34 fb       	mov	r11,79
8000cf62:	f6 0a 18 00 	cp.b	r10,r11
8000cf66:	c4 80       	breq	8000cff6 <get_arg+0x16e>
8000cf68:	e0 8b 00 0c 	brhi	8000cf80 <get_arg+0xf8>
8000cf6c:	34 5b       	mov	r11,69
8000cf6e:	f6 0a 18 00 	cp.b	r10,r11
8000cf72:	c3 e0       	breq	8000cfee <get_arg+0x166>
8000cf74:	34 7b       	mov	r11,71
8000cf76:	f6 0a 18 00 	cp.b	r10,r11
8000cf7a:	c3 a0       	breq	8000cfee <get_arg+0x166>
8000cf7c:	34 4b       	mov	r11,68
8000cf7e:	c0 88       	rjmp	8000cf8e <get_arg+0x106>
8000cf80:	35 8b       	mov	r11,88
8000cf82:	f6 0a 18 00 	cp.b	r10,r11
8000cf86:	c2 c0       	breq	8000cfde <get_arg+0x156>
8000cf88:	e0 8b 00 07 	brhi	8000cf96 <get_arg+0x10e>
8000cf8c:	35 5b       	mov	r11,85
8000cf8e:	f6 0a 18 00 	cp.b	r10,r11
8000cf92:	c3 51       	brne	8000cffc <get_arg+0x174>
8000cf94:	c3 18       	rjmp	8000cff6 <get_arg+0x16e>
8000cf96:	36 3b       	mov	r11,99
8000cf98:	f6 0a 18 00 	cp.b	r10,r11
8000cf9c:	c2 f0       	breq	8000cffa <get_arg+0x172>
8000cf9e:	36 4b       	mov	r11,100
8000cfa0:	c0 e8       	rjmp	8000cfbc <get_arg+0x134>
8000cfa2:	37 0b       	mov	r11,112
8000cfa4:	f6 0a 18 00 	cp.b	r10,r11
8000cfa8:	c2 50       	breq	8000cff2 <get_arg+0x16a>
8000cfaa:	e0 8b 00 0d 	brhi	8000cfc4 <get_arg+0x13c>
8000cfae:	36 eb       	mov	r11,110
8000cfb0:	f6 0a 18 00 	cp.b	r10,r11
8000cfb4:	c1 f0       	breq	8000cff2 <get_arg+0x16a>
8000cfb6:	e0 8b 00 14 	brhi	8000cfde <get_arg+0x156>
8000cfba:	36 9b       	mov	r11,105
8000cfbc:	f6 0a 18 00 	cp.b	r10,r11
8000cfc0:	c1 e1       	brne	8000cffc <get_arg+0x174>
8000cfc2:	c0 e8       	rjmp	8000cfde <get_arg+0x156>
8000cfc4:	37 5b       	mov	r11,117
8000cfc6:	f6 0a 18 00 	cp.b	r10,r11
8000cfca:	c0 a0       	breq	8000cfde <get_arg+0x156>
8000cfcc:	37 8b       	mov	r11,120
8000cfce:	f6 0a 18 00 	cp.b	r10,r11
8000cfd2:	c0 60       	breq	8000cfde <get_arg+0x156>
8000cfd4:	37 3b       	mov	r11,115
8000cfd6:	f6 0a 18 00 	cp.b	r10,r11
8000cfda:	c1 11       	brne	8000cffc <get_arg+0x174>
8000cfdc:	c0 b8       	rjmp	8000cff2 <get_arg+0x16a>
8000cfde:	ed b4 00 04 	bld	r4,0x4
8000cfe2:	c0 a0       	breq	8000cff6 <get_arg+0x16e>
8000cfe4:	ed b4 00 05 	bld	r4,0x5
8000cfe8:	c0 91       	brne	8000cffa <get_arg+0x172>
8000cfea:	30 20       	mov	r0,2
8000cfec:	c0 88       	rjmp	8000cffc <get_arg+0x174>
8000cfee:	30 40       	mov	r0,4
8000cff0:	c0 68       	rjmp	8000cffc <get_arg+0x174>
8000cff2:	30 30       	mov	r0,3
8000cff4:	c0 48       	rjmp	8000cffc <get_arg+0x174>
8000cff6:	30 10       	mov	r0,1
8000cff8:	c0 28       	rjmp	8000cffc <get_arg+0x174>
8000cffa:	30 00       	mov	r0,0
8000cffc:	40 3b       	lddsp	r11,sp[0xc]
8000cffe:	5b fb       	cp.w	r11,-1
8000d000:	c0 40       	breq	8000d008 <get_arg+0x180>
8000d002:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
8000d006:	c7 a8       	rjmp	8000d0fa <get_arg+0x272>
8000d008:	58 60       	cp.w	r0,6
8000d00a:	e0 8b 00 78 	brhi	8000d0fa <get_arg+0x272>
8000d00e:	6c 0a       	ld.w	r10,r6[0x0]
8000d010:	ea cc ff ff 	sub	r12,r5,-1
8000d014:	48 6e       	lddpc	lr,8000d02c <get_arg+0x1a4>
8000d016:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
8000d01a:	00 00       	add	r0,r0
8000d01c:	80 01       	ld.sh	r1,r0[0x0]
8000d01e:	2a 2c       	sub	r12,-94
8000d020:	80 01       	ld.sh	r1,r0[0x0]
8000d022:	29 64       	sub	r4,-106
8000d024:	80 01       	ld.sh	r1,r0[0x0]
8000d026:	28 f8       	sub	r8,-113
8000d028:	80 01       	ld.sh	r1,r0[0x0]
8000d02a:	27 58       	sub	r8,117
8000d02c:	80 01       	ld.sh	r1,r0[0x0]
8000d02e:	27 78       	sub	r8,119
8000d030:	f4 cb ff f8 	sub	r11,r10,-8
8000d034:	8d 0b       	st.w	r6[0x0],r11
8000d036:	f4 ea 00 00 	ld.d	r10,r10[0]
8000d03a:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
8000d03e:	c0 f8       	rjmp	8000d05c <get_arg+0x1d4>
8000d040:	f4 cb ff fc 	sub	r11,r10,-4
8000d044:	8d 0b       	st.w	r6[0x0],r11
8000d046:	74 0a       	ld.w	r10,r10[0x0]
8000d048:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
8000d04c:	c0 88       	rjmp	8000d05c <get_arg+0x1d4>
8000d04e:	f4 cb ff f8 	sub	r11,r10,-8
8000d052:	8d 0b       	st.w	r6[0x0],r11
8000d054:	f4 ea 00 00 	ld.d	r10,r10[0]
8000d058:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
8000d05c:	0e 9b       	mov	r11,r7
8000d05e:	18 95       	mov	r5,r12
8000d060:	c4 e8       	rjmp	8000d0fc <get_arg+0x274>
8000d062:	62 0a       	ld.w	r10,r1[0x0]
8000d064:	5b fa       	cp.w	r10,-1
8000d066:	c0 b1       	brne	8000d07c <get_arg+0x1f4>
8000d068:	50 19       	stdsp	sp[0x4],r9
8000d06a:	50 28       	stdsp	sp[0x8],r8
8000d06c:	e0 6a 00 80 	mov	r10,128
8000d070:	30 0b       	mov	r11,0
8000d072:	02 9c       	mov	r12,r1
8000d074:	f0 1f 00 4d 	mcall	8000d1a8 <get_arg+0x320>
8000d078:	40 28       	lddsp	r8,sp[0x8]
8000d07a:	40 19       	lddsp	r9,sp[0x4]
8000d07c:	e4 cc 00 01 	sub	r12,r2,1
8000d080:	0e 9b       	mov	r11,r7
8000d082:	50 3c       	stdsp	sp[0xc],r12
8000d084:	f2 0c 0c 49 	max	r9,r9,r12
8000d088:	c3 a8       	rjmp	8000d0fc <get_arg+0x274>
8000d08a:	62 0a       	ld.w	r10,r1[0x0]
8000d08c:	5b fa       	cp.w	r10,-1
8000d08e:	c0 b1       	brne	8000d0a4 <get_arg+0x21c>
8000d090:	50 19       	stdsp	sp[0x4],r9
8000d092:	50 28       	stdsp	sp[0x8],r8
8000d094:	e0 6a 00 80 	mov	r10,128
8000d098:	30 0b       	mov	r11,0
8000d09a:	02 9c       	mov	r12,r1
8000d09c:	f0 1f 00 43 	mcall	8000d1a8 <get_arg+0x320>
8000d0a0:	40 28       	lddsp	r8,sp[0x8]
8000d0a2:	40 19       	lddsp	r9,sp[0x4]
8000d0a4:	20 12       	sub	r2,1
8000d0a6:	30 0a       	mov	r10,0
8000d0a8:	0e 9b       	mov	r11,r7
8000d0aa:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
8000d0ae:	f2 02 0c 49 	max	r9,r9,r2
8000d0b2:	c2 58       	rjmp	8000d0fc <get_arg+0x274>
8000d0b4:	16 97       	mov	r7,r11
8000d0b6:	6c 0a       	ld.w	r10,r6[0x0]
8000d0b8:	f4 cb ff fc 	sub	r11,r10,-4
8000d0bc:	8d 0b       	st.w	r6[0x0],r11
8000d0be:	74 0a       	ld.w	r10,r10[0x0]
8000d0c0:	0e 9b       	mov	r11,r7
8000d0c2:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
8000d0c6:	2f f5       	sub	r5,-1
8000d0c8:	c1 a8       	rjmp	8000d0fc <get_arg+0x274>
8000d0ca:	f4 c2 00 30 	sub	r2,r10,48
8000d0ce:	c0 68       	rjmp	8000d0da <get_arg+0x252>
8000d0d0:	e4 02 00 22 	add	r2,r2,r2<<0x2
8000d0d4:	2f f7       	sub	r7,-1
8000d0d6:	f4 02 00 12 	add	r2,r10,r2<<0x1
8000d0da:	0f 8a       	ld.ub	r10,r7[0x0]
8000d0dc:	58 0a       	cp.w	r10,0
8000d0de:	c0 e0       	breq	8000d0fa <get_arg+0x272>
8000d0e0:	23 0a       	sub	r10,48
8000d0e2:	58 9a       	cp.w	r10,9
8000d0e4:	fe 98 ff f6 	brls	8000d0d0 <get_arg+0x248>
8000d0e8:	c0 98       	rjmp	8000d0fa <get_arg+0x272>
8000d0ea:	2f f7       	sub	r7,-1
8000d0ec:	0f 8a       	ld.ub	r10,r7[0x0]
8000d0ee:	58 0a       	cp.w	r10,0
8000d0f0:	c0 50       	breq	8000d0fa <get_arg+0x272>
8000d0f2:	23 0a       	sub	r10,48
8000d0f4:	58 9a       	cp.w	r10,9
8000d0f6:	fe 98 ff fa 	brls	8000d0ea <get_arg+0x262>
8000d0fa:	0e 9b       	mov	r11,r7
8000d0fc:	40 7c       	lddsp	r12,sp[0x1c]
8000d0fe:	30 ba       	mov	r10,11
8000d100:	f4 0c 18 00 	cp.b	r12,r10
8000d104:	fe 91 fe ec 	brne	8000cedc <get_arg+0x54>
8000d108:	40 42       	lddsp	r2,sp[0x10]
8000d10a:	17 8c       	ld.ub	r12,r11[0x0]
8000d10c:	0a 32       	cp.w	r2,r5
8000d10e:	5f 4a       	srge	r10
8000d110:	f0 0c 18 00 	cp.b	r12,r8
8000d114:	5f 1c       	srne	r12
8000d116:	f9 ea 00 0a 	and	r10,r12,r10
8000d11a:	f0 0a 18 00 	cp.b	r10,r8
8000d11e:	fe 91 fe c9 	brne	8000ceb0 <get_arg+0x28>
8000d122:	30 08       	mov	r8,0
8000d124:	40 4e       	lddsp	lr,sp[0x10]
8000d126:	17 8a       	ld.ub	r10,r11[0x0]
8000d128:	e2 05 00 21 	add	r1,r1,r5<<0x2
8000d12c:	f0 0a 18 00 	cp.b	r10,r8
8000d130:	fc 09 17 10 	movne	r9,lr
8000d134:	e6 05 00 38 	add	r8,r3,r5<<0x3
8000d138:	06 9e       	mov	lr,r3
8000d13a:	c2 a8       	rjmp	8000d18e <get_arg+0x306>
8000d13c:	62 0a       	ld.w	r10,r1[0x0]
8000d13e:	58 3a       	cp.w	r10,3
8000d140:	c1 e0       	breq	8000d17c <get_arg+0x2f4>
8000d142:	e0 89 00 07 	brgt	8000d150 <get_arg+0x2c8>
8000d146:	58 1a       	cp.w	r10,1
8000d148:	c1 a0       	breq	8000d17c <get_arg+0x2f4>
8000d14a:	58 2a       	cp.w	r10,2
8000d14c:	c1 81       	brne	8000d17c <get_arg+0x2f4>
8000d14e:	c0 58       	rjmp	8000d158 <get_arg+0x2d0>
8000d150:	58 5a       	cp.w	r10,5
8000d152:	c0 c0       	breq	8000d16a <get_arg+0x2e2>
8000d154:	c0 b5       	brlt	8000d16a <get_arg+0x2e2>
8000d156:	c1 38       	rjmp	8000d17c <get_arg+0x2f4>
8000d158:	6c 0a       	ld.w	r10,r6[0x0]
8000d15a:	f4 cc ff f8 	sub	r12,r10,-8
8000d15e:	8d 0c       	st.w	r6[0x0],r12
8000d160:	f4 e2 00 00 	ld.d	r2,r10[0]
8000d164:	f0 e3 00 00 	st.d	r8[0],r2
8000d168:	c1 08       	rjmp	8000d188 <get_arg+0x300>
8000d16a:	6c 0a       	ld.w	r10,r6[0x0]
8000d16c:	f4 cc ff f8 	sub	r12,r10,-8
8000d170:	8d 0c       	st.w	r6[0x0],r12
8000d172:	f4 e2 00 00 	ld.d	r2,r10[0]
8000d176:	f0 e3 00 00 	st.d	r8[0],r2
8000d17a:	c0 78       	rjmp	8000d188 <get_arg+0x300>
8000d17c:	6c 0a       	ld.w	r10,r6[0x0]
8000d17e:	f4 cc ff fc 	sub	r12,r10,-4
8000d182:	8d 0c       	st.w	r6[0x0],r12
8000d184:	74 0a       	ld.w	r10,r10[0x0]
8000d186:	91 0a       	st.w	r8[0x0],r10
8000d188:	2f f5       	sub	r5,-1
8000d18a:	2f 88       	sub	r8,-8
8000d18c:	2f c1       	sub	r1,-4
8000d18e:	12 35       	cp.w	r5,r9
8000d190:	fe 9a ff d6 	brle	8000d13c <get_arg+0x2b4>
8000d194:	1c 93       	mov	r3,lr
8000d196:	40 52       	lddsp	r2,sp[0x14]
8000d198:	40 6e       	lddsp	lr,sp[0x18]
8000d19a:	85 05       	st.w	r2[0x0],r5
8000d19c:	9d 0b       	st.w	lr[0x0],r11
8000d19e:	40 4b       	lddsp	r11,sp[0x10]
8000d1a0:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
8000d1a4:	2f 8d       	sub	sp,-32
8000d1a6:	d8 32       	popm	r0-r7,pc
8000d1a8:	80 00       	ld.sh	r0,r0[0x0]
8000d1aa:	ce 02       	brcc	8000d16a <get_arg+0x2e2>

8000d1ac <__sprint_r>:
8000d1ac:	d4 21       	pushm	r4-r7,lr
8000d1ae:	14 97       	mov	r7,r10
8000d1b0:	74 28       	ld.w	r8,r10[0x8]
8000d1b2:	58 08       	cp.w	r8,0
8000d1b4:	c0 41       	brne	8000d1bc <__sprint_r+0x10>
8000d1b6:	95 18       	st.w	r10[0x4],r8
8000d1b8:	10 9c       	mov	r12,r8
8000d1ba:	d8 22       	popm	r4-r7,pc
8000d1bc:	f0 1f 00 03 	mcall	8000d1c8 <__sprint_r+0x1c>
8000d1c0:	30 08       	mov	r8,0
8000d1c2:	8f 18       	st.w	r7[0x4],r8
8000d1c4:	8f 28       	st.w	r7[0x8],r8
8000d1c6:	d8 22       	popm	r4-r7,pc
8000d1c8:	80 01       	ld.sh	r1,r0[0x0]
8000d1ca:	04 d8       	st.w	--r2,r8

8000d1cc <_vfprintf_r>:
8000d1cc:	d4 31       	pushm	r0-r7,lr
8000d1ce:	fa cd 06 bc 	sub	sp,sp,1724
8000d1d2:	51 09       	stdsp	sp[0x40],r9
8000d1d4:	16 91       	mov	r1,r11
8000d1d6:	14 97       	mov	r7,r10
8000d1d8:	18 95       	mov	r5,r12
8000d1da:	f0 1f 00 56 	mcall	8000d330 <_vfprintf_r+0x164>
8000d1de:	78 0c       	ld.w	r12,r12[0x0]
8000d1e0:	50 cc       	stdsp	sp[0x30],r12
8000d1e2:	58 05       	cp.w	r5,0
8000d1e4:	c0 70       	breq	8000d1f2 <_vfprintf_r+0x26>
8000d1e6:	6a 68       	ld.w	r8,r5[0x18]
8000d1e8:	58 08       	cp.w	r8,0
8000d1ea:	c0 41       	brne	8000d1f2 <_vfprintf_r+0x26>
8000d1ec:	0a 9c       	mov	r12,r5
8000d1ee:	f0 1f 00 52 	mcall	8000d334 <_vfprintf_r+0x168>
8000d1f2:	4d 28       	lddpc	r8,8000d338 <_vfprintf_r+0x16c>
8000d1f4:	10 31       	cp.w	r1,r8
8000d1f6:	c0 31       	brne	8000d1fc <_vfprintf_r+0x30>
8000d1f8:	6a 01       	ld.w	r1,r5[0x0]
8000d1fa:	c0 a8       	rjmp	8000d20e <_vfprintf_r+0x42>
8000d1fc:	4d 08       	lddpc	r8,8000d33c <_vfprintf_r+0x170>
8000d1fe:	10 31       	cp.w	r1,r8
8000d200:	c0 31       	brne	8000d206 <_vfprintf_r+0x3a>
8000d202:	6a 11       	ld.w	r1,r5[0x4]
8000d204:	c0 58       	rjmp	8000d20e <_vfprintf_r+0x42>
8000d206:	4c f8       	lddpc	r8,8000d340 <_vfprintf_r+0x174>
8000d208:	10 31       	cp.w	r1,r8
8000d20a:	eb f1 00 02 	ld.weq	r1,r5[0x8]
8000d20e:	82 68       	ld.sh	r8,r1[0xc]
8000d210:	ed b8 00 03 	bld	r8,0x3
8000d214:	c0 41       	brne	8000d21c <_vfprintf_r+0x50>
8000d216:	62 48       	ld.w	r8,r1[0x10]
8000d218:	58 08       	cp.w	r8,0
8000d21a:	c0 71       	brne	8000d228 <_vfprintf_r+0x5c>
8000d21c:	02 9b       	mov	r11,r1
8000d21e:	0a 9c       	mov	r12,r5
8000d220:	f0 1f 00 49 	mcall	8000d344 <_vfprintf_r+0x178>
8000d224:	e0 81 0f 99 	brne	8000f156 <_vfprintf_r+0x1f8a>
8000d228:	82 68       	ld.sh	r8,r1[0xc]
8000d22a:	10 99       	mov	r9,r8
8000d22c:	e2 19 00 1a 	andl	r9,0x1a,COH
8000d230:	58 a9       	cp.w	r9,10
8000d232:	c3 d1       	brne	8000d2ac <_vfprintf_r+0xe0>
8000d234:	82 79       	ld.sh	r9,r1[0xe]
8000d236:	30 0a       	mov	r10,0
8000d238:	f4 09 19 00 	cp.h	r9,r10
8000d23c:	c3 85       	brlt	8000d2ac <_vfprintf_r+0xe0>
8000d23e:	a1 d8       	cbr	r8,0x1
8000d240:	fb 58 05 d0 	st.h	sp[1488],r8
8000d244:	62 88       	ld.w	r8,r1[0x20]
8000d246:	fb 48 05 e4 	st.w	sp[1508],r8
8000d24a:	62 a8       	ld.w	r8,r1[0x28]
8000d24c:	fb 48 05 ec 	st.w	sp[1516],r8
8000d250:	fa c8 ff bc 	sub	r8,sp,-68
8000d254:	fb 48 05 d4 	st.w	sp[1492],r8
8000d258:	fb 48 05 c4 	st.w	sp[1476],r8
8000d25c:	e0 68 04 00 	mov	r8,1024
8000d260:	fb 48 05 d8 	st.w	sp[1496],r8
8000d264:	fb 48 05 cc 	st.w	sp[1484],r8
8000d268:	30 08       	mov	r8,0
8000d26a:	fb 59 05 d2 	st.h	sp[1490],r9
8000d26e:	0e 9a       	mov	r10,r7
8000d270:	41 09       	lddsp	r9,sp[0x40]
8000d272:	fa c7 fa 3c 	sub	r7,sp,-1476
8000d276:	fb 48 05 dc 	st.w	sp[1500],r8
8000d27a:	0a 9c       	mov	r12,r5
8000d27c:	0e 9b       	mov	r11,r7
8000d27e:	f0 1f 00 33 	mcall	8000d348 <_vfprintf_r+0x17c>
8000d282:	50 bc       	stdsp	sp[0x2c],r12
8000d284:	c0 95       	brlt	8000d296 <_vfprintf_r+0xca>
8000d286:	0e 9b       	mov	r11,r7
8000d288:	0a 9c       	mov	r12,r5
8000d28a:	f0 1f 00 31 	mcall	8000d34c <_vfprintf_r+0x180>
8000d28e:	40 be       	lddsp	lr,sp[0x2c]
8000d290:	f9 be 01 ff 	movne	lr,-1
8000d294:	50 be       	stdsp	sp[0x2c],lr
8000d296:	fb 08 05 d0 	ld.sh	r8,sp[1488]
8000d29a:	ed b8 00 06 	bld	r8,0x6
8000d29e:	e0 81 0f 5e 	brne	8000f15a <_vfprintf_r+0x1f8e>
8000d2a2:	82 68       	ld.sh	r8,r1[0xc]
8000d2a4:	a7 a8       	sbr	r8,0x6
8000d2a6:	a2 68       	st.h	r1[0xc],r8
8000d2a8:	e0 8f 0f 59 	bral	8000f15a <_vfprintf_r+0x1f8e>
8000d2ac:	30 08       	mov	r8,0
8000d2ae:	fb 48 06 b4 	st.w	sp[1716],r8
8000d2b2:	fb 48 06 90 	st.w	sp[1680],r8
8000d2b6:	fb 48 06 8c 	st.w	sp[1676],r8
8000d2ba:	fb 48 06 b0 	st.w	sp[1712],r8
8000d2be:	30 08       	mov	r8,0
8000d2c0:	30 09       	mov	r9,0
8000d2c2:	50 a7       	stdsp	sp[0x28],r7
8000d2c4:	50 78       	stdsp	sp[0x1c],r8
8000d2c6:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d2ca:	3f f8       	mov	r8,-1
8000d2cc:	50 59       	stdsp	sp[0x14],r9
8000d2ce:	fb 43 06 88 	st.w	sp[1672],r3
8000d2d2:	fb 48 05 44 	st.w	sp[1348],r8
8000d2d6:	12 9c       	mov	r12,r9
8000d2d8:	50 69       	stdsp	sp[0x18],r9
8000d2da:	50 d9       	stdsp	sp[0x34],r9
8000d2dc:	50 e9       	stdsp	sp[0x38],r9
8000d2de:	50 b9       	stdsp	sp[0x2c],r9
8000d2e0:	12 97       	mov	r7,r9
8000d2e2:	0a 94       	mov	r4,r5
8000d2e4:	40 a2       	lddsp	r2,sp[0x28]
8000d2e6:	32 5a       	mov	r10,37
8000d2e8:	30 08       	mov	r8,0
8000d2ea:	c0 28       	rjmp	8000d2ee <_vfprintf_r+0x122>
8000d2ec:	2f f2       	sub	r2,-1
8000d2ee:	05 89       	ld.ub	r9,r2[0x0]
8000d2f0:	f0 09 18 00 	cp.b	r9,r8
8000d2f4:	5f 1b       	srne	r11
8000d2f6:	f4 09 18 00 	cp.b	r9,r10
8000d2fa:	5f 19       	srne	r9
8000d2fc:	f3 eb 00 0b 	and	r11,r9,r11
8000d300:	f0 0b 18 00 	cp.b	r11,r8
8000d304:	cf 41       	brne	8000d2ec <_vfprintf_r+0x120>
8000d306:	40 ab       	lddsp	r11,sp[0x28]
8000d308:	e4 0b 01 06 	sub	r6,r2,r11
8000d30c:	c2 f0       	breq	8000d36a <_vfprintf_r+0x19e>
8000d30e:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d312:	0c 08       	add	r8,r6
8000d314:	87 0b       	st.w	r3[0x0],r11
8000d316:	fb 48 06 90 	st.w	sp[1680],r8
8000d31a:	87 16       	st.w	r3[0x4],r6
8000d31c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d320:	2f f8       	sub	r8,-1
8000d322:	fb 48 06 8c 	st.w	sp[1676],r8
8000d326:	58 78       	cp.w	r8,7
8000d328:	e0 89 00 14 	brgt	8000d350 <_vfprintf_r+0x184>
8000d32c:	2f 83       	sub	r3,-8
8000d32e:	c1 b8       	rjmp	8000d364 <_vfprintf_r+0x198>
8000d330:	80 01       	ld.sh	r1,r0[0x0]
8000d332:	07 f0       	ld.ub	r0,r3[0x7]
8000d334:	80 01       	ld.sh	r1,r0[0x0]
8000d336:	01 e0       	ld.ub	r0,r0[0x6]
8000d338:	80 01       	ld.sh	r1,r0[0x0]
8000d33a:	2b 3c       	sub	r12,-77
8000d33c:	80 01       	ld.sh	r1,r0[0x0]
8000d33e:	2b 5c       	sub	r12,-75
8000d340:	80 01       	ld.sh	r1,r0[0x0]
8000d342:	2b 7c       	sub	r12,-73
8000d344:	80 00       	ld.sh	r0,r0[0x0]
8000d346:	f1 68 80 00 	st.b	r8[-32768],r8
8000d34a:	d1 cc       	*unknown*
8000d34c:	80 01       	ld.sh	r1,r0[0x0]
8000d34e:	00 04       	add	r4,r0
8000d350:	fa ca f9 78 	sub	r10,sp,-1672
8000d354:	02 9b       	mov	r11,r1
8000d356:	08 9c       	mov	r12,r4
8000d358:	f0 1f 00 71 	mcall	8000d51c <_vfprintf_r+0x350>
8000d35c:	e0 81 0e f9 	brne	8000f14e <_vfprintf_r+0x1f82>
8000d360:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d364:	40 ba       	lddsp	r10,sp[0x2c]
8000d366:	0c 0a       	add	r10,r6
8000d368:	50 ba       	stdsp	sp[0x2c],r10
8000d36a:	05 89       	ld.ub	r9,r2[0x0]
8000d36c:	30 08       	mov	r8,0
8000d36e:	f0 09 18 00 	cp.b	r9,r8
8000d372:	e0 80 0e dd 	breq	8000f12c <_vfprintf_r+0x1f60>
8000d376:	30 09       	mov	r9,0
8000d378:	fb 68 06 bb 	st.b	sp[1723],r8
8000d37c:	0e 96       	mov	r6,r7
8000d37e:	e4 c8 ff ff 	sub	r8,r2,-1
8000d382:	3f fe       	mov	lr,-1
8000d384:	50 93       	stdsp	sp[0x24],r3
8000d386:	50 41       	stdsp	sp[0x10],r1
8000d388:	0e 93       	mov	r3,r7
8000d38a:	04 91       	mov	r1,r2
8000d38c:	50 89       	stdsp	sp[0x20],r9
8000d38e:	50 a8       	stdsp	sp[0x28],r8
8000d390:	50 2e       	stdsp	sp[0x8],lr
8000d392:	50 39       	stdsp	sp[0xc],r9
8000d394:	12 95       	mov	r5,r9
8000d396:	12 90       	mov	r0,r9
8000d398:	10 97       	mov	r7,r8
8000d39a:	08 92       	mov	r2,r4
8000d39c:	c0 78       	rjmp	8000d3aa <_vfprintf_r+0x1de>
8000d39e:	3f fc       	mov	r12,-1
8000d3a0:	08 97       	mov	r7,r4
8000d3a2:	50 2c       	stdsp	sp[0x8],r12
8000d3a4:	c0 38       	rjmp	8000d3aa <_vfprintf_r+0x1de>
8000d3a6:	30 0b       	mov	r11,0
8000d3a8:	50 3b       	stdsp	sp[0xc],r11
8000d3aa:	0f 38       	ld.ub	r8,r7++
8000d3ac:	c0 28       	rjmp	8000d3b0 <_vfprintf_r+0x1e4>
8000d3ae:	12 90       	mov	r0,r9
8000d3b0:	f0 c9 00 20 	sub	r9,r8,32
8000d3b4:	e0 49 00 58 	cp.w	r9,88
8000d3b8:	e0 8b 0a 4d 	brhi	8000e852 <_vfprintf_r+0x1686>
8000d3bc:	4d 9a       	lddpc	r10,8000d520 <_vfprintf_r+0x354>
8000d3be:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
8000d3c2:	50 a7       	stdsp	sp[0x28],r7
8000d3c4:	50 80       	stdsp	sp[0x20],r0
8000d3c6:	0c 97       	mov	r7,r6
8000d3c8:	04 94       	mov	r4,r2
8000d3ca:	06 96       	mov	r6,r3
8000d3cc:	02 92       	mov	r2,r1
8000d3ce:	4d 69       	lddpc	r9,8000d524 <_vfprintf_r+0x358>
8000d3d0:	40 93       	lddsp	r3,sp[0x24]
8000d3d2:	10 90       	mov	r0,r8
8000d3d4:	40 41       	lddsp	r1,sp[0x10]
8000d3d6:	50 d9       	stdsp	sp[0x34],r9
8000d3d8:	e0 8f 08 aa 	bral	8000e52c <_vfprintf_r+0x1360>
8000d3dc:	30 08       	mov	r8,0
8000d3de:	fb 39 06 bb 	ld.ub	r9,sp[1723]
8000d3e2:	f0 09 18 00 	cp.b	r9,r8
8000d3e6:	ce 21       	brne	8000d3aa <_vfprintf_r+0x1de>
8000d3e8:	32 08       	mov	r8,32
8000d3ea:	c6 e8       	rjmp	8000d4c6 <_vfprintf_r+0x2fa>
8000d3ec:	a1 a5       	sbr	r5,0x0
8000d3ee:	cd eb       	rjmp	8000d3aa <_vfprintf_r+0x1de>
8000d3f0:	0f 89       	ld.ub	r9,r7[0x0]
8000d3f2:	f2 c8 00 30 	sub	r8,r9,48
8000d3f6:	58 98       	cp.w	r8,9
8000d3f8:	e0 8b 00 1d 	brhi	8000d432 <_vfprintf_r+0x266>
8000d3fc:	ee c8 ff ff 	sub	r8,r7,-1
8000d400:	30 0b       	mov	r11,0
8000d402:	23 09       	sub	r9,48
8000d404:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000d408:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
8000d40c:	11 39       	ld.ub	r9,r8++
8000d40e:	f2 ca 00 30 	sub	r10,r9,48
8000d412:	58 9a       	cp.w	r10,9
8000d414:	fe 98 ff f7 	brls	8000d402 <_vfprintf_r+0x236>
8000d418:	e0 49 00 24 	cp.w	r9,36
8000d41c:	cc 51       	brne	8000d3a6 <_vfprintf_r+0x1da>
8000d41e:	e0 4b 00 20 	cp.w	r11,32
8000d422:	e0 89 0e 95 	brgt	8000f14c <_vfprintf_r+0x1f80>
8000d426:	20 1b       	sub	r11,1
8000d428:	fa f9 06 b4 	ld.w	r9,sp[1716]
8000d42c:	12 3b       	cp.w	r11,r9
8000d42e:	c0 95       	brlt	8000d440 <_vfprintf_r+0x274>
8000d430:	c1 08       	rjmp	8000d450 <_vfprintf_r+0x284>
8000d432:	fa f9 06 b4 	ld.w	r9,sp[1716]
8000d436:	ec ca ff ff 	sub	r10,r6,-1
8000d43a:	12 36       	cp.w	r6,r9
8000d43c:	c1 f5       	brlt	8000d47a <_vfprintf_r+0x2ae>
8000d43e:	c2 68       	rjmp	8000d48a <_vfprintf_r+0x2be>
8000d440:	fa ce f9 44 	sub	lr,sp,-1724
8000d444:	10 97       	mov	r7,r8
8000d446:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
8000d44a:	f6 f0 fd 88 	ld.w	r0,r11[-632]
8000d44e:	c3 58       	rjmp	8000d4b8 <_vfprintf_r+0x2ec>
8000d450:	10 97       	mov	r7,r8
8000d452:	fa c8 f9 50 	sub	r8,sp,-1712
8000d456:	1a d8       	st.w	--sp,r8
8000d458:	fa c8 fa b8 	sub	r8,sp,-1352
8000d45c:	1a d8       	st.w	--sp,r8
8000d45e:	fa c8 fb b4 	sub	r8,sp,-1100
8000d462:	02 9a       	mov	r10,r1
8000d464:	1a d8       	st.w	--sp,r8
8000d466:	04 9c       	mov	r12,r2
8000d468:	fa c8 f9 40 	sub	r8,sp,-1728
8000d46c:	fa c9 ff b4 	sub	r9,sp,-76
8000d470:	f0 1f 00 2e 	mcall	8000d528 <_vfprintf_r+0x35c>
8000d474:	2f dd       	sub	sp,-12
8000d476:	78 00       	ld.w	r0,r12[0x0]
8000d478:	c2 08       	rjmp	8000d4b8 <_vfprintf_r+0x2ec>
8000d47a:	fa cc f9 44 	sub	r12,sp,-1724
8000d47e:	14 96       	mov	r6,r10
8000d480:	f8 03 00 38 	add	r8,r12,r3<<0x3
8000d484:	f0 f0 fd 88 	ld.w	r0,r8[-632]
8000d488:	c1 88       	rjmp	8000d4b8 <_vfprintf_r+0x2ec>
8000d48a:	41 08       	lddsp	r8,sp[0x40]
8000d48c:	59 f9       	cp.w	r9,31
8000d48e:	e0 89 00 11 	brgt	8000d4b0 <_vfprintf_r+0x2e4>
8000d492:	f0 cb ff fc 	sub	r11,r8,-4
8000d496:	51 0b       	stdsp	sp[0x40],r11
8000d498:	70 00       	ld.w	r0,r8[0x0]
8000d49a:	fa cb f9 44 	sub	r11,sp,-1724
8000d49e:	f6 09 00 38 	add	r8,r11,r9<<0x3
8000d4a2:	f1 40 fd 88 	st.w	r8[-632],r0
8000d4a6:	2f f9       	sub	r9,-1
8000d4a8:	14 96       	mov	r6,r10
8000d4aa:	fb 49 06 b4 	st.w	sp[1716],r9
8000d4ae:	c0 58       	rjmp	8000d4b8 <_vfprintf_r+0x2ec>
8000d4b0:	70 00       	ld.w	r0,r8[0x0]
8000d4b2:	14 96       	mov	r6,r10
8000d4b4:	2f c8       	sub	r8,-4
8000d4b6:	51 08       	stdsp	sp[0x40],r8
8000d4b8:	58 00       	cp.w	r0,0
8000d4ba:	fe 94 ff 78 	brge	8000d3aa <_vfprintf_r+0x1de>
8000d4be:	5c 30       	neg	r0
8000d4c0:	a3 a5       	sbr	r5,0x2
8000d4c2:	c7 4b       	rjmp	8000d3aa <_vfprintf_r+0x1de>
8000d4c4:	32 b8       	mov	r8,43
8000d4c6:	fb 68 06 bb 	st.b	sp[1723],r8
8000d4ca:	c7 0b       	rjmp	8000d3aa <_vfprintf_r+0x1de>
8000d4cc:	0f 38       	ld.ub	r8,r7++
8000d4ce:	e0 48 00 2a 	cp.w	r8,42
8000d4d2:	c0 30       	breq	8000d4d8 <_vfprintf_r+0x30c>
8000d4d4:	30 09       	mov	r9,0
8000d4d6:	c8 08       	rjmp	8000d5d6 <_vfprintf_r+0x40a>
8000d4d8:	0f 88       	ld.ub	r8,r7[0x0]
8000d4da:	f0 c9 00 30 	sub	r9,r8,48
8000d4de:	58 99       	cp.w	r9,9
8000d4e0:	e0 8b 00 26 	brhi	8000d52c <_vfprintf_r+0x360>
8000d4e4:	ee c4 ff ff 	sub	r4,r7,-1
8000d4e8:	30 0b       	mov	r11,0
8000d4ea:	23 08       	sub	r8,48
8000d4ec:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000d4f0:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
8000d4f4:	09 38       	ld.ub	r8,r4++
8000d4f6:	f0 c9 00 30 	sub	r9,r8,48
8000d4fa:	58 99       	cp.w	r9,9
8000d4fc:	fe 98 ff f7 	brls	8000d4ea <_vfprintf_r+0x31e>
8000d500:	e0 48 00 24 	cp.w	r8,36
8000d504:	fe 91 ff 51 	brne	8000d3a6 <_vfprintf_r+0x1da>
8000d508:	e0 4b 00 20 	cp.w	r11,32
8000d50c:	e0 89 0e 20 	brgt	8000f14c <_vfprintf_r+0x1f80>
8000d510:	20 1b       	sub	r11,1
8000d512:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000d516:	10 3b       	cp.w	r11,r8
8000d518:	c1 15       	brlt	8000d53a <_vfprintf_r+0x36e>
8000d51a:	c1 88       	rjmp	8000d54a <_vfprintf_r+0x37e>
8000d51c:	80 00       	ld.sh	r0,r0[0x0]
8000d51e:	d1 ac       	*unknown*
8000d520:	80 01       	ld.sh	r1,r0[0x0]
8000d522:	27 94       	sub	r4,121
8000d524:	80 01       	ld.sh	r1,r0[0x0]
8000d526:	29 d0       	sub	r0,-99
8000d528:	80 00       	ld.sh	r0,r0[0x0]
8000d52a:	ce 88       	rjmp	8000d6fa <_vfprintf_r+0x52e>
8000d52c:	fa fa 06 b4 	ld.w	r10,sp[1716]
8000d530:	ec c9 ff ff 	sub	r9,r6,-1
8000d534:	14 36       	cp.w	r6,r10
8000d536:	c1 f5       	brlt	8000d574 <_vfprintf_r+0x3a8>
8000d538:	c2 88       	rjmp	8000d588 <_vfprintf_r+0x3bc>
8000d53a:	fa ca f9 44 	sub	r10,sp,-1724
8000d53e:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
8000d542:	f6 fb fd 88 	ld.w	r11,r11[-632]
8000d546:	50 2b       	stdsp	sp[0x8],r11
8000d548:	c3 c8       	rjmp	8000d5c0 <_vfprintf_r+0x3f4>
8000d54a:	fa c8 f9 50 	sub	r8,sp,-1712
8000d54e:	1a d8       	st.w	--sp,r8
8000d550:	fa c8 fa b8 	sub	r8,sp,-1352
8000d554:	1a d8       	st.w	--sp,r8
8000d556:	fa c8 fb b4 	sub	r8,sp,-1100
8000d55a:	02 9a       	mov	r10,r1
8000d55c:	1a d8       	st.w	--sp,r8
8000d55e:	04 9c       	mov	r12,r2
8000d560:	fa c8 f9 40 	sub	r8,sp,-1728
8000d564:	fa c9 ff b4 	sub	r9,sp,-76
8000d568:	f0 1f 01 9e 	mcall	8000dbe0 <_vfprintf_r+0xa14>
8000d56c:	2f dd       	sub	sp,-12
8000d56e:	78 0c       	ld.w	r12,r12[0x0]
8000d570:	50 2c       	stdsp	sp[0x8],r12
8000d572:	c2 78       	rjmp	8000d5c0 <_vfprintf_r+0x3f4>
8000d574:	12 96       	mov	r6,r9
8000d576:	0e 94       	mov	r4,r7
8000d578:	fa c9 f9 44 	sub	r9,sp,-1724
8000d57c:	f2 03 00 38 	add	r8,r9,r3<<0x3
8000d580:	f0 f8 fd 88 	ld.w	r8,r8[-632]
8000d584:	50 28       	stdsp	sp[0x8],r8
8000d586:	c1 d8       	rjmp	8000d5c0 <_vfprintf_r+0x3f4>
8000d588:	41 08       	lddsp	r8,sp[0x40]
8000d58a:	59 fa       	cp.w	r10,31
8000d58c:	e0 89 00 14 	brgt	8000d5b4 <_vfprintf_r+0x3e8>
8000d590:	f0 cb ff fc 	sub	r11,r8,-4
8000d594:	70 08       	ld.w	r8,r8[0x0]
8000d596:	51 0b       	stdsp	sp[0x40],r11
8000d598:	50 28       	stdsp	sp[0x8],r8
8000d59a:	fa c6 f9 44 	sub	r6,sp,-1724
8000d59e:	40 2e       	lddsp	lr,sp[0x8]
8000d5a0:	ec 0a 00 38 	add	r8,r6,r10<<0x3
8000d5a4:	f1 4e fd 88 	st.w	r8[-632],lr
8000d5a8:	2f fa       	sub	r10,-1
8000d5aa:	0e 94       	mov	r4,r7
8000d5ac:	fb 4a 06 b4 	st.w	sp[1716],r10
8000d5b0:	12 96       	mov	r6,r9
8000d5b2:	c0 78       	rjmp	8000d5c0 <_vfprintf_r+0x3f4>
8000d5b4:	70 0c       	ld.w	r12,r8[0x0]
8000d5b6:	0e 94       	mov	r4,r7
8000d5b8:	2f c8       	sub	r8,-4
8000d5ba:	50 2c       	stdsp	sp[0x8],r12
8000d5bc:	12 96       	mov	r6,r9
8000d5be:	51 08       	stdsp	sp[0x40],r8
8000d5c0:	40 2b       	lddsp	r11,sp[0x8]
8000d5c2:	58 0b       	cp.w	r11,0
8000d5c4:	fe 95 fe ed 	brlt	8000d39e <_vfprintf_r+0x1d2>
8000d5c8:	08 97       	mov	r7,r4
8000d5ca:	cf 0a       	rjmp	8000d3aa <_vfprintf_r+0x1de>
8000d5cc:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000d5d0:	0f 38       	ld.ub	r8,r7++
8000d5d2:	f4 09 00 19 	add	r9,r10,r9<<0x1
8000d5d6:	f0 ca 00 30 	sub	r10,r8,48
8000d5da:	58 9a       	cp.w	r10,9
8000d5dc:	fe 98 ff f8 	brls	8000d5cc <_vfprintf_r+0x400>
8000d5e0:	3f fa       	mov	r10,-1
8000d5e2:	f2 0a 0c 49 	max	r9,r9,r10
8000d5e6:	50 29       	stdsp	sp[0x8],r9
8000d5e8:	ce 4a       	rjmp	8000d3b0 <_vfprintf_r+0x1e4>
8000d5ea:	a7 b5       	sbr	r5,0x7
8000d5ec:	cd fa       	rjmp	8000d3aa <_vfprintf_r+0x1de>
8000d5ee:	30 09       	mov	r9,0
8000d5f0:	23 08       	sub	r8,48
8000d5f2:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000d5f6:	f0 09 00 19 	add	r9,r8,r9<<0x1
8000d5fa:	0f 38       	ld.ub	r8,r7++
8000d5fc:	f0 ca 00 30 	sub	r10,r8,48
8000d600:	58 9a       	cp.w	r10,9
8000d602:	fe 98 ff f7 	brls	8000d5f0 <_vfprintf_r+0x424>
8000d606:	e0 48 00 24 	cp.w	r8,36
8000d60a:	fe 91 fe d2 	brne	8000d3ae <_vfprintf_r+0x1e2>
8000d60e:	e0 49 00 20 	cp.w	r9,32
8000d612:	e0 89 0d 9d 	brgt	8000f14c <_vfprintf_r+0x1f80>
8000d616:	f2 c3 00 01 	sub	r3,r9,1
8000d61a:	30 19       	mov	r9,1
8000d61c:	50 39       	stdsp	sp[0xc],r9
8000d61e:	cc 6a       	rjmp	8000d3aa <_vfprintf_r+0x1de>
8000d620:	a3 b5       	sbr	r5,0x3
8000d622:	cc 4a       	rjmp	8000d3aa <_vfprintf_r+0x1de>
8000d624:	a7 a5       	sbr	r5,0x6
8000d626:	cc 2a       	rjmp	8000d3aa <_vfprintf_r+0x1de>
8000d628:	0a 98       	mov	r8,r5
8000d62a:	a5 b5       	sbr	r5,0x5
8000d62c:	a5 a8       	sbr	r8,0x4
8000d62e:	0f 89       	ld.ub	r9,r7[0x0]
8000d630:	36 ce       	mov	lr,108
8000d632:	fc 09 18 00 	cp.b	r9,lr
8000d636:	f7 b7 00 ff 	subeq	r7,-1
8000d63a:	f0 05 17 10 	movne	r5,r8
8000d63e:	cb 6a       	rjmp	8000d3aa <_vfprintf_r+0x1de>
8000d640:	a5 b5       	sbr	r5,0x5
8000d642:	cb 4a       	rjmp	8000d3aa <_vfprintf_r+0x1de>
8000d644:	50 a7       	stdsp	sp[0x28],r7
8000d646:	50 80       	stdsp	sp[0x20],r0
8000d648:	0c 97       	mov	r7,r6
8000d64a:	10 90       	mov	r0,r8
8000d64c:	06 96       	mov	r6,r3
8000d64e:	04 94       	mov	r4,r2
8000d650:	40 93       	lddsp	r3,sp[0x24]
8000d652:	02 92       	mov	r2,r1
8000d654:	0e 99       	mov	r9,r7
8000d656:	40 41       	lddsp	r1,sp[0x10]
8000d658:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000d65c:	40 3c       	lddsp	r12,sp[0xc]
8000d65e:	58 0c       	cp.w	r12,0
8000d660:	c1 d0       	breq	8000d69a <_vfprintf_r+0x4ce>
8000d662:	10 36       	cp.w	r6,r8
8000d664:	c0 64       	brge	8000d670 <_vfprintf_r+0x4a4>
8000d666:	fa cb f9 44 	sub	r11,sp,-1724
8000d66a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000d66e:	c1 d8       	rjmp	8000d6a8 <_vfprintf_r+0x4dc>
8000d670:	fa c8 f9 50 	sub	r8,sp,-1712
8000d674:	1a d8       	st.w	--sp,r8
8000d676:	fa c8 fa b8 	sub	r8,sp,-1352
8000d67a:	1a d8       	st.w	--sp,r8
8000d67c:	fa c8 fb b4 	sub	r8,sp,-1100
8000d680:	1a d8       	st.w	--sp,r8
8000d682:	fa c8 f9 40 	sub	r8,sp,-1728
8000d686:	fa c9 ff b4 	sub	r9,sp,-76
8000d68a:	04 9a       	mov	r10,r2
8000d68c:	0c 9b       	mov	r11,r6
8000d68e:	08 9c       	mov	r12,r4
8000d690:	f0 1f 01 54 	mcall	8000dbe0 <_vfprintf_r+0xa14>
8000d694:	2f dd       	sub	sp,-12
8000d696:	19 b8       	ld.ub	r8,r12[0x3]
8000d698:	c2 28       	rjmp	8000d6dc <_vfprintf_r+0x510>
8000d69a:	2f f7       	sub	r7,-1
8000d69c:	10 39       	cp.w	r9,r8
8000d69e:	c0 84       	brge	8000d6ae <_vfprintf_r+0x4e2>
8000d6a0:	fa ca f9 44 	sub	r10,sp,-1724
8000d6a4:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000d6a8:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
8000d6ac:	c1 88       	rjmp	8000d6dc <_vfprintf_r+0x510>
8000d6ae:	41 09       	lddsp	r9,sp[0x40]
8000d6b0:	59 f8       	cp.w	r8,31
8000d6b2:	e0 89 00 12 	brgt	8000d6d6 <_vfprintf_r+0x50a>
8000d6b6:	f2 ca ff fc 	sub	r10,r9,-4
8000d6ba:	51 0a       	stdsp	sp[0x40],r10
8000d6bc:	72 09       	ld.w	r9,r9[0x0]
8000d6be:	fa c6 f9 44 	sub	r6,sp,-1724
8000d6c2:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000d6c6:	2f f8       	sub	r8,-1
8000d6c8:	f5 49 fd 88 	st.w	r10[-632],r9
8000d6cc:	fb 48 06 b4 	st.w	sp[1716],r8
8000d6d0:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
8000d6d4:	c0 48       	rjmp	8000d6dc <_vfprintf_r+0x510>
8000d6d6:	13 b8       	ld.ub	r8,r9[0x3]
8000d6d8:	2f c9       	sub	r9,-4
8000d6da:	51 09       	stdsp	sp[0x40],r9
8000d6dc:	fb 68 06 60 	st.b	sp[1632],r8
8000d6e0:	30 0e       	mov	lr,0
8000d6e2:	30 08       	mov	r8,0
8000d6e4:	30 12       	mov	r2,1
8000d6e6:	fb 68 06 bb 	st.b	sp[1723],r8
8000d6ea:	50 2e       	stdsp	sp[0x8],lr
8000d6ec:	e0 8f 08 c5 	bral	8000e876 <_vfprintf_r+0x16aa>
8000d6f0:	50 a7       	stdsp	sp[0x28],r7
8000d6f2:	50 80       	stdsp	sp[0x20],r0
8000d6f4:	0c 97       	mov	r7,r6
8000d6f6:	04 94       	mov	r4,r2
8000d6f8:	06 96       	mov	r6,r3
8000d6fa:	02 92       	mov	r2,r1
8000d6fc:	40 93       	lddsp	r3,sp[0x24]
8000d6fe:	10 90       	mov	r0,r8
8000d700:	40 41       	lddsp	r1,sp[0x10]
8000d702:	a5 a5       	sbr	r5,0x4
8000d704:	c0 a8       	rjmp	8000d718 <_vfprintf_r+0x54c>
8000d706:	50 a7       	stdsp	sp[0x28],r7
8000d708:	50 80       	stdsp	sp[0x20],r0
8000d70a:	0c 97       	mov	r7,r6
8000d70c:	04 94       	mov	r4,r2
8000d70e:	06 96       	mov	r6,r3
8000d710:	02 92       	mov	r2,r1
8000d712:	40 93       	lddsp	r3,sp[0x24]
8000d714:	10 90       	mov	r0,r8
8000d716:	40 41       	lddsp	r1,sp[0x10]
8000d718:	ed b5 00 05 	bld	r5,0x5
8000d71c:	c5 11       	brne	8000d7be <_vfprintf_r+0x5f2>
8000d71e:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000d722:	40 3c       	lddsp	r12,sp[0xc]
8000d724:	58 0c       	cp.w	r12,0
8000d726:	c1 e0       	breq	8000d762 <_vfprintf_r+0x596>
8000d728:	10 36       	cp.w	r6,r8
8000d72a:	c0 64       	brge	8000d736 <_vfprintf_r+0x56a>
8000d72c:	fa cb f9 44 	sub	r11,sp,-1724
8000d730:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000d734:	c2 08       	rjmp	8000d774 <_vfprintf_r+0x5a8>
8000d736:	fa c8 f9 50 	sub	r8,sp,-1712
8000d73a:	1a d8       	st.w	--sp,r8
8000d73c:	fa c8 fa b8 	sub	r8,sp,-1352
8000d740:	0c 9b       	mov	r11,r6
8000d742:	1a d8       	st.w	--sp,r8
8000d744:	fa c8 fb b4 	sub	r8,sp,-1100
8000d748:	1a d8       	st.w	--sp,r8
8000d74a:	fa c9 ff b4 	sub	r9,sp,-76
8000d74e:	fa c8 f9 40 	sub	r8,sp,-1728
8000d752:	04 9a       	mov	r10,r2
8000d754:	08 9c       	mov	r12,r4
8000d756:	f0 1f 01 23 	mcall	8000dbe0 <_vfprintf_r+0xa14>
8000d75a:	2f dd       	sub	sp,-12
8000d75c:	78 1b       	ld.w	r11,r12[0x4]
8000d75e:	78 09       	ld.w	r9,r12[0x0]
8000d760:	c2 b8       	rjmp	8000d7b6 <_vfprintf_r+0x5ea>
8000d762:	ee ca ff ff 	sub	r10,r7,-1
8000d766:	10 37       	cp.w	r7,r8
8000d768:	c0 b4       	brge	8000d77e <_vfprintf_r+0x5b2>
8000d76a:	fa c9 f9 44 	sub	r9,sp,-1724
8000d76e:	14 97       	mov	r7,r10
8000d770:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000d774:	ec fb fd 8c 	ld.w	r11,r6[-628]
8000d778:	ec f9 fd 88 	ld.w	r9,r6[-632]
8000d77c:	c1 d8       	rjmp	8000d7b6 <_vfprintf_r+0x5ea>
8000d77e:	41 09       	lddsp	r9,sp[0x40]
8000d780:	59 f8       	cp.w	r8,31
8000d782:	e0 89 00 14 	brgt	8000d7aa <_vfprintf_r+0x5de>
8000d786:	f2 cb ff f8 	sub	r11,r9,-8
8000d78a:	51 0b       	stdsp	sp[0x40],r11
8000d78c:	fa c6 f9 44 	sub	r6,sp,-1724
8000d790:	72 1b       	ld.w	r11,r9[0x4]
8000d792:	ec 08 00 3c 	add	r12,r6,r8<<0x3
8000d796:	72 09       	ld.w	r9,r9[0x0]
8000d798:	f9 4b fd 8c 	st.w	r12[-628],r11
8000d79c:	f9 49 fd 88 	st.w	r12[-632],r9
8000d7a0:	2f f8       	sub	r8,-1
8000d7a2:	14 97       	mov	r7,r10
8000d7a4:	fb 48 06 b4 	st.w	sp[1716],r8
8000d7a8:	c0 78       	rjmp	8000d7b6 <_vfprintf_r+0x5ea>
8000d7aa:	f2 c8 ff f8 	sub	r8,r9,-8
8000d7ae:	72 1b       	ld.w	r11,r9[0x4]
8000d7b0:	14 97       	mov	r7,r10
8000d7b2:	51 08       	stdsp	sp[0x40],r8
8000d7b4:	72 09       	ld.w	r9,r9[0x0]
8000d7b6:	16 98       	mov	r8,r11
8000d7b8:	fa e9 00 00 	st.d	sp[0],r8
8000d7bc:	ca e8       	rjmp	8000d918 <_vfprintf_r+0x74c>
8000d7be:	ed b5 00 04 	bld	r5,0x4
8000d7c2:	c1 71       	brne	8000d7f0 <_vfprintf_r+0x624>
8000d7c4:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000d7c8:	40 3e       	lddsp	lr,sp[0xc]
8000d7ca:	58 0e       	cp.w	lr,0
8000d7cc:	c0 80       	breq	8000d7dc <_vfprintf_r+0x610>
8000d7ce:	10 36       	cp.w	r6,r8
8000d7d0:	c6 94       	brge	8000d8a2 <_vfprintf_r+0x6d6>
8000d7d2:	fa cc f9 44 	sub	r12,sp,-1724
8000d7d6:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000d7da:	c8 28       	rjmp	8000d8de <_vfprintf_r+0x712>
8000d7dc:	ee ca ff ff 	sub	r10,r7,-1
8000d7e0:	10 37       	cp.w	r7,r8
8000d7e2:	e0 84 00 81 	brge	8000d8e4 <_vfprintf_r+0x718>
8000d7e6:	fa cb f9 44 	sub	r11,sp,-1724
8000d7ea:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000d7ee:	c7 78       	rjmp	8000d8dc <_vfprintf_r+0x710>
8000d7f0:	ed b5 00 06 	bld	r5,0x6
8000d7f4:	c4 b1       	brne	8000d88a <_vfprintf_r+0x6be>
8000d7f6:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000d7fa:	40 3c       	lddsp	r12,sp[0xc]
8000d7fc:	58 0c       	cp.w	r12,0
8000d7fe:	c1 d0       	breq	8000d838 <_vfprintf_r+0x66c>
8000d800:	10 36       	cp.w	r6,r8
8000d802:	c0 64       	brge	8000d80e <_vfprintf_r+0x642>
8000d804:	fa cb f9 44 	sub	r11,sp,-1724
8000d808:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000d80c:	c1 f8       	rjmp	8000d84a <_vfprintf_r+0x67e>
8000d80e:	fa c8 f9 50 	sub	r8,sp,-1712
8000d812:	1a d8       	st.w	--sp,r8
8000d814:	fa c8 fa b8 	sub	r8,sp,-1352
8000d818:	1a d8       	st.w	--sp,r8
8000d81a:	fa c8 fb b4 	sub	r8,sp,-1100
8000d81e:	1a d8       	st.w	--sp,r8
8000d820:	fa c8 f9 40 	sub	r8,sp,-1728
8000d824:	fa c9 ff b4 	sub	r9,sp,-76
8000d828:	04 9a       	mov	r10,r2
8000d82a:	0c 9b       	mov	r11,r6
8000d82c:	08 9c       	mov	r12,r4
8000d82e:	f0 1f 00 ed 	mcall	8000dbe0 <_vfprintf_r+0xa14>
8000d832:	2f dd       	sub	sp,-12
8000d834:	98 18       	ld.sh	r8,r12[0x2]
8000d836:	c2 68       	rjmp	8000d882 <_vfprintf_r+0x6b6>
8000d838:	ee ca ff ff 	sub	r10,r7,-1
8000d83c:	10 37       	cp.w	r7,r8
8000d83e:	c0 94       	brge	8000d850 <_vfprintf_r+0x684>
8000d840:	fa c9 f9 44 	sub	r9,sp,-1724
8000d844:	14 97       	mov	r7,r10
8000d846:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000d84a:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000d84e:	c1 a8       	rjmp	8000d882 <_vfprintf_r+0x6b6>
8000d850:	41 09       	lddsp	r9,sp[0x40]
8000d852:	59 f8       	cp.w	r8,31
8000d854:	e0 89 00 13 	brgt	8000d87a <_vfprintf_r+0x6ae>
8000d858:	f2 cb ff fc 	sub	r11,r9,-4
8000d85c:	51 0b       	stdsp	sp[0x40],r11
8000d85e:	72 09       	ld.w	r9,r9[0x0]
8000d860:	fa c6 f9 44 	sub	r6,sp,-1724
8000d864:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000d868:	2f f8       	sub	r8,-1
8000d86a:	f7 49 fd 88 	st.w	r11[-632],r9
8000d86e:	fb 48 06 b4 	st.w	sp[1716],r8
8000d872:	14 97       	mov	r7,r10
8000d874:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000d878:	c0 58       	rjmp	8000d882 <_vfprintf_r+0x6b6>
8000d87a:	92 18       	ld.sh	r8,r9[0x2]
8000d87c:	14 97       	mov	r7,r10
8000d87e:	2f c9       	sub	r9,-4
8000d880:	51 09       	stdsp	sp[0x40],r9
8000d882:	50 18       	stdsp	sp[0x4],r8
8000d884:	bf 58       	asr	r8,0x1f
8000d886:	50 08       	stdsp	sp[0x0],r8
8000d888:	c4 88       	rjmp	8000d918 <_vfprintf_r+0x74c>
8000d88a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000d88e:	40 3c       	lddsp	r12,sp[0xc]
8000d890:	58 0c       	cp.w	r12,0
8000d892:	c1 d0       	breq	8000d8cc <_vfprintf_r+0x700>
8000d894:	10 36       	cp.w	r6,r8
8000d896:	c0 64       	brge	8000d8a2 <_vfprintf_r+0x6d6>
8000d898:	fa cb f9 44 	sub	r11,sp,-1724
8000d89c:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000d8a0:	c1 f8       	rjmp	8000d8de <_vfprintf_r+0x712>
8000d8a2:	fa c8 f9 50 	sub	r8,sp,-1712
8000d8a6:	1a d8       	st.w	--sp,r8
8000d8a8:	fa c8 fa b8 	sub	r8,sp,-1352
8000d8ac:	0c 9b       	mov	r11,r6
8000d8ae:	1a d8       	st.w	--sp,r8
8000d8b0:	fa c8 fb b4 	sub	r8,sp,-1100
8000d8b4:	04 9a       	mov	r10,r2
8000d8b6:	1a d8       	st.w	--sp,r8
8000d8b8:	08 9c       	mov	r12,r4
8000d8ba:	fa c8 f9 40 	sub	r8,sp,-1728
8000d8be:	fa c9 ff b4 	sub	r9,sp,-76
8000d8c2:	f0 1f 00 c8 	mcall	8000dbe0 <_vfprintf_r+0xa14>
8000d8c6:	2f dd       	sub	sp,-12
8000d8c8:	78 0b       	ld.w	r11,r12[0x0]
8000d8ca:	c2 48       	rjmp	8000d912 <_vfprintf_r+0x746>
8000d8cc:	ee ca ff ff 	sub	r10,r7,-1
8000d8d0:	10 37       	cp.w	r7,r8
8000d8d2:	c0 94       	brge	8000d8e4 <_vfprintf_r+0x718>
8000d8d4:	fa c9 f9 44 	sub	r9,sp,-1724
8000d8d8:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000d8dc:	14 97       	mov	r7,r10
8000d8de:	ec fb fd 88 	ld.w	r11,r6[-632]
8000d8e2:	c1 88       	rjmp	8000d912 <_vfprintf_r+0x746>
8000d8e4:	41 09       	lddsp	r9,sp[0x40]
8000d8e6:	59 f8       	cp.w	r8,31
8000d8e8:	e0 89 00 11 	brgt	8000d90a <_vfprintf_r+0x73e>
8000d8ec:	f2 cb ff fc 	sub	r11,r9,-4
8000d8f0:	51 0b       	stdsp	sp[0x40],r11
8000d8f2:	fa c6 f9 44 	sub	r6,sp,-1724
8000d8f6:	72 0b       	ld.w	r11,r9[0x0]
8000d8f8:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000d8fc:	f3 4b fd 88 	st.w	r9[-632],r11
8000d900:	2f f8       	sub	r8,-1
8000d902:	14 97       	mov	r7,r10
8000d904:	fb 48 06 b4 	st.w	sp[1716],r8
8000d908:	c0 58       	rjmp	8000d912 <_vfprintf_r+0x746>
8000d90a:	72 0b       	ld.w	r11,r9[0x0]
8000d90c:	14 97       	mov	r7,r10
8000d90e:	2f c9       	sub	r9,-4
8000d910:	51 09       	stdsp	sp[0x40],r9
8000d912:	50 1b       	stdsp	sp[0x4],r11
8000d914:	bf 5b       	asr	r11,0x1f
8000d916:	50 0b       	stdsp	sp[0x0],r11
8000d918:	fa ea 00 00 	ld.d	r10,sp[0]
8000d91c:	58 0a       	cp.w	r10,0
8000d91e:	5c 2b       	cpc	r11
8000d920:	c0 e4       	brge	8000d93c <_vfprintf_r+0x770>
8000d922:	30 08       	mov	r8,0
8000d924:	fa ea 00 00 	ld.d	r10,sp[0]
8000d928:	30 09       	mov	r9,0
8000d92a:	f0 0a 01 0a 	sub	r10,r8,r10
8000d92e:	f2 0b 01 4b 	sbc	r11,r9,r11
8000d932:	32 d8       	mov	r8,45
8000d934:	fa eb 00 00 	st.d	sp[0],r10
8000d938:	fb 68 06 bb 	st.b	sp[1723],r8
8000d93c:	30 18       	mov	r8,1
8000d93e:	e0 8f 07 12 	bral	8000e762 <_vfprintf_r+0x1596>
8000d942:	50 a7       	stdsp	sp[0x28],r7
8000d944:	50 80       	stdsp	sp[0x20],r0
8000d946:	0c 97       	mov	r7,r6
8000d948:	04 94       	mov	r4,r2
8000d94a:	06 96       	mov	r6,r3
8000d94c:	02 92       	mov	r2,r1
8000d94e:	40 93       	lddsp	r3,sp[0x24]
8000d950:	10 90       	mov	r0,r8
8000d952:	40 41       	lddsp	r1,sp[0x10]
8000d954:	0e 99       	mov	r9,r7
8000d956:	ed b5 00 03 	bld	r5,0x3
8000d95a:	c4 11       	brne	8000d9dc <_vfprintf_r+0x810>
8000d95c:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000d960:	40 3a       	lddsp	r10,sp[0xc]
8000d962:	58 0a       	cp.w	r10,0
8000d964:	c1 90       	breq	8000d996 <_vfprintf_r+0x7ca>
8000d966:	10 36       	cp.w	r6,r8
8000d968:	c6 45       	brlt	8000da30 <_vfprintf_r+0x864>
8000d96a:	fa c8 f9 50 	sub	r8,sp,-1712
8000d96e:	1a d8       	st.w	--sp,r8
8000d970:	fa c8 fa b8 	sub	r8,sp,-1352
8000d974:	1a d8       	st.w	--sp,r8
8000d976:	fa c8 fb b4 	sub	r8,sp,-1100
8000d97a:	0c 9b       	mov	r11,r6
8000d97c:	1a d8       	st.w	--sp,r8
8000d97e:	04 9a       	mov	r10,r2
8000d980:	fa c8 f9 40 	sub	r8,sp,-1728
8000d984:	fa c9 ff b4 	sub	r9,sp,-76
8000d988:	08 9c       	mov	r12,r4
8000d98a:	f0 1f 00 96 	mcall	8000dbe0 <_vfprintf_r+0xa14>
8000d98e:	2f dd       	sub	sp,-12
8000d990:	78 16       	ld.w	r6,r12[0x4]
8000d992:	50 76       	stdsp	sp[0x1c],r6
8000d994:	c4 88       	rjmp	8000da24 <_vfprintf_r+0x858>
8000d996:	2f f7       	sub	r7,-1
8000d998:	10 39       	cp.w	r9,r8
8000d99a:	c0 c4       	brge	8000d9b2 <_vfprintf_r+0x7e6>
8000d99c:	fa ce f9 44 	sub	lr,sp,-1724
8000d9a0:	fc 06 00 36 	add	r6,lr,r6<<0x3
8000d9a4:	ec fc fd 8c 	ld.w	r12,r6[-628]
8000d9a8:	50 7c       	stdsp	sp[0x1c],r12
8000d9aa:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000d9ae:	50 56       	stdsp	sp[0x14],r6
8000d9b0:	c6 68       	rjmp	8000da7c <_vfprintf_r+0x8b0>
8000d9b2:	41 09       	lddsp	r9,sp[0x40]
8000d9b4:	59 f8       	cp.w	r8,31
8000d9b6:	e0 89 00 10 	brgt	8000d9d6 <_vfprintf_r+0x80a>
8000d9ba:	f2 ca ff f8 	sub	r10,r9,-8
8000d9be:	72 1b       	ld.w	r11,r9[0x4]
8000d9c0:	51 0a       	stdsp	sp[0x40],r10
8000d9c2:	72 09       	ld.w	r9,r9[0x0]
8000d9c4:	fa ca f9 44 	sub	r10,sp,-1724
8000d9c8:	50 7b       	stdsp	sp[0x1c],r11
8000d9ca:	50 59       	stdsp	sp[0x14],r9
8000d9cc:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000d9d0:	40 5b       	lddsp	r11,sp[0x14]
8000d9d2:	40 7a       	lddsp	r10,sp[0x1c]
8000d9d4:	c4 78       	rjmp	8000da62 <_vfprintf_r+0x896>
8000d9d6:	72 18       	ld.w	r8,r9[0x4]
8000d9d8:	50 78       	stdsp	sp[0x1c],r8
8000d9da:	c4 c8       	rjmp	8000da72 <_vfprintf_r+0x8a6>
8000d9dc:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000d9e0:	40 3e       	lddsp	lr,sp[0xc]
8000d9e2:	58 0e       	cp.w	lr,0
8000d9e4:	c2 30       	breq	8000da2a <_vfprintf_r+0x85e>
8000d9e6:	10 36       	cp.w	r6,r8
8000d9e8:	c0 94       	brge	8000d9fa <_vfprintf_r+0x82e>
8000d9ea:	fa cc f9 44 	sub	r12,sp,-1724
8000d9ee:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000d9f2:	ec fb fd 8c 	ld.w	r11,r6[-628]
8000d9f6:	50 7b       	stdsp	sp[0x1c],r11
8000d9f8:	cd 9b       	rjmp	8000d9aa <_vfprintf_r+0x7de>
8000d9fa:	fa c8 f9 50 	sub	r8,sp,-1712
8000d9fe:	1a d8       	st.w	--sp,r8
8000da00:	fa c8 fa b8 	sub	r8,sp,-1352
8000da04:	04 9a       	mov	r10,r2
8000da06:	1a d8       	st.w	--sp,r8
8000da08:	fa c8 fb b4 	sub	r8,sp,-1100
8000da0c:	0c 9b       	mov	r11,r6
8000da0e:	1a d8       	st.w	--sp,r8
8000da10:	08 9c       	mov	r12,r4
8000da12:	fa c8 f9 40 	sub	r8,sp,-1728
8000da16:	fa c9 ff b4 	sub	r9,sp,-76
8000da1a:	f0 1f 00 72 	mcall	8000dbe0 <_vfprintf_r+0xa14>
8000da1e:	2f dd       	sub	sp,-12
8000da20:	78 1a       	ld.w	r10,r12[0x4]
8000da22:	50 7a       	stdsp	sp[0x1c],r10
8000da24:	78 0c       	ld.w	r12,r12[0x0]
8000da26:	50 5c       	stdsp	sp[0x14],r12
8000da28:	c2 a8       	rjmp	8000da7c <_vfprintf_r+0x8b0>
8000da2a:	2f f7       	sub	r7,-1
8000da2c:	10 39       	cp.w	r9,r8
8000da2e:	c0 94       	brge	8000da40 <_vfprintf_r+0x874>
8000da30:	fa c9 f9 44 	sub	r9,sp,-1724
8000da34:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000da38:	ec f8 fd 8c 	ld.w	r8,r6[-628]
8000da3c:	50 78       	stdsp	sp[0x1c],r8
8000da3e:	cb 6b       	rjmp	8000d9aa <_vfprintf_r+0x7de>
8000da40:	41 09       	lddsp	r9,sp[0x40]
8000da42:	59 f8       	cp.w	r8,31
8000da44:	e0 89 00 15 	brgt	8000da6e <_vfprintf_r+0x8a2>
8000da48:	f2 ca ff f8 	sub	r10,r9,-8
8000da4c:	72 16       	ld.w	r6,r9[0x4]
8000da4e:	72 09       	ld.w	r9,r9[0x0]
8000da50:	51 0a       	stdsp	sp[0x40],r10
8000da52:	50 59       	stdsp	sp[0x14],r9
8000da54:	fa ce f9 44 	sub	lr,sp,-1724
8000da58:	50 76       	stdsp	sp[0x1c],r6
8000da5a:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000da5e:	40 5b       	lddsp	r11,sp[0x14]
8000da60:	0c 9a       	mov	r10,r6
8000da62:	f2 eb fd 88 	st.d	r9[-632],r10
8000da66:	2f f8       	sub	r8,-1
8000da68:	fb 48 06 b4 	st.w	sp[1716],r8
8000da6c:	c0 88       	rjmp	8000da7c <_vfprintf_r+0x8b0>
8000da6e:	72 1c       	ld.w	r12,r9[0x4]
8000da70:	50 7c       	stdsp	sp[0x1c],r12
8000da72:	f2 c8 ff f8 	sub	r8,r9,-8
8000da76:	51 08       	stdsp	sp[0x40],r8
8000da78:	72 09       	ld.w	r9,r9[0x0]
8000da7a:	50 59       	stdsp	sp[0x14],r9
8000da7c:	40 5b       	lddsp	r11,sp[0x14]
8000da7e:	40 7a       	lddsp	r10,sp[0x1c]
8000da80:	f0 1f 00 59 	mcall	8000dbe4 <_vfprintf_r+0xa18>
8000da84:	18 96       	mov	r6,r12
8000da86:	c1 50       	breq	8000dab0 <_vfprintf_r+0x8e4>
8000da88:	30 08       	mov	r8,0
8000da8a:	30 09       	mov	r9,0
8000da8c:	40 5b       	lddsp	r11,sp[0x14]
8000da8e:	40 7a       	lddsp	r10,sp[0x1c]
8000da90:	f0 1f 00 56 	mcall	8000dbe8 <_vfprintf_r+0xa1c>
8000da94:	c0 40       	breq	8000da9c <_vfprintf_r+0x8d0>
8000da96:	32 d8       	mov	r8,45
8000da98:	fb 68 06 bb 	st.b	sp[1723],r8
8000da9c:	4d 48       	lddpc	r8,8000dbec <_vfprintf_r+0xa20>
8000da9e:	4d 56       	lddpc	r6,8000dbf0 <_vfprintf_r+0xa24>
8000daa0:	a7 d5       	cbr	r5,0x7
8000daa2:	e0 40 00 47 	cp.w	r0,71
8000daa6:	f0 06 17 a0 	movle	r6,r8
8000daaa:	30 32       	mov	r2,3
8000daac:	e0 8f 06 e8 	bral	8000e87c <_vfprintf_r+0x16b0>
8000dab0:	40 5b       	lddsp	r11,sp[0x14]
8000dab2:	40 7a       	lddsp	r10,sp[0x1c]
8000dab4:	f0 1f 00 50 	mcall	8000dbf4 <_vfprintf_r+0xa28>
8000dab8:	c0 c0       	breq	8000dad0 <_vfprintf_r+0x904>
8000daba:	50 26       	stdsp	sp[0x8],r6
8000dabc:	4c f8       	lddpc	r8,8000dbf8 <_vfprintf_r+0xa2c>
8000dabe:	4d 06       	lddpc	r6,8000dbfc <_vfprintf_r+0xa30>
8000dac0:	a7 d5       	cbr	r5,0x7
8000dac2:	e0 40 00 47 	cp.w	r0,71
8000dac6:	f0 06 17 a0 	movle	r6,r8
8000daca:	30 32       	mov	r2,3
8000dacc:	e0 8f 06 de 	bral	8000e888 <_vfprintf_r+0x16bc>
8000dad0:	40 2a       	lddsp	r10,sp[0x8]
8000dad2:	5b fa       	cp.w	r10,-1
8000dad4:	c0 41       	brne	8000dadc <_vfprintf_r+0x910>
8000dad6:	30 69       	mov	r9,6
8000dad8:	50 29       	stdsp	sp[0x8],r9
8000dada:	c1 18       	rjmp	8000dafc <_vfprintf_r+0x930>
8000dadc:	e0 40 00 47 	cp.w	r0,71
8000dae0:	5f 09       	sreq	r9
8000dae2:	e0 40 00 67 	cp.w	r0,103
8000dae6:	5f 08       	sreq	r8
8000dae8:	f3 e8 10 08 	or	r8,r9,r8
8000daec:	f8 08 18 00 	cp.b	r8,r12
8000daf0:	c0 60       	breq	8000dafc <_vfprintf_r+0x930>
8000daf2:	40 28       	lddsp	r8,sp[0x8]
8000daf4:	58 08       	cp.w	r8,0
8000daf6:	f9 b8 00 01 	moveq	r8,1
8000dafa:	50 28       	stdsp	sp[0x8],r8
8000dafc:	40 78       	lddsp	r8,sp[0x1c]
8000dafe:	40 59       	lddsp	r9,sp[0x14]
8000db00:	fa e9 06 94 	st.d	sp[1684],r8
8000db04:	a9 a5       	sbr	r5,0x8
8000db06:	fa f8 06 94 	ld.w	r8,sp[1684]
8000db0a:	58 08       	cp.w	r8,0
8000db0c:	c0 65       	brlt	8000db18 <_vfprintf_r+0x94c>
8000db0e:	40 5e       	lddsp	lr,sp[0x14]
8000db10:	30 0c       	mov	r12,0
8000db12:	50 6e       	stdsp	sp[0x18],lr
8000db14:	50 9c       	stdsp	sp[0x24],r12
8000db16:	c0 78       	rjmp	8000db24 <_vfprintf_r+0x958>
8000db18:	40 5b       	lddsp	r11,sp[0x14]
8000db1a:	32 da       	mov	r10,45
8000db1c:	ee 1b 80 00 	eorh	r11,0x8000
8000db20:	50 9a       	stdsp	sp[0x24],r10
8000db22:	50 6b       	stdsp	sp[0x18],r11
8000db24:	e0 40 00 46 	cp.w	r0,70
8000db28:	5f 09       	sreq	r9
8000db2a:	e0 40 00 66 	cp.w	r0,102
8000db2e:	5f 08       	sreq	r8
8000db30:	f3 e8 10 08 	or	r8,r9,r8
8000db34:	50 48       	stdsp	sp[0x10],r8
8000db36:	c0 40       	breq	8000db3e <_vfprintf_r+0x972>
8000db38:	40 22       	lddsp	r2,sp[0x8]
8000db3a:	30 39       	mov	r9,3
8000db3c:	c1 08       	rjmp	8000db5c <_vfprintf_r+0x990>
8000db3e:	e0 40 00 45 	cp.w	r0,69
8000db42:	5f 09       	sreq	r9
8000db44:	e0 40 00 65 	cp.w	r0,101
8000db48:	5f 08       	sreq	r8
8000db4a:	40 22       	lddsp	r2,sp[0x8]
8000db4c:	10 49       	or	r9,r8
8000db4e:	2f f2       	sub	r2,-1
8000db50:	40 46       	lddsp	r6,sp[0x10]
8000db52:	ec 09 18 00 	cp.b	r9,r6
8000db56:	fb f2 00 02 	ld.weq	r2,sp[0x8]
8000db5a:	30 29       	mov	r9,2
8000db5c:	fa c8 f9 5c 	sub	r8,sp,-1700
8000db60:	1a d8       	st.w	--sp,r8
8000db62:	fa c8 f9 54 	sub	r8,sp,-1708
8000db66:	1a d8       	st.w	--sp,r8
8000db68:	fa c8 f9 4c 	sub	r8,sp,-1716
8000db6c:	08 9c       	mov	r12,r4
8000db6e:	1a d8       	st.w	--sp,r8
8000db70:	04 98       	mov	r8,r2
8000db72:	40 9b       	lddsp	r11,sp[0x24]
8000db74:	40 aa       	lddsp	r10,sp[0x28]
8000db76:	f0 1f 00 23 	mcall	8000dc00 <_vfprintf_r+0xa34>
8000db7a:	e0 40 00 47 	cp.w	r0,71
8000db7e:	5f 19       	srne	r9
8000db80:	e0 40 00 67 	cp.w	r0,103
8000db84:	5f 18       	srne	r8
8000db86:	18 96       	mov	r6,r12
8000db88:	2f dd       	sub	sp,-12
8000db8a:	f3 e8 00 08 	and	r8,r9,r8
8000db8e:	c0 41       	brne	8000db96 <_vfprintf_r+0x9ca>
8000db90:	ed b5 00 00 	bld	r5,0x0
8000db94:	c4 41       	brne	8000dc1c <_vfprintf_r+0xa50>
8000db96:	ec 02 00 0e 	add	lr,r6,r2
8000db9a:	50 3e       	stdsp	sp[0xc],lr
8000db9c:	40 4c       	lddsp	r12,sp[0x10]
8000db9e:	58 0c       	cp.w	r12,0
8000dba0:	c1 50       	breq	8000dbca <_vfprintf_r+0x9fe>
8000dba2:	0d 89       	ld.ub	r9,r6[0x0]
8000dba4:	33 08       	mov	r8,48
8000dba6:	f0 09 18 00 	cp.b	r9,r8
8000dbaa:	c0 b1       	brne	8000dbc0 <_vfprintf_r+0x9f4>
8000dbac:	30 08       	mov	r8,0
8000dbae:	30 09       	mov	r9,0
8000dbb0:	40 6b       	lddsp	r11,sp[0x18]
8000dbb2:	40 7a       	lddsp	r10,sp[0x1c]
8000dbb4:	f0 1f 00 14 	mcall	8000dc04 <_vfprintf_r+0xa38>
8000dbb8:	fb b2 00 01 	rsubeq	r2,1
8000dbbc:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
8000dbc0:	40 3b       	lddsp	r11,sp[0xc]
8000dbc2:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000dbc6:	10 0b       	add	r11,r8
8000dbc8:	50 3b       	stdsp	sp[0xc],r11
8000dbca:	40 6b       	lddsp	r11,sp[0x18]
8000dbcc:	30 08       	mov	r8,0
8000dbce:	30 09       	mov	r9,0
8000dbd0:	40 7a       	lddsp	r10,sp[0x1c]
8000dbd2:	f0 1f 00 0d 	mcall	8000dc04 <_vfprintf_r+0xa38>
8000dbd6:	c1 d0       	breq	8000dc10 <_vfprintf_r+0xa44>
8000dbd8:	40 3a       	lddsp	r10,sp[0xc]
8000dbda:	fb 4a 06 a4 	st.w	sp[1700],r10
8000dbde:	c1 98       	rjmp	8000dc10 <_vfprintf_r+0xa44>
8000dbe0:	80 00       	ld.sh	r0,r0[0x0]
8000dbe2:	ce 88       	rjmp	8000ddb2 <_vfprintf_r+0xbe6>
8000dbe4:	80 01       	ld.sh	r1,r0[0x0]
8000dbe6:	16 a8       	st.w	r11++,r8
8000dbe8:	80 01       	ld.sh	r1,r0[0x0]
8000dbea:	1b b0       	ld.ub	r0,sp[0x3]
8000dbec:	80 01       	ld.sh	r1,r0[0x0]
8000dbee:	29 e4       	sub	r4,-98
8000dbf0:	80 01       	ld.sh	r1,r0[0x0]
8000dbf2:	29 e8       	sub	r8,-98
8000dbf4:	80 01       	ld.sh	r1,r0[0x0]
8000dbf6:	16 d2       	st.w	--r11,r2
8000dbf8:	80 01       	ld.sh	r1,r0[0x0]
8000dbfa:	29 ec       	sub	r12,-98
8000dbfc:	80 01       	ld.sh	r1,r0[0x0]
8000dbfe:	29 f0       	sub	r0,-97
8000dc00:	80 00       	ld.sh	r0,r0[0x0]
8000dc02:	f3 74 80 01 	stcond	r9[-32767],r4
8000dc06:	1b 22       	ld.uh	r2,sp++
8000dc08:	10 c9       	st.b	r8++,r9
8000dc0a:	fb 48 06 a4 	st.w	sp[1700],r8
8000dc0e:	c0 28       	rjmp	8000dc12 <_vfprintf_r+0xa46>
8000dc10:	33 09       	mov	r9,48
8000dc12:	fa f8 06 a4 	ld.w	r8,sp[1700]
8000dc16:	40 3e       	lddsp	lr,sp[0xc]
8000dc18:	1c 38       	cp.w	r8,lr
8000dc1a:	cf 73       	brcs	8000dc08 <_vfprintf_r+0xa3c>
8000dc1c:	e0 40 00 47 	cp.w	r0,71
8000dc20:	5f 09       	sreq	r9
8000dc22:	e0 40 00 67 	cp.w	r0,103
8000dc26:	5f 08       	sreq	r8
8000dc28:	f3 e8 10 08 	or	r8,r9,r8
8000dc2c:	fa f9 06 a4 	ld.w	r9,sp[1700]
8000dc30:	0c 19       	sub	r9,r6
8000dc32:	50 69       	stdsp	sp[0x18],r9
8000dc34:	58 08       	cp.w	r8,0
8000dc36:	c0 b0       	breq	8000dc4c <_vfprintf_r+0xa80>
8000dc38:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000dc3c:	5b d8       	cp.w	r8,-3
8000dc3e:	c0 55       	brlt	8000dc48 <_vfprintf_r+0xa7c>
8000dc40:	40 2c       	lddsp	r12,sp[0x8]
8000dc42:	18 38       	cp.w	r8,r12
8000dc44:	e0 8a 00 6a 	brle	8000dd18 <_vfprintf_r+0xb4c>
8000dc48:	20 20       	sub	r0,2
8000dc4a:	c0 58       	rjmp	8000dc54 <_vfprintf_r+0xa88>
8000dc4c:	e0 40 00 65 	cp.w	r0,101
8000dc50:	e0 89 00 46 	brgt	8000dcdc <_vfprintf_r+0xb10>
8000dc54:	fa fb 06 ac 	ld.w	r11,sp[1708]
8000dc58:	fb 60 06 9c 	st.b	sp[1692],r0
8000dc5c:	20 1b       	sub	r11,1
8000dc5e:	fb 4b 06 ac 	st.w	sp[1708],r11
8000dc62:	c0 47       	brpl	8000dc6a <_vfprintf_r+0xa9e>
8000dc64:	5c 3b       	neg	r11
8000dc66:	32 d8       	mov	r8,45
8000dc68:	c0 28       	rjmp	8000dc6c <_vfprintf_r+0xaa0>
8000dc6a:	32 b8       	mov	r8,43
8000dc6c:	fb 68 06 9d 	st.b	sp[1693],r8
8000dc70:	58 9b       	cp.w	r11,9
8000dc72:	e0 8a 00 1d 	brle	8000dcac <_vfprintf_r+0xae0>
8000dc76:	fa c9 fa 35 	sub	r9,sp,-1483
8000dc7a:	30 aa       	mov	r10,10
8000dc7c:	12 98       	mov	r8,r9
8000dc7e:	0e 9c       	mov	r12,r7
8000dc80:	0c 92       	mov	r2,r6
8000dc82:	f6 0a 0c 06 	divs	r6,r11,r10
8000dc86:	0e 9b       	mov	r11,r7
8000dc88:	2d 0b       	sub	r11,-48
8000dc8a:	10 fb       	st.b	--r8,r11
8000dc8c:	0c 9b       	mov	r11,r6
8000dc8e:	58 96       	cp.w	r6,9
8000dc90:	fe 99 ff f9 	brgt	8000dc82 <_vfprintf_r+0xab6>
8000dc94:	2d 0b       	sub	r11,-48
8000dc96:	18 97       	mov	r7,r12
8000dc98:	04 96       	mov	r6,r2
8000dc9a:	10 fb       	st.b	--r8,r11
8000dc9c:	fa ca f9 62 	sub	r10,sp,-1694
8000dca0:	c0 38       	rjmp	8000dca6 <_vfprintf_r+0xada>
8000dca2:	11 3b       	ld.ub	r11,r8++
8000dca4:	14 cb       	st.b	r10++,r11
8000dca6:	12 38       	cp.w	r8,r9
8000dca8:	cf d3       	brcs	8000dca2 <_vfprintf_r+0xad6>
8000dcaa:	c0 98       	rjmp	8000dcbc <_vfprintf_r+0xaf0>
8000dcac:	2d 0b       	sub	r11,-48
8000dcae:	33 08       	mov	r8,48
8000dcb0:	fb 6b 06 9f 	st.b	sp[1695],r11
8000dcb4:	fb 68 06 9e 	st.b	sp[1694],r8
8000dcb8:	fa ca f9 60 	sub	r10,sp,-1696
8000dcbc:	fa c8 f9 64 	sub	r8,sp,-1692
8000dcc0:	f4 08 01 08 	sub	r8,r10,r8
8000dcc4:	50 e8       	stdsp	sp[0x38],r8
8000dcc6:	10 92       	mov	r2,r8
8000dcc8:	40 6b       	lddsp	r11,sp[0x18]
8000dcca:	16 02       	add	r2,r11
8000dccc:	58 1b       	cp.w	r11,1
8000dcce:	e0 89 00 05 	brgt	8000dcd8 <_vfprintf_r+0xb0c>
8000dcd2:	ed b5 00 00 	bld	r5,0x0
8000dcd6:	c3 51       	brne	8000dd40 <_vfprintf_r+0xb74>
8000dcd8:	2f f2       	sub	r2,-1
8000dcda:	c3 38       	rjmp	8000dd40 <_vfprintf_r+0xb74>
8000dcdc:	e0 40 00 66 	cp.w	r0,102
8000dce0:	c1 c1       	brne	8000dd18 <_vfprintf_r+0xb4c>
8000dce2:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000dce6:	58 02       	cp.w	r2,0
8000dce8:	e0 8a 00 0c 	brle	8000dd00 <_vfprintf_r+0xb34>
8000dcec:	40 2a       	lddsp	r10,sp[0x8]
8000dcee:	58 0a       	cp.w	r10,0
8000dcf0:	c0 41       	brne	8000dcf8 <_vfprintf_r+0xb2c>
8000dcf2:	ed b5 00 00 	bld	r5,0x0
8000dcf6:	c2 51       	brne	8000dd40 <_vfprintf_r+0xb74>
8000dcf8:	2f f2       	sub	r2,-1
8000dcfa:	40 29       	lddsp	r9,sp[0x8]
8000dcfc:	12 02       	add	r2,r9
8000dcfe:	c0 b8       	rjmp	8000dd14 <_vfprintf_r+0xb48>
8000dd00:	40 28       	lddsp	r8,sp[0x8]
8000dd02:	58 08       	cp.w	r8,0
8000dd04:	c0 61       	brne	8000dd10 <_vfprintf_r+0xb44>
8000dd06:	ed b5 00 00 	bld	r5,0x0
8000dd0a:	c0 30       	breq	8000dd10 <_vfprintf_r+0xb44>
8000dd0c:	30 12       	mov	r2,1
8000dd0e:	c1 98       	rjmp	8000dd40 <_vfprintf_r+0xb74>
8000dd10:	40 22       	lddsp	r2,sp[0x8]
8000dd12:	2f e2       	sub	r2,-2
8000dd14:	36 60       	mov	r0,102
8000dd16:	c1 58       	rjmp	8000dd40 <_vfprintf_r+0xb74>
8000dd18:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000dd1c:	40 6e       	lddsp	lr,sp[0x18]
8000dd1e:	1c 32       	cp.w	r2,lr
8000dd20:	c0 65       	brlt	8000dd2c <_vfprintf_r+0xb60>
8000dd22:	ed b5 00 00 	bld	r5,0x0
8000dd26:	f7 b2 00 ff 	subeq	r2,-1
8000dd2a:	c0 a8       	rjmp	8000dd3e <_vfprintf_r+0xb72>
8000dd2c:	e4 08 11 02 	rsub	r8,r2,2
8000dd30:	40 6c       	lddsp	r12,sp[0x18]
8000dd32:	58 02       	cp.w	r2,0
8000dd34:	f0 02 17 a0 	movle	r2,r8
8000dd38:	f9 b2 09 01 	movgt	r2,1
8000dd3c:	18 02       	add	r2,r12
8000dd3e:	36 70       	mov	r0,103
8000dd40:	40 9b       	lddsp	r11,sp[0x24]
8000dd42:	58 0b       	cp.w	r11,0
8000dd44:	e0 80 05 9c 	breq	8000e87c <_vfprintf_r+0x16b0>
8000dd48:	32 d8       	mov	r8,45
8000dd4a:	fb 68 06 bb 	st.b	sp[1723],r8
8000dd4e:	e0 8f 05 9b 	bral	8000e884 <_vfprintf_r+0x16b8>
8000dd52:	50 a7       	stdsp	sp[0x28],r7
8000dd54:	04 94       	mov	r4,r2
8000dd56:	0c 97       	mov	r7,r6
8000dd58:	02 92       	mov	r2,r1
8000dd5a:	06 96       	mov	r6,r3
8000dd5c:	40 41       	lddsp	r1,sp[0x10]
8000dd5e:	40 93       	lddsp	r3,sp[0x24]
8000dd60:	0e 99       	mov	r9,r7
8000dd62:	ed b5 00 05 	bld	r5,0x5
8000dd66:	c4 81       	brne	8000ddf6 <_vfprintf_r+0xc2a>
8000dd68:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000dd6c:	40 3e       	lddsp	lr,sp[0xc]
8000dd6e:	58 0e       	cp.w	lr,0
8000dd70:	c1 d0       	breq	8000ddaa <_vfprintf_r+0xbde>
8000dd72:	10 36       	cp.w	r6,r8
8000dd74:	c0 64       	brge	8000dd80 <_vfprintf_r+0xbb4>
8000dd76:	fa cc f9 44 	sub	r12,sp,-1724
8000dd7a:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000dd7e:	c1 d8       	rjmp	8000ddb8 <_vfprintf_r+0xbec>
8000dd80:	fa c8 f9 50 	sub	r8,sp,-1712
8000dd84:	1a d8       	st.w	--sp,r8
8000dd86:	fa c8 fa b8 	sub	r8,sp,-1352
8000dd8a:	04 9a       	mov	r10,r2
8000dd8c:	1a d8       	st.w	--sp,r8
8000dd8e:	fa c8 fb b4 	sub	r8,sp,-1100
8000dd92:	0c 9b       	mov	r11,r6
8000dd94:	1a d8       	st.w	--sp,r8
8000dd96:	08 9c       	mov	r12,r4
8000dd98:	fa c8 f9 40 	sub	r8,sp,-1728
8000dd9c:	fa c9 ff b4 	sub	r9,sp,-76
8000dda0:	f0 1f 01 5f 	mcall	8000e31c <_vfprintf_r+0x1150>
8000dda4:	2f dd       	sub	sp,-12
8000dda6:	78 0a       	ld.w	r10,r12[0x0]
8000dda8:	c2 08       	rjmp	8000dde8 <_vfprintf_r+0xc1c>
8000ddaa:	2f f7       	sub	r7,-1
8000ddac:	10 39       	cp.w	r9,r8
8000ddae:	c0 84       	brge	8000ddbe <_vfprintf_r+0xbf2>
8000ddb0:	fa cb f9 44 	sub	r11,sp,-1724
8000ddb4:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000ddb8:	ec fa fd 88 	ld.w	r10,r6[-632]
8000ddbc:	c1 68       	rjmp	8000dde8 <_vfprintf_r+0xc1c>
8000ddbe:	41 09       	lddsp	r9,sp[0x40]
8000ddc0:	59 f8       	cp.w	r8,31
8000ddc2:	e0 89 00 10 	brgt	8000dde2 <_vfprintf_r+0xc16>
8000ddc6:	f2 ca ff fc 	sub	r10,r9,-4
8000ddca:	51 0a       	stdsp	sp[0x40],r10
8000ddcc:	fa c6 f9 44 	sub	r6,sp,-1724
8000ddd0:	72 0a       	ld.w	r10,r9[0x0]
8000ddd2:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000ddd6:	f3 4a fd 88 	st.w	r9[-632],r10
8000ddda:	2f f8       	sub	r8,-1
8000dddc:	fb 48 06 b4 	st.w	sp[1716],r8
8000dde0:	c0 48       	rjmp	8000dde8 <_vfprintf_r+0xc1c>
8000dde2:	72 0a       	ld.w	r10,r9[0x0]
8000dde4:	2f c9       	sub	r9,-4
8000dde6:	51 09       	stdsp	sp[0x40],r9
8000dde8:	40 be       	lddsp	lr,sp[0x2c]
8000ddea:	1c 98       	mov	r8,lr
8000ddec:	95 1e       	st.w	r10[0x4],lr
8000ddee:	bf 58       	asr	r8,0x1f
8000ddf0:	95 08       	st.w	r10[0x0],r8
8000ddf2:	fe 9f fa 79 	bral	8000d2e4 <_vfprintf_r+0x118>
8000ddf6:	ed b5 00 04 	bld	r5,0x4
8000ddfa:	c4 80       	breq	8000de8a <_vfprintf_r+0xcbe>
8000ddfc:	e2 15 00 40 	andl	r5,0x40,COH
8000de00:	c4 50       	breq	8000de8a <_vfprintf_r+0xcbe>
8000de02:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000de06:	40 3c       	lddsp	r12,sp[0xc]
8000de08:	58 0c       	cp.w	r12,0
8000de0a:	c1 d0       	breq	8000de44 <_vfprintf_r+0xc78>
8000de0c:	10 36       	cp.w	r6,r8
8000de0e:	c0 64       	brge	8000de1a <_vfprintf_r+0xc4e>
8000de10:	fa cb f9 44 	sub	r11,sp,-1724
8000de14:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000de18:	c1 d8       	rjmp	8000de52 <_vfprintf_r+0xc86>
8000de1a:	fa c8 f9 50 	sub	r8,sp,-1712
8000de1e:	1a d8       	st.w	--sp,r8
8000de20:	fa c8 fa b8 	sub	r8,sp,-1352
8000de24:	04 9a       	mov	r10,r2
8000de26:	1a d8       	st.w	--sp,r8
8000de28:	fa c8 fb b4 	sub	r8,sp,-1100
8000de2c:	0c 9b       	mov	r11,r6
8000de2e:	1a d8       	st.w	--sp,r8
8000de30:	08 9c       	mov	r12,r4
8000de32:	fa c8 f9 40 	sub	r8,sp,-1728
8000de36:	fa c9 ff b4 	sub	r9,sp,-76
8000de3a:	f0 1f 01 39 	mcall	8000e31c <_vfprintf_r+0x1150>
8000de3e:	2f dd       	sub	sp,-12
8000de40:	78 0a       	ld.w	r10,r12[0x0]
8000de42:	c2 08       	rjmp	8000de82 <_vfprintf_r+0xcb6>
8000de44:	2f f7       	sub	r7,-1
8000de46:	10 39       	cp.w	r9,r8
8000de48:	c0 84       	brge	8000de58 <_vfprintf_r+0xc8c>
8000de4a:	fa ca f9 44 	sub	r10,sp,-1724
8000de4e:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000de52:	ec fa fd 88 	ld.w	r10,r6[-632]
8000de56:	c1 68       	rjmp	8000de82 <_vfprintf_r+0xcb6>
8000de58:	41 09       	lddsp	r9,sp[0x40]
8000de5a:	59 f8       	cp.w	r8,31
8000de5c:	e0 89 00 10 	brgt	8000de7c <_vfprintf_r+0xcb0>
8000de60:	f2 ca ff fc 	sub	r10,r9,-4
8000de64:	51 0a       	stdsp	sp[0x40],r10
8000de66:	fa c6 f9 44 	sub	r6,sp,-1724
8000de6a:	72 0a       	ld.w	r10,r9[0x0]
8000de6c:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000de70:	f3 4a fd 88 	st.w	r9[-632],r10
8000de74:	2f f8       	sub	r8,-1
8000de76:	fb 48 06 b4 	st.w	sp[1716],r8
8000de7a:	c0 48       	rjmp	8000de82 <_vfprintf_r+0xcb6>
8000de7c:	72 0a       	ld.w	r10,r9[0x0]
8000de7e:	2f c9       	sub	r9,-4
8000de80:	51 09       	stdsp	sp[0x40],r9
8000de82:	40 be       	lddsp	lr,sp[0x2c]
8000de84:	b4 0e       	st.h	r10[0x0],lr
8000de86:	fe 9f fa 2f 	bral	8000d2e4 <_vfprintf_r+0x118>
8000de8a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000de8e:	40 3c       	lddsp	r12,sp[0xc]
8000de90:	58 0c       	cp.w	r12,0
8000de92:	c1 d0       	breq	8000decc <_vfprintf_r+0xd00>
8000de94:	10 36       	cp.w	r6,r8
8000de96:	c0 64       	brge	8000dea2 <_vfprintf_r+0xcd6>
8000de98:	fa cb f9 44 	sub	r11,sp,-1724
8000de9c:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000dea0:	c1 d8       	rjmp	8000deda <_vfprintf_r+0xd0e>
8000dea2:	fa c8 f9 50 	sub	r8,sp,-1712
8000dea6:	1a d8       	st.w	--sp,r8
8000dea8:	fa c8 fa b8 	sub	r8,sp,-1352
8000deac:	04 9a       	mov	r10,r2
8000deae:	1a d8       	st.w	--sp,r8
8000deb0:	fa c8 fb b4 	sub	r8,sp,-1100
8000deb4:	0c 9b       	mov	r11,r6
8000deb6:	1a d8       	st.w	--sp,r8
8000deb8:	08 9c       	mov	r12,r4
8000deba:	fa c8 f9 40 	sub	r8,sp,-1728
8000debe:	fa c9 ff b4 	sub	r9,sp,-76
8000dec2:	f0 1f 01 17 	mcall	8000e31c <_vfprintf_r+0x1150>
8000dec6:	2f dd       	sub	sp,-12
8000dec8:	78 0a       	ld.w	r10,r12[0x0]
8000deca:	c2 08       	rjmp	8000df0a <_vfprintf_r+0xd3e>
8000decc:	2f f7       	sub	r7,-1
8000dece:	10 39       	cp.w	r9,r8
8000ded0:	c0 84       	brge	8000dee0 <_vfprintf_r+0xd14>
8000ded2:	fa ca f9 44 	sub	r10,sp,-1724
8000ded6:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000deda:	ec fa fd 88 	ld.w	r10,r6[-632]
8000dede:	c1 68       	rjmp	8000df0a <_vfprintf_r+0xd3e>
8000dee0:	41 09       	lddsp	r9,sp[0x40]
8000dee2:	59 f8       	cp.w	r8,31
8000dee4:	e0 89 00 10 	brgt	8000df04 <_vfprintf_r+0xd38>
8000dee8:	f2 ca ff fc 	sub	r10,r9,-4
8000deec:	51 0a       	stdsp	sp[0x40],r10
8000deee:	fa c6 f9 44 	sub	r6,sp,-1724
8000def2:	72 0a       	ld.w	r10,r9[0x0]
8000def4:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000def8:	f3 4a fd 88 	st.w	r9[-632],r10
8000defc:	2f f8       	sub	r8,-1
8000defe:	fb 48 06 b4 	st.w	sp[1716],r8
8000df02:	c0 48       	rjmp	8000df0a <_vfprintf_r+0xd3e>
8000df04:	72 0a       	ld.w	r10,r9[0x0]
8000df06:	2f c9       	sub	r9,-4
8000df08:	51 09       	stdsp	sp[0x40],r9
8000df0a:	40 be       	lddsp	lr,sp[0x2c]
8000df0c:	95 0e       	st.w	r10[0x0],lr
8000df0e:	fe 9f f9 eb 	bral	8000d2e4 <_vfprintf_r+0x118>
8000df12:	50 a7       	stdsp	sp[0x28],r7
8000df14:	50 80       	stdsp	sp[0x20],r0
8000df16:	0c 97       	mov	r7,r6
8000df18:	04 94       	mov	r4,r2
8000df1a:	06 96       	mov	r6,r3
8000df1c:	02 92       	mov	r2,r1
8000df1e:	40 93       	lddsp	r3,sp[0x24]
8000df20:	10 90       	mov	r0,r8
8000df22:	40 41       	lddsp	r1,sp[0x10]
8000df24:	a5 a5       	sbr	r5,0x4
8000df26:	c0 a8       	rjmp	8000df3a <_vfprintf_r+0xd6e>
8000df28:	50 a7       	stdsp	sp[0x28],r7
8000df2a:	50 80       	stdsp	sp[0x20],r0
8000df2c:	0c 97       	mov	r7,r6
8000df2e:	04 94       	mov	r4,r2
8000df30:	06 96       	mov	r6,r3
8000df32:	02 92       	mov	r2,r1
8000df34:	40 93       	lddsp	r3,sp[0x24]
8000df36:	10 90       	mov	r0,r8
8000df38:	40 41       	lddsp	r1,sp[0x10]
8000df3a:	ed b5 00 05 	bld	r5,0x5
8000df3e:	c5 d1       	brne	8000dff8 <_vfprintf_r+0xe2c>
8000df40:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000df44:	40 3c       	lddsp	r12,sp[0xc]
8000df46:	58 0c       	cp.w	r12,0
8000df48:	c2 60       	breq	8000df94 <_vfprintf_r+0xdc8>
8000df4a:	10 36       	cp.w	r6,r8
8000df4c:	c0 a4       	brge	8000df60 <_vfprintf_r+0xd94>
8000df4e:	fa cb f9 44 	sub	r11,sp,-1724
8000df52:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000df56:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000df5a:	fa e9 00 00 	st.d	sp[0],r8
8000df5e:	c1 88       	rjmp	8000df8e <_vfprintf_r+0xdc2>
8000df60:	fa c8 f9 50 	sub	r8,sp,-1712
8000df64:	1a d8       	st.w	--sp,r8
8000df66:	fa c8 fa b8 	sub	r8,sp,-1352
8000df6a:	04 9a       	mov	r10,r2
8000df6c:	1a d8       	st.w	--sp,r8
8000df6e:	0c 9b       	mov	r11,r6
8000df70:	fa c8 fb b4 	sub	r8,sp,-1100
8000df74:	08 9c       	mov	r12,r4
8000df76:	1a d8       	st.w	--sp,r8
8000df78:	fa c8 f9 40 	sub	r8,sp,-1728
8000df7c:	fa c9 ff b4 	sub	r9,sp,-76
8000df80:	f0 1f 00 e7 	mcall	8000e31c <_vfprintf_r+0x1150>
8000df84:	2f dd       	sub	sp,-12
8000df86:	f8 ea 00 00 	ld.d	r10,r12[0]
8000df8a:	fa eb 00 00 	st.d	sp[0],r10
8000df8e:	30 08       	mov	r8,0
8000df90:	e0 8f 03 e6 	bral	8000e75c <_vfprintf_r+0x1590>
8000df94:	ee ca ff ff 	sub	r10,r7,-1
8000df98:	10 37       	cp.w	r7,r8
8000df9a:	c0 b4       	brge	8000dfb0 <_vfprintf_r+0xde4>
8000df9c:	fa c9 f9 44 	sub	r9,sp,-1724
8000dfa0:	14 97       	mov	r7,r10
8000dfa2:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000dfa6:	ec ea fd 88 	ld.d	r10,r6[-632]
8000dfaa:	fa eb 00 00 	st.d	sp[0],r10
8000dfae:	c1 88       	rjmp	8000dfde <_vfprintf_r+0xe12>
8000dfb0:	41 09       	lddsp	r9,sp[0x40]
8000dfb2:	59 f8       	cp.w	r8,31
8000dfb4:	e0 89 00 18 	brgt	8000dfe4 <_vfprintf_r+0xe18>
8000dfb8:	f2 e6 00 00 	ld.d	r6,r9[0]
8000dfbc:	f2 cb ff f8 	sub	r11,r9,-8
8000dfc0:	fa e7 00 00 	st.d	sp[0],r6
8000dfc4:	51 0b       	stdsp	sp[0x40],r11
8000dfc6:	fa c6 f9 44 	sub	r6,sp,-1724
8000dfca:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000dfce:	fa e6 00 00 	ld.d	r6,sp[0]
8000dfd2:	f2 e7 fd 88 	st.d	r9[-632],r6
8000dfd6:	2f f8       	sub	r8,-1
8000dfd8:	14 97       	mov	r7,r10
8000dfda:	fb 48 06 b4 	st.w	sp[1716],r8
8000dfde:	40 38       	lddsp	r8,sp[0xc]
8000dfe0:	e0 8f 03 be 	bral	8000e75c <_vfprintf_r+0x1590>
8000dfe4:	f2 e6 00 00 	ld.d	r6,r9[0]
8000dfe8:	40 38       	lddsp	r8,sp[0xc]
8000dfea:	fa e7 00 00 	st.d	sp[0],r6
8000dfee:	2f 89       	sub	r9,-8
8000dff0:	14 97       	mov	r7,r10
8000dff2:	51 09       	stdsp	sp[0x40],r9
8000dff4:	e0 8f 03 b4 	bral	8000e75c <_vfprintf_r+0x1590>
8000dff8:	ed b5 00 04 	bld	r5,0x4
8000dffc:	c1 61       	brne	8000e028 <_vfprintf_r+0xe5c>
8000dffe:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000e002:	40 3e       	lddsp	lr,sp[0xc]
8000e004:	58 0e       	cp.w	lr,0
8000e006:	c0 80       	breq	8000e016 <_vfprintf_r+0xe4a>
8000e008:	10 36       	cp.w	r6,r8
8000e00a:	c6 74       	brge	8000e0d8 <_vfprintf_r+0xf0c>
8000e00c:	fa cc f9 44 	sub	r12,sp,-1724
8000e010:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000e014:	c8 08       	rjmp	8000e114 <_vfprintf_r+0xf48>
8000e016:	ee ca ff ff 	sub	r10,r7,-1
8000e01a:	10 37       	cp.w	r7,r8
8000e01c:	c7 f4       	brge	8000e11a <_vfprintf_r+0xf4e>
8000e01e:	fa cb f9 44 	sub	r11,sp,-1724
8000e022:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000e026:	c7 68       	rjmp	8000e112 <_vfprintf_r+0xf46>
8000e028:	ed b5 00 06 	bld	r5,0x6
8000e02c:	c4 a1       	brne	8000e0c0 <_vfprintf_r+0xef4>
8000e02e:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000e032:	40 3c       	lddsp	r12,sp[0xc]
8000e034:	58 0c       	cp.w	r12,0
8000e036:	c1 d0       	breq	8000e070 <_vfprintf_r+0xea4>
8000e038:	10 36       	cp.w	r6,r8
8000e03a:	c0 64       	brge	8000e046 <_vfprintf_r+0xe7a>
8000e03c:	fa cb f9 44 	sub	r11,sp,-1724
8000e040:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000e044:	c1 f8       	rjmp	8000e082 <_vfprintf_r+0xeb6>
8000e046:	fa c8 f9 50 	sub	r8,sp,-1712
8000e04a:	1a d8       	st.w	--sp,r8
8000e04c:	fa c8 fa b8 	sub	r8,sp,-1352
8000e050:	1a d8       	st.w	--sp,r8
8000e052:	fa c8 fb b4 	sub	r8,sp,-1100
8000e056:	1a d8       	st.w	--sp,r8
8000e058:	fa c8 f9 40 	sub	r8,sp,-1728
8000e05c:	fa c9 ff b4 	sub	r9,sp,-76
8000e060:	04 9a       	mov	r10,r2
8000e062:	0c 9b       	mov	r11,r6
8000e064:	08 9c       	mov	r12,r4
8000e066:	f0 1f 00 ae 	mcall	8000e31c <_vfprintf_r+0x1150>
8000e06a:	2f dd       	sub	sp,-12
8000e06c:	98 18       	ld.sh	r8,r12[0x2]
8000e06e:	c2 68       	rjmp	8000e0ba <_vfprintf_r+0xeee>
8000e070:	ee ca ff ff 	sub	r10,r7,-1
8000e074:	10 37       	cp.w	r7,r8
8000e076:	c0 94       	brge	8000e088 <_vfprintf_r+0xebc>
8000e078:	fa c9 f9 44 	sub	r9,sp,-1724
8000e07c:	14 97       	mov	r7,r10
8000e07e:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000e082:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000e086:	c1 a8       	rjmp	8000e0ba <_vfprintf_r+0xeee>
8000e088:	41 09       	lddsp	r9,sp[0x40]
8000e08a:	59 f8       	cp.w	r8,31
8000e08c:	e0 89 00 13 	brgt	8000e0b2 <_vfprintf_r+0xee6>
8000e090:	f2 cb ff fc 	sub	r11,r9,-4
8000e094:	51 0b       	stdsp	sp[0x40],r11
8000e096:	72 09       	ld.w	r9,r9[0x0]
8000e098:	fa c6 f9 44 	sub	r6,sp,-1724
8000e09c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000e0a0:	2f f8       	sub	r8,-1
8000e0a2:	f7 49 fd 88 	st.w	r11[-632],r9
8000e0a6:	fb 48 06 b4 	st.w	sp[1716],r8
8000e0aa:	14 97       	mov	r7,r10
8000e0ac:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000e0b0:	c0 58       	rjmp	8000e0ba <_vfprintf_r+0xeee>
8000e0b2:	92 18       	ld.sh	r8,r9[0x2]
8000e0b4:	14 97       	mov	r7,r10
8000e0b6:	2f c9       	sub	r9,-4
8000e0b8:	51 09       	stdsp	sp[0x40],r9
8000e0ba:	5c 78       	castu.h	r8
8000e0bc:	50 18       	stdsp	sp[0x4],r8
8000e0be:	c4 68       	rjmp	8000e14a <_vfprintf_r+0xf7e>
8000e0c0:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000e0c4:	40 3c       	lddsp	r12,sp[0xc]
8000e0c6:	58 0c       	cp.w	r12,0
8000e0c8:	c1 d0       	breq	8000e102 <_vfprintf_r+0xf36>
8000e0ca:	10 36       	cp.w	r6,r8
8000e0cc:	c0 64       	brge	8000e0d8 <_vfprintf_r+0xf0c>
8000e0ce:	fa cb f9 44 	sub	r11,sp,-1724
8000e0d2:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000e0d6:	c1 f8       	rjmp	8000e114 <_vfprintf_r+0xf48>
8000e0d8:	fa c8 f9 50 	sub	r8,sp,-1712
8000e0dc:	1a d8       	st.w	--sp,r8
8000e0de:	fa c8 fa b8 	sub	r8,sp,-1352
8000e0e2:	0c 9b       	mov	r11,r6
8000e0e4:	1a d8       	st.w	--sp,r8
8000e0e6:	fa c8 fb b4 	sub	r8,sp,-1100
8000e0ea:	04 9a       	mov	r10,r2
8000e0ec:	1a d8       	st.w	--sp,r8
8000e0ee:	08 9c       	mov	r12,r4
8000e0f0:	fa c8 f9 40 	sub	r8,sp,-1728
8000e0f4:	fa c9 ff b4 	sub	r9,sp,-76
8000e0f8:	f0 1f 00 89 	mcall	8000e31c <_vfprintf_r+0x1150>
8000e0fc:	2f dd       	sub	sp,-12
8000e0fe:	78 0b       	ld.w	r11,r12[0x0]
8000e100:	c2 48       	rjmp	8000e148 <_vfprintf_r+0xf7c>
8000e102:	ee ca ff ff 	sub	r10,r7,-1
8000e106:	10 37       	cp.w	r7,r8
8000e108:	c0 94       	brge	8000e11a <_vfprintf_r+0xf4e>
8000e10a:	fa c9 f9 44 	sub	r9,sp,-1724
8000e10e:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000e112:	14 97       	mov	r7,r10
8000e114:	ec fb fd 88 	ld.w	r11,r6[-632]
8000e118:	c1 88       	rjmp	8000e148 <_vfprintf_r+0xf7c>
8000e11a:	41 09       	lddsp	r9,sp[0x40]
8000e11c:	59 f8       	cp.w	r8,31
8000e11e:	e0 89 00 11 	brgt	8000e140 <_vfprintf_r+0xf74>
8000e122:	f2 cb ff fc 	sub	r11,r9,-4
8000e126:	51 0b       	stdsp	sp[0x40],r11
8000e128:	fa c6 f9 44 	sub	r6,sp,-1724
8000e12c:	72 0b       	ld.w	r11,r9[0x0]
8000e12e:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000e132:	f3 4b fd 88 	st.w	r9[-632],r11
8000e136:	2f f8       	sub	r8,-1
8000e138:	14 97       	mov	r7,r10
8000e13a:	fb 48 06 b4 	st.w	sp[1716],r8
8000e13e:	c0 58       	rjmp	8000e148 <_vfprintf_r+0xf7c>
8000e140:	72 0b       	ld.w	r11,r9[0x0]
8000e142:	14 97       	mov	r7,r10
8000e144:	2f c9       	sub	r9,-4
8000e146:	51 09       	stdsp	sp[0x40],r9
8000e148:	50 1b       	stdsp	sp[0x4],r11
8000e14a:	30 0e       	mov	lr,0
8000e14c:	50 0e       	stdsp	sp[0x0],lr
8000e14e:	1c 98       	mov	r8,lr
8000e150:	e0 8f 03 06 	bral	8000e75c <_vfprintf_r+0x1590>
8000e154:	50 a7       	stdsp	sp[0x28],r7
8000e156:	50 80       	stdsp	sp[0x20],r0
8000e158:	0c 97       	mov	r7,r6
8000e15a:	04 94       	mov	r4,r2
8000e15c:	06 96       	mov	r6,r3
8000e15e:	02 92       	mov	r2,r1
8000e160:	40 93       	lddsp	r3,sp[0x24]
8000e162:	40 41       	lddsp	r1,sp[0x10]
8000e164:	0e 99       	mov	r9,r7
8000e166:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000e16a:	40 3c       	lddsp	r12,sp[0xc]
8000e16c:	58 0c       	cp.w	r12,0
8000e16e:	c1 d0       	breq	8000e1a8 <_vfprintf_r+0xfdc>
8000e170:	10 36       	cp.w	r6,r8
8000e172:	c0 64       	brge	8000e17e <_vfprintf_r+0xfb2>
8000e174:	fa cb f9 44 	sub	r11,sp,-1724
8000e178:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000e17c:	c1 d8       	rjmp	8000e1b6 <_vfprintf_r+0xfea>
8000e17e:	fa c8 f9 50 	sub	r8,sp,-1712
8000e182:	1a d8       	st.w	--sp,r8
8000e184:	fa c8 fa b8 	sub	r8,sp,-1352
8000e188:	1a d8       	st.w	--sp,r8
8000e18a:	fa c8 fb b4 	sub	r8,sp,-1100
8000e18e:	1a d8       	st.w	--sp,r8
8000e190:	fa c9 ff b4 	sub	r9,sp,-76
8000e194:	fa c8 f9 40 	sub	r8,sp,-1728
8000e198:	04 9a       	mov	r10,r2
8000e19a:	0c 9b       	mov	r11,r6
8000e19c:	08 9c       	mov	r12,r4
8000e19e:	f0 1f 00 60 	mcall	8000e31c <_vfprintf_r+0x1150>
8000e1a2:	2f dd       	sub	sp,-12
8000e1a4:	78 09       	ld.w	r9,r12[0x0]
8000e1a6:	c2 18       	rjmp	8000e1e8 <_vfprintf_r+0x101c>
8000e1a8:	2f f7       	sub	r7,-1
8000e1aa:	10 39       	cp.w	r9,r8
8000e1ac:	c0 84       	brge	8000e1bc <_vfprintf_r+0xff0>
8000e1ae:	fa ca f9 44 	sub	r10,sp,-1724
8000e1b2:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000e1b6:	ec f9 fd 88 	ld.w	r9,r6[-632]
8000e1ba:	c1 78       	rjmp	8000e1e8 <_vfprintf_r+0x101c>
8000e1bc:	41 09       	lddsp	r9,sp[0x40]
8000e1be:	59 f8       	cp.w	r8,31
8000e1c0:	e0 89 00 10 	brgt	8000e1e0 <_vfprintf_r+0x1014>
8000e1c4:	f2 ca ff fc 	sub	r10,r9,-4
8000e1c8:	51 0a       	stdsp	sp[0x40],r10
8000e1ca:	fa c6 f9 44 	sub	r6,sp,-1724
8000e1ce:	72 09       	ld.w	r9,r9[0x0]
8000e1d0:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000e1d4:	f5 49 fd 88 	st.w	r10[-632],r9
8000e1d8:	2f f8       	sub	r8,-1
8000e1da:	fb 48 06 b4 	st.w	sp[1716],r8
8000e1de:	c0 58       	rjmp	8000e1e8 <_vfprintf_r+0x101c>
8000e1e0:	f2 c8 ff fc 	sub	r8,r9,-4
8000e1e4:	51 08       	stdsp	sp[0x40],r8
8000e1e6:	72 09       	ld.w	r9,r9[0x0]
8000e1e8:	33 08       	mov	r8,48
8000e1ea:	fb 68 06 b8 	st.b	sp[1720],r8
8000e1ee:	37 88       	mov	r8,120
8000e1f0:	30 0e       	mov	lr,0
8000e1f2:	fb 68 06 b9 	st.b	sp[1721],r8
8000e1f6:	4c bc       	lddpc	r12,8000e320 <_vfprintf_r+0x1154>
8000e1f8:	50 19       	stdsp	sp[0x4],r9
8000e1fa:	a1 b5       	sbr	r5,0x1
8000e1fc:	50 0e       	stdsp	sp[0x0],lr
8000e1fe:	50 dc       	stdsp	sp[0x34],r12
8000e200:	30 28       	mov	r8,2
8000e202:	37 80       	mov	r0,120
8000e204:	e0 8f 02 ac 	bral	8000e75c <_vfprintf_r+0x1590>
8000e208:	50 a7       	stdsp	sp[0x28],r7
8000e20a:	50 80       	stdsp	sp[0x20],r0
8000e20c:	10 90       	mov	r0,r8
8000e20e:	30 08       	mov	r8,0
8000e210:	fb 68 06 bb 	st.b	sp[1723],r8
8000e214:	0c 97       	mov	r7,r6
8000e216:	04 94       	mov	r4,r2
8000e218:	06 96       	mov	r6,r3
8000e21a:	02 92       	mov	r2,r1
8000e21c:	40 93       	lddsp	r3,sp[0x24]
8000e21e:	40 41       	lddsp	r1,sp[0x10]
8000e220:	0e 99       	mov	r9,r7
8000e222:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000e226:	40 3b       	lddsp	r11,sp[0xc]
8000e228:	58 0b       	cp.w	r11,0
8000e22a:	c1 d0       	breq	8000e264 <_vfprintf_r+0x1098>
8000e22c:	10 36       	cp.w	r6,r8
8000e22e:	c0 64       	brge	8000e23a <_vfprintf_r+0x106e>
8000e230:	fa ca f9 44 	sub	r10,sp,-1724
8000e234:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000e238:	c1 d8       	rjmp	8000e272 <_vfprintf_r+0x10a6>
8000e23a:	fa c8 f9 50 	sub	r8,sp,-1712
8000e23e:	1a d8       	st.w	--sp,r8
8000e240:	fa c8 fa b8 	sub	r8,sp,-1352
8000e244:	1a d8       	st.w	--sp,r8
8000e246:	fa c8 fb b4 	sub	r8,sp,-1100
8000e24a:	0c 9b       	mov	r11,r6
8000e24c:	1a d8       	st.w	--sp,r8
8000e24e:	04 9a       	mov	r10,r2
8000e250:	fa c8 f9 40 	sub	r8,sp,-1728
8000e254:	fa c9 ff b4 	sub	r9,sp,-76
8000e258:	08 9c       	mov	r12,r4
8000e25a:	f0 1f 00 31 	mcall	8000e31c <_vfprintf_r+0x1150>
8000e25e:	2f dd       	sub	sp,-12
8000e260:	78 06       	ld.w	r6,r12[0x0]
8000e262:	c2 08       	rjmp	8000e2a2 <_vfprintf_r+0x10d6>
8000e264:	2f f7       	sub	r7,-1
8000e266:	10 39       	cp.w	r9,r8
8000e268:	c0 84       	brge	8000e278 <_vfprintf_r+0x10ac>
8000e26a:	fa c9 f9 44 	sub	r9,sp,-1724
8000e26e:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000e272:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000e276:	c1 68       	rjmp	8000e2a2 <_vfprintf_r+0x10d6>
8000e278:	41 09       	lddsp	r9,sp[0x40]
8000e27a:	59 f8       	cp.w	r8,31
8000e27c:	e0 89 00 10 	brgt	8000e29c <_vfprintf_r+0x10d0>
8000e280:	f2 ca ff fc 	sub	r10,r9,-4
8000e284:	51 0a       	stdsp	sp[0x40],r10
8000e286:	72 06       	ld.w	r6,r9[0x0]
8000e288:	fa ce f9 44 	sub	lr,sp,-1724
8000e28c:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000e290:	f3 46 fd 88 	st.w	r9[-632],r6
8000e294:	2f f8       	sub	r8,-1
8000e296:	fb 48 06 b4 	st.w	sp[1716],r8
8000e29a:	c0 48       	rjmp	8000e2a2 <_vfprintf_r+0x10d6>
8000e29c:	72 06       	ld.w	r6,r9[0x0]
8000e29e:	2f c9       	sub	r9,-4
8000e2a0:	51 09       	stdsp	sp[0x40],r9
8000e2a2:	40 2c       	lddsp	r12,sp[0x8]
8000e2a4:	58 0c       	cp.w	r12,0
8000e2a6:	c1 05       	brlt	8000e2c6 <_vfprintf_r+0x10fa>
8000e2a8:	18 9a       	mov	r10,r12
8000e2aa:	30 0b       	mov	r11,0
8000e2ac:	0c 9c       	mov	r12,r6
8000e2ae:	f0 1f 00 1e 	mcall	8000e324 <_vfprintf_r+0x1158>
8000e2b2:	e0 80 02 e8 	breq	8000e882 <_vfprintf_r+0x16b6>
8000e2b6:	f8 06 01 02 	sub	r2,r12,r6
8000e2ba:	40 2b       	lddsp	r11,sp[0x8]
8000e2bc:	16 32       	cp.w	r2,r11
8000e2be:	e0 89 02 e2 	brgt	8000e882 <_vfprintf_r+0x16b6>
8000e2c2:	e0 8f 02 dd 	bral	8000e87c <_vfprintf_r+0x16b0>
8000e2c6:	30 0a       	mov	r10,0
8000e2c8:	0c 9c       	mov	r12,r6
8000e2ca:	50 2a       	stdsp	sp[0x8],r10
8000e2cc:	f0 1f 00 17 	mcall	8000e328 <_vfprintf_r+0x115c>
8000e2d0:	18 92       	mov	r2,r12
8000e2d2:	e0 8f 02 db 	bral	8000e888 <_vfprintf_r+0x16bc>
8000e2d6:	50 a7       	stdsp	sp[0x28],r7
8000e2d8:	50 80       	stdsp	sp[0x20],r0
8000e2da:	0c 97       	mov	r7,r6
8000e2dc:	04 94       	mov	r4,r2
8000e2de:	06 96       	mov	r6,r3
8000e2e0:	02 92       	mov	r2,r1
8000e2e2:	40 93       	lddsp	r3,sp[0x24]
8000e2e4:	10 90       	mov	r0,r8
8000e2e6:	40 41       	lddsp	r1,sp[0x10]
8000e2e8:	a5 a5       	sbr	r5,0x4
8000e2ea:	c0 a8       	rjmp	8000e2fe <_vfprintf_r+0x1132>
8000e2ec:	50 a7       	stdsp	sp[0x28],r7
8000e2ee:	50 80       	stdsp	sp[0x20],r0
8000e2f0:	0c 97       	mov	r7,r6
8000e2f2:	04 94       	mov	r4,r2
8000e2f4:	06 96       	mov	r6,r3
8000e2f6:	02 92       	mov	r2,r1
8000e2f8:	40 93       	lddsp	r3,sp[0x24]
8000e2fa:	10 90       	mov	r0,r8
8000e2fc:	40 41       	lddsp	r1,sp[0x10]
8000e2fe:	ed b5 00 05 	bld	r5,0x5
8000e302:	c5 d1       	brne	8000e3bc <_vfprintf_r+0x11f0>
8000e304:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000e308:	40 39       	lddsp	r9,sp[0xc]
8000e30a:	58 09       	cp.w	r9,0
8000e30c:	c2 80       	breq	8000e35c <_vfprintf_r+0x1190>
8000e30e:	10 36       	cp.w	r6,r8
8000e310:	c0 e4       	brge	8000e32c <_vfprintf_r+0x1160>
8000e312:	fa c8 f9 44 	sub	r8,sp,-1724
8000e316:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000e31a:	c2 a8       	rjmp	8000e36e <_vfprintf_r+0x11a2>
8000e31c:	80 00       	ld.sh	r0,r0[0x0]
8000e31e:	ce 88       	rjmp	8000e4ee <_vfprintf_r+0x1322>
8000e320:	80 01       	ld.sh	r1,r0[0x0]
8000e322:	29 f4       	sub	r4,-97
8000e324:	80 01       	ld.sh	r1,r0[0x0]
8000e326:	0d 2c       	ld.uh	r12,r6++
8000e328:	80 00       	ld.sh	r0,r0[0x0]
8000e32a:	ce 50       	breq	8000e2f4 <_vfprintf_r+0x1128>
8000e32c:	fa c8 f9 50 	sub	r8,sp,-1712
8000e330:	1a d8       	st.w	--sp,r8
8000e332:	fa c8 fa b8 	sub	r8,sp,-1352
8000e336:	1a d8       	st.w	--sp,r8
8000e338:	fa c8 fb b4 	sub	r8,sp,-1100
8000e33c:	1a d8       	st.w	--sp,r8
8000e33e:	fa c8 f9 40 	sub	r8,sp,-1728
8000e342:	fa c9 ff b4 	sub	r9,sp,-76
8000e346:	04 9a       	mov	r10,r2
8000e348:	0c 9b       	mov	r11,r6
8000e34a:	08 9c       	mov	r12,r4
8000e34c:	f0 1f 00 c8 	mcall	8000e66c <_vfprintf_r+0x14a0>
8000e350:	2f dd       	sub	sp,-12
8000e352:	f8 e8 00 00 	ld.d	r8,r12[0]
8000e356:	fa e9 00 00 	st.d	sp[0],r8
8000e35a:	c2 e8       	rjmp	8000e3b6 <_vfprintf_r+0x11ea>
8000e35c:	ee ca ff ff 	sub	r10,r7,-1
8000e360:	10 37       	cp.w	r7,r8
8000e362:	c0 b4       	brge	8000e378 <_vfprintf_r+0x11ac>
8000e364:	fa c8 f9 44 	sub	r8,sp,-1724
8000e368:	14 97       	mov	r7,r10
8000e36a:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000e36e:	ec ea fd 88 	ld.d	r10,r6[-632]
8000e372:	fa eb 00 00 	st.d	sp[0],r10
8000e376:	c2 08       	rjmp	8000e3b6 <_vfprintf_r+0x11ea>
8000e378:	41 09       	lddsp	r9,sp[0x40]
8000e37a:	59 f8       	cp.w	r8,31
8000e37c:	e0 89 00 16 	brgt	8000e3a8 <_vfprintf_r+0x11dc>
8000e380:	f2 e6 00 00 	ld.d	r6,r9[0]
8000e384:	f2 cb ff f8 	sub	r11,r9,-8
8000e388:	fa e7 00 00 	st.d	sp[0],r6
8000e38c:	51 0b       	stdsp	sp[0x40],r11
8000e38e:	fa c6 f9 44 	sub	r6,sp,-1724
8000e392:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000e396:	fa e6 00 00 	ld.d	r6,sp[0]
8000e39a:	f2 e7 fd 88 	st.d	r9[-632],r6
8000e39e:	2f f8       	sub	r8,-1
8000e3a0:	14 97       	mov	r7,r10
8000e3a2:	fb 48 06 b4 	st.w	sp[1716],r8
8000e3a6:	c0 88       	rjmp	8000e3b6 <_vfprintf_r+0x11ea>
8000e3a8:	f2 e6 00 00 	ld.d	r6,r9[0]
8000e3ac:	2f 89       	sub	r9,-8
8000e3ae:	fa e7 00 00 	st.d	sp[0],r6
8000e3b2:	51 09       	stdsp	sp[0x40],r9
8000e3b4:	14 97       	mov	r7,r10
8000e3b6:	30 18       	mov	r8,1
8000e3b8:	e0 8f 01 d2 	bral	8000e75c <_vfprintf_r+0x1590>
8000e3bc:	ed b5 00 04 	bld	r5,0x4
8000e3c0:	c1 61       	brne	8000e3ec <_vfprintf_r+0x1220>
8000e3c2:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000e3c6:	40 3e       	lddsp	lr,sp[0xc]
8000e3c8:	58 0e       	cp.w	lr,0
8000e3ca:	c0 80       	breq	8000e3da <_vfprintf_r+0x120e>
8000e3cc:	10 36       	cp.w	r6,r8
8000e3ce:	c6 74       	brge	8000e49c <_vfprintf_r+0x12d0>
8000e3d0:	fa cc f9 44 	sub	r12,sp,-1724
8000e3d4:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000e3d8:	c8 08       	rjmp	8000e4d8 <_vfprintf_r+0x130c>
8000e3da:	ee ca ff ff 	sub	r10,r7,-1
8000e3de:	10 37       	cp.w	r7,r8
8000e3e0:	c7 f4       	brge	8000e4de <_vfprintf_r+0x1312>
8000e3e2:	fa cb f9 44 	sub	r11,sp,-1724
8000e3e6:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000e3ea:	c7 68       	rjmp	8000e4d6 <_vfprintf_r+0x130a>
8000e3ec:	ed b5 00 06 	bld	r5,0x6
8000e3f0:	c4 a1       	brne	8000e484 <_vfprintf_r+0x12b8>
8000e3f2:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000e3f6:	40 3c       	lddsp	r12,sp[0xc]
8000e3f8:	58 0c       	cp.w	r12,0
8000e3fa:	c1 d0       	breq	8000e434 <_vfprintf_r+0x1268>
8000e3fc:	10 36       	cp.w	r6,r8
8000e3fe:	c0 64       	brge	8000e40a <_vfprintf_r+0x123e>
8000e400:	fa cb f9 44 	sub	r11,sp,-1724
8000e404:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000e408:	c1 f8       	rjmp	8000e446 <_vfprintf_r+0x127a>
8000e40a:	fa c8 f9 50 	sub	r8,sp,-1712
8000e40e:	1a d8       	st.w	--sp,r8
8000e410:	fa c8 fa b8 	sub	r8,sp,-1352
8000e414:	1a d8       	st.w	--sp,r8
8000e416:	fa c8 fb b4 	sub	r8,sp,-1100
8000e41a:	1a d8       	st.w	--sp,r8
8000e41c:	fa c8 f9 40 	sub	r8,sp,-1728
8000e420:	fa c9 ff b4 	sub	r9,sp,-76
8000e424:	04 9a       	mov	r10,r2
8000e426:	0c 9b       	mov	r11,r6
8000e428:	08 9c       	mov	r12,r4
8000e42a:	f0 1f 00 91 	mcall	8000e66c <_vfprintf_r+0x14a0>
8000e42e:	2f dd       	sub	sp,-12
8000e430:	98 18       	ld.sh	r8,r12[0x2]
8000e432:	c2 68       	rjmp	8000e47e <_vfprintf_r+0x12b2>
8000e434:	ee ca ff ff 	sub	r10,r7,-1
8000e438:	10 37       	cp.w	r7,r8
8000e43a:	c0 94       	brge	8000e44c <_vfprintf_r+0x1280>
8000e43c:	fa c9 f9 44 	sub	r9,sp,-1724
8000e440:	14 97       	mov	r7,r10
8000e442:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000e446:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000e44a:	c1 a8       	rjmp	8000e47e <_vfprintf_r+0x12b2>
8000e44c:	41 09       	lddsp	r9,sp[0x40]
8000e44e:	59 f8       	cp.w	r8,31
8000e450:	e0 89 00 13 	brgt	8000e476 <_vfprintf_r+0x12aa>
8000e454:	f2 cb ff fc 	sub	r11,r9,-4
8000e458:	51 0b       	stdsp	sp[0x40],r11
8000e45a:	72 09       	ld.w	r9,r9[0x0]
8000e45c:	fa c6 f9 44 	sub	r6,sp,-1724
8000e460:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000e464:	2f f8       	sub	r8,-1
8000e466:	f7 49 fd 88 	st.w	r11[-632],r9
8000e46a:	fb 48 06 b4 	st.w	sp[1716],r8
8000e46e:	14 97       	mov	r7,r10
8000e470:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000e474:	c0 58       	rjmp	8000e47e <_vfprintf_r+0x12b2>
8000e476:	92 18       	ld.sh	r8,r9[0x2]
8000e478:	14 97       	mov	r7,r10
8000e47a:	2f c9       	sub	r9,-4
8000e47c:	51 09       	stdsp	sp[0x40],r9
8000e47e:	5c 78       	castu.h	r8
8000e480:	50 18       	stdsp	sp[0x4],r8
8000e482:	c4 68       	rjmp	8000e50e <_vfprintf_r+0x1342>
8000e484:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000e488:	40 3c       	lddsp	r12,sp[0xc]
8000e48a:	58 0c       	cp.w	r12,0
8000e48c:	c1 d0       	breq	8000e4c6 <_vfprintf_r+0x12fa>
8000e48e:	10 36       	cp.w	r6,r8
8000e490:	c0 64       	brge	8000e49c <_vfprintf_r+0x12d0>
8000e492:	fa cb f9 44 	sub	r11,sp,-1724
8000e496:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000e49a:	c1 f8       	rjmp	8000e4d8 <_vfprintf_r+0x130c>
8000e49c:	fa c8 f9 50 	sub	r8,sp,-1712
8000e4a0:	1a d8       	st.w	--sp,r8
8000e4a2:	fa c8 fa b8 	sub	r8,sp,-1352
8000e4a6:	0c 9b       	mov	r11,r6
8000e4a8:	1a d8       	st.w	--sp,r8
8000e4aa:	fa c8 fb b4 	sub	r8,sp,-1100
8000e4ae:	04 9a       	mov	r10,r2
8000e4b0:	1a d8       	st.w	--sp,r8
8000e4b2:	08 9c       	mov	r12,r4
8000e4b4:	fa c8 f9 40 	sub	r8,sp,-1728
8000e4b8:	fa c9 ff b4 	sub	r9,sp,-76
8000e4bc:	f0 1f 00 6c 	mcall	8000e66c <_vfprintf_r+0x14a0>
8000e4c0:	2f dd       	sub	sp,-12
8000e4c2:	78 0b       	ld.w	r11,r12[0x0]
8000e4c4:	c2 48       	rjmp	8000e50c <_vfprintf_r+0x1340>
8000e4c6:	ee ca ff ff 	sub	r10,r7,-1
8000e4ca:	10 37       	cp.w	r7,r8
8000e4cc:	c0 94       	brge	8000e4de <_vfprintf_r+0x1312>
8000e4ce:	fa c9 f9 44 	sub	r9,sp,-1724
8000e4d2:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000e4d6:	14 97       	mov	r7,r10
8000e4d8:	ec fb fd 88 	ld.w	r11,r6[-632]
8000e4dc:	c1 88       	rjmp	8000e50c <_vfprintf_r+0x1340>
8000e4de:	41 09       	lddsp	r9,sp[0x40]
8000e4e0:	59 f8       	cp.w	r8,31
8000e4e2:	e0 89 00 11 	brgt	8000e504 <_vfprintf_r+0x1338>
8000e4e6:	f2 cb ff fc 	sub	r11,r9,-4
8000e4ea:	51 0b       	stdsp	sp[0x40],r11
8000e4ec:	fa c6 f9 44 	sub	r6,sp,-1724
8000e4f0:	72 0b       	ld.w	r11,r9[0x0]
8000e4f2:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000e4f6:	f3 4b fd 88 	st.w	r9[-632],r11
8000e4fa:	2f f8       	sub	r8,-1
8000e4fc:	14 97       	mov	r7,r10
8000e4fe:	fb 48 06 b4 	st.w	sp[1716],r8
8000e502:	c0 58       	rjmp	8000e50c <_vfprintf_r+0x1340>
8000e504:	72 0b       	ld.w	r11,r9[0x0]
8000e506:	14 97       	mov	r7,r10
8000e508:	2f c9       	sub	r9,-4
8000e50a:	51 09       	stdsp	sp[0x40],r9
8000e50c:	50 1b       	stdsp	sp[0x4],r11
8000e50e:	30 0e       	mov	lr,0
8000e510:	30 18       	mov	r8,1
8000e512:	50 0e       	stdsp	sp[0x0],lr
8000e514:	c2 49       	rjmp	8000e75c <_vfprintf_r+0x1590>
8000e516:	50 a7       	stdsp	sp[0x28],r7
8000e518:	50 80       	stdsp	sp[0x20],r0
8000e51a:	0c 97       	mov	r7,r6
8000e51c:	04 94       	mov	r4,r2
8000e51e:	06 96       	mov	r6,r3
8000e520:	02 92       	mov	r2,r1
8000e522:	4d 4c       	lddpc	r12,8000e670 <_vfprintf_r+0x14a4>
8000e524:	40 93       	lddsp	r3,sp[0x24]
8000e526:	10 90       	mov	r0,r8
8000e528:	40 41       	lddsp	r1,sp[0x10]
8000e52a:	50 dc       	stdsp	sp[0x34],r12
8000e52c:	ed b5 00 05 	bld	r5,0x5
8000e530:	c5 51       	brne	8000e5da <_vfprintf_r+0x140e>
8000e532:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000e536:	40 3b       	lddsp	r11,sp[0xc]
8000e538:	58 0b       	cp.w	r11,0
8000e53a:	c2 20       	breq	8000e57e <_vfprintf_r+0x13b2>
8000e53c:	10 36       	cp.w	r6,r8
8000e53e:	c0 a4       	brge	8000e552 <_vfprintf_r+0x1386>
8000e540:	fa ca f9 44 	sub	r10,sp,-1724
8000e544:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000e548:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000e54c:	fa e9 00 00 	st.d	sp[0],r8
8000e550:	cf 58       	rjmp	8000e73a <_vfprintf_r+0x156e>
8000e552:	fa c8 f9 50 	sub	r8,sp,-1712
8000e556:	1a d8       	st.w	--sp,r8
8000e558:	fa c8 fa b8 	sub	r8,sp,-1352
8000e55c:	04 9a       	mov	r10,r2
8000e55e:	1a d8       	st.w	--sp,r8
8000e560:	0c 9b       	mov	r11,r6
8000e562:	fa c8 fb b4 	sub	r8,sp,-1100
8000e566:	08 9c       	mov	r12,r4
8000e568:	1a d8       	st.w	--sp,r8
8000e56a:	fa c8 f9 40 	sub	r8,sp,-1728
8000e56e:	fa c9 ff b4 	sub	r9,sp,-76
8000e572:	f0 1f 00 3f 	mcall	8000e66c <_vfprintf_r+0x14a0>
8000e576:	2f dd       	sub	sp,-12
8000e578:	f8 ea 00 00 	ld.d	r10,r12[0]
8000e57c:	c0 c8       	rjmp	8000e594 <_vfprintf_r+0x13c8>
8000e57e:	ee ca ff ff 	sub	r10,r7,-1
8000e582:	10 37       	cp.w	r7,r8
8000e584:	c0 b4       	brge	8000e59a <_vfprintf_r+0x13ce>
8000e586:	fa c9 f9 44 	sub	r9,sp,-1724
8000e58a:	14 97       	mov	r7,r10
8000e58c:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000e590:	ec ea fd 88 	ld.d	r10,r6[-632]
8000e594:	fa eb 00 00 	st.d	sp[0],r10
8000e598:	cd 18       	rjmp	8000e73a <_vfprintf_r+0x156e>
8000e59a:	41 09       	lddsp	r9,sp[0x40]
8000e59c:	59 f8       	cp.w	r8,31
8000e59e:	e0 89 00 16 	brgt	8000e5ca <_vfprintf_r+0x13fe>
8000e5a2:	f2 e6 00 00 	ld.d	r6,r9[0]
8000e5a6:	f2 cb ff f8 	sub	r11,r9,-8
8000e5aa:	fa e7 00 00 	st.d	sp[0],r6
8000e5ae:	51 0b       	stdsp	sp[0x40],r11
8000e5b0:	fa c6 f9 44 	sub	r6,sp,-1724
8000e5b4:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000e5b8:	fa e6 00 00 	ld.d	r6,sp[0]
8000e5bc:	f2 e7 fd 88 	st.d	r9[-632],r6
8000e5c0:	2f f8       	sub	r8,-1
8000e5c2:	14 97       	mov	r7,r10
8000e5c4:	fb 48 06 b4 	st.w	sp[1716],r8
8000e5c8:	cb 98       	rjmp	8000e73a <_vfprintf_r+0x156e>
8000e5ca:	f2 e6 00 00 	ld.d	r6,r9[0]
8000e5ce:	2f 89       	sub	r9,-8
8000e5d0:	fa e7 00 00 	st.d	sp[0],r6
8000e5d4:	51 09       	stdsp	sp[0x40],r9
8000e5d6:	14 97       	mov	r7,r10
8000e5d8:	cb 18       	rjmp	8000e73a <_vfprintf_r+0x156e>
8000e5da:	ed b5 00 04 	bld	r5,0x4
8000e5de:	c1 71       	brne	8000e60c <_vfprintf_r+0x1440>
8000e5e0:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000e5e4:	40 3e       	lddsp	lr,sp[0xc]
8000e5e6:	58 0e       	cp.w	lr,0
8000e5e8:	c0 80       	breq	8000e5f8 <_vfprintf_r+0x142c>
8000e5ea:	10 36       	cp.w	r6,r8
8000e5ec:	c6 c4       	brge	8000e6c4 <_vfprintf_r+0x14f8>
8000e5ee:	fa cc f9 44 	sub	r12,sp,-1724
8000e5f2:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000e5f6:	c8 58       	rjmp	8000e700 <_vfprintf_r+0x1534>
8000e5f8:	ee ca ff ff 	sub	r10,r7,-1
8000e5fc:	10 37       	cp.w	r7,r8
8000e5fe:	e0 84 00 84 	brge	8000e706 <_vfprintf_r+0x153a>
8000e602:	fa cb f9 44 	sub	r11,sp,-1724
8000e606:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000e60a:	c7 a8       	rjmp	8000e6fe <_vfprintf_r+0x1532>
8000e60c:	ed b5 00 06 	bld	r5,0x6
8000e610:	c4 e1       	brne	8000e6ac <_vfprintf_r+0x14e0>
8000e612:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000e616:	40 3c       	lddsp	r12,sp[0xc]
8000e618:	58 0c       	cp.w	r12,0
8000e61a:	c1 d0       	breq	8000e654 <_vfprintf_r+0x1488>
8000e61c:	10 36       	cp.w	r6,r8
8000e61e:	c0 64       	brge	8000e62a <_vfprintf_r+0x145e>
8000e620:	fa cb f9 44 	sub	r11,sp,-1724
8000e624:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000e628:	c1 f8       	rjmp	8000e666 <_vfprintf_r+0x149a>
8000e62a:	fa c8 f9 50 	sub	r8,sp,-1712
8000e62e:	1a d8       	st.w	--sp,r8
8000e630:	fa c8 fa b8 	sub	r8,sp,-1352
8000e634:	1a d8       	st.w	--sp,r8
8000e636:	fa c8 fb b4 	sub	r8,sp,-1100
8000e63a:	1a d8       	st.w	--sp,r8
8000e63c:	fa c8 f9 40 	sub	r8,sp,-1728
8000e640:	fa c9 ff b4 	sub	r9,sp,-76
8000e644:	04 9a       	mov	r10,r2
8000e646:	0c 9b       	mov	r11,r6
8000e648:	08 9c       	mov	r12,r4
8000e64a:	f0 1f 00 09 	mcall	8000e66c <_vfprintf_r+0x14a0>
8000e64e:	2f dd       	sub	sp,-12
8000e650:	98 18       	ld.sh	r8,r12[0x2]
8000e652:	c2 a8       	rjmp	8000e6a6 <_vfprintf_r+0x14da>
8000e654:	ee ca ff ff 	sub	r10,r7,-1
8000e658:	10 37       	cp.w	r7,r8
8000e65a:	c0 d4       	brge	8000e674 <_vfprintf_r+0x14a8>
8000e65c:	fa c9 f9 44 	sub	r9,sp,-1724
8000e660:	14 97       	mov	r7,r10
8000e662:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000e666:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000e66a:	c1 e8       	rjmp	8000e6a6 <_vfprintf_r+0x14da>
8000e66c:	80 00       	ld.sh	r0,r0[0x0]
8000e66e:	ce 88       	rjmp	8000e83e <_vfprintf_r+0x1672>
8000e670:	80 01       	ld.sh	r1,r0[0x0]
8000e672:	29 f4       	sub	r4,-97
8000e674:	41 09       	lddsp	r9,sp[0x40]
8000e676:	59 f8       	cp.w	r8,31
8000e678:	e0 89 00 13 	brgt	8000e69e <_vfprintf_r+0x14d2>
8000e67c:	f2 cb ff fc 	sub	r11,r9,-4
8000e680:	51 0b       	stdsp	sp[0x40],r11
8000e682:	72 09       	ld.w	r9,r9[0x0]
8000e684:	fa c6 f9 44 	sub	r6,sp,-1724
8000e688:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000e68c:	2f f8       	sub	r8,-1
8000e68e:	f7 49 fd 88 	st.w	r11[-632],r9
8000e692:	fb 48 06 b4 	st.w	sp[1716],r8
8000e696:	14 97       	mov	r7,r10
8000e698:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000e69c:	c0 58       	rjmp	8000e6a6 <_vfprintf_r+0x14da>
8000e69e:	92 18       	ld.sh	r8,r9[0x2]
8000e6a0:	14 97       	mov	r7,r10
8000e6a2:	2f c9       	sub	r9,-4
8000e6a4:	51 09       	stdsp	sp[0x40],r9
8000e6a6:	5c 78       	castu.h	r8
8000e6a8:	50 18       	stdsp	sp[0x4],r8
8000e6aa:	c4 68       	rjmp	8000e736 <_vfprintf_r+0x156a>
8000e6ac:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000e6b0:	40 3c       	lddsp	r12,sp[0xc]
8000e6b2:	58 0c       	cp.w	r12,0
8000e6b4:	c1 d0       	breq	8000e6ee <_vfprintf_r+0x1522>
8000e6b6:	10 36       	cp.w	r6,r8
8000e6b8:	c0 64       	brge	8000e6c4 <_vfprintf_r+0x14f8>
8000e6ba:	fa cb f9 44 	sub	r11,sp,-1724
8000e6be:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000e6c2:	c1 f8       	rjmp	8000e700 <_vfprintf_r+0x1534>
8000e6c4:	fa c8 f9 50 	sub	r8,sp,-1712
8000e6c8:	1a d8       	st.w	--sp,r8
8000e6ca:	fa c8 fa b8 	sub	r8,sp,-1352
8000e6ce:	0c 9b       	mov	r11,r6
8000e6d0:	1a d8       	st.w	--sp,r8
8000e6d2:	fa c8 fb b4 	sub	r8,sp,-1100
8000e6d6:	04 9a       	mov	r10,r2
8000e6d8:	1a d8       	st.w	--sp,r8
8000e6da:	08 9c       	mov	r12,r4
8000e6dc:	fa c8 f9 40 	sub	r8,sp,-1728
8000e6e0:	fa c9 ff b4 	sub	r9,sp,-76
8000e6e4:	f0 1f 00 cb 	mcall	8000ea10 <_vfprintf_r+0x1844>
8000e6e8:	2f dd       	sub	sp,-12
8000e6ea:	78 0b       	ld.w	r11,r12[0x0]
8000e6ec:	c2 48       	rjmp	8000e734 <_vfprintf_r+0x1568>
8000e6ee:	ee ca ff ff 	sub	r10,r7,-1
8000e6f2:	10 37       	cp.w	r7,r8
8000e6f4:	c0 94       	brge	8000e706 <_vfprintf_r+0x153a>
8000e6f6:	fa c9 f9 44 	sub	r9,sp,-1724
8000e6fa:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000e6fe:	14 97       	mov	r7,r10
8000e700:	ec fb fd 88 	ld.w	r11,r6[-632]
8000e704:	c1 88       	rjmp	8000e734 <_vfprintf_r+0x1568>
8000e706:	41 09       	lddsp	r9,sp[0x40]
8000e708:	59 f8       	cp.w	r8,31
8000e70a:	e0 89 00 11 	brgt	8000e72c <_vfprintf_r+0x1560>
8000e70e:	f2 cb ff fc 	sub	r11,r9,-4
8000e712:	51 0b       	stdsp	sp[0x40],r11
8000e714:	fa c6 f9 44 	sub	r6,sp,-1724
8000e718:	72 0b       	ld.w	r11,r9[0x0]
8000e71a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000e71e:	f3 4b fd 88 	st.w	r9[-632],r11
8000e722:	2f f8       	sub	r8,-1
8000e724:	14 97       	mov	r7,r10
8000e726:	fb 48 06 b4 	st.w	sp[1716],r8
8000e72a:	c0 58       	rjmp	8000e734 <_vfprintf_r+0x1568>
8000e72c:	72 0b       	ld.w	r11,r9[0x0]
8000e72e:	14 97       	mov	r7,r10
8000e730:	2f c9       	sub	r9,-4
8000e732:	51 09       	stdsp	sp[0x40],r9
8000e734:	50 1b       	stdsp	sp[0x4],r11
8000e736:	30 0e       	mov	lr,0
8000e738:	50 0e       	stdsp	sp[0x0],lr
8000e73a:	40 08       	lddsp	r8,sp[0x0]
8000e73c:	40 1c       	lddsp	r12,sp[0x4]
8000e73e:	18 48       	or	r8,r12
8000e740:	5f 19       	srne	r9
8000e742:	0a 98       	mov	r8,r5
8000e744:	eb e9 00 09 	and	r9,r5,r9
8000e748:	a1 b8       	sbr	r8,0x1
8000e74a:	58 09       	cp.w	r9,0
8000e74c:	c0 70       	breq	8000e75a <_vfprintf_r+0x158e>
8000e74e:	10 95       	mov	r5,r8
8000e750:	fb 60 06 b9 	st.b	sp[1721],r0
8000e754:	33 08       	mov	r8,48
8000e756:	fb 68 06 b8 	st.b	sp[1720],r8
8000e75a:	30 28       	mov	r8,2
8000e75c:	30 09       	mov	r9,0
8000e75e:	fb 69 06 bb 	st.b	sp[1723],r9
8000e762:	0a 99       	mov	r9,r5
8000e764:	a7 d9       	cbr	r9,0x7
8000e766:	40 2b       	lddsp	r11,sp[0x8]
8000e768:	40 16       	lddsp	r6,sp[0x4]
8000e76a:	58 0b       	cp.w	r11,0
8000e76c:	5f 1a       	srne	r10
8000e76e:	f2 05 17 40 	movge	r5,r9
8000e772:	fa c2 f9 78 	sub	r2,sp,-1672
8000e776:	40 09       	lddsp	r9,sp[0x0]
8000e778:	0c 49       	or	r9,r6
8000e77a:	5f 19       	srne	r9
8000e77c:	f5 e9 10 09 	or	r9,r10,r9
8000e780:	c5 c0       	breq	8000e838 <_vfprintf_r+0x166c>
8000e782:	30 19       	mov	r9,1
8000e784:	f2 08 18 00 	cp.b	r8,r9
8000e788:	c0 60       	breq	8000e794 <_vfprintf_r+0x15c8>
8000e78a:	30 29       	mov	r9,2
8000e78c:	f2 08 18 00 	cp.b	r8,r9
8000e790:	c0 41       	brne	8000e798 <_vfprintf_r+0x15cc>
8000e792:	c3 c8       	rjmp	8000e80a <_vfprintf_r+0x163e>
8000e794:	04 96       	mov	r6,r2
8000e796:	c3 08       	rjmp	8000e7f6 <_vfprintf_r+0x162a>
8000e798:	04 96       	mov	r6,r2
8000e79a:	fa e8 00 00 	ld.d	r8,sp[0]
8000e79e:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
8000e7a2:	2d 0a       	sub	r10,-48
8000e7a4:	0c fa       	st.b	--r6,r10
8000e7a6:	f0 0b 16 03 	lsr	r11,r8,0x3
8000e7aa:	f2 0c 16 03 	lsr	r12,r9,0x3
8000e7ae:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
8000e7b2:	18 99       	mov	r9,r12
8000e7b4:	16 98       	mov	r8,r11
8000e7b6:	58 08       	cp.w	r8,0
8000e7b8:	5c 29       	cpc	r9
8000e7ba:	cf 21       	brne	8000e79e <_vfprintf_r+0x15d2>
8000e7bc:	fa e9 00 00 	st.d	sp[0],r8
8000e7c0:	ed b5 00 00 	bld	r5,0x0
8000e7c4:	c4 51       	brne	8000e84e <_vfprintf_r+0x1682>
8000e7c6:	33 09       	mov	r9,48
8000e7c8:	f2 0a 18 00 	cp.b	r10,r9
8000e7cc:	c4 10       	breq	8000e84e <_vfprintf_r+0x1682>
8000e7ce:	0c f9       	st.b	--r6,r9
8000e7d0:	c3 f8       	rjmp	8000e84e <_vfprintf_r+0x1682>
8000e7d2:	fa ea 00 00 	ld.d	r10,sp[0]
8000e7d6:	30 a8       	mov	r8,10
8000e7d8:	30 09       	mov	r9,0
8000e7da:	f0 1f 00 8f 	mcall	8000ea14 <_vfprintf_r+0x1848>
8000e7de:	30 a8       	mov	r8,10
8000e7e0:	2d 0a       	sub	r10,-48
8000e7e2:	30 09       	mov	r9,0
8000e7e4:	ac 8a       	st.b	r6[0x0],r10
8000e7e6:	fa ea 00 00 	ld.d	r10,sp[0]
8000e7ea:	f0 1f 00 8c 	mcall	8000ea18 <_vfprintf_r+0x184c>
8000e7ee:	16 99       	mov	r9,r11
8000e7f0:	14 98       	mov	r8,r10
8000e7f2:	fa e9 00 00 	st.d	sp[0],r8
8000e7f6:	20 16       	sub	r6,1
8000e7f8:	fa ea 00 00 	ld.d	r10,sp[0]
8000e7fc:	58 9a       	cp.w	r10,9
8000e7fe:	5c 2b       	cpc	r11
8000e800:	fe 9b ff e9 	brhi	8000e7d2 <_vfprintf_r+0x1606>
8000e804:	1b f8       	ld.ub	r8,sp[0x7]
8000e806:	2d 08       	sub	r8,-48
8000e808:	c2 08       	rjmp	8000e848 <_vfprintf_r+0x167c>
8000e80a:	04 96       	mov	r6,r2
8000e80c:	fa e8 00 00 	ld.d	r8,sp[0]
8000e810:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
8000e814:	40 de       	lddsp	lr,sp[0x34]
8000e816:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
8000e81a:	0c fa       	st.b	--r6,r10
8000e81c:	f2 0b 16 04 	lsr	r11,r9,0x4
8000e820:	f0 0a 16 04 	lsr	r10,r8,0x4
8000e824:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
8000e828:	16 99       	mov	r9,r11
8000e82a:	14 98       	mov	r8,r10
8000e82c:	58 08       	cp.w	r8,0
8000e82e:	5c 29       	cpc	r9
8000e830:	cf 01       	brne	8000e810 <_vfprintf_r+0x1644>
8000e832:	fa e9 00 00 	st.d	sp[0],r8
8000e836:	c0 c8       	rjmp	8000e84e <_vfprintf_r+0x1682>
8000e838:	58 08       	cp.w	r8,0
8000e83a:	c0 91       	brne	8000e84c <_vfprintf_r+0x1680>
8000e83c:	ed b5 00 00 	bld	r5,0x0
8000e840:	c0 61       	brne	8000e84c <_vfprintf_r+0x1680>
8000e842:	fa c6 f9 79 	sub	r6,sp,-1671
8000e846:	33 08       	mov	r8,48
8000e848:	ac 88       	st.b	r6[0x0],r8
8000e84a:	c0 28       	rjmp	8000e84e <_vfprintf_r+0x1682>
8000e84c:	04 96       	mov	r6,r2
8000e84e:	0c 12       	sub	r2,r6
8000e850:	c1 c8       	rjmp	8000e888 <_vfprintf_r+0x16bc>
8000e852:	50 a7       	stdsp	sp[0x28],r7
8000e854:	50 80       	stdsp	sp[0x20],r0
8000e856:	40 93       	lddsp	r3,sp[0x24]
8000e858:	0c 97       	mov	r7,r6
8000e85a:	10 90       	mov	r0,r8
8000e85c:	04 94       	mov	r4,r2
8000e85e:	40 41       	lddsp	r1,sp[0x10]
8000e860:	58 08       	cp.w	r8,0
8000e862:	e0 80 04 65 	breq	8000f12c <_vfprintf_r+0x1f60>
8000e866:	fb 68 06 60 	st.b	sp[1632],r8
8000e86a:	30 0c       	mov	r12,0
8000e86c:	30 08       	mov	r8,0
8000e86e:	30 12       	mov	r2,1
8000e870:	fb 68 06 bb 	st.b	sp[1723],r8
8000e874:	50 2c       	stdsp	sp[0x8],r12
8000e876:	fa c6 f9 a0 	sub	r6,sp,-1632
8000e87a:	c0 78       	rjmp	8000e888 <_vfprintf_r+0x16bc>
8000e87c:	30 0b       	mov	r11,0
8000e87e:	50 2b       	stdsp	sp[0x8],r11
8000e880:	c0 48       	rjmp	8000e888 <_vfprintf_r+0x16bc>
8000e882:	40 22       	lddsp	r2,sp[0x8]
8000e884:	30 0a       	mov	r10,0
8000e886:	50 2a       	stdsp	sp[0x8],r10
8000e888:	40 29       	lddsp	r9,sp[0x8]
8000e88a:	e4 09 0c 49 	max	r9,r2,r9
8000e88e:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000e892:	50 39       	stdsp	sp[0xc],r9
8000e894:	0a 9e       	mov	lr,r5
8000e896:	30 09       	mov	r9,0
8000e898:	e2 1e 00 02 	andl	lr,0x2,COH
8000e89c:	f2 08 18 00 	cp.b	r8,r9
8000e8a0:	fb f8 10 03 	ld.wne	r8,sp[0xc]
8000e8a4:	f7 b8 01 ff 	subne	r8,-1
8000e8a8:	fb f8 1a 03 	st.wne	sp[0xc],r8
8000e8ac:	0a 9b       	mov	r11,r5
8000e8ae:	58 0e       	cp.w	lr,0
8000e8b0:	fb fc 10 03 	ld.wne	r12,sp[0xc]
8000e8b4:	f7 bc 01 fe 	subne	r12,-2
8000e8b8:	fb fc 1a 03 	st.wne	sp[0xc],r12
8000e8bc:	e2 1b 00 84 	andl	r11,0x84,COH
8000e8c0:	50 fe       	stdsp	sp[0x3c],lr
8000e8c2:	50 9b       	stdsp	sp[0x24],r11
8000e8c4:	c4 51       	brne	8000e94e <_vfprintf_r+0x1782>
8000e8c6:	40 8a       	lddsp	r10,sp[0x20]
8000e8c8:	40 39       	lddsp	r9,sp[0xc]
8000e8ca:	12 1a       	sub	r10,r9
8000e8cc:	50 4a       	stdsp	sp[0x10],r10
8000e8ce:	58 0a       	cp.w	r10,0
8000e8d0:	e0 89 00 1f 	brgt	8000e90e <_vfprintf_r+0x1742>
8000e8d4:	c3 d8       	rjmp	8000e94e <_vfprintf_r+0x1782>
8000e8d6:	2f 09       	sub	r9,-16
8000e8d8:	2f f8       	sub	r8,-1
8000e8da:	4d 1e       	lddpc	lr,8000ea1c <_vfprintf_r+0x1850>
8000e8dc:	31 0c       	mov	r12,16
8000e8de:	fb 49 06 90 	st.w	sp[1680],r9
8000e8e2:	87 0e       	st.w	r3[0x0],lr
8000e8e4:	87 1c       	st.w	r3[0x4],r12
8000e8e6:	fb 48 06 8c 	st.w	sp[1676],r8
8000e8ea:	58 78       	cp.w	r8,7
8000e8ec:	e0 89 00 04 	brgt	8000e8f4 <_vfprintf_r+0x1728>
8000e8f0:	2f 83       	sub	r3,-8
8000e8f2:	c0 b8       	rjmp	8000e908 <_vfprintf_r+0x173c>
8000e8f4:	fa ca f9 78 	sub	r10,sp,-1672
8000e8f8:	02 9b       	mov	r11,r1
8000e8fa:	08 9c       	mov	r12,r4
8000e8fc:	f0 1f 00 49 	mcall	8000ea20 <_vfprintf_r+0x1854>
8000e900:	e0 81 04 27 	brne	8000f14e <_vfprintf_r+0x1f82>
8000e904:	fa c3 f9 e0 	sub	r3,sp,-1568
8000e908:	40 4b       	lddsp	r11,sp[0x10]
8000e90a:	21 0b       	sub	r11,16
8000e90c:	50 4b       	stdsp	sp[0x10],r11
8000e90e:	fa f9 06 90 	ld.w	r9,sp[1680]
8000e912:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000e916:	4c 2a       	lddpc	r10,8000ea1c <_vfprintf_r+0x1850>
8000e918:	40 4e       	lddsp	lr,sp[0x10]
8000e91a:	59 0e       	cp.w	lr,16
8000e91c:	fe 99 ff dd 	brgt	8000e8d6 <_vfprintf_r+0x170a>
8000e920:	1c 09       	add	r9,lr
8000e922:	2f f8       	sub	r8,-1
8000e924:	87 0a       	st.w	r3[0x0],r10
8000e926:	fb 49 06 90 	st.w	sp[1680],r9
8000e92a:	87 1e       	st.w	r3[0x4],lr
8000e92c:	fb 48 06 8c 	st.w	sp[1676],r8
8000e930:	58 78       	cp.w	r8,7
8000e932:	e0 89 00 04 	brgt	8000e93a <_vfprintf_r+0x176e>
8000e936:	2f 83       	sub	r3,-8
8000e938:	c0 b8       	rjmp	8000e94e <_vfprintf_r+0x1782>
8000e93a:	fa ca f9 78 	sub	r10,sp,-1672
8000e93e:	02 9b       	mov	r11,r1
8000e940:	08 9c       	mov	r12,r4
8000e942:	f0 1f 00 38 	mcall	8000ea20 <_vfprintf_r+0x1854>
8000e946:	e0 81 04 04 	brne	8000f14e <_vfprintf_r+0x1f82>
8000e94a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000e94e:	30 09       	mov	r9,0
8000e950:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000e954:	f2 08 18 00 	cp.b	r8,r9
8000e958:	c1 f0       	breq	8000e996 <_vfprintf_r+0x17ca>
8000e95a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000e95e:	fa c9 f9 45 	sub	r9,sp,-1723
8000e962:	2f f8       	sub	r8,-1
8000e964:	87 09       	st.w	r3[0x0],r9
8000e966:	fb 48 06 90 	st.w	sp[1680],r8
8000e96a:	30 19       	mov	r9,1
8000e96c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000e970:	87 19       	st.w	r3[0x4],r9
8000e972:	2f f8       	sub	r8,-1
8000e974:	fb 48 06 8c 	st.w	sp[1676],r8
8000e978:	58 78       	cp.w	r8,7
8000e97a:	e0 89 00 04 	brgt	8000e982 <_vfprintf_r+0x17b6>
8000e97e:	2f 83       	sub	r3,-8
8000e980:	c0 b8       	rjmp	8000e996 <_vfprintf_r+0x17ca>
8000e982:	fa ca f9 78 	sub	r10,sp,-1672
8000e986:	02 9b       	mov	r11,r1
8000e988:	08 9c       	mov	r12,r4
8000e98a:	f0 1f 00 26 	mcall	8000ea20 <_vfprintf_r+0x1854>
8000e98e:	e0 81 03 e0 	brne	8000f14e <_vfprintf_r+0x1f82>
8000e992:	fa c3 f9 e0 	sub	r3,sp,-1568
8000e996:	40 fc       	lddsp	r12,sp[0x3c]
8000e998:	58 0c       	cp.w	r12,0
8000e99a:	c1 f0       	breq	8000e9d8 <_vfprintf_r+0x180c>
8000e99c:	fa f8 06 90 	ld.w	r8,sp[1680]
8000e9a0:	fa c9 f9 48 	sub	r9,sp,-1720
8000e9a4:	2f e8       	sub	r8,-2
8000e9a6:	87 09       	st.w	r3[0x0],r9
8000e9a8:	fb 48 06 90 	st.w	sp[1680],r8
8000e9ac:	30 29       	mov	r9,2
8000e9ae:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000e9b2:	87 19       	st.w	r3[0x4],r9
8000e9b4:	2f f8       	sub	r8,-1
8000e9b6:	fb 48 06 8c 	st.w	sp[1676],r8
8000e9ba:	58 78       	cp.w	r8,7
8000e9bc:	e0 89 00 04 	brgt	8000e9c4 <_vfprintf_r+0x17f8>
8000e9c0:	2f 83       	sub	r3,-8
8000e9c2:	c0 b8       	rjmp	8000e9d8 <_vfprintf_r+0x180c>
8000e9c4:	fa ca f9 78 	sub	r10,sp,-1672
8000e9c8:	02 9b       	mov	r11,r1
8000e9ca:	08 9c       	mov	r12,r4
8000e9cc:	f0 1f 00 15 	mcall	8000ea20 <_vfprintf_r+0x1854>
8000e9d0:	e0 81 03 bf 	brne	8000f14e <_vfprintf_r+0x1f82>
8000e9d4:	fa c3 f9 e0 	sub	r3,sp,-1568
8000e9d8:	40 9b       	lddsp	r11,sp[0x24]
8000e9da:	e0 4b 00 80 	cp.w	r11,128
8000e9de:	c5 21       	brne	8000ea82 <_vfprintf_r+0x18b6>
8000e9e0:	40 8a       	lddsp	r10,sp[0x20]
8000e9e2:	40 39       	lddsp	r9,sp[0xc]
8000e9e4:	12 1a       	sub	r10,r9
8000e9e6:	50 4a       	stdsp	sp[0x10],r10
8000e9e8:	58 0a       	cp.w	r10,0
8000e9ea:	e0 89 00 2c 	brgt	8000ea42 <_vfprintf_r+0x1876>
8000e9ee:	c4 a8       	rjmp	8000ea82 <_vfprintf_r+0x18b6>
8000e9f0:	2f 09       	sub	r9,-16
8000e9f2:	2f f8       	sub	r8,-1
8000e9f4:	48 ce       	lddpc	lr,8000ea24 <_vfprintf_r+0x1858>
8000e9f6:	31 0c       	mov	r12,16
8000e9f8:	fb 49 06 90 	st.w	sp[1680],r9
8000e9fc:	87 0e       	st.w	r3[0x0],lr
8000e9fe:	87 1c       	st.w	r3[0x4],r12
8000ea00:	fb 48 06 8c 	st.w	sp[1676],r8
8000ea04:	58 78       	cp.w	r8,7
8000ea06:	e0 89 00 11 	brgt	8000ea28 <_vfprintf_r+0x185c>
8000ea0a:	2f 83       	sub	r3,-8
8000ea0c:	c1 88       	rjmp	8000ea3c <_vfprintf_r+0x1870>
8000ea0e:	00 00       	add	r0,r0
8000ea10:	80 00       	ld.sh	r0,r0[0x0]
8000ea12:	ce 88       	rjmp	8000ebe2 <_vfprintf_r+0x1a16>
8000ea14:	80 01       	ld.sh	r1,r0[0x0]
8000ea16:	1f 30       	ld.ub	r0,pc++
8000ea18:	80 00       	ld.sh	r0,r0[0x0]
8000ea1a:	ca 56       	brmi	8000e964 <_vfprintf_r+0x1798>
8000ea1c:	80 01       	ld.sh	r1,r0[0x0]
8000ea1e:	2a 0c       	sub	r12,-96
8000ea20:	80 00       	ld.sh	r0,r0[0x0]
8000ea22:	d1 ac       	*unknown*
8000ea24:	80 01       	ld.sh	r1,r0[0x0]
8000ea26:	2a 1c       	sub	r12,-95
8000ea28:	fa ca f9 78 	sub	r10,sp,-1672
8000ea2c:	02 9b       	mov	r11,r1
8000ea2e:	08 9c       	mov	r12,r4
8000ea30:	f0 1f 00 4c 	mcall	8000eb60 <_vfprintf_r+0x1994>
8000ea34:	e0 81 03 8d 	brne	8000f14e <_vfprintf_r+0x1f82>
8000ea38:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ea3c:	40 4b       	lddsp	r11,sp[0x10]
8000ea3e:	21 0b       	sub	r11,16
8000ea40:	50 4b       	stdsp	sp[0x10],r11
8000ea42:	fa f9 06 90 	ld.w	r9,sp[1680]
8000ea46:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ea4a:	4c 7a       	lddpc	r10,8000eb64 <_vfprintf_r+0x1998>
8000ea4c:	40 4e       	lddsp	lr,sp[0x10]
8000ea4e:	59 0e       	cp.w	lr,16
8000ea50:	fe 99 ff d0 	brgt	8000e9f0 <_vfprintf_r+0x1824>
8000ea54:	1c 09       	add	r9,lr
8000ea56:	2f f8       	sub	r8,-1
8000ea58:	87 0a       	st.w	r3[0x0],r10
8000ea5a:	fb 49 06 90 	st.w	sp[1680],r9
8000ea5e:	87 1e       	st.w	r3[0x4],lr
8000ea60:	fb 48 06 8c 	st.w	sp[1676],r8
8000ea64:	58 78       	cp.w	r8,7
8000ea66:	e0 89 00 04 	brgt	8000ea6e <_vfprintf_r+0x18a2>
8000ea6a:	2f 83       	sub	r3,-8
8000ea6c:	c0 b8       	rjmp	8000ea82 <_vfprintf_r+0x18b6>
8000ea6e:	fa ca f9 78 	sub	r10,sp,-1672
8000ea72:	02 9b       	mov	r11,r1
8000ea74:	08 9c       	mov	r12,r4
8000ea76:	f0 1f 00 3b 	mcall	8000eb60 <_vfprintf_r+0x1994>
8000ea7a:	e0 81 03 6a 	brne	8000f14e <_vfprintf_r+0x1f82>
8000ea7e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ea82:	40 2c       	lddsp	r12,sp[0x8]
8000ea84:	04 1c       	sub	r12,r2
8000ea86:	50 2c       	stdsp	sp[0x8],r12
8000ea88:	58 0c       	cp.w	r12,0
8000ea8a:	e0 89 00 1f 	brgt	8000eac8 <_vfprintf_r+0x18fc>
8000ea8e:	c3 d8       	rjmp	8000eb08 <_vfprintf_r+0x193c>
8000ea90:	2f 09       	sub	r9,-16
8000ea92:	2f f8       	sub	r8,-1
8000ea94:	4b 4b       	lddpc	r11,8000eb64 <_vfprintf_r+0x1998>
8000ea96:	31 0a       	mov	r10,16
8000ea98:	fb 49 06 90 	st.w	sp[1680],r9
8000ea9c:	87 0b       	st.w	r3[0x0],r11
8000ea9e:	87 1a       	st.w	r3[0x4],r10
8000eaa0:	fb 48 06 8c 	st.w	sp[1676],r8
8000eaa4:	58 78       	cp.w	r8,7
8000eaa6:	e0 89 00 04 	brgt	8000eaae <_vfprintf_r+0x18e2>
8000eaaa:	2f 83       	sub	r3,-8
8000eaac:	c0 b8       	rjmp	8000eac2 <_vfprintf_r+0x18f6>
8000eaae:	fa ca f9 78 	sub	r10,sp,-1672
8000eab2:	02 9b       	mov	r11,r1
8000eab4:	08 9c       	mov	r12,r4
8000eab6:	f0 1f 00 2b 	mcall	8000eb60 <_vfprintf_r+0x1994>
8000eaba:	e0 81 03 4a 	brne	8000f14e <_vfprintf_r+0x1f82>
8000eabe:	fa c3 f9 e0 	sub	r3,sp,-1568
8000eac2:	40 29       	lddsp	r9,sp[0x8]
8000eac4:	21 09       	sub	r9,16
8000eac6:	50 29       	stdsp	sp[0x8],r9
8000eac8:	fa f9 06 90 	ld.w	r9,sp[1680]
8000eacc:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ead0:	4a 5a       	lddpc	r10,8000eb64 <_vfprintf_r+0x1998>
8000ead2:	40 2e       	lddsp	lr,sp[0x8]
8000ead4:	59 0e       	cp.w	lr,16
8000ead6:	fe 99 ff dd 	brgt	8000ea90 <_vfprintf_r+0x18c4>
8000eada:	1c 09       	add	r9,lr
8000eadc:	2f f8       	sub	r8,-1
8000eade:	87 0a       	st.w	r3[0x0],r10
8000eae0:	fb 49 06 90 	st.w	sp[1680],r9
8000eae4:	87 1e       	st.w	r3[0x4],lr
8000eae6:	fb 48 06 8c 	st.w	sp[1676],r8
8000eaea:	58 78       	cp.w	r8,7
8000eaec:	e0 89 00 04 	brgt	8000eaf4 <_vfprintf_r+0x1928>
8000eaf0:	2f 83       	sub	r3,-8
8000eaf2:	c0 b8       	rjmp	8000eb08 <_vfprintf_r+0x193c>
8000eaf4:	fa ca f9 78 	sub	r10,sp,-1672
8000eaf8:	02 9b       	mov	r11,r1
8000eafa:	08 9c       	mov	r12,r4
8000eafc:	f0 1f 00 19 	mcall	8000eb60 <_vfprintf_r+0x1994>
8000eb00:	e0 81 03 27 	brne	8000f14e <_vfprintf_r+0x1f82>
8000eb04:	fa c3 f9 e0 	sub	r3,sp,-1568
8000eb08:	ed b5 00 08 	bld	r5,0x8
8000eb0c:	c0 b0       	breq	8000eb22 <_vfprintf_r+0x1956>
8000eb0e:	fa f8 06 90 	ld.w	r8,sp[1680]
8000eb12:	87 12       	st.w	r3[0x4],r2
8000eb14:	87 06       	st.w	r3[0x0],r6
8000eb16:	f0 02 00 02 	add	r2,r8,r2
8000eb1a:	fb 42 06 90 	st.w	sp[1680],r2
8000eb1e:	e0 8f 01 db 	bral	8000eed4 <_vfprintf_r+0x1d08>
8000eb22:	e0 40 00 65 	cp.w	r0,101
8000eb26:	e0 8a 01 dd 	brle	8000eee0 <_vfprintf_r+0x1d14>
8000eb2a:	30 08       	mov	r8,0
8000eb2c:	30 09       	mov	r9,0
8000eb2e:	40 5b       	lddsp	r11,sp[0x14]
8000eb30:	40 7a       	lddsp	r10,sp[0x1c]
8000eb32:	f0 1f 00 0e 	mcall	8000eb68 <_vfprintf_r+0x199c>
8000eb36:	c7 e0       	breq	8000ec32 <_vfprintf_r+0x1a66>
8000eb38:	fa f8 06 90 	ld.w	r8,sp[1680]
8000eb3c:	48 c9       	lddpc	r9,8000eb6c <_vfprintf_r+0x19a0>
8000eb3e:	2f f8       	sub	r8,-1
8000eb40:	87 09       	st.w	r3[0x0],r9
8000eb42:	fb 48 06 90 	st.w	sp[1680],r8
8000eb46:	30 19       	mov	r9,1
8000eb48:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000eb4c:	87 19       	st.w	r3[0x4],r9
8000eb4e:	2f f8       	sub	r8,-1
8000eb50:	fb 48 06 8c 	st.w	sp[1676],r8
8000eb54:	58 78       	cp.w	r8,7
8000eb56:	e0 89 00 0d 	brgt	8000eb70 <_vfprintf_r+0x19a4>
8000eb5a:	2f 83       	sub	r3,-8
8000eb5c:	c1 48       	rjmp	8000eb84 <_vfprintf_r+0x19b8>
8000eb5e:	00 00       	add	r0,r0
8000eb60:	80 00       	ld.sh	r0,r0[0x0]
8000eb62:	d1 ac       	*unknown*
8000eb64:	80 01       	ld.sh	r1,r0[0x0]
8000eb66:	2a 1c       	sub	r12,-95
8000eb68:	80 01       	ld.sh	r1,r0[0x0]
8000eb6a:	1b 22       	ld.uh	r2,sp++
8000eb6c:	80 01       	ld.sh	r1,r0[0x0]
8000eb6e:	2a 08       	sub	r8,-96
8000eb70:	fa ca f9 78 	sub	r10,sp,-1672
8000eb74:	02 9b       	mov	r11,r1
8000eb76:	08 9c       	mov	r12,r4
8000eb78:	f0 1f 00 78 	mcall	8000ed58 <_vfprintf_r+0x1b8c>
8000eb7c:	e0 81 02 e9 	brne	8000f14e <_vfprintf_r+0x1f82>
8000eb80:	fa c3 f9 e0 	sub	r3,sp,-1568
8000eb84:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000eb88:	40 6c       	lddsp	r12,sp[0x18]
8000eb8a:	18 38       	cp.w	r8,r12
8000eb8c:	c0 55       	brlt	8000eb96 <_vfprintf_r+0x19ca>
8000eb8e:	ed b5 00 00 	bld	r5,0x0
8000eb92:	e0 81 02 6d 	brne	8000f06c <_vfprintf_r+0x1ea0>
8000eb96:	fa f8 06 90 	ld.w	r8,sp[1680]
8000eb9a:	2f f8       	sub	r8,-1
8000eb9c:	40 cb       	lddsp	r11,sp[0x30]
8000eb9e:	fb 48 06 90 	st.w	sp[1680],r8
8000eba2:	30 19       	mov	r9,1
8000eba4:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000eba8:	87 0b       	st.w	r3[0x0],r11
8000ebaa:	2f f8       	sub	r8,-1
8000ebac:	87 19       	st.w	r3[0x4],r9
8000ebae:	fb 48 06 8c 	st.w	sp[1676],r8
8000ebb2:	58 78       	cp.w	r8,7
8000ebb4:	e0 89 00 04 	brgt	8000ebbc <_vfprintf_r+0x19f0>
8000ebb8:	2f 83       	sub	r3,-8
8000ebba:	c0 b8       	rjmp	8000ebd0 <_vfprintf_r+0x1a04>
8000ebbc:	fa ca f9 78 	sub	r10,sp,-1672
8000ebc0:	02 9b       	mov	r11,r1
8000ebc2:	08 9c       	mov	r12,r4
8000ebc4:	f0 1f 00 65 	mcall	8000ed58 <_vfprintf_r+0x1b8c>
8000ebc8:	e0 81 02 c3 	brne	8000f14e <_vfprintf_r+0x1f82>
8000ebcc:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ebd0:	40 66       	lddsp	r6,sp[0x18]
8000ebd2:	20 16       	sub	r6,1
8000ebd4:	58 06       	cp.w	r6,0
8000ebd6:	e0 89 00 1d 	brgt	8000ec10 <_vfprintf_r+0x1a44>
8000ebda:	e0 8f 02 49 	bral	8000f06c <_vfprintf_r+0x1ea0>
8000ebde:	2f 09       	sub	r9,-16
8000ebe0:	2f f8       	sub	r8,-1
8000ebe2:	fb 49 06 90 	st.w	sp[1680],r9
8000ebe6:	87 02       	st.w	r3[0x0],r2
8000ebe8:	87 10       	st.w	r3[0x4],r0
8000ebea:	fb 48 06 8c 	st.w	sp[1676],r8
8000ebee:	58 78       	cp.w	r8,7
8000ebf0:	e0 89 00 04 	brgt	8000ebf8 <_vfprintf_r+0x1a2c>
8000ebf4:	2f 83       	sub	r3,-8
8000ebf6:	c0 b8       	rjmp	8000ec0c <_vfprintf_r+0x1a40>
8000ebf8:	fa ca f9 78 	sub	r10,sp,-1672
8000ebfc:	02 9b       	mov	r11,r1
8000ebfe:	08 9c       	mov	r12,r4
8000ec00:	f0 1f 00 56 	mcall	8000ed58 <_vfprintf_r+0x1b8c>
8000ec04:	e0 81 02 a5 	brne	8000f14e <_vfprintf_r+0x1f82>
8000ec08:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ec0c:	21 06       	sub	r6,16
8000ec0e:	c0 38       	rjmp	8000ec14 <_vfprintf_r+0x1a48>
8000ec10:	4d 32       	lddpc	r2,8000ed5c <_vfprintf_r+0x1b90>
8000ec12:	31 00       	mov	r0,16
8000ec14:	fa f9 06 90 	ld.w	r9,sp[1680]
8000ec18:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ec1c:	4d 0a       	lddpc	r10,8000ed5c <_vfprintf_r+0x1b90>
8000ec1e:	59 06       	cp.w	r6,16
8000ec20:	fe 99 ff df 	brgt	8000ebde <_vfprintf_r+0x1a12>
8000ec24:	0c 09       	add	r9,r6
8000ec26:	87 0a       	st.w	r3[0x0],r10
8000ec28:	fb 49 06 90 	st.w	sp[1680],r9
8000ec2c:	2f f8       	sub	r8,-1
8000ec2e:	87 16       	st.w	r3[0x4],r6
8000ec30:	c5 59       	rjmp	8000eeda <_vfprintf_r+0x1d0e>
8000ec32:	fa fa 06 ac 	ld.w	r10,sp[1708]
8000ec36:	58 0a       	cp.w	r10,0
8000ec38:	e0 89 00 96 	brgt	8000ed64 <_vfprintf_r+0x1b98>
8000ec3c:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ec40:	4c 89       	lddpc	r9,8000ed60 <_vfprintf_r+0x1b94>
8000ec42:	2f f8       	sub	r8,-1
8000ec44:	87 09       	st.w	r3[0x0],r9
8000ec46:	fb 48 06 90 	st.w	sp[1680],r8
8000ec4a:	30 19       	mov	r9,1
8000ec4c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ec50:	87 19       	st.w	r3[0x4],r9
8000ec52:	2f f8       	sub	r8,-1
8000ec54:	fb 48 06 8c 	st.w	sp[1676],r8
8000ec58:	58 78       	cp.w	r8,7
8000ec5a:	e0 89 00 04 	brgt	8000ec62 <_vfprintf_r+0x1a96>
8000ec5e:	2f 83       	sub	r3,-8
8000ec60:	c0 b8       	rjmp	8000ec76 <_vfprintf_r+0x1aaa>
8000ec62:	fa ca f9 78 	sub	r10,sp,-1672
8000ec66:	02 9b       	mov	r11,r1
8000ec68:	08 9c       	mov	r12,r4
8000ec6a:	f0 1f 00 3c 	mcall	8000ed58 <_vfprintf_r+0x1b8c>
8000ec6e:	e0 81 02 70 	brne	8000f14e <_vfprintf_r+0x1f82>
8000ec72:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ec76:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000ec7a:	58 08       	cp.w	r8,0
8000ec7c:	c0 81       	brne	8000ec8c <_vfprintf_r+0x1ac0>
8000ec7e:	40 6a       	lddsp	r10,sp[0x18]
8000ec80:	58 0a       	cp.w	r10,0
8000ec82:	c0 51       	brne	8000ec8c <_vfprintf_r+0x1ac0>
8000ec84:	ed b5 00 00 	bld	r5,0x0
8000ec88:	e0 81 01 f2 	brne	8000f06c <_vfprintf_r+0x1ea0>
8000ec8c:	40 c9       	lddsp	r9,sp[0x30]
8000ec8e:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ec92:	2f f8       	sub	r8,-1
8000ec94:	87 09       	st.w	r3[0x0],r9
8000ec96:	fb 48 06 90 	st.w	sp[1680],r8
8000ec9a:	30 19       	mov	r9,1
8000ec9c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000eca0:	87 19       	st.w	r3[0x4],r9
8000eca2:	2f f8       	sub	r8,-1
8000eca4:	fb 48 06 8c 	st.w	sp[1676],r8
8000eca8:	58 78       	cp.w	r8,7
8000ecaa:	e0 89 00 04 	brgt	8000ecb2 <_vfprintf_r+0x1ae6>
8000ecae:	2f 83       	sub	r3,-8
8000ecb0:	c0 b8       	rjmp	8000ecc6 <_vfprintf_r+0x1afa>
8000ecb2:	fa ca f9 78 	sub	r10,sp,-1672
8000ecb6:	02 9b       	mov	r11,r1
8000ecb8:	08 9c       	mov	r12,r4
8000ecba:	f0 1f 00 28 	mcall	8000ed58 <_vfprintf_r+0x1b8c>
8000ecbe:	e0 81 02 48 	brne	8000f14e <_vfprintf_r+0x1f82>
8000ecc2:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ecc6:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000ecca:	5c 32       	neg	r2
8000eccc:	58 02       	cp.w	r2,0
8000ecce:	e0 89 00 1d 	brgt	8000ed08 <_vfprintf_r+0x1b3c>
8000ecd2:	c3 b8       	rjmp	8000ed48 <_vfprintf_r+0x1b7c>
8000ecd4:	2f 09       	sub	r9,-16
8000ecd6:	2f f8       	sub	r8,-1
8000ecd8:	31 0e       	mov	lr,16
8000ecda:	fb 49 06 90 	st.w	sp[1680],r9
8000ecde:	87 00       	st.w	r3[0x0],r0
8000ece0:	87 1e       	st.w	r3[0x4],lr
8000ece2:	fb 48 06 8c 	st.w	sp[1676],r8
8000ece6:	58 78       	cp.w	r8,7
8000ece8:	e0 89 00 04 	brgt	8000ecf0 <_vfprintf_r+0x1b24>
8000ecec:	2f 83       	sub	r3,-8
8000ecee:	c0 b8       	rjmp	8000ed04 <_vfprintf_r+0x1b38>
8000ecf0:	fa ca f9 78 	sub	r10,sp,-1672
8000ecf4:	02 9b       	mov	r11,r1
8000ecf6:	08 9c       	mov	r12,r4
8000ecf8:	f0 1f 00 18 	mcall	8000ed58 <_vfprintf_r+0x1b8c>
8000ecfc:	e0 81 02 29 	brne	8000f14e <_vfprintf_r+0x1f82>
8000ed00:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ed04:	21 02       	sub	r2,16
8000ed06:	c0 28       	rjmp	8000ed0a <_vfprintf_r+0x1b3e>
8000ed08:	49 50       	lddpc	r0,8000ed5c <_vfprintf_r+0x1b90>
8000ed0a:	fa f9 06 90 	ld.w	r9,sp[1680]
8000ed0e:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ed12:	49 3a       	lddpc	r10,8000ed5c <_vfprintf_r+0x1b90>
8000ed14:	59 02       	cp.w	r2,16
8000ed16:	fe 99 ff df 	brgt	8000ecd4 <_vfprintf_r+0x1b08>
8000ed1a:	04 09       	add	r9,r2
8000ed1c:	2f f8       	sub	r8,-1
8000ed1e:	87 0a       	st.w	r3[0x0],r10
8000ed20:	fb 49 06 90 	st.w	sp[1680],r9
8000ed24:	87 12       	st.w	r3[0x4],r2
8000ed26:	fb 48 06 8c 	st.w	sp[1676],r8
8000ed2a:	58 78       	cp.w	r8,7
8000ed2c:	e0 89 00 04 	brgt	8000ed34 <_vfprintf_r+0x1b68>
8000ed30:	2f 83       	sub	r3,-8
8000ed32:	c0 b8       	rjmp	8000ed48 <_vfprintf_r+0x1b7c>
8000ed34:	fa ca f9 78 	sub	r10,sp,-1672
8000ed38:	02 9b       	mov	r11,r1
8000ed3a:	08 9c       	mov	r12,r4
8000ed3c:	f0 1f 00 07 	mcall	8000ed58 <_vfprintf_r+0x1b8c>
8000ed40:	e0 81 02 07 	brne	8000f14e <_vfprintf_r+0x1f82>
8000ed44:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ed48:	40 6c       	lddsp	r12,sp[0x18]
8000ed4a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ed4e:	87 06       	st.w	r3[0x0],r6
8000ed50:	87 1c       	st.w	r3[0x4],r12
8000ed52:	18 08       	add	r8,r12
8000ed54:	cb e8       	rjmp	8000eed0 <_vfprintf_r+0x1d04>
8000ed56:	00 00       	add	r0,r0
8000ed58:	80 00       	ld.sh	r0,r0[0x0]
8000ed5a:	d1 ac       	*unknown*
8000ed5c:	80 01       	ld.sh	r1,r0[0x0]
8000ed5e:	2a 1c       	sub	r12,-95
8000ed60:	80 01       	ld.sh	r1,r0[0x0]
8000ed62:	2a 08       	sub	r8,-96
8000ed64:	fa f9 06 90 	ld.w	r9,sp[1680]
8000ed68:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ed6c:	40 6b       	lddsp	r11,sp[0x18]
8000ed6e:	16 3a       	cp.w	r10,r11
8000ed70:	c6 d5       	brlt	8000ee4a <_vfprintf_r+0x1c7e>
8000ed72:	16 09       	add	r9,r11
8000ed74:	2f f8       	sub	r8,-1
8000ed76:	87 06       	st.w	r3[0x0],r6
8000ed78:	fb 49 06 90 	st.w	sp[1680],r9
8000ed7c:	87 1b       	st.w	r3[0x4],r11
8000ed7e:	fb 48 06 8c 	st.w	sp[1676],r8
8000ed82:	58 78       	cp.w	r8,7
8000ed84:	e0 89 00 04 	brgt	8000ed8c <_vfprintf_r+0x1bc0>
8000ed88:	2f 83       	sub	r3,-8
8000ed8a:	c0 b8       	rjmp	8000eda0 <_vfprintf_r+0x1bd4>
8000ed8c:	fa ca f9 78 	sub	r10,sp,-1672
8000ed90:	02 9b       	mov	r11,r1
8000ed92:	08 9c       	mov	r12,r4
8000ed94:	f0 1f 00 6f 	mcall	8000ef50 <_vfprintf_r+0x1d84>
8000ed98:	e0 81 01 db 	brne	8000f14e <_vfprintf_r+0x1f82>
8000ed9c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000eda0:	fa f6 06 ac 	ld.w	r6,sp[1708]
8000eda4:	40 6a       	lddsp	r10,sp[0x18]
8000eda6:	14 16       	sub	r6,r10
8000eda8:	58 06       	cp.w	r6,0
8000edaa:	e0 89 00 1c 	brgt	8000ede2 <_vfprintf_r+0x1c16>
8000edae:	c3 b8       	rjmp	8000ee24 <_vfprintf_r+0x1c58>
8000edb0:	2f 09       	sub	r9,-16
8000edb2:	2f f8       	sub	r8,-1
8000edb4:	fb 49 06 90 	st.w	sp[1680],r9
8000edb8:	87 02       	st.w	r3[0x0],r2
8000edba:	87 10       	st.w	r3[0x4],r0
8000edbc:	fb 48 06 8c 	st.w	sp[1676],r8
8000edc0:	58 78       	cp.w	r8,7
8000edc2:	e0 89 00 04 	brgt	8000edca <_vfprintf_r+0x1bfe>
8000edc6:	2f 83       	sub	r3,-8
8000edc8:	c0 b8       	rjmp	8000edde <_vfprintf_r+0x1c12>
8000edca:	fa ca f9 78 	sub	r10,sp,-1672
8000edce:	02 9b       	mov	r11,r1
8000edd0:	08 9c       	mov	r12,r4
8000edd2:	f0 1f 00 60 	mcall	8000ef50 <_vfprintf_r+0x1d84>
8000edd6:	e0 81 01 bc 	brne	8000f14e <_vfprintf_r+0x1f82>
8000edda:	fa c3 f9 e0 	sub	r3,sp,-1568
8000edde:	21 06       	sub	r6,16
8000ede0:	c0 38       	rjmp	8000ede6 <_vfprintf_r+0x1c1a>
8000ede2:	4d d2       	lddpc	r2,8000ef54 <_vfprintf_r+0x1d88>
8000ede4:	31 00       	mov	r0,16
8000ede6:	fa f9 06 90 	ld.w	r9,sp[1680]
8000edea:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000edee:	4d aa       	lddpc	r10,8000ef54 <_vfprintf_r+0x1d88>
8000edf0:	59 06       	cp.w	r6,16
8000edf2:	fe 99 ff df 	brgt	8000edb0 <_vfprintf_r+0x1be4>
8000edf6:	0c 09       	add	r9,r6
8000edf8:	2f f8       	sub	r8,-1
8000edfa:	87 0a       	st.w	r3[0x0],r10
8000edfc:	fb 49 06 90 	st.w	sp[1680],r9
8000ee00:	87 16       	st.w	r3[0x4],r6
8000ee02:	fb 48 06 8c 	st.w	sp[1676],r8
8000ee06:	58 78       	cp.w	r8,7
8000ee08:	e0 89 00 04 	brgt	8000ee10 <_vfprintf_r+0x1c44>
8000ee0c:	2f 83       	sub	r3,-8
8000ee0e:	c0 b8       	rjmp	8000ee24 <_vfprintf_r+0x1c58>
8000ee10:	fa ca f9 78 	sub	r10,sp,-1672
8000ee14:	02 9b       	mov	r11,r1
8000ee16:	08 9c       	mov	r12,r4
8000ee18:	f0 1f 00 4e 	mcall	8000ef50 <_vfprintf_r+0x1d84>
8000ee1c:	e0 81 01 99 	brne	8000f14e <_vfprintf_r+0x1f82>
8000ee20:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ee24:	ed b5 00 00 	bld	r5,0x0
8000ee28:	e0 81 01 22 	brne	8000f06c <_vfprintf_r+0x1ea0>
8000ee2c:	40 c9       	lddsp	r9,sp[0x30]
8000ee2e:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ee32:	2f f8       	sub	r8,-1
8000ee34:	87 09       	st.w	r3[0x0],r9
8000ee36:	fb 48 06 90 	st.w	sp[1680],r8
8000ee3a:	30 19       	mov	r9,1
8000ee3c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ee40:	87 19       	st.w	r3[0x4],r9
8000ee42:	2f f8       	sub	r8,-1
8000ee44:	fb 48 06 8c 	st.w	sp[1676],r8
8000ee48:	c0 49       	rjmp	8000f050 <_vfprintf_r+0x1e84>
8000ee4a:	14 09       	add	r9,r10
8000ee4c:	2f f8       	sub	r8,-1
8000ee4e:	fb 49 06 90 	st.w	sp[1680],r9
8000ee52:	87 06       	st.w	r3[0x0],r6
8000ee54:	87 1a       	st.w	r3[0x4],r10
8000ee56:	fb 48 06 8c 	st.w	sp[1676],r8
8000ee5a:	58 78       	cp.w	r8,7
8000ee5c:	e0 89 00 04 	brgt	8000ee64 <_vfprintf_r+0x1c98>
8000ee60:	2f 83       	sub	r3,-8
8000ee62:	c0 b8       	rjmp	8000ee78 <_vfprintf_r+0x1cac>
8000ee64:	fa ca f9 78 	sub	r10,sp,-1672
8000ee68:	02 9b       	mov	r11,r1
8000ee6a:	08 9c       	mov	r12,r4
8000ee6c:	f0 1f 00 39 	mcall	8000ef50 <_vfprintf_r+0x1d84>
8000ee70:	e0 81 01 6f 	brne	8000f14e <_vfprintf_r+0x1f82>
8000ee74:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ee78:	40 c8       	lddsp	r8,sp[0x30]
8000ee7a:	87 08       	st.w	r3[0x0],r8
8000ee7c:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ee80:	2f f8       	sub	r8,-1
8000ee82:	30 19       	mov	r9,1
8000ee84:	fb 48 06 90 	st.w	sp[1680],r8
8000ee88:	87 19       	st.w	r3[0x4],r9
8000ee8a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ee8e:	2f f8       	sub	r8,-1
8000ee90:	fb 48 06 8c 	st.w	sp[1676],r8
8000ee94:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000ee98:	58 78       	cp.w	r8,7
8000ee9a:	e0 89 00 04 	brgt	8000eea2 <_vfprintf_r+0x1cd6>
8000ee9e:	2f 83       	sub	r3,-8
8000eea0:	c0 b8       	rjmp	8000eeb6 <_vfprintf_r+0x1cea>
8000eea2:	fa ca f9 78 	sub	r10,sp,-1672
8000eea6:	02 9b       	mov	r11,r1
8000eea8:	08 9c       	mov	r12,r4
8000eeaa:	f0 1f 00 2a 	mcall	8000ef50 <_vfprintf_r+0x1d84>
8000eeae:	e0 81 01 50 	brne	8000f14e <_vfprintf_r+0x1f82>
8000eeb2:	fa c3 f9 e0 	sub	r3,sp,-1568
8000eeb6:	04 06       	add	r6,r2
8000eeb8:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000eebc:	87 06       	st.w	r3[0x0],r6
8000eebe:	fa f9 06 90 	ld.w	r9,sp[1680]
8000eec2:	40 66       	lddsp	r6,sp[0x18]
8000eec4:	40 6e       	lddsp	lr,sp[0x18]
8000eec6:	10 16       	sub	r6,r8
8000eec8:	f2 08 01 08 	sub	r8,r9,r8
8000eecc:	87 16       	st.w	r3[0x4],r6
8000eece:	1c 08       	add	r8,lr
8000eed0:	fb 48 06 90 	st.w	sp[1680],r8
8000eed4:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000eed8:	2f f8       	sub	r8,-1
8000eeda:	fb 48 06 8c 	st.w	sp[1676],r8
8000eede:	cb 98       	rjmp	8000f050 <_vfprintf_r+0x1e84>
8000eee0:	40 6c       	lddsp	r12,sp[0x18]
8000eee2:	58 1c       	cp.w	r12,1
8000eee4:	e0 89 00 06 	brgt	8000eef0 <_vfprintf_r+0x1d24>
8000eee8:	ed b5 00 00 	bld	r5,0x0
8000eeec:	e0 81 00 87 	brne	8000effa <_vfprintf_r+0x1e2e>
8000eef0:	fa f8 06 90 	ld.w	r8,sp[1680]
8000eef4:	2f f8       	sub	r8,-1
8000eef6:	30 19       	mov	r9,1
8000eef8:	fb 48 06 90 	st.w	sp[1680],r8
8000eefc:	87 06       	st.w	r3[0x0],r6
8000eefe:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ef02:	87 19       	st.w	r3[0x4],r9
8000ef04:	2f f8       	sub	r8,-1
8000ef06:	fb 48 06 8c 	st.w	sp[1676],r8
8000ef0a:	58 78       	cp.w	r8,7
8000ef0c:	e0 89 00 04 	brgt	8000ef14 <_vfprintf_r+0x1d48>
8000ef10:	2f 83       	sub	r3,-8
8000ef12:	c0 b8       	rjmp	8000ef28 <_vfprintf_r+0x1d5c>
8000ef14:	fa ca f9 78 	sub	r10,sp,-1672
8000ef18:	02 9b       	mov	r11,r1
8000ef1a:	08 9c       	mov	r12,r4
8000ef1c:	f0 1f 00 0d 	mcall	8000ef50 <_vfprintf_r+0x1d84>
8000ef20:	e0 81 01 17 	brne	8000f14e <_vfprintf_r+0x1f82>
8000ef24:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ef28:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ef2c:	2f f8       	sub	r8,-1
8000ef2e:	40 cb       	lddsp	r11,sp[0x30]
8000ef30:	fb 48 06 90 	st.w	sp[1680],r8
8000ef34:	30 19       	mov	r9,1
8000ef36:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ef3a:	87 0b       	st.w	r3[0x0],r11
8000ef3c:	2f f8       	sub	r8,-1
8000ef3e:	87 19       	st.w	r3[0x4],r9
8000ef40:	fb 48 06 8c 	st.w	sp[1676],r8
8000ef44:	58 78       	cp.w	r8,7
8000ef46:	e0 89 00 09 	brgt	8000ef58 <_vfprintf_r+0x1d8c>
8000ef4a:	2f 83       	sub	r3,-8
8000ef4c:	c1 08       	rjmp	8000ef6c <_vfprintf_r+0x1da0>
8000ef4e:	00 00       	add	r0,r0
8000ef50:	80 00       	ld.sh	r0,r0[0x0]
8000ef52:	d1 ac       	*unknown*
8000ef54:	80 01       	ld.sh	r1,r0[0x0]
8000ef56:	2a 1c       	sub	r12,-95
8000ef58:	fa ca f9 78 	sub	r10,sp,-1672
8000ef5c:	02 9b       	mov	r11,r1
8000ef5e:	08 9c       	mov	r12,r4
8000ef60:	f0 1f 00 6f 	mcall	8000f11c <_vfprintf_r+0x1f50>
8000ef64:	e0 81 00 f5 	brne	8000f14e <_vfprintf_r+0x1f82>
8000ef68:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ef6c:	30 08       	mov	r8,0
8000ef6e:	30 09       	mov	r9,0
8000ef70:	40 5b       	lddsp	r11,sp[0x14]
8000ef72:	40 7a       	lddsp	r10,sp[0x1c]
8000ef74:	f0 1f 00 6b 	mcall	8000f120 <_vfprintf_r+0x1f54>
8000ef78:	40 68       	lddsp	r8,sp[0x18]
8000ef7a:	20 18       	sub	r8,1
8000ef7c:	58 0c       	cp.w	r12,0
8000ef7e:	c0 d1       	brne	8000ef98 <_vfprintf_r+0x1dcc>
8000ef80:	2f f6       	sub	r6,-1
8000ef82:	87 18       	st.w	r3[0x4],r8
8000ef84:	87 06       	st.w	r3[0x0],r6
8000ef86:	fa f6 06 90 	ld.w	r6,sp[1680]
8000ef8a:	10 06       	add	r6,r8
8000ef8c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ef90:	fb 46 06 90 	st.w	sp[1680],r6
8000ef94:	2f f8       	sub	r8,-1
8000ef96:	c2 f8       	rjmp	8000eff4 <_vfprintf_r+0x1e28>
8000ef98:	10 96       	mov	r6,r8
8000ef9a:	58 08       	cp.w	r8,0
8000ef9c:	e0 89 00 1c 	brgt	8000efd4 <_vfprintf_r+0x1e08>
8000efa0:	c4 98       	rjmp	8000f032 <_vfprintf_r+0x1e66>
8000efa2:	2f 09       	sub	r9,-16
8000efa4:	2f f8       	sub	r8,-1
8000efa6:	fb 49 06 90 	st.w	sp[1680],r9
8000efaa:	87 02       	st.w	r3[0x0],r2
8000efac:	87 10       	st.w	r3[0x4],r0
8000efae:	fb 48 06 8c 	st.w	sp[1676],r8
8000efb2:	58 78       	cp.w	r8,7
8000efb4:	e0 89 00 04 	brgt	8000efbc <_vfprintf_r+0x1df0>
8000efb8:	2f 83       	sub	r3,-8
8000efba:	c0 b8       	rjmp	8000efd0 <_vfprintf_r+0x1e04>
8000efbc:	fa ca f9 78 	sub	r10,sp,-1672
8000efc0:	02 9b       	mov	r11,r1
8000efc2:	08 9c       	mov	r12,r4
8000efc4:	f0 1f 00 56 	mcall	8000f11c <_vfprintf_r+0x1f50>
8000efc8:	e0 81 00 c3 	brne	8000f14e <_vfprintf_r+0x1f82>
8000efcc:	fa c3 f9 e0 	sub	r3,sp,-1568
8000efd0:	21 06       	sub	r6,16
8000efd2:	c0 38       	rjmp	8000efd8 <_vfprintf_r+0x1e0c>
8000efd4:	4d 42       	lddpc	r2,8000f124 <_vfprintf_r+0x1f58>
8000efd6:	31 00       	mov	r0,16
8000efd8:	fa f9 06 90 	ld.w	r9,sp[1680]
8000efdc:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000efe0:	4d 1a       	lddpc	r10,8000f124 <_vfprintf_r+0x1f58>
8000efe2:	59 06       	cp.w	r6,16
8000efe4:	fe 99 ff df 	brgt	8000efa2 <_vfprintf_r+0x1dd6>
8000efe8:	0c 09       	add	r9,r6
8000efea:	87 0a       	st.w	r3[0x0],r10
8000efec:	fb 49 06 90 	st.w	sp[1680],r9
8000eff0:	2f f8       	sub	r8,-1
8000eff2:	87 16       	st.w	r3[0x4],r6
8000eff4:	fb 48 06 8c 	st.w	sp[1676],r8
8000eff8:	c0 e8       	rjmp	8000f014 <_vfprintf_r+0x1e48>
8000effa:	fa f8 06 90 	ld.w	r8,sp[1680]
8000effe:	2f f8       	sub	r8,-1
8000f000:	30 19       	mov	r9,1
8000f002:	fb 48 06 90 	st.w	sp[1680],r8
8000f006:	87 06       	st.w	r3[0x0],r6
8000f008:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000f00c:	87 19       	st.w	r3[0x4],r9
8000f00e:	2f f8       	sub	r8,-1
8000f010:	fb 48 06 8c 	st.w	sp[1676],r8
8000f014:	58 78       	cp.w	r8,7
8000f016:	e0 89 00 04 	brgt	8000f01e <_vfprintf_r+0x1e52>
8000f01a:	2f 83       	sub	r3,-8
8000f01c:	c0 b8       	rjmp	8000f032 <_vfprintf_r+0x1e66>
8000f01e:	fa ca f9 78 	sub	r10,sp,-1672
8000f022:	02 9b       	mov	r11,r1
8000f024:	08 9c       	mov	r12,r4
8000f026:	f0 1f 00 3e 	mcall	8000f11c <_vfprintf_r+0x1f50>
8000f02a:	e0 81 00 92 	brne	8000f14e <_vfprintf_r+0x1f82>
8000f02e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000f032:	40 ea       	lddsp	r10,sp[0x38]
8000f034:	fa f8 06 90 	ld.w	r8,sp[1680]
8000f038:	14 08       	add	r8,r10
8000f03a:	fa c9 f9 64 	sub	r9,sp,-1692
8000f03e:	fb 48 06 90 	st.w	sp[1680],r8
8000f042:	87 1a       	st.w	r3[0x4],r10
8000f044:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000f048:	87 09       	st.w	r3[0x0],r9
8000f04a:	2f f8       	sub	r8,-1
8000f04c:	fb 48 06 8c 	st.w	sp[1676],r8
8000f050:	58 78       	cp.w	r8,7
8000f052:	e0 89 00 04 	brgt	8000f05a <_vfprintf_r+0x1e8e>
8000f056:	2f 83       	sub	r3,-8
8000f058:	c0 a8       	rjmp	8000f06c <_vfprintf_r+0x1ea0>
8000f05a:	fa ca f9 78 	sub	r10,sp,-1672
8000f05e:	02 9b       	mov	r11,r1
8000f060:	08 9c       	mov	r12,r4
8000f062:	f0 1f 00 2f 	mcall	8000f11c <_vfprintf_r+0x1f50>
8000f066:	c7 41       	brne	8000f14e <_vfprintf_r+0x1f82>
8000f068:	fa c3 f9 e0 	sub	r3,sp,-1568
8000f06c:	e2 15 00 04 	andl	r5,0x4,COH
8000f070:	c3 d0       	breq	8000f0ea <_vfprintf_r+0x1f1e>
8000f072:	40 86       	lddsp	r6,sp[0x20]
8000f074:	40 39       	lddsp	r9,sp[0xc]
8000f076:	12 16       	sub	r6,r9
8000f078:	58 06       	cp.w	r6,0
8000f07a:	e0 89 00 1a 	brgt	8000f0ae <_vfprintf_r+0x1ee2>
8000f07e:	c3 68       	rjmp	8000f0ea <_vfprintf_r+0x1f1e>
8000f080:	2f 09       	sub	r9,-16
8000f082:	2f f8       	sub	r8,-1
8000f084:	fb 49 06 90 	st.w	sp[1680],r9
8000f088:	87 05       	st.w	r3[0x0],r5
8000f08a:	87 12       	st.w	r3[0x4],r2
8000f08c:	fb 48 06 8c 	st.w	sp[1676],r8
8000f090:	58 78       	cp.w	r8,7
8000f092:	e0 89 00 04 	brgt	8000f09a <_vfprintf_r+0x1ece>
8000f096:	2f 83       	sub	r3,-8
8000f098:	c0 98       	rjmp	8000f0aa <_vfprintf_r+0x1ede>
8000f09a:	00 9a       	mov	r10,r0
8000f09c:	02 9b       	mov	r11,r1
8000f09e:	08 9c       	mov	r12,r4
8000f0a0:	f0 1f 00 1f 	mcall	8000f11c <_vfprintf_r+0x1f50>
8000f0a4:	c5 51       	brne	8000f14e <_vfprintf_r+0x1f82>
8000f0a6:	fa c3 f9 e0 	sub	r3,sp,-1568
8000f0aa:	21 06       	sub	r6,16
8000f0ac:	c0 58       	rjmp	8000f0b6 <_vfprintf_r+0x1eea>
8000f0ae:	49 f5       	lddpc	r5,8000f128 <_vfprintf_r+0x1f5c>
8000f0b0:	31 02       	mov	r2,16
8000f0b2:	fa c0 f9 78 	sub	r0,sp,-1672
8000f0b6:	fa f9 06 90 	ld.w	r9,sp[1680]
8000f0ba:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000f0be:	49 ba       	lddpc	r10,8000f128 <_vfprintf_r+0x1f5c>
8000f0c0:	59 06       	cp.w	r6,16
8000f0c2:	fe 99 ff df 	brgt	8000f080 <_vfprintf_r+0x1eb4>
8000f0c6:	0c 09       	add	r9,r6
8000f0c8:	2f f8       	sub	r8,-1
8000f0ca:	87 0a       	st.w	r3[0x0],r10
8000f0cc:	87 16       	st.w	r3[0x4],r6
8000f0ce:	fb 49 06 90 	st.w	sp[1680],r9
8000f0d2:	fb 48 06 8c 	st.w	sp[1676],r8
8000f0d6:	58 78       	cp.w	r8,7
8000f0d8:	e0 8a 00 09 	brle	8000f0ea <_vfprintf_r+0x1f1e>
8000f0dc:	fa ca f9 78 	sub	r10,sp,-1672
8000f0e0:	02 9b       	mov	r11,r1
8000f0e2:	08 9c       	mov	r12,r4
8000f0e4:	f0 1f 00 0e 	mcall	8000f11c <_vfprintf_r+0x1f50>
8000f0e8:	c3 31       	brne	8000f14e <_vfprintf_r+0x1f82>
8000f0ea:	40 bc       	lddsp	r12,sp[0x2c]
8000f0ec:	40 36       	lddsp	r6,sp[0xc]
8000f0ee:	40 8e       	lddsp	lr,sp[0x20]
8000f0f0:	ec 0e 0c 48 	max	r8,r6,lr
8000f0f4:	10 0c       	add	r12,r8
8000f0f6:	50 bc       	stdsp	sp[0x2c],r12
8000f0f8:	fa f8 06 90 	ld.w	r8,sp[1680]
8000f0fc:	58 08       	cp.w	r8,0
8000f0fe:	c0 80       	breq	8000f10e <_vfprintf_r+0x1f42>
8000f100:	fa ca f9 78 	sub	r10,sp,-1672
8000f104:	02 9b       	mov	r11,r1
8000f106:	08 9c       	mov	r12,r4
8000f108:	f0 1f 00 05 	mcall	8000f11c <_vfprintf_r+0x1f50>
8000f10c:	c2 11       	brne	8000f14e <_vfprintf_r+0x1f82>
8000f10e:	30 0b       	mov	r11,0
8000f110:	fa c3 f9 e0 	sub	r3,sp,-1568
8000f114:	fb 4b 06 8c 	st.w	sp[1676],r11
8000f118:	fe 9f f0 e6 	bral	8000d2e4 <_vfprintf_r+0x118>
8000f11c:	80 00       	ld.sh	r0,r0[0x0]
8000f11e:	d1 ac       	*unknown*
8000f120:	80 01       	ld.sh	r1,r0[0x0]
8000f122:	1b 22       	ld.uh	r2,sp++
8000f124:	80 01       	ld.sh	r1,r0[0x0]
8000f126:	2a 1c       	sub	r12,-95
8000f128:	80 01       	ld.sh	r1,r0[0x0]
8000f12a:	2a 0c       	sub	r12,-96
8000f12c:	08 95       	mov	r5,r4
8000f12e:	fa f8 06 90 	ld.w	r8,sp[1680]
8000f132:	58 08       	cp.w	r8,0
8000f134:	c0 80       	breq	8000f144 <_vfprintf_r+0x1f78>
8000f136:	08 9c       	mov	r12,r4
8000f138:	fa ca f9 78 	sub	r10,sp,-1672
8000f13c:	02 9b       	mov	r11,r1
8000f13e:	f0 1f 00 0a 	mcall	8000f164 <_vfprintf_r+0x1f98>
8000f142:	c0 61       	brne	8000f14e <_vfprintf_r+0x1f82>
8000f144:	30 08       	mov	r8,0
8000f146:	fb 48 06 8c 	st.w	sp[1676],r8
8000f14a:	c0 28       	rjmp	8000f14e <_vfprintf_r+0x1f82>
8000f14c:	40 41       	lddsp	r1,sp[0x10]
8000f14e:	82 68       	ld.sh	r8,r1[0xc]
8000f150:	ed b8 00 06 	bld	r8,0x6
8000f154:	c0 31       	brne	8000f15a <_vfprintf_r+0x1f8e>
8000f156:	3f fa       	mov	r10,-1
8000f158:	50 ba       	stdsp	sp[0x2c],r10
8000f15a:	40 bc       	lddsp	r12,sp[0x2c]
8000f15c:	fe 3d f9 44 	sub	sp,-1724
8000f160:	d8 32       	popm	r0-r7,pc
8000f162:	00 00       	add	r0,r0
8000f164:	80 00       	ld.sh	r0,r0[0x0]
8000f166:	d1 ac       	*unknown*

8000f168 <__swsetup_r>:
8000f168:	d4 21       	pushm	r4-r7,lr
8000f16a:	4b 38       	lddpc	r8,8000f234 <__swsetup_r+0xcc>
8000f16c:	18 96       	mov	r6,r12
8000f16e:	16 97       	mov	r7,r11
8000f170:	70 0c       	ld.w	r12,r8[0x0]
8000f172:	58 0c       	cp.w	r12,0
8000f174:	c0 60       	breq	8000f180 <__swsetup_r+0x18>
8000f176:	78 68       	ld.w	r8,r12[0x18]
8000f178:	58 08       	cp.w	r8,0
8000f17a:	c0 31       	brne	8000f180 <__swsetup_r+0x18>
8000f17c:	f0 1f 00 2f 	mcall	8000f238 <__swsetup_r+0xd0>
8000f180:	4a f8       	lddpc	r8,8000f23c <__swsetup_r+0xd4>
8000f182:	10 37       	cp.w	r7,r8
8000f184:	c0 51       	brne	8000f18e <__swsetup_r+0x26>
8000f186:	4a c8       	lddpc	r8,8000f234 <__swsetup_r+0xcc>
8000f188:	70 08       	ld.w	r8,r8[0x0]
8000f18a:	70 07       	ld.w	r7,r8[0x0]
8000f18c:	c0 e8       	rjmp	8000f1a8 <__swsetup_r+0x40>
8000f18e:	4a d8       	lddpc	r8,8000f240 <__swsetup_r+0xd8>
8000f190:	10 37       	cp.w	r7,r8
8000f192:	c0 51       	brne	8000f19c <__swsetup_r+0x34>
8000f194:	4a 88       	lddpc	r8,8000f234 <__swsetup_r+0xcc>
8000f196:	70 08       	ld.w	r8,r8[0x0]
8000f198:	70 17       	ld.w	r7,r8[0x4]
8000f19a:	c0 78       	rjmp	8000f1a8 <__swsetup_r+0x40>
8000f19c:	4a a8       	lddpc	r8,8000f244 <__swsetup_r+0xdc>
8000f19e:	10 37       	cp.w	r7,r8
8000f1a0:	c0 41       	brne	8000f1a8 <__swsetup_r+0x40>
8000f1a2:	4a 58       	lddpc	r8,8000f234 <__swsetup_r+0xcc>
8000f1a4:	70 08       	ld.w	r8,r8[0x0]
8000f1a6:	70 27       	ld.w	r7,r8[0x8]
8000f1a8:	8e 68       	ld.sh	r8,r7[0xc]
8000f1aa:	ed b8 00 03 	bld	r8,0x3
8000f1ae:	c1 e0       	breq	8000f1ea <__swsetup_r+0x82>
8000f1b0:	ed b8 00 04 	bld	r8,0x4
8000f1b4:	c3 e1       	brne	8000f230 <__swsetup_r+0xc8>
8000f1b6:	ed b8 00 02 	bld	r8,0x2
8000f1ba:	c1 51       	brne	8000f1e4 <__swsetup_r+0x7c>
8000f1bc:	6e db       	ld.w	r11,r7[0x34]
8000f1be:	58 0b       	cp.w	r11,0
8000f1c0:	c0 a0       	breq	8000f1d4 <__swsetup_r+0x6c>
8000f1c2:	ee c8 ff bc 	sub	r8,r7,-68
8000f1c6:	10 3b       	cp.w	r11,r8
8000f1c8:	c0 40       	breq	8000f1d0 <__swsetup_r+0x68>
8000f1ca:	0c 9c       	mov	r12,r6
8000f1cc:	f0 1f 00 1f 	mcall	8000f248 <__swsetup_r+0xe0>
8000f1d0:	30 08       	mov	r8,0
8000f1d2:	8f d8       	st.w	r7[0x34],r8
8000f1d4:	8e 68       	ld.sh	r8,r7[0xc]
8000f1d6:	e0 18 ff db 	andl	r8,0xffdb
8000f1da:	ae 68       	st.h	r7[0xc],r8
8000f1dc:	30 08       	mov	r8,0
8000f1de:	8f 18       	st.w	r7[0x4],r8
8000f1e0:	6e 48       	ld.w	r8,r7[0x10]
8000f1e2:	8f 08       	st.w	r7[0x0],r8
8000f1e4:	8e 68       	ld.sh	r8,r7[0xc]
8000f1e6:	a3 b8       	sbr	r8,0x3
8000f1e8:	ae 68       	st.h	r7[0xc],r8
8000f1ea:	6e 48       	ld.w	r8,r7[0x10]
8000f1ec:	58 08       	cp.w	r8,0
8000f1ee:	c0 b1       	brne	8000f204 <__swsetup_r+0x9c>
8000f1f0:	8e 68       	ld.sh	r8,r7[0xc]
8000f1f2:	e2 18 02 80 	andl	r8,0x280,COH
8000f1f6:	e0 48 02 00 	cp.w	r8,512
8000f1fa:	c0 50       	breq	8000f204 <__swsetup_r+0x9c>
8000f1fc:	0c 9c       	mov	r12,r6
8000f1fe:	0e 9b       	mov	r11,r7
8000f200:	f0 1f 00 13 	mcall	8000f24c <__swsetup_r+0xe4>
8000f204:	8e 69       	ld.sh	r9,r7[0xc]
8000f206:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
8000f20a:	c0 70       	breq	8000f218 <__swsetup_r+0xb0>
8000f20c:	30 08       	mov	r8,0
8000f20e:	8f 28       	st.w	r7[0x8],r8
8000f210:	6e 58       	ld.w	r8,r7[0x14]
8000f212:	5c 38       	neg	r8
8000f214:	8f 68       	st.w	r7[0x18],r8
8000f216:	c0 68       	rjmp	8000f222 <__swsetup_r+0xba>
8000f218:	ed b9 00 01 	bld	r9,0x1
8000f21c:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8000f220:	8f 28       	st.w	r7[0x8],r8
8000f222:	6e 48       	ld.w	r8,r7[0x10]
8000f224:	58 08       	cp.w	r8,0
8000f226:	c0 61       	brne	8000f232 <__swsetup_r+0xca>
8000f228:	8e 68       	ld.sh	r8,r7[0xc]
8000f22a:	ed b8 00 07 	bld	r8,0x7
8000f22e:	c0 21       	brne	8000f232 <__swsetup_r+0xca>
8000f230:	dc 2a       	popm	r4-r7,pc,r12=-1
8000f232:	d8 2a       	popm	r4-r7,pc,r12=0
8000f234:	00 00       	add	r0,r0
8000f236:	01 a8       	ld.ub	r8,r0[0x2]
8000f238:	80 01       	ld.sh	r1,r0[0x0]
8000f23a:	01 e0       	ld.ub	r0,r0[0x6]
8000f23c:	80 01       	ld.sh	r1,r0[0x0]
8000f23e:	2b 3c       	sub	r12,-77
8000f240:	80 01       	ld.sh	r1,r0[0x0]
8000f242:	2b 5c       	sub	r12,-75
8000f244:	80 01       	ld.sh	r1,r0[0x0]
8000f246:	2b 7c       	sub	r12,-73
8000f248:	80 01       	ld.sh	r1,r0[0x0]
8000f24a:	03 38       	ld.ub	r8,r1++
8000f24c:	80 01       	ld.sh	r1,r0[0x0]
8000f24e:	07 f8       	ld.ub	r8,r3[0x7]

8000f250 <quorem>:
8000f250:	d4 31       	pushm	r0-r7,lr
8000f252:	20 2d       	sub	sp,8
8000f254:	18 97       	mov	r7,r12
8000f256:	78 48       	ld.w	r8,r12[0x10]
8000f258:	76 46       	ld.w	r6,r11[0x10]
8000f25a:	0c 38       	cp.w	r8,r6
8000f25c:	c0 34       	brge	8000f262 <quorem+0x12>
8000f25e:	30 0c       	mov	r12,0
8000f260:	c8 58       	rjmp	8000f36a <quorem+0x11a>
8000f262:	ec c2 ff fc 	sub	r2,r6,-4
8000f266:	f6 c3 ff ec 	sub	r3,r11,-20
8000f26a:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
8000f26e:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
8000f272:	2f f9       	sub	r9,-1
8000f274:	20 16       	sub	r6,1
8000f276:	f8 09 0d 08 	divu	r8,r12,r9
8000f27a:	f6 02 00 22 	add	r2,r11,r2<<0x2
8000f27e:	ee c4 ff ec 	sub	r4,r7,-20
8000f282:	10 95       	mov	r5,r8
8000f284:	58 08       	cp.w	r8,0
8000f286:	c4 10       	breq	8000f308 <quorem+0xb8>
8000f288:	30 09       	mov	r9,0
8000f28a:	06 9a       	mov	r10,r3
8000f28c:	08 98       	mov	r8,r4
8000f28e:	12 91       	mov	r1,r9
8000f290:	50 0b       	stdsp	sp[0x0],r11
8000f292:	70 0e       	ld.w	lr,r8[0x0]
8000f294:	b1 8e       	lsr	lr,0x10
8000f296:	50 1e       	stdsp	sp[0x4],lr
8000f298:	15 0e       	ld.w	lr,r10++
8000f29a:	fc 00 16 10 	lsr	r0,lr,0x10
8000f29e:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000f2a2:	ea 0e 03 41 	mac	r1,r5,lr
8000f2a6:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
8000f2aa:	b1 81       	lsr	r1,0x10
8000f2ac:	40 1b       	lddsp	r11,sp[0x4]
8000f2ae:	ea 00 02 40 	mul	r0,r5,r0
8000f2b2:	e2 00 00 00 	add	r0,r1,r0
8000f2b6:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
8000f2ba:	02 1b       	sub	r11,r1
8000f2bc:	50 1b       	stdsp	sp[0x4],r11
8000f2be:	70 0b       	ld.w	r11,r8[0x0]
8000f2c0:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
8000f2c4:	02 09       	add	r9,r1
8000f2c6:	f2 0e 01 0e 	sub	lr,r9,lr
8000f2ca:	b0 1e       	st.h	r8[0x2],lr
8000f2cc:	fc 09 14 10 	asr	r9,lr,0x10
8000f2d0:	40 1e       	lddsp	lr,sp[0x4]
8000f2d2:	fc 09 00 09 	add	r9,lr,r9
8000f2d6:	b0 09       	st.h	r8[0x0],r9
8000f2d8:	e0 01 16 10 	lsr	r1,r0,0x10
8000f2dc:	2f c8       	sub	r8,-4
8000f2de:	b1 49       	asr	r9,0x10
8000f2e0:	04 3a       	cp.w	r10,r2
8000f2e2:	fe 98 ff d8 	brls	8000f292 <quorem+0x42>
8000f2e6:	40 0b       	lddsp	r11,sp[0x0]
8000f2e8:	58 0c       	cp.w	r12,0
8000f2ea:	c0 f1       	brne	8000f308 <quorem+0xb8>
8000f2ec:	ec c8 ff fb 	sub	r8,r6,-5
8000f2f0:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000f2f4:	c0 28       	rjmp	8000f2f8 <quorem+0xa8>
8000f2f6:	20 16       	sub	r6,1
8000f2f8:	20 48       	sub	r8,4
8000f2fa:	08 38       	cp.w	r8,r4
8000f2fc:	e0 88 00 05 	brls	8000f306 <quorem+0xb6>
8000f300:	70 09       	ld.w	r9,r8[0x0]
8000f302:	58 09       	cp.w	r9,0
8000f304:	cf 90       	breq	8000f2f6 <quorem+0xa6>
8000f306:	8f 46       	st.w	r7[0x10],r6
8000f308:	0e 9c       	mov	r12,r7
8000f30a:	f0 1f 00 1a 	mcall	8000f370 <quorem+0x120>
8000f30e:	c2 d5       	brlt	8000f368 <quorem+0x118>
8000f310:	2f f5       	sub	r5,-1
8000f312:	08 98       	mov	r8,r4
8000f314:	30 09       	mov	r9,0
8000f316:	07 0b       	ld.w	r11,r3++
8000f318:	f6 0a 16 10 	lsr	r10,r11,0x10
8000f31c:	70 0c       	ld.w	r12,r8[0x0]
8000f31e:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000f322:	f8 0e 16 10 	lsr	lr,r12,0x10
8000f326:	14 1e       	sub	lr,r10
8000f328:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000f32c:	16 1a       	sub	r10,r11
8000f32e:	12 0a       	add	r10,r9
8000f330:	b0 1a       	st.h	r8[0x2],r10
8000f332:	b1 4a       	asr	r10,0x10
8000f334:	fc 0a 00 09 	add	r9,lr,r10
8000f338:	b0 09       	st.h	r8[0x0],r9
8000f33a:	2f c8       	sub	r8,-4
8000f33c:	b1 49       	asr	r9,0x10
8000f33e:	04 33       	cp.w	r3,r2
8000f340:	fe 98 ff eb 	brls	8000f316 <quorem+0xc6>
8000f344:	ec c8 ff fb 	sub	r8,r6,-5
8000f348:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
8000f34c:	58 09       	cp.w	r9,0
8000f34e:	c0 d1       	brne	8000f368 <quorem+0x118>
8000f350:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000f354:	c0 28       	rjmp	8000f358 <quorem+0x108>
8000f356:	20 16       	sub	r6,1
8000f358:	20 48       	sub	r8,4
8000f35a:	08 38       	cp.w	r8,r4
8000f35c:	e0 88 00 05 	brls	8000f366 <quorem+0x116>
8000f360:	70 09       	ld.w	r9,r8[0x0]
8000f362:	58 09       	cp.w	r9,0
8000f364:	cf 90       	breq	8000f356 <quorem+0x106>
8000f366:	8f 46       	st.w	r7[0x10],r6
8000f368:	0a 9c       	mov	r12,r5
8000f36a:	2f ed       	sub	sp,-8
8000f36c:	d8 32       	popm	r0-r7,pc
8000f36e:	00 00       	add	r0,r0
8000f370:	80 01       	ld.sh	r1,r0[0x0]
8000f372:	0e 72       	tst	r2,r7

8000f374 <_dtoa_r>:
8000f374:	d4 31       	pushm	r0-r7,lr
8000f376:	21 ad       	sub	sp,104
8000f378:	fa c4 ff 74 	sub	r4,sp,-140
8000f37c:	18 97       	mov	r7,r12
8000f37e:	16 95       	mov	r5,r11
8000f380:	68 2c       	ld.w	r12,r4[0x8]
8000f382:	50 c9       	stdsp	sp[0x30],r9
8000f384:	68 16       	ld.w	r6,r4[0x4]
8000f386:	68 09       	ld.w	r9,r4[0x0]
8000f388:	50 e8       	stdsp	sp[0x38],r8
8000f38a:	14 94       	mov	r4,r10
8000f38c:	51 2c       	stdsp	sp[0x48],r12
8000f38e:	fa e5 00 08 	st.d	sp[8],r4
8000f392:	51 59       	stdsp	sp[0x54],r9
8000f394:	6e 95       	ld.w	r5,r7[0x24]
8000f396:	58 05       	cp.w	r5,0
8000f398:	c0 91       	brne	8000f3aa <_dtoa_r+0x36>
8000f39a:	31 0c       	mov	r12,16
8000f39c:	f0 1f 00 47 	mcall	8000f4b8 <_dtoa_r+0x144>
8000f3a0:	99 35       	st.w	r12[0xc],r5
8000f3a2:	8f 9c       	st.w	r7[0x24],r12
8000f3a4:	99 15       	st.w	r12[0x4],r5
8000f3a6:	99 25       	st.w	r12[0x8],r5
8000f3a8:	99 05       	st.w	r12[0x0],r5
8000f3aa:	6e 99       	ld.w	r9,r7[0x24]
8000f3ac:	72 08       	ld.w	r8,r9[0x0]
8000f3ae:	58 08       	cp.w	r8,0
8000f3b0:	c0 f0       	breq	8000f3ce <_dtoa_r+0x5a>
8000f3b2:	72 1a       	ld.w	r10,r9[0x4]
8000f3b4:	91 1a       	st.w	r8[0x4],r10
8000f3b6:	30 1a       	mov	r10,1
8000f3b8:	72 19       	ld.w	r9,r9[0x4]
8000f3ba:	f4 09 09 49 	lsl	r9,r10,r9
8000f3be:	10 9b       	mov	r11,r8
8000f3c0:	91 29       	st.w	r8[0x8],r9
8000f3c2:	0e 9c       	mov	r12,r7
8000f3c4:	f0 1f 00 3e 	mcall	8000f4bc <_dtoa_r+0x148>
8000f3c8:	6e 98       	ld.w	r8,r7[0x24]
8000f3ca:	30 09       	mov	r9,0
8000f3cc:	91 09       	st.w	r8[0x0],r9
8000f3ce:	40 28       	lddsp	r8,sp[0x8]
8000f3d0:	10 94       	mov	r4,r8
8000f3d2:	58 08       	cp.w	r8,0
8000f3d4:	c0 64       	brge	8000f3e0 <_dtoa_r+0x6c>
8000f3d6:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000f3da:	50 28       	stdsp	sp[0x8],r8
8000f3dc:	30 18       	mov	r8,1
8000f3de:	c0 28       	rjmp	8000f3e2 <_dtoa_r+0x6e>
8000f3e0:	30 08       	mov	r8,0
8000f3e2:	8d 08       	st.w	r6[0x0],r8
8000f3e4:	fc 1c 7f f0 	movh	r12,0x7ff0
8000f3e8:	40 26       	lddsp	r6,sp[0x8]
8000f3ea:	0c 98       	mov	r8,r6
8000f3ec:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000f3f0:	18 38       	cp.w	r8,r12
8000f3f2:	c1 e1       	brne	8000f42e <_dtoa_r+0xba>
8000f3f4:	e0 68 27 0f 	mov	r8,9999
8000f3f8:	41 5b       	lddsp	r11,sp[0x54]
8000f3fa:	97 08       	st.w	r11[0x0],r8
8000f3fc:	40 3a       	lddsp	r10,sp[0xc]
8000f3fe:	58 0a       	cp.w	r10,0
8000f400:	c0 61       	brne	8000f40c <_dtoa_r+0x98>
8000f402:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
8000f406:	c0 31       	brne	8000f40c <_dtoa_r+0x98>
8000f408:	4a ec       	lddpc	r12,8000f4c0 <_dtoa_r+0x14c>
8000f40a:	c0 28       	rjmp	8000f40e <_dtoa_r+0x9a>
8000f40c:	4a ec       	lddpc	r12,8000f4c4 <_dtoa_r+0x150>
8000f40e:	41 29       	lddsp	r9,sp[0x48]
8000f410:	58 09       	cp.w	r9,0
8000f412:	e0 80 05 de 	breq	8000ffce <_dtoa_r+0xc5a>
8000f416:	f8 c8 ff fd 	sub	r8,r12,-3
8000f41a:	f8 c9 ff f8 	sub	r9,r12,-8
8000f41e:	11 8b       	ld.ub	r11,r8[0x0]
8000f420:	30 0a       	mov	r10,0
8000f422:	41 25       	lddsp	r5,sp[0x48]
8000f424:	f4 0b 18 00 	cp.b	r11,r10
8000f428:	f2 08 17 10 	movne	r8,r9
8000f42c:	c1 58       	rjmp	8000f456 <_dtoa_r+0xe2>
8000f42e:	fa ea 00 08 	ld.d	r10,sp[8]
8000f432:	30 08       	mov	r8,0
8000f434:	fa eb 00 3c 	st.d	sp[60],r10
8000f438:	30 09       	mov	r9,0
8000f43a:	f0 1f 00 24 	mcall	8000f4c8 <_dtoa_r+0x154>
8000f43e:	c0 f0       	breq	8000f45c <_dtoa_r+0xe8>
8000f440:	30 18       	mov	r8,1
8000f442:	41 5a       	lddsp	r10,sp[0x54]
8000f444:	95 08       	st.w	r10[0x0],r8
8000f446:	4a 2c       	lddpc	r12,8000f4cc <_dtoa_r+0x158>
8000f448:	41 29       	lddsp	r9,sp[0x48]
8000f44a:	f8 08 00 08 	add	r8,r12,r8
8000f44e:	58 09       	cp.w	r9,0
8000f450:	e0 80 05 bf 	breq	8000ffce <_dtoa_r+0xc5a>
8000f454:	12 95       	mov	r5,r9
8000f456:	8b 08       	st.w	r5[0x0],r8
8000f458:	e0 8f 05 bb 	bral	8000ffce <_dtoa_r+0xc5a>
8000f45c:	fa c8 ff 9c 	sub	r8,sp,-100
8000f460:	fa c9 ff a0 	sub	r9,sp,-96
8000f464:	fa ea 00 3c 	ld.d	r10,sp[60]
8000f468:	0e 9c       	mov	r12,r7
8000f46a:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000f46e:	f0 1f 00 19 	mcall	8000f4d0 <_dtoa_r+0x15c>
8000f472:	18 93       	mov	r3,r12
8000f474:	58 05       	cp.w	r5,0
8000f476:	c0 d0       	breq	8000f490 <_dtoa_r+0x11c>
8000f478:	fa ea 00 3c 	ld.d	r10,sp[60]
8000f47c:	30 04       	mov	r4,0
8000f47e:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000f482:	ea c5 03 ff 	sub	r5,r5,1023
8000f486:	10 9b       	mov	r11,r8
8000f488:	51 74       	stdsp	sp[0x5c],r4
8000f48a:	ea 1b 3f f0 	orh	r11,0x3ff0
8000f48e:	c3 28       	rjmp	8000f4f2 <_dtoa_r+0x17e>
8000f490:	41 88       	lddsp	r8,sp[0x60]
8000f492:	41 9c       	lddsp	r12,sp[0x64]
8000f494:	10 0c       	add	r12,r8
8000f496:	f8 c5 fb ce 	sub	r5,r12,-1074
8000f49a:	e0 45 00 20 	cp.w	r5,32
8000f49e:	e0 8a 00 1b 	brle	8000f4d4 <_dtoa_r+0x160>
8000f4a2:	f8 cc fb ee 	sub	r12,r12,-1042
8000f4a6:	40 3b       	lddsp	r11,sp[0xc]
8000f4a8:	ea 08 11 40 	rsub	r8,r5,64
8000f4ac:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000f4b0:	ec 08 09 46 	lsl	r6,r6,r8
8000f4b4:	0c 4c       	or	r12,r6
8000f4b6:	c1 48       	rjmp	8000f4de <_dtoa_r+0x16a>
8000f4b8:	80 01       	ld.sh	r1,r0[0x0]
8000f4ba:	08 c4       	st.b	r4++,r4
8000f4bc:	80 01       	ld.sh	r1,r0[0x0]
8000f4be:	0e a4       	st.w	r7++,r4
8000f4c0:	80 01       	ld.sh	r1,r0[0x0]
8000f4c2:	2b 2c       	sub	r12,-78
8000f4c4:	80 01       	ld.sh	r1,r0[0x0]
8000f4c6:	2b 38       	sub	r8,-77
8000f4c8:	80 01       	ld.sh	r1,r0[0x0]
8000f4ca:	1b 22       	ld.uh	r2,sp++
8000f4cc:	80 01       	ld.sh	r1,r0[0x0]
8000f4ce:	2a 08       	sub	r8,-96
8000f4d0:	80 01       	ld.sh	r1,r0[0x0]
8000f4d2:	0f 54       	ld.sh	r4,--r7
8000f4d4:	ea 0c 11 20 	rsub	r12,r5,32
8000f4d8:	40 3a       	lddsp	r10,sp[0xc]
8000f4da:	f4 0c 09 4c 	lsl	r12,r10,r12
8000f4de:	f0 1f 00 6b 	mcall	8000f688 <_dtoa_r+0x314>
8000f4e2:	fc 18 fe 10 	movh	r8,0xfe10
8000f4e6:	30 19       	mov	r9,1
8000f4e8:	ea c5 04 33 	sub	r5,r5,1075
8000f4ec:	f0 0b 00 0b 	add	r11,r8,r11
8000f4f0:	51 79       	stdsp	sp[0x5c],r9
8000f4f2:	30 08       	mov	r8,0
8000f4f4:	fc 19 3f f8 	movh	r9,0x3ff8
8000f4f8:	f0 1f 00 65 	mcall	8000f68c <_dtoa_r+0x318>
8000f4fc:	e0 68 43 61 	mov	r8,17249
8000f500:	ea 18 63 6f 	orh	r8,0x636f
8000f504:	e0 69 87 a7 	mov	r9,34727
8000f508:	ea 19 3f d2 	orh	r9,0x3fd2
8000f50c:	f0 1f 00 61 	mcall	8000f690 <_dtoa_r+0x31c>
8000f510:	e0 68 c8 b3 	mov	r8,51379
8000f514:	ea 18 8b 60 	orh	r8,0x8b60
8000f518:	e0 69 8a 28 	mov	r9,35368
8000f51c:	ea 19 3f c6 	orh	r9,0x3fc6
8000f520:	f0 1f 00 5d 	mcall	8000f694 <_dtoa_r+0x320>
8000f524:	0a 9c       	mov	r12,r5
8000f526:	14 90       	mov	r0,r10
8000f528:	16 91       	mov	r1,r11
8000f52a:	f0 1f 00 5c 	mcall	8000f698 <_dtoa_r+0x324>
8000f52e:	e0 68 79 fb 	mov	r8,31227
8000f532:	ea 18 50 9f 	orh	r8,0x509f
8000f536:	e0 69 44 13 	mov	r9,17427
8000f53a:	ea 19 3f d3 	orh	r9,0x3fd3
8000f53e:	f0 1f 00 55 	mcall	8000f690 <_dtoa_r+0x31c>
8000f542:	14 98       	mov	r8,r10
8000f544:	16 99       	mov	r9,r11
8000f546:	00 9a       	mov	r10,r0
8000f548:	02 9b       	mov	r11,r1
8000f54a:	f0 1f 00 53 	mcall	8000f694 <_dtoa_r+0x320>
8000f54e:	14 90       	mov	r0,r10
8000f550:	16 91       	mov	r1,r11
8000f552:	f0 1f 00 53 	mcall	8000f69c <_dtoa_r+0x328>
8000f556:	30 08       	mov	r8,0
8000f558:	18 96       	mov	r6,r12
8000f55a:	30 09       	mov	r9,0
8000f55c:	00 9a       	mov	r10,r0
8000f55e:	02 9b       	mov	r11,r1
8000f560:	f0 1f 00 50 	mcall	8000f6a0 <_dtoa_r+0x32c>
8000f564:	c0 c0       	breq	8000f57c <_dtoa_r+0x208>
8000f566:	0c 9c       	mov	r12,r6
8000f568:	f0 1f 00 4c 	mcall	8000f698 <_dtoa_r+0x324>
8000f56c:	14 98       	mov	r8,r10
8000f56e:	16 99       	mov	r9,r11
8000f570:	00 9a       	mov	r10,r0
8000f572:	02 9b       	mov	r11,r1
8000f574:	f0 1f 00 4c 	mcall	8000f6a4 <_dtoa_r+0x330>
8000f578:	f7 b6 00 01 	subeq	r6,1
8000f57c:	59 66       	cp.w	r6,22
8000f57e:	e0 88 00 05 	brls	8000f588 <_dtoa_r+0x214>
8000f582:	30 18       	mov	r8,1
8000f584:	51 48       	stdsp	sp[0x50],r8
8000f586:	c1 28       	rjmp	8000f5aa <_dtoa_r+0x236>
8000f588:	4c 88       	lddpc	r8,8000f6a8 <_dtoa_r+0x334>
8000f58a:	fa ea 00 3c 	ld.d	r10,sp[60]
8000f58e:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000f592:	f0 1f 00 44 	mcall	8000f6a0 <_dtoa_r+0x32c>
8000f596:	f9 b4 00 00 	moveq	r4,0
8000f59a:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000f59e:	f7 b6 01 01 	subne	r6,1
8000f5a2:	f9 bc 01 00 	movne	r12,0
8000f5a6:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000f5aa:	41 90       	lddsp	r0,sp[0x64]
8000f5ac:	20 10       	sub	r0,1
8000f5ae:	0a 10       	sub	r0,r5
8000f5b0:	c0 46       	brmi	8000f5b8 <_dtoa_r+0x244>
8000f5b2:	50 40       	stdsp	sp[0x10],r0
8000f5b4:	30 00       	mov	r0,0
8000f5b6:	c0 48       	rjmp	8000f5be <_dtoa_r+0x24a>
8000f5b8:	30 0b       	mov	r11,0
8000f5ba:	5c 30       	neg	r0
8000f5bc:	50 4b       	stdsp	sp[0x10],r11
8000f5be:	ec 02 11 00 	rsub	r2,r6,0
8000f5c2:	58 06       	cp.w	r6,0
8000f5c4:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000f5c8:	f5 d6 e4 0a 	addge	r10,r10,r6
8000f5cc:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000f5d0:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000f5d4:	f9 b2 04 00 	movge	r2,0
8000f5d8:	e1 d6 e5 10 	sublt	r0,r0,r6
8000f5dc:	f9 b9 05 00 	movlt	r9,0
8000f5e0:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000f5e4:	40 c8       	lddsp	r8,sp[0x30]
8000f5e6:	58 98       	cp.w	r8,9
8000f5e8:	e0 8b 00 20 	brhi	8000f628 <_dtoa_r+0x2b4>
8000f5ec:	58 58       	cp.w	r8,5
8000f5ee:	f9 b4 0a 01 	movle	r4,1
8000f5f2:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000f5f6:	f7 b5 09 04 	subgt	r5,4
8000f5fa:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000f5fe:	f9 b4 09 00 	movgt	r4,0
8000f602:	40 cc       	lddsp	r12,sp[0x30]
8000f604:	58 3c       	cp.w	r12,3
8000f606:	c2 d0       	breq	8000f660 <_dtoa_r+0x2ec>
8000f608:	e0 89 00 05 	brgt	8000f612 <_dtoa_r+0x29e>
8000f60c:	58 2c       	cp.w	r12,2
8000f60e:	c1 01       	brne	8000f62e <_dtoa_r+0x2ba>
8000f610:	c1 88       	rjmp	8000f640 <_dtoa_r+0x2cc>
8000f612:	40 cb       	lddsp	r11,sp[0x30]
8000f614:	58 4b       	cp.w	r11,4
8000f616:	c0 60       	breq	8000f622 <_dtoa_r+0x2ae>
8000f618:	58 5b       	cp.w	r11,5
8000f61a:	c0 a1       	brne	8000f62e <_dtoa_r+0x2ba>
8000f61c:	30 1a       	mov	r10,1
8000f61e:	50 da       	stdsp	sp[0x34],r10
8000f620:	c2 28       	rjmp	8000f664 <_dtoa_r+0x2f0>
8000f622:	30 19       	mov	r9,1
8000f624:	50 d9       	stdsp	sp[0x34],r9
8000f626:	c0 f8       	rjmp	8000f644 <_dtoa_r+0x2d0>
8000f628:	30 08       	mov	r8,0
8000f62a:	30 14       	mov	r4,1
8000f62c:	50 c8       	stdsp	sp[0x30],r8
8000f62e:	3f f5       	mov	r5,-1
8000f630:	30 1c       	mov	r12,1
8000f632:	30 0b       	mov	r11,0
8000f634:	50 95       	stdsp	sp[0x24],r5
8000f636:	50 dc       	stdsp	sp[0x34],r12
8000f638:	0a 91       	mov	r1,r5
8000f63a:	31 28       	mov	r8,18
8000f63c:	50 eb       	stdsp	sp[0x38],r11
8000f63e:	c2 08       	rjmp	8000f67e <_dtoa_r+0x30a>
8000f640:	30 0a       	mov	r10,0
8000f642:	50 da       	stdsp	sp[0x34],r10
8000f644:	40 e9       	lddsp	r9,sp[0x38]
8000f646:	58 09       	cp.w	r9,0
8000f648:	e0 89 00 07 	brgt	8000f656 <_dtoa_r+0x2e2>
8000f64c:	30 18       	mov	r8,1
8000f64e:	50 98       	stdsp	sp[0x24],r8
8000f650:	10 91       	mov	r1,r8
8000f652:	50 e8       	stdsp	sp[0x38],r8
8000f654:	c1 58       	rjmp	8000f67e <_dtoa_r+0x30a>
8000f656:	40 e5       	lddsp	r5,sp[0x38]
8000f658:	50 95       	stdsp	sp[0x24],r5
8000f65a:	0a 91       	mov	r1,r5
8000f65c:	0a 98       	mov	r8,r5
8000f65e:	c1 08       	rjmp	8000f67e <_dtoa_r+0x30a>
8000f660:	30 0c       	mov	r12,0
8000f662:	50 dc       	stdsp	sp[0x34],r12
8000f664:	40 eb       	lddsp	r11,sp[0x38]
8000f666:	ec 0b 00 0b 	add	r11,r6,r11
8000f66a:	50 9b       	stdsp	sp[0x24],r11
8000f66c:	16 98       	mov	r8,r11
8000f66e:	2f f8       	sub	r8,-1
8000f670:	58 08       	cp.w	r8,0
8000f672:	e0 89 00 05 	brgt	8000f67c <_dtoa_r+0x308>
8000f676:	10 91       	mov	r1,r8
8000f678:	30 18       	mov	r8,1
8000f67a:	c0 28       	rjmp	8000f67e <_dtoa_r+0x30a>
8000f67c:	10 91       	mov	r1,r8
8000f67e:	30 09       	mov	r9,0
8000f680:	6e 9a       	ld.w	r10,r7[0x24]
8000f682:	95 19       	st.w	r10[0x4],r9
8000f684:	30 49       	mov	r9,4
8000f686:	c1 78       	rjmp	8000f6b4 <_dtoa_r+0x340>
8000f688:	80 00       	ld.sh	r0,r0[0x0]
8000f68a:	c7 84       	brge	8000f77a <_dtoa_r+0x406>
8000f68c:	80 00       	ld.sh	r0,r0[0x0]
8000f68e:	c4 d8       	rjmp	8000f728 <_dtoa_r+0x3b4>
8000f690:	80 00       	ld.sh	r0,r0[0x0]
8000f692:	c3 00       	breq	8000f6f2 <_dtoa_r+0x37e>
8000f694:	80 00       	ld.sh	r0,r0[0x0]
8000f696:	c6 74       	brge	8000f764 <_dtoa_r+0x3f0>
8000f698:	80 00       	ld.sh	r0,r0[0x0]
8000f69a:	c7 8c       	rcall	8000f78a <_dtoa_r+0x416>
8000f69c:	80 01       	ld.sh	r1,r0[0x0]
8000f69e:	1a fc       	st.b	--sp,r12
8000f6a0:	80 01       	ld.sh	r1,r0[0x0]
8000f6a2:	1b b0       	ld.ub	r0,sp[0x3]
8000f6a4:	80 01       	ld.sh	r1,r0[0x0]
8000f6a6:	1b 22       	ld.uh	r2,sp++
8000f6a8:	80 01       	ld.sh	r1,r0[0x0]
8000f6aa:	2b f0       	sub	r0,-65
8000f6ac:	6a 1a       	ld.w	r10,r5[0x4]
8000f6ae:	a1 79       	lsl	r9,0x1
8000f6b0:	2f fa       	sub	r10,-1
8000f6b2:	8b 1a       	st.w	r5[0x4],r10
8000f6b4:	6e 95       	ld.w	r5,r7[0x24]
8000f6b6:	f2 ca ff ec 	sub	r10,r9,-20
8000f6ba:	10 3a       	cp.w	r10,r8
8000f6bc:	fe 98 ff f8 	brls	8000f6ac <_dtoa_r+0x338>
8000f6c0:	6a 1b       	ld.w	r11,r5[0x4]
8000f6c2:	0e 9c       	mov	r12,r7
8000f6c4:	f0 1f 00 53 	mcall	8000f810 <_dtoa_r+0x49c>
8000f6c8:	58 e1       	cp.w	r1,14
8000f6ca:	5f 88       	srls	r8
8000f6cc:	8b 0c       	st.w	r5[0x0],r12
8000f6ce:	f1 e4 00 04 	and	r4,r8,r4
8000f6d2:	6e 98       	ld.w	r8,r7[0x24]
8000f6d4:	70 08       	ld.w	r8,r8[0x0]
8000f6d6:	50 88       	stdsp	sp[0x20],r8
8000f6d8:	e0 80 01 98 	breq	8000fa08 <_dtoa_r+0x694>
8000f6dc:	58 06       	cp.w	r6,0
8000f6de:	e0 8a 00 40 	brle	8000f75e <_dtoa_r+0x3ea>
8000f6e2:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000f6e6:	4c c8       	lddpc	r8,8000f814 <_dtoa_r+0x4a0>
8000f6e8:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000f6ec:	fa e5 00 18 	st.d	sp[24],r4
8000f6f0:	ec 04 14 04 	asr	r4,r6,0x4
8000f6f4:	ed b4 00 04 	bld	r4,0x4
8000f6f8:	c0 30       	breq	8000f6fe <_dtoa_r+0x38a>
8000f6fa:	30 25       	mov	r5,2
8000f6fc:	c0 f8       	rjmp	8000f71a <_dtoa_r+0x3a6>
8000f6fe:	4c 78       	lddpc	r8,8000f818 <_dtoa_r+0x4a4>
8000f700:	f0 e8 00 20 	ld.d	r8,r8[32]
8000f704:	fa ea 00 3c 	ld.d	r10,sp[60]
8000f708:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000f70c:	f0 1f 00 44 	mcall	8000f81c <_dtoa_r+0x4a8>
8000f710:	30 35       	mov	r5,3
8000f712:	14 98       	mov	r8,r10
8000f714:	16 99       	mov	r9,r11
8000f716:	fa e9 00 08 	st.d	sp[8],r8
8000f71a:	4c 0c       	lddpc	r12,8000f818 <_dtoa_r+0x4a4>
8000f71c:	50 a3       	stdsp	sp[0x28],r3
8000f71e:	0c 93       	mov	r3,r6
8000f720:	18 96       	mov	r6,r12
8000f722:	c0 f8       	rjmp	8000f740 <_dtoa_r+0x3cc>
8000f724:	fa ea 00 18 	ld.d	r10,sp[24]
8000f728:	ed b4 00 00 	bld	r4,0x0
8000f72c:	c0 81       	brne	8000f73c <_dtoa_r+0x3c8>
8000f72e:	ec e8 00 00 	ld.d	r8,r6[0]
8000f732:	2f f5       	sub	r5,-1
8000f734:	f0 1f 00 3b 	mcall	8000f820 <_dtoa_r+0x4ac>
8000f738:	fa eb 00 18 	st.d	sp[24],r10
8000f73c:	a1 54       	asr	r4,0x1
8000f73e:	2f 86       	sub	r6,-8
8000f740:	58 04       	cp.w	r4,0
8000f742:	cf 11       	brne	8000f724 <_dtoa_r+0x3b0>
8000f744:	fa e8 00 18 	ld.d	r8,sp[24]
8000f748:	fa ea 00 08 	ld.d	r10,sp[8]
8000f74c:	06 96       	mov	r6,r3
8000f74e:	f0 1f 00 34 	mcall	8000f81c <_dtoa_r+0x4a8>
8000f752:	40 a3       	lddsp	r3,sp[0x28]
8000f754:	14 98       	mov	r8,r10
8000f756:	16 99       	mov	r9,r11
8000f758:	fa e9 00 08 	st.d	sp[8],r8
8000f75c:	c2 d8       	rjmp	8000f7b6 <_dtoa_r+0x442>
8000f75e:	ec 08 11 00 	rsub	r8,r6,0
8000f762:	c0 31       	brne	8000f768 <_dtoa_r+0x3f4>
8000f764:	30 25       	mov	r5,2
8000f766:	c2 88       	rjmp	8000f7b6 <_dtoa_r+0x442>
8000f768:	4a cc       	lddpc	r12,8000f818 <_dtoa_r+0x4a4>
8000f76a:	f0 04 14 04 	asr	r4,r8,0x4
8000f76e:	50 1c       	stdsp	sp[0x4],r12
8000f770:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000f774:	4a 89       	lddpc	r9,8000f814 <_dtoa_r+0x4a0>
8000f776:	fa ea 00 3c 	ld.d	r10,sp[60]
8000f77a:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000f77e:	f0 1f 00 29 	mcall	8000f820 <_dtoa_r+0x4ac>
8000f782:	40 1c       	lddsp	r12,sp[0x4]
8000f784:	50 63       	stdsp	sp[0x18],r3
8000f786:	30 25       	mov	r5,2
8000f788:	0c 93       	mov	r3,r6
8000f78a:	fa eb 00 08 	st.d	sp[8],r10
8000f78e:	18 96       	mov	r6,r12
8000f790:	c0 f8       	rjmp	8000f7ae <_dtoa_r+0x43a>
8000f792:	fa ea 00 08 	ld.d	r10,sp[8]
8000f796:	ed b4 00 00 	bld	r4,0x0
8000f79a:	c0 81       	brne	8000f7aa <_dtoa_r+0x436>
8000f79c:	ec e8 00 00 	ld.d	r8,r6[0]
8000f7a0:	2f f5       	sub	r5,-1
8000f7a2:	f0 1f 00 20 	mcall	8000f820 <_dtoa_r+0x4ac>
8000f7a6:	fa eb 00 08 	st.d	sp[8],r10
8000f7aa:	a1 54       	asr	r4,0x1
8000f7ac:	2f 86       	sub	r6,-8
8000f7ae:	58 04       	cp.w	r4,0
8000f7b0:	cf 11       	brne	8000f792 <_dtoa_r+0x41e>
8000f7b2:	06 96       	mov	r6,r3
8000f7b4:	40 63       	lddsp	r3,sp[0x18]
8000f7b6:	41 4a       	lddsp	r10,sp[0x50]
8000f7b8:	58 0a       	cp.w	r10,0
8000f7ba:	c3 70       	breq	8000f828 <_dtoa_r+0x4b4>
8000f7bc:	fa e8 00 08 	ld.d	r8,sp[8]
8000f7c0:	58 01       	cp.w	r1,0
8000f7c2:	5f 94       	srgt	r4
8000f7c4:	fa e9 00 18 	st.d	sp[24],r8
8000f7c8:	30 08       	mov	r8,0
8000f7ca:	fc 19 3f f0 	movh	r9,0x3ff0
8000f7ce:	fa ea 00 18 	ld.d	r10,sp[24]
8000f7d2:	f0 1f 00 15 	mcall	8000f824 <_dtoa_r+0x4b0>
8000f7d6:	f9 bc 00 00 	moveq	r12,0
8000f7da:	f9 bc 01 01 	movne	r12,1
8000f7de:	e9 ec 00 0c 	and	r12,r4,r12
8000f7e2:	c2 30       	breq	8000f828 <_dtoa_r+0x4b4>
8000f7e4:	40 98       	lddsp	r8,sp[0x24]
8000f7e6:	58 08       	cp.w	r8,0
8000f7e8:	e0 8a 01 0c 	brle	8000fa00 <_dtoa_r+0x68c>
8000f7ec:	30 08       	mov	r8,0
8000f7ee:	fc 19 40 24 	movh	r9,0x4024
8000f7f2:	ec c4 00 01 	sub	r4,r6,1
8000f7f6:	fa ea 00 18 	ld.d	r10,sp[24]
8000f7fa:	2f f5       	sub	r5,-1
8000f7fc:	50 64       	stdsp	sp[0x18],r4
8000f7fe:	f0 1f 00 09 	mcall	8000f820 <_dtoa_r+0x4ac>
8000f802:	40 94       	lddsp	r4,sp[0x24]
8000f804:	14 98       	mov	r8,r10
8000f806:	16 99       	mov	r9,r11
8000f808:	fa e9 00 08 	st.d	sp[8],r8
8000f80c:	c1 08       	rjmp	8000f82c <_dtoa_r+0x4b8>
8000f80e:	00 00       	add	r0,r0
8000f810:	80 01       	ld.sh	r1,r0[0x0]
8000f812:	0e dc       	st.w	--r7,r12
8000f814:	80 01       	ld.sh	r1,r0[0x0]
8000f816:	2b f0       	sub	r0,-65
8000f818:	80 01       	ld.sh	r1,r0[0x0]
8000f81a:	2c b8       	sub	r8,-53
8000f81c:	80 01       	ld.sh	r1,r0[0x0]
8000f81e:	1c 18       	sub	r8,lr
8000f820:	80 00       	ld.sh	r0,r0[0x0]
8000f822:	c3 00       	breq	8000f882 <_dtoa_r+0x50e>
8000f824:	80 01       	ld.sh	r1,r0[0x0]
8000f826:	1b b0       	ld.ub	r0,sp[0x3]
8000f828:	50 66       	stdsp	sp[0x18],r6
8000f82a:	02 94       	mov	r4,r1
8000f82c:	0a 9c       	mov	r12,r5
8000f82e:	f0 1f 00 69 	mcall	8000f9d0 <_dtoa_r+0x65c>
8000f832:	fa e8 00 08 	ld.d	r8,sp[8]
8000f836:	f0 1f 00 68 	mcall	8000f9d4 <_dtoa_r+0x660>
8000f83a:	30 08       	mov	r8,0
8000f83c:	fc 19 40 1c 	movh	r9,0x401c
8000f840:	f0 1f 00 66 	mcall	8000f9d8 <_dtoa_r+0x664>
8000f844:	14 98       	mov	r8,r10
8000f846:	16 99       	mov	r9,r11
8000f848:	fa e9 00 28 	st.d	sp[40],r8
8000f84c:	fc 18 fc c0 	movh	r8,0xfcc0
8000f850:	40 a5       	lddsp	r5,sp[0x28]
8000f852:	10 05       	add	r5,r8
8000f854:	50 a5       	stdsp	sp[0x28],r5
8000f856:	58 04       	cp.w	r4,0
8000f858:	c2 11       	brne	8000f89a <_dtoa_r+0x526>
8000f85a:	fa ea 00 08 	ld.d	r10,sp[8]
8000f85e:	30 08       	mov	r8,0
8000f860:	fc 19 40 14 	movh	r9,0x4014
8000f864:	f0 1f 00 5e 	mcall	8000f9dc <_dtoa_r+0x668>
8000f868:	40 bc       	lddsp	r12,sp[0x2c]
8000f86a:	fa eb 00 08 	st.d	sp[8],r10
8000f86e:	14 98       	mov	r8,r10
8000f870:	16 99       	mov	r9,r11
8000f872:	18 9a       	mov	r10,r12
8000f874:	0a 9b       	mov	r11,r5
8000f876:	f0 1f 00 5b 	mcall	8000f9e0 <_dtoa_r+0x66c>
8000f87a:	e0 81 02 74 	brne	8000fd62 <_dtoa_r+0x9ee>
8000f87e:	0a 98       	mov	r8,r5
8000f880:	40 b9       	lddsp	r9,sp[0x2c]
8000f882:	ee 18 80 00 	eorh	r8,0x8000
8000f886:	fa ea 00 08 	ld.d	r10,sp[8]
8000f88a:	10 95       	mov	r5,r8
8000f88c:	12 98       	mov	r8,r9
8000f88e:	0a 99       	mov	r9,r5
8000f890:	f0 1f 00 54 	mcall	8000f9e0 <_dtoa_r+0x66c>
8000f894:	e0 81 02 5e 	brne	8000fd50 <_dtoa_r+0x9dc>
8000f898:	cb 48       	rjmp	8000fa00 <_dtoa_r+0x68c>
8000f89a:	4d 39       	lddpc	r9,8000f9e4 <_dtoa_r+0x670>
8000f89c:	e8 c8 00 01 	sub	r8,r4,1
8000f8a0:	40 d5       	lddsp	r5,sp[0x34]
8000f8a2:	58 05       	cp.w	r5,0
8000f8a4:	c4 f0       	breq	8000f942 <_dtoa_r+0x5ce>
8000f8a6:	30 0c       	mov	r12,0
8000f8a8:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000f8ac:	51 3c       	stdsp	sp[0x4c],r12
8000f8ae:	30 0a       	mov	r10,0
8000f8b0:	fc 1b 3f e0 	movh	r11,0x3fe0
8000f8b4:	f0 1f 00 4d 	mcall	8000f9e8 <_dtoa_r+0x674>
8000f8b8:	fa e8 00 28 	ld.d	r8,sp[40]
8000f8bc:	40 85       	lddsp	r5,sp[0x20]
8000f8be:	f0 1f 00 48 	mcall	8000f9dc <_dtoa_r+0x668>
8000f8c2:	fa eb 00 28 	st.d	sp[40],r10
8000f8c6:	fa ea 00 08 	ld.d	r10,sp[8]
8000f8ca:	f0 1f 00 49 	mcall	8000f9ec <_dtoa_r+0x678>
8000f8ce:	51 6c       	stdsp	sp[0x58],r12
8000f8d0:	f0 1f 00 40 	mcall	8000f9d0 <_dtoa_r+0x65c>
8000f8d4:	14 98       	mov	r8,r10
8000f8d6:	16 99       	mov	r9,r11
8000f8d8:	fa ea 00 08 	ld.d	r10,sp[8]
8000f8dc:	f0 1f 00 40 	mcall	8000f9dc <_dtoa_r+0x668>
8000f8e0:	fa eb 00 08 	st.d	sp[8],r10
8000f8e4:	41 68       	lddsp	r8,sp[0x58]
8000f8e6:	2d 08       	sub	r8,-48
8000f8e8:	0a c8       	st.b	r5++,r8
8000f8ea:	41 39       	lddsp	r9,sp[0x4c]
8000f8ec:	2f f9       	sub	r9,-1
8000f8ee:	51 39       	stdsp	sp[0x4c],r9
8000f8f0:	fa e8 00 28 	ld.d	r8,sp[40]
8000f8f4:	f0 1f 00 3b 	mcall	8000f9e0 <_dtoa_r+0x66c>
8000f8f8:	e0 81 03 5a 	brne	8000ffac <_dtoa_r+0xc38>
8000f8fc:	fa e8 00 08 	ld.d	r8,sp[8]
8000f900:	30 0a       	mov	r10,0
8000f902:	fc 1b 3f f0 	movh	r11,0x3ff0
8000f906:	f0 1f 00 36 	mcall	8000f9dc <_dtoa_r+0x668>
8000f90a:	fa e8 00 28 	ld.d	r8,sp[40]
8000f90e:	f0 1f 00 35 	mcall	8000f9e0 <_dtoa_r+0x66c>
8000f912:	fa ea 00 28 	ld.d	r10,sp[40]
8000f916:	30 08       	mov	r8,0
8000f918:	fc 19 40 24 	movh	r9,0x4024
8000f91c:	e0 81 00 e8 	brne	8000faec <_dtoa_r+0x778>
8000f920:	41 3c       	lddsp	r12,sp[0x4c]
8000f922:	08 3c       	cp.w	r12,r4
8000f924:	c6 e4       	brge	8000fa00 <_dtoa_r+0x68c>
8000f926:	f0 1f 00 2c 	mcall	8000f9d4 <_dtoa_r+0x660>
8000f92a:	30 08       	mov	r8,0
8000f92c:	fa eb 00 28 	st.d	sp[40],r10
8000f930:	fc 19 40 24 	movh	r9,0x4024
8000f934:	fa ea 00 08 	ld.d	r10,sp[8]
8000f938:	f0 1f 00 27 	mcall	8000f9d4 <_dtoa_r+0x660>
8000f93c:	fa eb 00 08 	st.d	sp[8],r10
8000f940:	cc 3b       	rjmp	8000f8c6 <_dtoa_r+0x552>
8000f942:	40 85       	lddsp	r5,sp[0x20]
8000f944:	08 05       	add	r5,r4
8000f946:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000f94a:	51 35       	stdsp	sp[0x4c],r5
8000f94c:	fa e8 00 28 	ld.d	r8,sp[40]
8000f950:	40 85       	lddsp	r5,sp[0x20]
8000f952:	f0 1f 00 21 	mcall	8000f9d4 <_dtoa_r+0x660>
8000f956:	fa eb 00 28 	st.d	sp[40],r10
8000f95a:	fa ea 00 08 	ld.d	r10,sp[8]
8000f95e:	f0 1f 00 24 	mcall	8000f9ec <_dtoa_r+0x678>
8000f962:	51 6c       	stdsp	sp[0x58],r12
8000f964:	f0 1f 00 1b 	mcall	8000f9d0 <_dtoa_r+0x65c>
8000f968:	14 98       	mov	r8,r10
8000f96a:	16 99       	mov	r9,r11
8000f96c:	fa ea 00 08 	ld.d	r10,sp[8]
8000f970:	f0 1f 00 1b 	mcall	8000f9dc <_dtoa_r+0x668>
8000f974:	fa eb 00 08 	st.d	sp[8],r10
8000f978:	41 68       	lddsp	r8,sp[0x58]
8000f97a:	2d 08       	sub	r8,-48
8000f97c:	0a c8       	st.b	r5++,r8
8000f97e:	41 3c       	lddsp	r12,sp[0x4c]
8000f980:	18 35       	cp.w	r5,r12
8000f982:	c3 71       	brne	8000f9f0 <_dtoa_r+0x67c>
8000f984:	30 08       	mov	r8,0
8000f986:	fc 19 3f e0 	movh	r9,0x3fe0
8000f98a:	fa ea 00 28 	ld.d	r10,sp[40]
8000f98e:	f0 1f 00 13 	mcall	8000f9d8 <_dtoa_r+0x664>
8000f992:	40 85       	lddsp	r5,sp[0x20]
8000f994:	fa e8 00 08 	ld.d	r8,sp[8]
8000f998:	08 05       	add	r5,r4
8000f99a:	f0 1f 00 12 	mcall	8000f9e0 <_dtoa_r+0x66c>
8000f99e:	e0 81 00 a7 	brne	8000faec <_dtoa_r+0x778>
8000f9a2:	fa e8 00 28 	ld.d	r8,sp[40]
8000f9a6:	30 0a       	mov	r10,0
8000f9a8:	fc 1b 3f e0 	movh	r11,0x3fe0
8000f9ac:	f0 1f 00 0c 	mcall	8000f9dc <_dtoa_r+0x668>
8000f9b0:	14 98       	mov	r8,r10
8000f9b2:	16 99       	mov	r9,r11
8000f9b4:	fa ea 00 08 	ld.d	r10,sp[8]
8000f9b8:	f0 1f 00 0a 	mcall	8000f9e0 <_dtoa_r+0x66c>
8000f9bc:	c2 20       	breq	8000fa00 <_dtoa_r+0x68c>
8000f9be:	33 09       	mov	r9,48
8000f9c0:	0a 98       	mov	r8,r5
8000f9c2:	11 7a       	ld.ub	r10,--r8
8000f9c4:	f2 0a 18 00 	cp.b	r10,r9
8000f9c8:	e0 81 02 f2 	brne	8000ffac <_dtoa_r+0xc38>
8000f9cc:	10 95       	mov	r5,r8
8000f9ce:	cf 9b       	rjmp	8000f9c0 <_dtoa_r+0x64c>
8000f9d0:	80 00       	ld.sh	r0,r0[0x0]
8000f9d2:	c7 8c       	rcall	8000fac2 <_dtoa_r+0x74e>
8000f9d4:	80 00       	ld.sh	r0,r0[0x0]
8000f9d6:	c3 00       	breq	8000fa36 <_dtoa_r+0x6c2>
8000f9d8:	80 00       	ld.sh	r0,r0[0x0]
8000f9da:	c6 74       	brge	8000faa8 <_dtoa_r+0x734>
8000f9dc:	80 00       	ld.sh	r0,r0[0x0]
8000f9de:	c4 d8       	rjmp	8000fa78 <_dtoa_r+0x704>
8000f9e0:	80 01       	ld.sh	r1,r0[0x0]
8000f9e2:	1b b0       	ld.ub	r0,sp[0x3]
8000f9e4:	80 01       	ld.sh	r1,r0[0x0]
8000f9e6:	2b f0       	sub	r0,-65
8000f9e8:	80 01       	ld.sh	r1,r0[0x0]
8000f9ea:	1c 18       	sub	r8,lr
8000f9ec:	80 01       	ld.sh	r1,r0[0x0]
8000f9ee:	1a fc       	st.b	--sp,r12
8000f9f0:	30 08       	mov	r8,0
8000f9f2:	fc 19 40 24 	movh	r9,0x4024
8000f9f6:	f0 1f 00 56 	mcall	8000fb4c <_dtoa_r+0x7d8>
8000f9fa:	fa eb 00 08 	st.d	sp[8],r10
8000f9fe:	ca eb       	rjmp	8000f95a <_dtoa_r+0x5e6>
8000fa00:	fa ea 00 3c 	ld.d	r10,sp[60]
8000fa04:	fa eb 00 08 	st.d	sp[8],r10
8000fa08:	58 e6       	cp.w	r6,14
8000fa0a:	5f ab       	srle	r11
8000fa0c:	41 8a       	lddsp	r10,sp[0x60]
8000fa0e:	30 08       	mov	r8,0
8000fa10:	f4 09 11 ff 	rsub	r9,r10,-1
8000fa14:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000fa18:	f0 09 18 00 	cp.b	r9,r8
8000fa1c:	e0 80 00 81 	breq	8000fb1e <_dtoa_r+0x7aa>
8000fa20:	40 ea       	lddsp	r10,sp[0x38]
8000fa22:	58 01       	cp.w	r1,0
8000fa24:	5f a9       	srle	r9
8000fa26:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000fa2a:	4c aa       	lddpc	r10,8000fb50 <_dtoa_r+0x7dc>
8000fa2c:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000fa30:	fa e5 00 10 	st.d	sp[16],r4
8000fa34:	f0 09 18 00 	cp.b	r9,r8
8000fa38:	c1 40       	breq	8000fa60 <_dtoa_r+0x6ec>
8000fa3a:	58 01       	cp.w	r1,0
8000fa3c:	e0 81 01 8a 	brne	8000fd50 <_dtoa_r+0x9dc>
8000fa40:	30 08       	mov	r8,0
8000fa42:	fc 19 40 14 	movh	r9,0x4014
8000fa46:	08 9a       	mov	r10,r4
8000fa48:	0a 9b       	mov	r11,r5
8000fa4a:	f0 1f 00 41 	mcall	8000fb4c <_dtoa_r+0x7d8>
8000fa4e:	fa e8 00 08 	ld.d	r8,sp[8]
8000fa52:	f0 1f 00 41 	mcall	8000fb54 <_dtoa_r+0x7e0>
8000fa56:	e0 81 01 7d 	brne	8000fd50 <_dtoa_r+0x9dc>
8000fa5a:	02 92       	mov	r2,r1
8000fa5c:	e0 8f 01 85 	bral	8000fd66 <_dtoa_r+0x9f2>
8000fa60:	40 85       	lddsp	r5,sp[0x20]
8000fa62:	30 14       	mov	r4,1
8000fa64:	fa e8 00 10 	ld.d	r8,sp[16]
8000fa68:	fa ea 00 08 	ld.d	r10,sp[8]
8000fa6c:	f0 1f 00 3b 	mcall	8000fb58 <_dtoa_r+0x7e4>
8000fa70:	f0 1f 00 3b 	mcall	8000fb5c <_dtoa_r+0x7e8>
8000fa74:	18 92       	mov	r2,r12
8000fa76:	f0 1f 00 3b 	mcall	8000fb60 <_dtoa_r+0x7ec>
8000fa7a:	fa e8 00 10 	ld.d	r8,sp[16]
8000fa7e:	f0 1f 00 34 	mcall	8000fb4c <_dtoa_r+0x7d8>
8000fa82:	14 98       	mov	r8,r10
8000fa84:	16 99       	mov	r9,r11
8000fa86:	fa ea 00 08 	ld.d	r10,sp[8]
8000fa8a:	f0 1f 00 37 	mcall	8000fb64 <_dtoa_r+0x7f0>
8000fa8e:	fa eb 00 08 	st.d	sp[8],r10
8000fa92:	e4 c8 ff d0 	sub	r8,r2,-48
8000fa96:	0a c8       	st.b	r5++,r8
8000fa98:	fc 19 40 24 	movh	r9,0x4024
8000fa9c:	30 08       	mov	r8,0
8000fa9e:	02 34       	cp.w	r4,r1
8000faa0:	c3 31       	brne	8000fb06 <_dtoa_r+0x792>
8000faa2:	fa e8 00 08 	ld.d	r8,sp[8]
8000faa6:	f0 1f 00 31 	mcall	8000fb68 <_dtoa_r+0x7f4>
8000faaa:	16 91       	mov	r1,r11
8000faac:	14 90       	mov	r0,r10
8000faae:	14 98       	mov	r8,r10
8000fab0:	02 99       	mov	r9,r1
8000fab2:	fa ea 00 10 	ld.d	r10,sp[16]
8000fab6:	f0 1f 00 2e 	mcall	8000fb6c <_dtoa_r+0x7f8>
8000faba:	c1 a1       	brne	8000faee <_dtoa_r+0x77a>
8000fabc:	fa e8 00 10 	ld.d	r8,sp[16]
8000fac0:	00 9a       	mov	r10,r0
8000fac2:	02 9b       	mov	r11,r1
8000fac4:	f0 1f 00 2b 	mcall	8000fb70 <_dtoa_r+0x7fc>
8000fac8:	e0 80 02 71 	breq	8000ffaa <_dtoa_r+0xc36>
8000facc:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000fad0:	c0 f1       	brne	8000faee <_dtoa_r+0x77a>
8000fad2:	e0 8f 02 6c 	bral	8000ffaa <_dtoa_r+0xc36>
8000fad6:	40 8a       	lddsp	r10,sp[0x20]
8000fad8:	14 38       	cp.w	r8,r10
8000fada:	c0 30       	breq	8000fae0 <_dtoa_r+0x76c>
8000fadc:	10 95       	mov	r5,r8
8000fade:	c0 98       	rjmp	8000faf0 <_dtoa_r+0x77c>
8000fae0:	33 08       	mov	r8,48
8000fae2:	40 89       	lddsp	r9,sp[0x20]
8000fae4:	2f f6       	sub	r6,-1
8000fae6:	b2 88       	st.b	r9[0x0],r8
8000fae8:	40 88       	lddsp	r8,sp[0x20]
8000faea:	c0 88       	rjmp	8000fafa <_dtoa_r+0x786>
8000faec:	40 66       	lddsp	r6,sp[0x18]
8000faee:	33 99       	mov	r9,57
8000faf0:	0a 98       	mov	r8,r5
8000faf2:	11 7a       	ld.ub	r10,--r8
8000faf4:	f2 0a 18 00 	cp.b	r10,r9
8000faf8:	ce f0       	breq	8000fad6 <_dtoa_r+0x762>
8000fafa:	50 66       	stdsp	sp[0x18],r6
8000fafc:	11 89       	ld.ub	r9,r8[0x0]
8000fafe:	2f f9       	sub	r9,-1
8000fb00:	b0 89       	st.b	r8[0x0],r9
8000fb02:	e0 8f 02 55 	bral	8000ffac <_dtoa_r+0xc38>
8000fb06:	f0 1f 00 12 	mcall	8000fb4c <_dtoa_r+0x7d8>
8000fb0a:	2f f4       	sub	r4,-1
8000fb0c:	fa eb 00 08 	st.d	sp[8],r10
8000fb10:	30 08       	mov	r8,0
8000fb12:	30 09       	mov	r9,0
8000fb14:	f0 1f 00 17 	mcall	8000fb70 <_dtoa_r+0x7fc>
8000fb18:	ca 60       	breq	8000fa64 <_dtoa_r+0x6f0>
8000fb1a:	e0 8f 02 48 	bral	8000ffaa <_dtoa_r+0xc36>
8000fb1e:	40 d8       	lddsp	r8,sp[0x34]
8000fb20:	58 08       	cp.w	r8,0
8000fb22:	c0 51       	brne	8000fb2c <_dtoa_r+0x7b8>
8000fb24:	04 98       	mov	r8,r2
8000fb26:	00 95       	mov	r5,r0
8000fb28:	40 d4       	lddsp	r4,sp[0x34]
8000fb2a:	c4 a8       	rjmp	8000fbbe <_dtoa_r+0x84a>
8000fb2c:	40 c5       	lddsp	r5,sp[0x30]
8000fb2e:	58 15       	cp.w	r5,1
8000fb30:	e0 89 00 22 	brgt	8000fb74 <_dtoa_r+0x800>
8000fb34:	41 74       	lddsp	r4,sp[0x5c]
8000fb36:	58 04       	cp.w	r4,0
8000fb38:	c0 40       	breq	8000fb40 <_dtoa_r+0x7cc>
8000fb3a:	f4 c9 fb cd 	sub	r9,r10,-1075
8000fb3e:	c0 48       	rjmp	8000fb46 <_dtoa_r+0x7d2>
8000fb40:	41 99       	lddsp	r9,sp[0x64]
8000fb42:	f2 09 11 36 	rsub	r9,r9,54
8000fb46:	04 98       	mov	r8,r2
8000fb48:	00 95       	mov	r5,r0
8000fb4a:	c2 f8       	rjmp	8000fba8 <_dtoa_r+0x834>
8000fb4c:	80 00       	ld.sh	r0,r0[0x0]
8000fb4e:	c3 00       	breq	8000fbae <_dtoa_r+0x83a>
8000fb50:	80 01       	ld.sh	r1,r0[0x0]
8000fb52:	2b f0       	sub	r0,-65
8000fb54:	80 01       	ld.sh	r1,r0[0x0]
8000fb56:	1b 48       	ld.w	r8,--sp
8000fb58:	80 01       	ld.sh	r1,r0[0x0]
8000fb5a:	1c 18       	sub	r8,lr
8000fb5c:	80 01       	ld.sh	r1,r0[0x0]
8000fb5e:	1a fc       	st.b	--sp,r12
8000fb60:	80 00       	ld.sh	r0,r0[0x0]
8000fb62:	c7 8c       	rcall	8000fc52 <_dtoa_r+0x8de>
8000fb64:	80 00       	ld.sh	r0,r0[0x0]
8000fb66:	c4 d8       	rjmp	8000fc00 <_dtoa_r+0x88c>
8000fb68:	80 00       	ld.sh	r0,r0[0x0]
8000fb6a:	c6 74       	brge	8000fc38 <_dtoa_r+0x8c4>
8000fb6c:	80 01       	ld.sh	r1,r0[0x0]
8000fb6e:	1b b0       	ld.ub	r0,sp[0x3]
8000fb70:	80 01       	ld.sh	r1,r0[0x0]
8000fb72:	1b 22       	ld.uh	r2,sp++
8000fb74:	e2 c8 00 01 	sub	r8,r1,1
8000fb78:	58 01       	cp.w	r1,0
8000fb7a:	e0 05 17 40 	movge	r5,r0
8000fb7e:	e2 09 17 40 	movge	r9,r1
8000fb82:	e1 d1 e5 15 	sublt	r5,r0,r1
8000fb86:	f9 b9 05 00 	movlt	r9,0
8000fb8a:	10 32       	cp.w	r2,r8
8000fb8c:	e5 d8 e4 18 	subge	r8,r2,r8
8000fb90:	f1 d2 e5 18 	sublt	r8,r8,r2
8000fb94:	e5 d8 e5 02 	addlt	r2,r2,r8
8000fb98:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000fb9c:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000fba0:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000fba4:	f9 b8 05 00 	movlt	r8,0
8000fba8:	40 4b       	lddsp	r11,sp[0x10]
8000fbaa:	12 0b       	add	r11,r9
8000fbac:	50 08       	stdsp	sp[0x0],r8
8000fbae:	50 4b       	stdsp	sp[0x10],r11
8000fbb0:	12 00       	add	r0,r9
8000fbb2:	30 1b       	mov	r11,1
8000fbb4:	0e 9c       	mov	r12,r7
8000fbb6:	f0 1f 01 08 	mcall	8000ffd4 <_dtoa_r+0xc60>
8000fbba:	40 08       	lddsp	r8,sp[0x0]
8000fbbc:	18 94       	mov	r4,r12
8000fbbe:	40 4a       	lddsp	r10,sp[0x10]
8000fbc0:	58 05       	cp.w	r5,0
8000fbc2:	5f 99       	srgt	r9
8000fbc4:	58 0a       	cp.w	r10,0
8000fbc6:	5f 9a       	srgt	r10
8000fbc8:	f5 e9 00 09 	and	r9,r10,r9
8000fbcc:	c0 80       	breq	8000fbdc <_dtoa_r+0x868>
8000fbce:	40 4c       	lddsp	r12,sp[0x10]
8000fbd0:	f8 05 0d 49 	min	r9,r12,r5
8000fbd4:	12 1c       	sub	r12,r9
8000fbd6:	12 10       	sub	r0,r9
8000fbd8:	50 4c       	stdsp	sp[0x10],r12
8000fbda:	12 15       	sub	r5,r9
8000fbdc:	58 02       	cp.w	r2,0
8000fbde:	e0 8a 00 27 	brle	8000fc2c <_dtoa_r+0x8b8>
8000fbe2:	40 db       	lddsp	r11,sp[0x34]
8000fbe4:	58 0b       	cp.w	r11,0
8000fbe6:	c1 d0       	breq	8000fc20 <_dtoa_r+0x8ac>
8000fbe8:	58 08       	cp.w	r8,0
8000fbea:	e0 8a 00 17 	brle	8000fc18 <_dtoa_r+0x8a4>
8000fbee:	10 9a       	mov	r10,r8
8000fbf0:	50 08       	stdsp	sp[0x0],r8
8000fbf2:	08 9b       	mov	r11,r4
8000fbf4:	0e 9c       	mov	r12,r7
8000fbf6:	f0 1f 00 f9 	mcall	8000ffd8 <_dtoa_r+0xc64>
8000fbfa:	06 9a       	mov	r10,r3
8000fbfc:	18 9b       	mov	r11,r12
8000fbfe:	18 94       	mov	r4,r12
8000fc00:	0e 9c       	mov	r12,r7
8000fc02:	f0 1f 00 f7 	mcall	8000ffdc <_dtoa_r+0xc68>
8000fc06:	18 99       	mov	r9,r12
8000fc08:	06 9b       	mov	r11,r3
8000fc0a:	50 19       	stdsp	sp[0x4],r9
8000fc0c:	0e 9c       	mov	r12,r7
8000fc0e:	f0 1f 00 f5 	mcall	8000ffe0 <_dtoa_r+0xc6c>
8000fc12:	40 19       	lddsp	r9,sp[0x4]
8000fc14:	40 08       	lddsp	r8,sp[0x0]
8000fc16:	12 93       	mov	r3,r9
8000fc18:	e4 08 01 0a 	sub	r10,r2,r8
8000fc1c:	c0 80       	breq	8000fc2c <_dtoa_r+0x8b8>
8000fc1e:	c0 28       	rjmp	8000fc22 <_dtoa_r+0x8ae>
8000fc20:	04 9a       	mov	r10,r2
8000fc22:	06 9b       	mov	r11,r3
8000fc24:	0e 9c       	mov	r12,r7
8000fc26:	f0 1f 00 ed 	mcall	8000ffd8 <_dtoa_r+0xc64>
8000fc2a:	18 93       	mov	r3,r12
8000fc2c:	30 1b       	mov	r11,1
8000fc2e:	0e 9c       	mov	r12,r7
8000fc30:	f0 1f 00 e9 	mcall	8000ffd4 <_dtoa_r+0xc60>
8000fc34:	41 1a       	lddsp	r10,sp[0x44]
8000fc36:	18 92       	mov	r2,r12
8000fc38:	58 0a       	cp.w	r10,0
8000fc3a:	e0 8a 00 07 	brle	8000fc48 <_dtoa_r+0x8d4>
8000fc3e:	18 9b       	mov	r11,r12
8000fc40:	0e 9c       	mov	r12,r7
8000fc42:	f0 1f 00 e6 	mcall	8000ffd8 <_dtoa_r+0xc64>
8000fc46:	18 92       	mov	r2,r12
8000fc48:	40 c9       	lddsp	r9,sp[0x30]
8000fc4a:	58 19       	cp.w	r9,1
8000fc4c:	e0 89 00 14 	brgt	8000fc74 <_dtoa_r+0x900>
8000fc50:	40 38       	lddsp	r8,sp[0xc]
8000fc52:	58 08       	cp.w	r8,0
8000fc54:	c1 01       	brne	8000fc74 <_dtoa_r+0x900>
8000fc56:	40 29       	lddsp	r9,sp[0x8]
8000fc58:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000fc5c:	c0 c1       	brne	8000fc74 <_dtoa_r+0x900>
8000fc5e:	12 98       	mov	r8,r9
8000fc60:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000fc64:	c0 80       	breq	8000fc74 <_dtoa_r+0x900>
8000fc66:	40 4c       	lddsp	r12,sp[0x10]
8000fc68:	30 1b       	mov	r11,1
8000fc6a:	2f fc       	sub	r12,-1
8000fc6c:	2f f0       	sub	r0,-1
8000fc6e:	50 4c       	stdsp	sp[0x10],r12
8000fc70:	50 6b       	stdsp	sp[0x18],r11
8000fc72:	c0 38       	rjmp	8000fc78 <_dtoa_r+0x904>
8000fc74:	30 0a       	mov	r10,0
8000fc76:	50 6a       	stdsp	sp[0x18],r10
8000fc78:	41 19       	lddsp	r9,sp[0x44]
8000fc7a:	58 09       	cp.w	r9,0
8000fc7c:	c0 31       	brne	8000fc82 <_dtoa_r+0x90e>
8000fc7e:	30 1c       	mov	r12,1
8000fc80:	c0 98       	rjmp	8000fc92 <_dtoa_r+0x91e>
8000fc82:	64 48       	ld.w	r8,r2[0x10]
8000fc84:	2f c8       	sub	r8,-4
8000fc86:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000fc8a:	f0 1f 00 d7 	mcall	8000ffe4 <_dtoa_r+0xc70>
8000fc8e:	f8 0c 11 20 	rsub	r12,r12,32
8000fc92:	40 4b       	lddsp	r11,sp[0x10]
8000fc94:	f8 0b 00 08 	add	r8,r12,r11
8000fc98:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000fc9c:	c0 c0       	breq	8000fcb4 <_dtoa_r+0x940>
8000fc9e:	f0 08 11 20 	rsub	r8,r8,32
8000fca2:	58 48       	cp.w	r8,4
8000fca4:	e0 8a 00 06 	brle	8000fcb0 <_dtoa_r+0x93c>
8000fca8:	20 48       	sub	r8,4
8000fcaa:	10 0b       	add	r11,r8
8000fcac:	50 4b       	stdsp	sp[0x10],r11
8000fcae:	c0 78       	rjmp	8000fcbc <_dtoa_r+0x948>
8000fcb0:	58 48       	cp.w	r8,4
8000fcb2:	c0 70       	breq	8000fcc0 <_dtoa_r+0x94c>
8000fcb4:	40 4a       	lddsp	r10,sp[0x10]
8000fcb6:	2e 48       	sub	r8,-28
8000fcb8:	10 0a       	add	r10,r8
8000fcba:	50 4a       	stdsp	sp[0x10],r10
8000fcbc:	10 00       	add	r0,r8
8000fcbe:	10 05       	add	r5,r8
8000fcc0:	58 00       	cp.w	r0,0
8000fcc2:	e0 8a 00 08 	brle	8000fcd2 <_dtoa_r+0x95e>
8000fcc6:	06 9b       	mov	r11,r3
8000fcc8:	00 9a       	mov	r10,r0
8000fcca:	0e 9c       	mov	r12,r7
8000fccc:	f0 1f 00 c7 	mcall	8000ffe8 <_dtoa_r+0xc74>
8000fcd0:	18 93       	mov	r3,r12
8000fcd2:	40 49       	lddsp	r9,sp[0x10]
8000fcd4:	58 09       	cp.w	r9,0
8000fcd6:	e0 8a 00 08 	brle	8000fce6 <_dtoa_r+0x972>
8000fcda:	04 9b       	mov	r11,r2
8000fcdc:	12 9a       	mov	r10,r9
8000fcde:	0e 9c       	mov	r12,r7
8000fce0:	f0 1f 00 c2 	mcall	8000ffe8 <_dtoa_r+0xc74>
8000fce4:	18 92       	mov	r2,r12
8000fce6:	41 48       	lddsp	r8,sp[0x50]
8000fce8:	58 08       	cp.w	r8,0
8000fcea:	c1 b0       	breq	8000fd20 <_dtoa_r+0x9ac>
8000fcec:	04 9b       	mov	r11,r2
8000fcee:	06 9c       	mov	r12,r3
8000fcf0:	f0 1f 00 bf 	mcall	8000ffec <_dtoa_r+0xc78>
8000fcf4:	c1 64       	brge	8000fd20 <_dtoa_r+0x9ac>
8000fcf6:	06 9b       	mov	r11,r3
8000fcf8:	30 09       	mov	r9,0
8000fcfa:	30 aa       	mov	r10,10
8000fcfc:	0e 9c       	mov	r12,r7
8000fcfe:	f0 1f 00 bd 	mcall	8000fff0 <_dtoa_r+0xc7c>
8000fd02:	20 16       	sub	r6,1
8000fd04:	18 93       	mov	r3,r12
8000fd06:	40 dc       	lddsp	r12,sp[0x34]
8000fd08:	58 0c       	cp.w	r12,0
8000fd0a:	c0 31       	brne	8000fd10 <_dtoa_r+0x99c>
8000fd0c:	40 91       	lddsp	r1,sp[0x24]
8000fd0e:	c0 98       	rjmp	8000fd20 <_dtoa_r+0x9ac>
8000fd10:	08 9b       	mov	r11,r4
8000fd12:	40 91       	lddsp	r1,sp[0x24]
8000fd14:	30 09       	mov	r9,0
8000fd16:	30 aa       	mov	r10,10
8000fd18:	0e 9c       	mov	r12,r7
8000fd1a:	f0 1f 00 b6 	mcall	8000fff0 <_dtoa_r+0xc7c>
8000fd1e:	18 94       	mov	r4,r12
8000fd20:	58 01       	cp.w	r1,0
8000fd22:	5f a9       	srle	r9
8000fd24:	40 cb       	lddsp	r11,sp[0x30]
8000fd26:	58 2b       	cp.w	r11,2
8000fd28:	5f 98       	srgt	r8
8000fd2a:	f3 e8 00 08 	and	r8,r9,r8
8000fd2e:	c2 50       	breq	8000fd78 <_dtoa_r+0xa04>
8000fd30:	58 01       	cp.w	r1,0
8000fd32:	c1 11       	brne	8000fd54 <_dtoa_r+0x9e0>
8000fd34:	04 9b       	mov	r11,r2
8000fd36:	02 99       	mov	r9,r1
8000fd38:	30 5a       	mov	r10,5
8000fd3a:	0e 9c       	mov	r12,r7
8000fd3c:	f0 1f 00 ad 	mcall	8000fff0 <_dtoa_r+0xc7c>
8000fd40:	18 92       	mov	r2,r12
8000fd42:	18 9b       	mov	r11,r12
8000fd44:	06 9c       	mov	r12,r3
8000fd46:	f0 1f 00 aa 	mcall	8000ffec <_dtoa_r+0xc78>
8000fd4a:	e0 89 00 0f 	brgt	8000fd68 <_dtoa_r+0x9f4>
8000fd4e:	c0 38       	rjmp	8000fd54 <_dtoa_r+0x9e0>
8000fd50:	30 02       	mov	r2,0
8000fd52:	04 94       	mov	r4,r2
8000fd54:	40 ea       	lddsp	r10,sp[0x38]
8000fd56:	30 09       	mov	r9,0
8000fd58:	5c da       	com	r10
8000fd5a:	40 85       	lddsp	r5,sp[0x20]
8000fd5c:	50 6a       	stdsp	sp[0x18],r10
8000fd5e:	50 49       	stdsp	sp[0x10],r9
8000fd60:	c0 f9       	rjmp	8000ff7e <_dtoa_r+0xc0a>
8000fd62:	08 92       	mov	r2,r4
8000fd64:	40 66       	lddsp	r6,sp[0x18]
8000fd66:	04 94       	mov	r4,r2
8000fd68:	2f f6       	sub	r6,-1
8000fd6a:	50 66       	stdsp	sp[0x18],r6
8000fd6c:	33 18       	mov	r8,49
8000fd6e:	40 85       	lddsp	r5,sp[0x20]
8000fd70:	0a c8       	st.b	r5++,r8
8000fd72:	30 08       	mov	r8,0
8000fd74:	50 48       	stdsp	sp[0x10],r8
8000fd76:	c0 49       	rjmp	8000ff7e <_dtoa_r+0xc0a>
8000fd78:	40 dc       	lddsp	r12,sp[0x34]
8000fd7a:	58 0c       	cp.w	r12,0
8000fd7c:	e0 80 00 b5 	breq	8000fee6 <_dtoa_r+0xb72>
8000fd80:	58 05       	cp.w	r5,0
8000fd82:	e0 8a 00 08 	brle	8000fd92 <_dtoa_r+0xa1e>
8000fd86:	08 9b       	mov	r11,r4
8000fd88:	0a 9a       	mov	r10,r5
8000fd8a:	0e 9c       	mov	r12,r7
8000fd8c:	f0 1f 00 97 	mcall	8000ffe8 <_dtoa_r+0xc74>
8000fd90:	18 94       	mov	r4,r12
8000fd92:	40 6b       	lddsp	r11,sp[0x18]
8000fd94:	58 0b       	cp.w	r11,0
8000fd96:	c0 31       	brne	8000fd9c <_dtoa_r+0xa28>
8000fd98:	08 9c       	mov	r12,r4
8000fd9a:	c1 38       	rjmp	8000fdc0 <_dtoa_r+0xa4c>
8000fd9c:	68 1b       	ld.w	r11,r4[0x4]
8000fd9e:	0e 9c       	mov	r12,r7
8000fda0:	f0 1f 00 95 	mcall	8000fff4 <_dtoa_r+0xc80>
8000fda4:	68 4a       	ld.w	r10,r4[0x10]
8000fda6:	18 95       	mov	r5,r12
8000fda8:	e8 cb ff f4 	sub	r11,r4,-12
8000fdac:	2f ea       	sub	r10,-2
8000fdae:	2f 4c       	sub	r12,-12
8000fdb0:	a3 6a       	lsl	r10,0x2
8000fdb2:	f0 1f 00 92 	mcall	8000fff8 <_dtoa_r+0xc84>
8000fdb6:	0a 9b       	mov	r11,r5
8000fdb8:	30 1a       	mov	r10,1
8000fdba:	0e 9c       	mov	r12,r7
8000fdbc:	f0 1f 00 8b 	mcall	8000ffe8 <_dtoa_r+0xc74>
8000fdc0:	50 44       	stdsp	sp[0x10],r4
8000fdc2:	40 3a       	lddsp	r10,sp[0xc]
8000fdc4:	30 19       	mov	r9,1
8000fdc6:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000fdca:	18 94       	mov	r4,r12
8000fdcc:	50 da       	stdsp	sp[0x34],r10
8000fdce:	40 85       	lddsp	r5,sp[0x20]
8000fdd0:	50 99       	stdsp	sp[0x24],r9
8000fdd2:	50 26       	stdsp	sp[0x8],r6
8000fdd4:	50 e1       	stdsp	sp[0x38],r1
8000fdd6:	04 9b       	mov	r11,r2
8000fdd8:	06 9c       	mov	r12,r3
8000fdda:	f0 1f 00 89 	mcall	8000fffc <_dtoa_r+0xc88>
8000fdde:	40 4b       	lddsp	r11,sp[0x10]
8000fde0:	f8 c0 ff d0 	sub	r0,r12,-48
8000fde4:	06 9c       	mov	r12,r3
8000fde6:	f0 1f 00 82 	mcall	8000ffec <_dtoa_r+0xc78>
8000fdea:	08 9a       	mov	r10,r4
8000fdec:	50 6c       	stdsp	sp[0x18],r12
8000fdee:	04 9b       	mov	r11,r2
8000fdf0:	0e 9c       	mov	r12,r7
8000fdf2:	f0 1f 00 84 	mcall	80010000 <_dtoa_r+0xc8c>
8000fdf6:	18 91       	mov	r1,r12
8000fdf8:	78 38       	ld.w	r8,r12[0xc]
8000fdfa:	58 08       	cp.w	r8,0
8000fdfc:	c0 30       	breq	8000fe02 <_dtoa_r+0xa8e>
8000fdfe:	30 16       	mov	r6,1
8000fe00:	c0 68       	rjmp	8000fe0c <_dtoa_r+0xa98>
8000fe02:	18 9b       	mov	r11,r12
8000fe04:	06 9c       	mov	r12,r3
8000fe06:	f0 1f 00 7a 	mcall	8000ffec <_dtoa_r+0xc78>
8000fe0a:	18 96       	mov	r6,r12
8000fe0c:	0e 9c       	mov	r12,r7
8000fe0e:	02 9b       	mov	r11,r1
8000fe10:	f0 1f 00 74 	mcall	8000ffe0 <_dtoa_r+0xc6c>
8000fe14:	40 cc       	lddsp	r12,sp[0x30]
8000fe16:	ed ec 10 08 	or	r8,r6,r12
8000fe1a:	c0 d1       	brne	8000fe34 <_dtoa_r+0xac0>
8000fe1c:	40 db       	lddsp	r11,sp[0x34]
8000fe1e:	58 0b       	cp.w	r11,0
8000fe20:	c0 a1       	brne	8000fe34 <_dtoa_r+0xac0>
8000fe22:	40 26       	lddsp	r6,sp[0x8]
8000fe24:	e0 40 00 39 	cp.w	r0,57
8000fe28:	c3 00       	breq	8000fe88 <_dtoa_r+0xb14>
8000fe2a:	40 6a       	lddsp	r10,sp[0x18]
8000fe2c:	58 0a       	cp.w	r10,0
8000fe2e:	e0 89 00 24 	brgt	8000fe76 <_dtoa_r+0xb02>
8000fe32:	c2 f8       	rjmp	8000fe90 <_dtoa_r+0xb1c>
8000fe34:	40 69       	lddsp	r9,sp[0x18]
8000fe36:	58 09       	cp.w	r9,0
8000fe38:	c0 85       	brlt	8000fe48 <_dtoa_r+0xad4>
8000fe3a:	12 98       	mov	r8,r9
8000fe3c:	40 cc       	lddsp	r12,sp[0x30]
8000fe3e:	18 48       	or	r8,r12
8000fe40:	c1 d1       	brne	8000fe7a <_dtoa_r+0xb06>
8000fe42:	40 db       	lddsp	r11,sp[0x34]
8000fe44:	58 0b       	cp.w	r11,0
8000fe46:	c1 a1       	brne	8000fe7a <_dtoa_r+0xb06>
8000fe48:	0c 99       	mov	r9,r6
8000fe4a:	40 26       	lddsp	r6,sp[0x8]
8000fe4c:	58 09       	cp.w	r9,0
8000fe4e:	e0 8a 00 21 	brle	8000fe90 <_dtoa_r+0xb1c>
8000fe52:	06 9b       	mov	r11,r3
8000fe54:	30 1a       	mov	r10,1
8000fe56:	0e 9c       	mov	r12,r7
8000fe58:	f0 1f 00 64 	mcall	8000ffe8 <_dtoa_r+0xc74>
8000fe5c:	04 9b       	mov	r11,r2
8000fe5e:	18 93       	mov	r3,r12
8000fe60:	f0 1f 00 63 	mcall	8000ffec <_dtoa_r+0xc78>
8000fe64:	e0 89 00 06 	brgt	8000fe70 <_dtoa_r+0xafc>
8000fe68:	c1 41       	brne	8000fe90 <_dtoa_r+0xb1c>
8000fe6a:	ed b0 00 00 	bld	r0,0x0
8000fe6e:	c1 11       	brne	8000fe90 <_dtoa_r+0xb1c>
8000fe70:	e0 40 00 39 	cp.w	r0,57
8000fe74:	c0 a0       	breq	8000fe88 <_dtoa_r+0xb14>
8000fe76:	2f f0       	sub	r0,-1
8000fe78:	c0 c8       	rjmp	8000fe90 <_dtoa_r+0xb1c>
8000fe7a:	58 06       	cp.w	r6,0
8000fe7c:	e0 8a 00 0c 	brle	8000fe94 <_dtoa_r+0xb20>
8000fe80:	40 26       	lddsp	r6,sp[0x8]
8000fe82:	e0 40 00 39 	cp.w	r0,57
8000fe86:	c0 41       	brne	8000fe8e <_dtoa_r+0xb1a>
8000fe88:	33 98       	mov	r8,57
8000fe8a:	0a c8       	st.b	r5++,r8
8000fe8c:	c6 78       	rjmp	8000ff5a <_dtoa_r+0xbe6>
8000fe8e:	2f f0       	sub	r0,-1
8000fe90:	0a c0       	st.b	r5++,r0
8000fe92:	c7 58       	rjmp	8000ff7c <_dtoa_r+0xc08>
8000fe94:	0a c0       	st.b	r5++,r0
8000fe96:	40 9a       	lddsp	r10,sp[0x24]
8000fe98:	40 e9       	lddsp	r9,sp[0x38]
8000fe9a:	12 3a       	cp.w	r10,r9
8000fe9c:	c4 30       	breq	8000ff22 <_dtoa_r+0xbae>
8000fe9e:	06 9b       	mov	r11,r3
8000fea0:	30 09       	mov	r9,0
8000fea2:	30 aa       	mov	r10,10
8000fea4:	0e 9c       	mov	r12,r7
8000fea6:	f0 1f 00 53 	mcall	8000fff0 <_dtoa_r+0xc7c>
8000feaa:	40 48       	lddsp	r8,sp[0x10]
8000feac:	18 93       	mov	r3,r12
8000feae:	08 38       	cp.w	r8,r4
8000feb0:	c0 91       	brne	8000fec2 <_dtoa_r+0xb4e>
8000feb2:	10 9b       	mov	r11,r8
8000feb4:	30 09       	mov	r9,0
8000feb6:	30 aa       	mov	r10,10
8000feb8:	0e 9c       	mov	r12,r7
8000feba:	f0 1f 00 4e 	mcall	8000fff0 <_dtoa_r+0xc7c>
8000febe:	50 4c       	stdsp	sp[0x10],r12
8000fec0:	c0 e8       	rjmp	8000fedc <_dtoa_r+0xb68>
8000fec2:	40 4b       	lddsp	r11,sp[0x10]
8000fec4:	30 09       	mov	r9,0
8000fec6:	30 aa       	mov	r10,10
8000fec8:	0e 9c       	mov	r12,r7
8000feca:	f0 1f 00 4a 	mcall	8000fff0 <_dtoa_r+0xc7c>
8000fece:	08 9b       	mov	r11,r4
8000fed0:	50 4c       	stdsp	sp[0x10],r12
8000fed2:	30 09       	mov	r9,0
8000fed4:	30 aa       	mov	r10,10
8000fed6:	0e 9c       	mov	r12,r7
8000fed8:	f0 1f 00 46 	mcall	8000fff0 <_dtoa_r+0xc7c>
8000fedc:	18 94       	mov	r4,r12
8000fede:	40 9c       	lddsp	r12,sp[0x24]
8000fee0:	2f fc       	sub	r12,-1
8000fee2:	50 9c       	stdsp	sp[0x24],r12
8000fee4:	c7 9b       	rjmp	8000fdd6 <_dtoa_r+0xa62>
8000fee6:	30 18       	mov	r8,1
8000fee8:	06 90       	mov	r0,r3
8000feea:	40 85       	lddsp	r5,sp[0x20]
8000feec:	08 93       	mov	r3,r4
8000feee:	0c 94       	mov	r4,r6
8000fef0:	10 96       	mov	r6,r8
8000fef2:	04 9b       	mov	r11,r2
8000fef4:	00 9c       	mov	r12,r0
8000fef6:	f0 1f 00 42 	mcall	8000fffc <_dtoa_r+0xc88>
8000fefa:	2d 0c       	sub	r12,-48
8000fefc:	0a cc       	st.b	r5++,r12
8000fefe:	02 36       	cp.w	r6,r1
8000ff00:	c0 a4       	brge	8000ff14 <_dtoa_r+0xba0>
8000ff02:	00 9b       	mov	r11,r0
8000ff04:	30 09       	mov	r9,0
8000ff06:	30 aa       	mov	r10,10
8000ff08:	0e 9c       	mov	r12,r7
8000ff0a:	2f f6       	sub	r6,-1
8000ff0c:	f0 1f 00 39 	mcall	8000fff0 <_dtoa_r+0xc7c>
8000ff10:	18 90       	mov	r0,r12
8000ff12:	cf 0b       	rjmp	8000fef2 <_dtoa_r+0xb7e>
8000ff14:	08 96       	mov	r6,r4
8000ff16:	30 0b       	mov	r11,0
8000ff18:	06 94       	mov	r4,r3
8000ff1a:	50 4b       	stdsp	sp[0x10],r11
8000ff1c:	00 93       	mov	r3,r0
8000ff1e:	18 90       	mov	r0,r12
8000ff20:	c0 28       	rjmp	8000ff24 <_dtoa_r+0xbb0>
8000ff22:	40 26       	lddsp	r6,sp[0x8]
8000ff24:	06 9b       	mov	r11,r3
8000ff26:	30 1a       	mov	r10,1
8000ff28:	0e 9c       	mov	r12,r7
8000ff2a:	f0 1f 00 30 	mcall	8000ffe8 <_dtoa_r+0xc74>
8000ff2e:	04 9b       	mov	r11,r2
8000ff30:	18 93       	mov	r3,r12
8000ff32:	f0 1f 00 2f 	mcall	8000ffec <_dtoa_r+0xc78>
8000ff36:	e0 89 00 12 	brgt	8000ff5a <_dtoa_r+0xbe6>
8000ff3a:	c1 b1       	brne	8000ff70 <_dtoa_r+0xbfc>
8000ff3c:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000ff40:	c0 d1       	brne	8000ff5a <_dtoa_r+0xbe6>
8000ff42:	c1 78       	rjmp	8000ff70 <_dtoa_r+0xbfc>
8000ff44:	40 89       	lddsp	r9,sp[0x20]
8000ff46:	12 38       	cp.w	r8,r9
8000ff48:	c0 30       	breq	8000ff4e <_dtoa_r+0xbda>
8000ff4a:	10 95       	mov	r5,r8
8000ff4c:	c0 88       	rjmp	8000ff5c <_dtoa_r+0xbe8>
8000ff4e:	2f f6       	sub	r6,-1
8000ff50:	50 66       	stdsp	sp[0x18],r6
8000ff52:	33 18       	mov	r8,49
8000ff54:	40 8c       	lddsp	r12,sp[0x20]
8000ff56:	b8 88       	st.b	r12[0x0],r8
8000ff58:	c1 38       	rjmp	8000ff7e <_dtoa_r+0xc0a>
8000ff5a:	33 9a       	mov	r10,57
8000ff5c:	0a 98       	mov	r8,r5
8000ff5e:	11 79       	ld.ub	r9,--r8
8000ff60:	f4 09 18 00 	cp.b	r9,r10
8000ff64:	cf 00       	breq	8000ff44 <_dtoa_r+0xbd0>
8000ff66:	2f f9       	sub	r9,-1
8000ff68:	b0 89       	st.b	r8[0x0],r9
8000ff6a:	c0 98       	rjmp	8000ff7c <_dtoa_r+0xc08>
8000ff6c:	10 95       	mov	r5,r8
8000ff6e:	c0 28       	rjmp	8000ff72 <_dtoa_r+0xbfe>
8000ff70:	33 09       	mov	r9,48
8000ff72:	0a 98       	mov	r8,r5
8000ff74:	11 7a       	ld.ub	r10,--r8
8000ff76:	f2 0a 18 00 	cp.b	r10,r9
8000ff7a:	cf 90       	breq	8000ff6c <_dtoa_r+0xbf8>
8000ff7c:	50 66       	stdsp	sp[0x18],r6
8000ff7e:	04 9b       	mov	r11,r2
8000ff80:	0e 9c       	mov	r12,r7
8000ff82:	f0 1f 00 18 	mcall	8000ffe0 <_dtoa_r+0xc6c>
8000ff86:	58 04       	cp.w	r4,0
8000ff88:	c1 20       	breq	8000ffac <_dtoa_r+0xc38>
8000ff8a:	40 4b       	lddsp	r11,sp[0x10]
8000ff8c:	08 3b       	cp.w	r11,r4
8000ff8e:	5f 19       	srne	r9
8000ff90:	58 0b       	cp.w	r11,0
8000ff92:	5f 18       	srne	r8
8000ff94:	f3 e8 00 08 	and	r8,r9,r8
8000ff98:	c0 40       	breq	8000ffa0 <_dtoa_r+0xc2c>
8000ff9a:	0e 9c       	mov	r12,r7
8000ff9c:	f0 1f 00 11 	mcall	8000ffe0 <_dtoa_r+0xc6c>
8000ffa0:	08 9b       	mov	r11,r4
8000ffa2:	0e 9c       	mov	r12,r7
8000ffa4:	f0 1f 00 0f 	mcall	8000ffe0 <_dtoa_r+0xc6c>
8000ffa8:	c0 28       	rjmp	8000ffac <_dtoa_r+0xc38>
8000ffaa:	50 66       	stdsp	sp[0x18],r6
8000ffac:	0e 9c       	mov	r12,r7
8000ffae:	06 9b       	mov	r11,r3
8000ffb0:	f0 1f 00 0c 	mcall	8000ffe0 <_dtoa_r+0xc6c>
8000ffb4:	30 08       	mov	r8,0
8000ffb6:	aa 88       	st.b	r5[0x0],r8
8000ffb8:	40 68       	lddsp	r8,sp[0x18]
8000ffba:	41 5a       	lddsp	r10,sp[0x54]
8000ffbc:	2f f8       	sub	r8,-1
8000ffbe:	41 29       	lddsp	r9,sp[0x48]
8000ffc0:	95 08       	st.w	r10[0x0],r8
8000ffc2:	40 8c       	lddsp	r12,sp[0x20]
8000ffc4:	58 09       	cp.w	r9,0
8000ffc6:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000ffca:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000ffce:	2e 6d       	sub	sp,-104
8000ffd0:	d8 32       	popm	r0-r7,pc
8000ffd2:	00 00       	add	r0,r0
8000ffd4:	80 01       	ld.sh	r1,r0[0x0]
8000ffd6:	12 7c       	tst	r12,r9
8000ffd8:	80 01       	ld.sh	r1,r0[0x0]
8000ffda:	13 1c       	ld.sh	r12,r9++
8000ffdc:	80 01       	ld.sh	r1,r0[0x0]
8000ffde:	11 74       	ld.ub	r4,--r8
8000ffe0:	80 01       	ld.sh	r1,r0[0x0]
8000ffe2:	0e a4       	st.w	r7++,r4
8000ffe4:	80 01       	ld.sh	r1,r0[0x0]
8000ffe6:	0d 84       	ld.ub	r4,r6[0x0]
8000ffe8:	80 01       	ld.sh	r1,r0[0x0]
8000ffea:	10 e0       	st.h	--r8,r0
8000ffec:	80 01       	ld.sh	r1,r0[0x0]
8000ffee:	0e 72       	tst	r2,r7
8000fff0:	80 01       	ld.sh	r1,r0[0x0]
8000fff2:	12 94       	mov	r4,r9
8000fff4:	80 01       	ld.sh	r1,r0[0x0]
8000fff6:	0e dc       	st.w	--r7,r12
8000fff8:	80 00       	ld.sh	r0,r0[0x0]
8000fffa:	cc ba       	rjmp	8000fd90 <_dtoa_r+0xa1c>
8000fffc:	80 00       	ld.sh	r0,r0[0x0]
8000fffe:	f2 50 80 01 	cp.w	r0,-819199
80010002:	10 08       	add	r8,r8

80010004 <_fflush_r>:
80010004:	d4 21       	pushm	r4-r7,lr
80010006:	16 97       	mov	r7,r11
80010008:	18 96       	mov	r6,r12
8001000a:	76 48       	ld.w	r8,r11[0x10]
8001000c:	58 08       	cp.w	r8,0
8001000e:	c7 d0       	breq	80010108 <_fflush_r+0x104>
80010010:	58 0c       	cp.w	r12,0
80010012:	c0 60       	breq	8001001e <_fflush_r+0x1a>
80010014:	78 68       	ld.w	r8,r12[0x18]
80010016:	58 08       	cp.w	r8,0
80010018:	c0 31       	brne	8001001e <_fflush_r+0x1a>
8001001a:	f0 1f 00 3d 	mcall	8001010c <_fflush_r+0x108>
8001001e:	4b d8       	lddpc	r8,80010110 <_fflush_r+0x10c>
80010020:	10 37       	cp.w	r7,r8
80010022:	c0 31       	brne	80010028 <_fflush_r+0x24>
80010024:	6c 07       	ld.w	r7,r6[0x0]
80010026:	c0 a8       	rjmp	8001003a <_fflush_r+0x36>
80010028:	4b b8       	lddpc	r8,80010114 <_fflush_r+0x110>
8001002a:	10 37       	cp.w	r7,r8
8001002c:	c0 31       	brne	80010032 <_fflush_r+0x2e>
8001002e:	6c 17       	ld.w	r7,r6[0x4]
80010030:	c0 58       	rjmp	8001003a <_fflush_r+0x36>
80010032:	4b a8       	lddpc	r8,80010118 <_fflush_r+0x114>
80010034:	10 37       	cp.w	r7,r8
80010036:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8001003a:	8e 6a       	ld.sh	r10,r7[0xc]
8001003c:	14 98       	mov	r8,r10
8001003e:	ed ba 00 03 	bld	r10,0x3
80010042:	c4 20       	breq	800100c6 <_fflush_r+0xc2>
80010044:	ab ba       	sbr	r10,0xb
80010046:	ae 6a       	st.h	r7[0xc],r10
80010048:	6e 18       	ld.w	r8,r7[0x4]
8001004a:	58 08       	cp.w	r8,0
8001004c:	e0 89 00 06 	brgt	80010058 <_fflush_r+0x54>
80010050:	6f 08       	ld.w	r8,r7[0x40]
80010052:	58 08       	cp.w	r8,0
80010054:	e0 8a 00 5a 	brle	80010108 <_fflush_r+0x104>
80010058:	6e b8       	ld.w	r8,r7[0x2c]
8001005a:	58 08       	cp.w	r8,0
8001005c:	c5 60       	breq	80010108 <_fflush_r+0x104>
8001005e:	e2 1a 10 00 	andl	r10,0x1000,COH
80010062:	c0 30       	breq	80010068 <_fflush_r+0x64>
80010064:	6f 55       	ld.w	r5,r7[0x54]
80010066:	c0 f8       	rjmp	80010084 <_fflush_r+0x80>
80010068:	30 19       	mov	r9,1
8001006a:	6e 8b       	ld.w	r11,r7[0x20]
8001006c:	0c 9c       	mov	r12,r6
8001006e:	5d 18       	icall	r8
80010070:	18 95       	mov	r5,r12
80010072:	5b fc       	cp.w	r12,-1
80010074:	c0 81       	brne	80010084 <_fflush_r+0x80>
80010076:	6c 38       	ld.w	r8,r6[0xc]
80010078:	59 d8       	cp.w	r8,29
8001007a:	c4 70       	breq	80010108 <_fflush_r+0x104>
8001007c:	8e 68       	ld.sh	r8,r7[0xc]
8001007e:	a7 a8       	sbr	r8,0x6
80010080:	ae 68       	st.h	r7[0xc],r8
80010082:	d8 22       	popm	r4-r7,pc
80010084:	8e 68       	ld.sh	r8,r7[0xc]
80010086:	ed b8 00 02 	bld	r8,0x2
8001008a:	c0 91       	brne	8001009c <_fflush_r+0x98>
8001008c:	6e 18       	ld.w	r8,r7[0x4]
8001008e:	10 15       	sub	r5,r8
80010090:	6e d8       	ld.w	r8,r7[0x34]
80010092:	58 08       	cp.w	r8,0
80010094:	ef f8 10 10 	ld.wne	r8,r7[0x40]
80010098:	eb d8 e1 15 	subne	r5,r5,r8
8001009c:	6e b8       	ld.w	r8,r7[0x2c]
8001009e:	0c 9c       	mov	r12,r6
800100a0:	30 09       	mov	r9,0
800100a2:	0a 9a       	mov	r10,r5
800100a4:	6e 8b       	ld.w	r11,r7[0x20]
800100a6:	5d 18       	icall	r8
800100a8:	8e 68       	ld.sh	r8,r7[0xc]
800100aa:	0a 3c       	cp.w	r12,r5
800100ac:	c2 61       	brne	800100f8 <_fflush_r+0xf4>
800100ae:	ab d8       	cbr	r8,0xb
800100b0:	30 0c       	mov	r12,0
800100b2:	6e 49       	ld.w	r9,r7[0x10]
800100b4:	ae 68       	st.h	r7[0xc],r8
800100b6:	8f 1c       	st.w	r7[0x4],r12
800100b8:	8f 09       	st.w	r7[0x0],r9
800100ba:	ed b8 00 0c 	bld	r8,0xc
800100be:	c2 51       	brne	80010108 <_fflush_r+0x104>
800100c0:	ef 45 00 54 	st.w	r7[84],r5
800100c4:	d8 22       	popm	r4-r7,pc
800100c6:	6e 45       	ld.w	r5,r7[0x10]
800100c8:	58 05       	cp.w	r5,0
800100ca:	c1 f0       	breq	80010108 <_fflush_r+0x104>
800100cc:	6e 04       	ld.w	r4,r7[0x0]
800100ce:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
800100d2:	8f 05       	st.w	r7[0x0],r5
800100d4:	f9 b8 01 00 	movne	r8,0
800100d8:	ef f8 00 05 	ld.weq	r8,r7[0x14]
800100dc:	0a 14       	sub	r4,r5
800100de:	8f 28       	st.w	r7[0x8],r8
800100e0:	c1 18       	rjmp	80010102 <_fflush_r+0xfe>
800100e2:	08 99       	mov	r9,r4
800100e4:	0a 9a       	mov	r10,r5
800100e6:	6e a8       	ld.w	r8,r7[0x28]
800100e8:	6e 8b       	ld.w	r11,r7[0x20]
800100ea:	0c 9c       	mov	r12,r6
800100ec:	5d 18       	icall	r8
800100ee:	18 14       	sub	r4,r12
800100f0:	58 0c       	cp.w	r12,0
800100f2:	e0 89 00 07 	brgt	80010100 <_fflush_r+0xfc>
800100f6:	8e 68       	ld.sh	r8,r7[0xc]
800100f8:	a7 a8       	sbr	r8,0x6
800100fa:	3f fc       	mov	r12,-1
800100fc:	ae 68       	st.h	r7[0xc],r8
800100fe:	d8 22       	popm	r4-r7,pc
80010100:	18 05       	add	r5,r12
80010102:	58 04       	cp.w	r4,0
80010104:	fe 99 ff ef 	brgt	800100e2 <_fflush_r+0xde>
80010108:	d8 2a       	popm	r4-r7,pc,r12=0
8001010a:	00 00       	add	r0,r0
8001010c:	80 01       	ld.sh	r1,r0[0x0]
8001010e:	01 e0       	ld.ub	r0,r0[0x6]
80010110:	80 01       	ld.sh	r1,r0[0x0]
80010112:	2b 3c       	sub	r12,-77
80010114:	80 01       	ld.sh	r1,r0[0x0]
80010116:	2b 5c       	sub	r12,-75
80010118:	80 01       	ld.sh	r1,r0[0x0]
8001011a:	2b 7c       	sub	r12,-73

8001011c <__sfp_lock_acquire>:
8001011c:	5e fc       	retal	r12

8001011e <__sfp_lock_release>:
8001011e:	5e fc       	retal	r12

80010120 <_cleanup_r>:
80010120:	d4 01       	pushm	lr
80010122:	48 3b       	lddpc	r11,8001012c <_cleanup_r+0xc>
80010124:	f0 1f 00 03 	mcall	80010130 <_cleanup_r+0x10>
80010128:	d8 02       	popm	pc
8001012a:	00 00       	add	r0,r0
8001012c:	80 01       	ld.sh	r1,r0[0x0]
8001012e:	1a 5c       	eor	r12,sp
80010130:	80 01       	ld.sh	r1,r0[0x0]
80010132:	07 9c       	ld.ub	r12,r3[0x1]

80010134 <__sfmoreglue>:
80010134:	d4 21       	pushm	r4-r7,lr
80010136:	16 95       	mov	r5,r11
80010138:	f6 06 10 5c 	mul	r6,r11,92
8001013c:	ec cb ff f4 	sub	r11,r6,-12
80010140:	f0 1f 00 07 	mcall	8001015c <__sfmoreglue+0x28>
80010144:	18 97       	mov	r7,r12
80010146:	c0 90       	breq	80010158 <__sfmoreglue+0x24>
80010148:	99 15       	st.w	r12[0x4],r5
8001014a:	30 0b       	mov	r11,0
8001014c:	2f 4c       	sub	r12,-12
8001014e:	0c 9a       	mov	r10,r6
80010150:	8f 2c       	st.w	r7[0x8],r12
80010152:	8f 0b       	st.w	r7[0x0],r11
80010154:	f0 1f 00 03 	mcall	80010160 <__sfmoreglue+0x2c>
80010158:	0e 9c       	mov	r12,r7
8001015a:	d8 22       	popm	r4-r7,pc
8001015c:	80 01       	ld.sh	r1,r0[0x0]
8001015e:	08 dc       	st.w	--r4,r12
80010160:	80 00       	ld.sh	r0,r0[0x0]
80010162:	ce 02       	brcc	80010122 <_cleanup_r+0x2>

80010164 <__sfp>:
80010164:	d4 21       	pushm	r4-r7,lr
80010166:	49 c8       	lddpc	r8,800101d4 <__sfp+0x70>
80010168:	18 96       	mov	r6,r12
8001016a:	70 07       	ld.w	r7,r8[0x0]
8001016c:	6e 68       	ld.w	r8,r7[0x18]
8001016e:	58 08       	cp.w	r8,0
80010170:	c0 41       	brne	80010178 <__sfp+0x14>
80010172:	0e 9c       	mov	r12,r7
80010174:	f0 1f 00 19 	mcall	800101d8 <__sfp+0x74>
80010178:	ee c7 ff 28 	sub	r7,r7,-216
8001017c:	30 05       	mov	r5,0
8001017e:	6e 2c       	ld.w	r12,r7[0x8]
80010180:	6e 18       	ld.w	r8,r7[0x4]
80010182:	c0 68       	rjmp	8001018e <__sfp+0x2a>
80010184:	98 69       	ld.sh	r9,r12[0xc]
80010186:	ea 09 19 00 	cp.h	r9,r5
8001018a:	c1 20       	breq	800101ae <__sfp+0x4a>
8001018c:	2a 4c       	sub	r12,-92
8001018e:	20 18       	sub	r8,1
80010190:	cf a7       	brpl	80010184 <__sfp+0x20>
80010192:	6e 08       	ld.w	r8,r7[0x0]
80010194:	58 08       	cp.w	r8,0
80010196:	c0 71       	brne	800101a4 <__sfp+0x40>
80010198:	30 4b       	mov	r11,4
8001019a:	0c 9c       	mov	r12,r6
8001019c:	f0 1f 00 10 	mcall	800101dc <__sfp+0x78>
800101a0:	8f 0c       	st.w	r7[0x0],r12
800101a2:	c0 30       	breq	800101a8 <__sfp+0x44>
800101a4:	6e 07       	ld.w	r7,r7[0x0]
800101a6:	ce cb       	rjmp	8001017e <__sfp+0x1a>
800101a8:	30 c8       	mov	r8,12
800101aa:	8d 38       	st.w	r6[0xc],r8
800101ac:	d8 22       	popm	r4-r7,pc
800101ae:	30 08       	mov	r8,0
800101b0:	f9 48 00 4c 	st.w	r12[76],r8
800101b4:	99 08       	st.w	r12[0x0],r8
800101b6:	99 28       	st.w	r12[0x8],r8
800101b8:	99 18       	st.w	r12[0x4],r8
800101ba:	99 48       	st.w	r12[0x10],r8
800101bc:	99 58       	st.w	r12[0x14],r8
800101be:	99 68       	st.w	r12[0x18],r8
800101c0:	99 d8       	st.w	r12[0x34],r8
800101c2:	99 e8       	st.w	r12[0x38],r8
800101c4:	f9 48 00 48 	st.w	r12[72],r8
800101c8:	3f f8       	mov	r8,-1
800101ca:	b8 78       	st.h	r12[0xe],r8
800101cc:	30 18       	mov	r8,1
800101ce:	b8 68       	st.h	r12[0xc],r8
800101d0:	d8 22       	popm	r4-r7,pc
800101d2:	00 00       	add	r0,r0
800101d4:	80 01       	ld.sh	r1,r0[0x0]
800101d6:	2b a0       	sub	r0,-70
800101d8:	80 01       	ld.sh	r1,r0[0x0]
800101da:	01 e0       	ld.ub	r0,r0[0x6]
800101dc:	80 01       	ld.sh	r1,r0[0x0]
800101de:	01 34       	ld.ub	r4,r0++

800101e0 <__sinit>:
800101e0:	d4 21       	pushm	r4-r7,lr
800101e2:	18 96       	mov	r6,r12
800101e4:	78 67       	ld.w	r7,r12[0x18]
800101e6:	58 07       	cp.w	r7,0
800101e8:	c4 71       	brne	80010276 <__sinit+0x96>
800101ea:	4a 48       	lddpc	r8,80010278 <__sinit+0x98>
800101ec:	30 15       	mov	r5,1
800101ee:	99 a8       	st.w	r12[0x28],r8
800101f0:	f9 47 00 d8 	st.w	r12[216],r7
800101f4:	f9 47 00 dc 	st.w	r12[220],r7
800101f8:	f9 47 00 e0 	st.w	r12[224],r7
800101fc:	99 65       	st.w	r12[0x18],r5
800101fe:	f0 1f 00 20 	mcall	8001027c <__sinit+0x9c>
80010202:	8d 0c       	st.w	r6[0x0],r12
80010204:	0c 9c       	mov	r12,r6
80010206:	f0 1f 00 1e 	mcall	8001027c <__sinit+0x9c>
8001020a:	8d 1c       	st.w	r6[0x4],r12
8001020c:	0c 9c       	mov	r12,r6
8001020e:	f0 1f 00 1c 	mcall	8001027c <__sinit+0x9c>
80010212:	6c 09       	ld.w	r9,r6[0x0]
80010214:	30 48       	mov	r8,4
80010216:	93 07       	st.w	r9[0x0],r7
80010218:	b2 68       	st.h	r9[0xc],r8
8001021a:	93 17       	st.w	r9[0x4],r7
8001021c:	93 27       	st.w	r9[0x8],r7
8001021e:	6c 18       	ld.w	r8,r6[0x4]
80010220:	b2 77       	st.h	r9[0xe],r7
80010222:	93 47       	st.w	r9[0x10],r7
80010224:	93 57       	st.w	r9[0x14],r7
80010226:	93 67       	st.w	r9[0x18],r7
80010228:	93 89       	st.w	r9[0x20],r9
8001022a:	91 07       	st.w	r8[0x0],r7
8001022c:	91 17       	st.w	r8[0x4],r7
8001022e:	91 27       	st.w	r8[0x8],r7
80010230:	49 4e       	lddpc	lr,80010280 <__sinit+0xa0>
80010232:	49 5b       	lddpc	r11,80010284 <__sinit+0xa4>
80010234:	93 9e       	st.w	r9[0x24],lr
80010236:	93 ab       	st.w	r9[0x28],r11
80010238:	49 4a       	lddpc	r10,80010288 <__sinit+0xa8>
8001023a:	49 54       	lddpc	r4,8001028c <__sinit+0xac>
8001023c:	93 ba       	st.w	r9[0x2c],r10
8001023e:	93 c4       	st.w	r9[0x30],r4
80010240:	30 99       	mov	r9,9
80010242:	b0 69       	st.h	r8[0xc],r9
80010244:	b0 75       	st.h	r8[0xe],r5
80010246:	91 c4       	st.w	r8[0x30],r4
80010248:	91 47       	st.w	r8[0x10],r7
8001024a:	91 57       	st.w	r8[0x14],r7
8001024c:	91 67       	st.w	r8[0x18],r7
8001024e:	91 88       	st.w	r8[0x20],r8
80010250:	91 9e       	st.w	r8[0x24],lr
80010252:	91 ab       	st.w	r8[0x28],r11
80010254:	91 ba       	st.w	r8[0x2c],r10
80010256:	8d 2c       	st.w	r6[0x8],r12
80010258:	31 28       	mov	r8,18
8001025a:	99 07       	st.w	r12[0x0],r7
8001025c:	b8 68       	st.h	r12[0xc],r8
8001025e:	99 17       	st.w	r12[0x4],r7
80010260:	99 27       	st.w	r12[0x8],r7
80010262:	30 28       	mov	r8,2
80010264:	b8 78       	st.h	r12[0xe],r8
80010266:	99 c4       	st.w	r12[0x30],r4
80010268:	99 67       	st.w	r12[0x18],r7
8001026a:	99 9e       	st.w	r12[0x24],lr
8001026c:	99 ab       	st.w	r12[0x28],r11
8001026e:	99 ba       	st.w	r12[0x2c],r10
80010270:	99 47       	st.w	r12[0x10],r7
80010272:	99 57       	st.w	r12[0x14],r7
80010274:	99 8c       	st.w	r12[0x20],r12
80010276:	d8 22       	popm	r4-r7,pc
80010278:	80 01       	ld.sh	r1,r0[0x0]
8001027a:	01 20       	ld.uh	r0,r0++
8001027c:	80 01       	ld.sh	r1,r0[0x0]
8001027e:	01 64       	ld.uh	r4,--r0
80010280:	80 01       	ld.sh	r1,r0[0x0]
80010282:	17 88       	ld.ub	r8,r11[0x0]
80010284:	80 01       	ld.sh	r1,r0[0x0]
80010286:	17 50       	ld.sh	r0,--r11
80010288:	80 01       	ld.sh	r1,r0[0x0]
8001028a:	17 28       	ld.uh	r8,r11++
8001028c:	80 01       	ld.sh	r1,r0[0x0]
8001028e:	17 18       	ld.sh	r8,r11++

80010290 <_malloc_trim_r>:
80010290:	d4 21       	pushm	r4-r7,lr
80010292:	16 95       	mov	r5,r11
80010294:	18 97       	mov	r7,r12
80010296:	f0 1f 00 23 	mcall	80010320 <_malloc_trim_r+0x90>
8001029a:	4a 34       	lddpc	r4,80010324 <_malloc_trim_r+0x94>
8001029c:	68 28       	ld.w	r8,r4[0x8]
8001029e:	70 16       	ld.w	r6,r8[0x4]
800102a0:	e0 16 ff fc 	andl	r6,0xfffc
800102a4:	ec c8 ff 91 	sub	r8,r6,-111
800102a8:	f0 05 01 05 	sub	r5,r8,r5
800102ac:	e0 15 ff 80 	andl	r5,0xff80
800102b0:	ea c5 00 80 	sub	r5,r5,128
800102b4:	e0 45 00 7f 	cp.w	r5,127
800102b8:	e0 8a 00 23 	brle	800102fe <_malloc_trim_r+0x6e>
800102bc:	30 0b       	mov	r11,0
800102be:	0e 9c       	mov	r12,r7
800102c0:	f0 1f 00 1a 	mcall	80010328 <_malloc_trim_r+0x98>
800102c4:	68 28       	ld.w	r8,r4[0x8]
800102c6:	0c 08       	add	r8,r6
800102c8:	10 3c       	cp.w	r12,r8
800102ca:	c1 a1       	brne	800102fe <_malloc_trim_r+0x6e>
800102cc:	ea 0b 11 00 	rsub	r11,r5,0
800102d0:	0e 9c       	mov	r12,r7
800102d2:	f0 1f 00 16 	mcall	80010328 <_malloc_trim_r+0x98>
800102d6:	5b fc       	cp.w	r12,-1
800102d8:	c1 71       	brne	80010306 <_malloc_trim_r+0x76>
800102da:	30 0b       	mov	r11,0
800102dc:	0e 9c       	mov	r12,r7
800102de:	f0 1f 00 13 	mcall	80010328 <_malloc_trim_r+0x98>
800102e2:	68 28       	ld.w	r8,r4[0x8]
800102e4:	f8 08 01 09 	sub	r9,r12,r8
800102e8:	58 f9       	cp.w	r9,15
800102ea:	e0 8a 00 0a 	brle	800102fe <_malloc_trim_r+0x6e>
800102ee:	a1 a9       	sbr	r9,0x0
800102f0:	91 19       	st.w	r8[0x4],r9
800102f2:	48 f8       	lddpc	r8,8001032c <_malloc_trim_r+0x9c>
800102f4:	70 09       	ld.w	r9,r8[0x0]
800102f6:	48 f8       	lddpc	r8,80010330 <_malloc_trim_r+0xa0>
800102f8:	f8 09 01 09 	sub	r9,r12,r9
800102fc:	91 09       	st.w	r8[0x0],r9
800102fe:	0e 9c       	mov	r12,r7
80010300:	f0 1f 00 0d 	mcall	80010334 <_malloc_trim_r+0xa4>
80010304:	d8 2a       	popm	r4-r7,pc,r12=0
80010306:	68 28       	ld.w	r8,r4[0x8]
80010308:	0a 16       	sub	r6,r5
8001030a:	a1 a6       	sbr	r6,0x0
8001030c:	91 16       	st.w	r8[0x4],r6
8001030e:	48 98       	lddpc	r8,80010330 <_malloc_trim_r+0xa0>
80010310:	70 09       	ld.w	r9,r8[0x0]
80010312:	0a 19       	sub	r9,r5
80010314:	0e 9c       	mov	r12,r7
80010316:	91 09       	st.w	r8[0x0],r9
80010318:	f0 1f 00 07 	mcall	80010334 <_malloc_trim_r+0xa4>
8001031c:	da 2a       	popm	r4-r7,pc,r12=1
8001031e:	00 00       	add	r0,r0
80010320:	80 01       	ld.sh	r1,r0[0x0]
80010322:	0d 80       	ld.ub	r0,r6[0x0]
80010324:	00 00       	add	r0,r0
80010326:	01 ac       	ld.ub	r12,r0[0x2]
80010328:	80 01       	ld.sh	r1,r0[0x0]
8001032a:	16 f0       	st.b	--r11,r0
8001032c:	00 00       	add	r0,r0
8001032e:	05 b8       	ld.ub	r8,r2[0x3]
80010330:	00 00       	add	r0,r0
80010332:	07 e4       	ld.ub	r4,r3[0x6]
80010334:	80 01       	ld.sh	r1,r0[0x0]
80010336:	0d 82       	ld.ub	r2,r6[0x0]

80010338 <_free_r>:
80010338:	d4 21       	pushm	r4-r7,lr
8001033a:	16 96       	mov	r6,r11
8001033c:	18 97       	mov	r7,r12
8001033e:	58 0b       	cp.w	r11,0
80010340:	e0 80 00 c8 	breq	800104d0 <_free_r+0x198>
80010344:	f0 1f 00 4c 	mcall	80010474 <_free_r+0x13c>
80010348:	20 86       	sub	r6,8
8001034a:	4c ca       	lddpc	r10,80010478 <_free_r+0x140>
8001034c:	6c 18       	ld.w	r8,r6[0x4]
8001034e:	74 2e       	ld.w	lr,r10[0x8]
80010350:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80010354:	a1 c8       	cbr	r8,0x0
80010356:	ec 08 00 09 	add	r9,r6,r8
8001035a:	72 1b       	ld.w	r11,r9[0x4]
8001035c:	e0 1b ff fc 	andl	r11,0xfffc
80010360:	1c 39       	cp.w	r9,lr
80010362:	c1 d1       	brne	8001039c <_free_r+0x64>
80010364:	f6 08 00 08 	add	r8,r11,r8
80010368:	58 0c       	cp.w	r12,0
8001036a:	c0 81       	brne	8001037a <_free_r+0x42>
8001036c:	6c 09       	ld.w	r9,r6[0x0]
8001036e:	12 16       	sub	r6,r9
80010370:	12 08       	add	r8,r9
80010372:	6c 3b       	ld.w	r11,r6[0xc]
80010374:	6c 29       	ld.w	r9,r6[0x8]
80010376:	97 29       	st.w	r11[0x8],r9
80010378:	93 3b       	st.w	r9[0xc],r11
8001037a:	10 99       	mov	r9,r8
8001037c:	95 26       	st.w	r10[0x8],r6
8001037e:	a1 a9       	sbr	r9,0x0
80010380:	8d 19       	st.w	r6[0x4],r9
80010382:	4b f9       	lddpc	r9,8001047c <_free_r+0x144>
80010384:	72 09       	ld.w	r9,r9[0x0]
80010386:	12 38       	cp.w	r8,r9
80010388:	c0 63       	brcs	80010394 <_free_r+0x5c>
8001038a:	4b e8       	lddpc	r8,80010480 <_free_r+0x148>
8001038c:	0e 9c       	mov	r12,r7
8001038e:	70 0b       	ld.w	r11,r8[0x0]
80010390:	f0 1f 00 3d 	mcall	80010484 <_free_r+0x14c>
80010394:	0e 9c       	mov	r12,r7
80010396:	f0 1f 00 3d 	mcall	80010488 <_free_r+0x150>
8001039a:	d8 22       	popm	r4-r7,pc
8001039c:	93 1b       	st.w	r9[0x4],r11
8001039e:	58 0c       	cp.w	r12,0
800103a0:	c0 30       	breq	800103a6 <_free_r+0x6e>
800103a2:	30 0c       	mov	r12,0
800103a4:	c1 08       	rjmp	800103c4 <_free_r+0x8c>
800103a6:	6c 0e       	ld.w	lr,r6[0x0]
800103a8:	f4 c5 ff f8 	sub	r5,r10,-8
800103ac:	1c 16       	sub	r6,lr
800103ae:	1c 08       	add	r8,lr
800103b0:	6c 2e       	ld.w	lr,r6[0x8]
800103b2:	0a 3e       	cp.w	lr,r5
800103b4:	f9 bc 00 01 	moveq	r12,1
800103b8:	ed f5 10 03 	ld.wne	r5,r6[0xc]
800103bc:	eb fe 1a 02 	st.wne	r5[0x8],lr
800103c0:	fd f5 1a 03 	st.wne	lr[0xc],r5
800103c4:	f2 0b 00 0e 	add	lr,r9,r11
800103c8:	7c 1e       	ld.w	lr,lr[0x4]
800103ca:	ed be 00 00 	bld	lr,0x0
800103ce:	c1 30       	breq	800103f4 <_free_r+0xbc>
800103d0:	16 08       	add	r8,r11
800103d2:	58 0c       	cp.w	r12,0
800103d4:	c0 c1       	brne	800103ec <_free_r+0xb4>
800103d6:	4a 9e       	lddpc	lr,80010478 <_free_r+0x140>
800103d8:	72 2b       	ld.w	r11,r9[0x8]
800103da:	2f 8e       	sub	lr,-8
800103dc:	1c 3b       	cp.w	r11,lr
800103de:	c0 71       	brne	800103ec <_free_r+0xb4>
800103e0:	97 36       	st.w	r11[0xc],r6
800103e2:	97 26       	st.w	r11[0x8],r6
800103e4:	8d 2b       	st.w	r6[0x8],r11
800103e6:	8d 3b       	st.w	r6[0xc],r11
800103e8:	30 1c       	mov	r12,1
800103ea:	c0 58       	rjmp	800103f4 <_free_r+0xbc>
800103ec:	72 2b       	ld.w	r11,r9[0x8]
800103ee:	72 39       	ld.w	r9,r9[0xc]
800103f0:	93 2b       	st.w	r9[0x8],r11
800103f2:	97 39       	st.w	r11[0xc],r9
800103f4:	10 99       	mov	r9,r8
800103f6:	ec 08 09 08 	st.w	r6[r8],r8
800103fa:	a1 a9       	sbr	r9,0x0
800103fc:	8d 19       	st.w	r6[0x4],r9
800103fe:	58 0c       	cp.w	r12,0
80010400:	c6 51       	brne	800104ca <_free_r+0x192>
80010402:	e0 48 01 ff 	cp.w	r8,511
80010406:	e0 8b 00 13 	brhi	8001042c <_free_r+0xf4>
8001040a:	a3 98       	lsr	r8,0x3
8001040c:	f4 08 00 39 	add	r9,r10,r8<<0x3
80010410:	72 2b       	ld.w	r11,r9[0x8]
80010412:	8d 39       	st.w	r6[0xc],r9
80010414:	8d 2b       	st.w	r6[0x8],r11
80010416:	97 36       	st.w	r11[0xc],r6
80010418:	93 26       	st.w	r9[0x8],r6
8001041a:	a3 48       	asr	r8,0x2
8001041c:	74 19       	ld.w	r9,r10[0x4]
8001041e:	30 1b       	mov	r11,1
80010420:	f6 08 09 48 	lsl	r8,r11,r8
80010424:	f3 e8 10 08 	or	r8,r9,r8
80010428:	95 18       	st.w	r10[0x4],r8
8001042a:	c5 08       	rjmp	800104ca <_free_r+0x192>
8001042c:	f0 0b 16 09 	lsr	r11,r8,0x9
80010430:	58 4b       	cp.w	r11,4
80010432:	e0 8b 00 06 	brhi	8001043e <_free_r+0x106>
80010436:	f0 0b 16 06 	lsr	r11,r8,0x6
8001043a:	2c 8b       	sub	r11,-56
8001043c:	c2 b8       	rjmp	80010492 <_free_r+0x15a>
8001043e:	59 4b       	cp.w	r11,20
80010440:	e0 8b 00 04 	brhi	80010448 <_free_r+0x110>
80010444:	2a 5b       	sub	r11,-91
80010446:	c2 68       	rjmp	80010492 <_free_r+0x15a>
80010448:	e0 4b 00 54 	cp.w	r11,84
8001044c:	e0 8b 00 06 	brhi	80010458 <_free_r+0x120>
80010450:	f0 0b 16 0c 	lsr	r11,r8,0xc
80010454:	29 2b       	sub	r11,-110
80010456:	c1 e8       	rjmp	80010492 <_free_r+0x15a>
80010458:	e0 4b 01 54 	cp.w	r11,340
8001045c:	e0 8b 00 06 	brhi	80010468 <_free_r+0x130>
80010460:	f0 0b 16 0f 	lsr	r11,r8,0xf
80010464:	28 9b       	sub	r11,-119
80010466:	c1 68       	rjmp	80010492 <_free_r+0x15a>
80010468:	e0 4b 05 54 	cp.w	r11,1364
8001046c:	e0 88 00 10 	brls	8001048c <_free_r+0x154>
80010470:	37 eb       	mov	r11,126
80010472:	c1 08       	rjmp	80010492 <_free_r+0x15a>
80010474:	80 01       	ld.sh	r1,r0[0x0]
80010476:	0d 80       	ld.ub	r0,r6[0x0]
80010478:	00 00       	add	r0,r0
8001047a:	01 ac       	ld.ub	r12,r0[0x2]
8001047c:	00 00       	add	r0,r0
8001047e:	05 b4       	ld.ub	r4,r2[0x3]
80010480:	00 00       	add	r0,r0
80010482:	07 e0       	ld.ub	r0,r3[0x6]
80010484:	80 01       	ld.sh	r1,r0[0x0]
80010486:	02 90       	mov	r0,r1
80010488:	80 01       	ld.sh	r1,r0[0x0]
8001048a:	0d 82       	ld.ub	r2,r6[0x0]
8001048c:	f0 0b 16 12 	lsr	r11,r8,0x12
80010490:	28 4b       	sub	r11,-124
80010492:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
80010496:	78 29       	ld.w	r9,r12[0x8]
80010498:	18 39       	cp.w	r9,r12
8001049a:	c0 e1       	brne	800104b6 <_free_r+0x17e>
8001049c:	74 18       	ld.w	r8,r10[0x4]
8001049e:	a3 4b       	asr	r11,0x2
800104a0:	30 1c       	mov	r12,1
800104a2:	f8 0b 09 4b 	lsl	r11,r12,r11
800104a6:	f1 eb 10 0b 	or	r11,r8,r11
800104aa:	12 98       	mov	r8,r9
800104ac:	95 1b       	st.w	r10[0x4],r11
800104ae:	c0 a8       	rjmp	800104c2 <_free_r+0x18a>
800104b0:	72 29       	ld.w	r9,r9[0x8]
800104b2:	18 39       	cp.w	r9,r12
800104b4:	c0 60       	breq	800104c0 <_free_r+0x188>
800104b6:	72 1a       	ld.w	r10,r9[0x4]
800104b8:	e0 1a ff fc 	andl	r10,0xfffc
800104bc:	14 38       	cp.w	r8,r10
800104be:	cf 93       	brcs	800104b0 <_free_r+0x178>
800104c0:	72 38       	ld.w	r8,r9[0xc]
800104c2:	8d 38       	st.w	r6[0xc],r8
800104c4:	8d 29       	st.w	r6[0x8],r9
800104c6:	93 36       	st.w	r9[0xc],r6
800104c8:	91 26       	st.w	r8[0x8],r6
800104ca:	0e 9c       	mov	r12,r7
800104cc:	f0 1f 00 02 	mcall	800104d4 <_free_r+0x19c>
800104d0:	d8 22       	popm	r4-r7,pc
800104d2:	00 00       	add	r0,r0
800104d4:	80 01       	ld.sh	r1,r0[0x0]
800104d6:	0d 82       	ld.ub	r2,r6[0x0]

800104d8 <__sfvwrite_r>:
800104d8:	d4 31       	pushm	r0-r7,lr
800104da:	20 3d       	sub	sp,12
800104dc:	14 94       	mov	r4,r10
800104de:	18 95       	mov	r5,r12
800104e0:	16 97       	mov	r7,r11
800104e2:	74 28       	ld.w	r8,r10[0x8]
800104e4:	58 08       	cp.w	r8,0
800104e6:	e0 80 01 47 	breq	80010774 <__sfvwrite_r+0x29c>
800104ea:	96 68       	ld.sh	r8,r11[0xc]
800104ec:	ed b8 00 03 	bld	r8,0x3
800104f0:	c0 41       	brne	800104f8 <__sfvwrite_r+0x20>
800104f2:	76 48       	ld.w	r8,r11[0x10]
800104f4:	58 08       	cp.w	r8,0
800104f6:	c0 c1       	brne	8001050e <__sfvwrite_r+0x36>
800104f8:	0e 9b       	mov	r11,r7
800104fa:	0a 9c       	mov	r12,r5
800104fc:	f0 1f 00 a0 	mcall	8001077c <__sfvwrite_r+0x2a4>
80010500:	c0 70       	breq	8001050e <__sfvwrite_r+0x36>
80010502:	8e 68       	ld.sh	r8,r7[0xc]
80010504:	a7 a8       	sbr	r8,0x6
80010506:	ae 68       	st.h	r7[0xc],r8
80010508:	30 98       	mov	r8,9
8001050a:	8b 38       	st.w	r5[0xc],r8
8001050c:	c3 29       	rjmp	80010770 <__sfvwrite_r+0x298>
8001050e:	8e 63       	ld.sh	r3,r7[0xc]
80010510:	68 00       	ld.w	r0,r4[0x0]
80010512:	06 96       	mov	r6,r3
80010514:	e2 16 00 02 	andl	r6,0x2,COH
80010518:	c2 10       	breq	8001055a <__sfvwrite_r+0x82>
8001051a:	30 03       	mov	r3,0
8001051c:	e0 62 04 00 	mov	r2,1024
80010520:	06 96       	mov	r6,r3
80010522:	c0 48       	rjmp	8001052a <__sfvwrite_r+0x52>
80010524:	60 03       	ld.w	r3,r0[0x0]
80010526:	60 16       	ld.w	r6,r0[0x4]
80010528:	2f 80       	sub	r0,-8
8001052a:	58 06       	cp.w	r6,0
8001052c:	cf c0       	breq	80010524 <__sfvwrite_r+0x4c>
8001052e:	e0 46 04 00 	cp.w	r6,1024
80010532:	ec 09 17 80 	movls	r9,r6
80010536:	e4 09 17 b0 	movhi	r9,r2
8001053a:	06 9a       	mov	r10,r3
8001053c:	6e a8       	ld.w	r8,r7[0x28]
8001053e:	6e 8b       	ld.w	r11,r7[0x20]
80010540:	0a 9c       	mov	r12,r5
80010542:	5d 18       	icall	r8
80010544:	18 16       	sub	r6,r12
80010546:	58 0c       	cp.w	r12,0
80010548:	e0 8a 01 11 	brle	8001076a <__sfvwrite_r+0x292>
8001054c:	68 28       	ld.w	r8,r4[0x8]
8001054e:	18 18       	sub	r8,r12
80010550:	89 28       	st.w	r4[0x8],r8
80010552:	e0 80 01 11 	breq	80010774 <__sfvwrite_r+0x29c>
80010556:	18 03       	add	r3,r12
80010558:	ce 9b       	rjmp	8001052a <__sfvwrite_r+0x52>
8001055a:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8001055e:	c0 70       	breq	8001056c <__sfvwrite_r+0x94>
80010560:	50 06       	stdsp	sp[0x0],r6
80010562:	0c 93       	mov	r3,r6
80010564:	0c 91       	mov	r1,r6
80010566:	50 15       	stdsp	sp[0x4],r5
80010568:	08 92       	mov	r2,r4
8001056a:	ca 08       	rjmp	800106aa <__sfvwrite_r+0x1d2>
8001056c:	06 96       	mov	r6,r3
8001056e:	08 91       	mov	r1,r4
80010570:	c0 48       	rjmp	80010578 <__sfvwrite_r+0xa0>
80010572:	60 03       	ld.w	r3,r0[0x0]
80010574:	60 16       	ld.w	r6,r0[0x4]
80010576:	2f 80       	sub	r0,-8
80010578:	58 06       	cp.w	r6,0
8001057a:	cf c0       	breq	80010572 <__sfvwrite_r+0x9a>
8001057c:	8e 68       	ld.sh	r8,r7[0xc]
8001057e:	6e 24       	ld.w	r4,r7[0x8]
80010580:	10 99       	mov	r9,r8
80010582:	e2 19 02 00 	andl	r9,0x200,COH
80010586:	c5 70       	breq	80010634 <__sfvwrite_r+0x15c>
80010588:	08 36       	cp.w	r6,r4
8001058a:	c4 53       	brcs	80010614 <__sfvwrite_r+0x13c>
8001058c:	10 99       	mov	r9,r8
8001058e:	e2 19 04 80 	andl	r9,0x480,COH
80010592:	c4 10       	breq	80010614 <__sfvwrite_r+0x13c>
80010594:	6e 4b       	ld.w	r11,r7[0x10]
80010596:	6e 09       	ld.w	r9,r7[0x0]
80010598:	16 19       	sub	r9,r11
8001059a:	50 09       	stdsp	sp[0x0],r9
8001059c:	6e 59       	ld.w	r9,r7[0x14]
8001059e:	10 9c       	mov	r12,r8
800105a0:	f2 09 00 1a 	add	r10,r9,r9<<0x1
800105a4:	30 28       	mov	r8,2
800105a6:	f4 08 0c 08 	divs	r8,r10,r8
800105aa:	fa e9 00 04 	st.d	sp[4],r8
800105ae:	10 94       	mov	r4,r8
800105b0:	40 09       	lddsp	r9,sp[0x0]
800105b2:	e2 1c 04 00 	andl	r12,0x400,COH
800105b6:	2f f9       	sub	r9,-1
800105b8:	0c 09       	add	r9,r6
800105ba:	12 38       	cp.w	r8,r9
800105bc:	f2 04 17 30 	movlo	r4,r9
800105c0:	58 0c       	cp.w	r12,0
800105c2:	c1 10       	breq	800105e4 <__sfvwrite_r+0x10c>
800105c4:	08 9b       	mov	r11,r4
800105c6:	0a 9c       	mov	r12,r5
800105c8:	f0 1f 00 6e 	mcall	80010780 <__sfvwrite_r+0x2a8>
800105cc:	18 92       	mov	r2,r12
800105ce:	c1 50       	breq	800105f8 <__sfvwrite_r+0x120>
800105d0:	40 0a       	lddsp	r10,sp[0x0]
800105d2:	6e 4b       	ld.w	r11,r7[0x10]
800105d4:	f0 1f 00 6c 	mcall	80010784 <__sfvwrite_r+0x2ac>
800105d8:	8e 68       	ld.sh	r8,r7[0xc]
800105da:	e0 18 fb 7f 	andl	r8,0xfb7f
800105de:	a7 b8       	sbr	r8,0x7
800105e0:	ae 68       	st.h	r7[0xc],r8
800105e2:	c0 e8       	rjmp	800105fe <__sfvwrite_r+0x126>
800105e4:	08 9a       	mov	r10,r4
800105e6:	0a 9c       	mov	r12,r5
800105e8:	f0 1f 00 68 	mcall	80010788 <__sfvwrite_r+0x2b0>
800105ec:	18 92       	mov	r2,r12
800105ee:	c0 81       	brne	800105fe <__sfvwrite_r+0x126>
800105f0:	6e 4b       	ld.w	r11,r7[0x10]
800105f2:	0a 9c       	mov	r12,r5
800105f4:	f0 1f 00 66 	mcall	8001078c <__sfvwrite_r+0x2b4>
800105f8:	30 c8       	mov	r8,12
800105fa:	8b 38       	st.w	r5[0xc],r8
800105fc:	cb 78       	rjmp	8001076a <__sfvwrite_r+0x292>
800105fe:	40 0a       	lddsp	r10,sp[0x0]
80010600:	40 09       	lddsp	r9,sp[0x0]
80010602:	e8 0a 01 0a 	sub	r10,r4,r10
80010606:	e4 09 00 08 	add	r8,r2,r9
8001060a:	8f 54       	st.w	r7[0x14],r4
8001060c:	8f 2a       	st.w	r7[0x8],r10
8001060e:	8f 08       	st.w	r7[0x0],r8
80010610:	8f 42       	st.w	r7[0x10],r2
80010612:	0c 94       	mov	r4,r6
80010614:	08 36       	cp.w	r6,r4
80010616:	ec 04 17 30 	movlo	r4,r6
8001061a:	06 9b       	mov	r11,r3
8001061c:	08 9a       	mov	r10,r4
8001061e:	6e 0c       	ld.w	r12,r7[0x0]
80010620:	f0 1f 00 5c 	mcall	80010790 <__sfvwrite_r+0x2b8>
80010624:	6e 08       	ld.w	r8,r7[0x0]
80010626:	08 08       	add	r8,r4
80010628:	8f 08       	st.w	r7[0x0],r8
8001062a:	6e 28       	ld.w	r8,r7[0x8]
8001062c:	08 18       	sub	r8,r4
8001062e:	0c 94       	mov	r4,r6
80010630:	8f 28       	st.w	r7[0x8],r8
80010632:	c3 08       	rjmp	80010692 <__sfvwrite_r+0x1ba>
80010634:	08 36       	cp.w	r6,r4
80010636:	5f ba       	srhi	r10
80010638:	6e 0c       	ld.w	r12,r7[0x0]
8001063a:	6e 48       	ld.w	r8,r7[0x10]
8001063c:	10 3c       	cp.w	r12,r8
8001063e:	5f b8       	srhi	r8
80010640:	f5 e8 00 08 	and	r8,r10,r8
80010644:	f2 08 18 00 	cp.b	r8,r9
80010648:	c0 e0       	breq	80010664 <__sfvwrite_r+0x18c>
8001064a:	06 9b       	mov	r11,r3
8001064c:	08 9a       	mov	r10,r4
8001064e:	f0 1f 00 51 	mcall	80010790 <__sfvwrite_r+0x2b8>
80010652:	6e 08       	ld.w	r8,r7[0x0]
80010654:	08 08       	add	r8,r4
80010656:	0e 9b       	mov	r11,r7
80010658:	8f 08       	st.w	r7[0x0],r8
8001065a:	0a 9c       	mov	r12,r5
8001065c:	f0 1f 00 4e 	mcall	80010794 <__sfvwrite_r+0x2bc>
80010660:	c1 90       	breq	80010692 <__sfvwrite_r+0x1ba>
80010662:	c8 48       	rjmp	8001076a <__sfvwrite_r+0x292>
80010664:	6e 59       	ld.w	r9,r7[0x14]
80010666:	12 36       	cp.w	r6,r9
80010668:	c0 a3       	brcs	8001067c <__sfvwrite_r+0x1a4>
8001066a:	6e a8       	ld.w	r8,r7[0x28]
8001066c:	06 9a       	mov	r10,r3
8001066e:	6e 8b       	ld.w	r11,r7[0x20]
80010670:	0a 9c       	mov	r12,r5
80010672:	5d 18       	icall	r8
80010674:	18 94       	mov	r4,r12
80010676:	e0 89 00 0e 	brgt	80010692 <__sfvwrite_r+0x1ba>
8001067a:	c7 88       	rjmp	8001076a <__sfvwrite_r+0x292>
8001067c:	0c 9a       	mov	r10,r6
8001067e:	06 9b       	mov	r11,r3
80010680:	f0 1f 00 44 	mcall	80010790 <__sfvwrite_r+0x2b8>
80010684:	6e 08       	ld.w	r8,r7[0x0]
80010686:	0c 08       	add	r8,r6
80010688:	0c 94       	mov	r4,r6
8001068a:	8f 08       	st.w	r7[0x0],r8
8001068c:	6e 28       	ld.w	r8,r7[0x8]
8001068e:	0c 18       	sub	r8,r6
80010690:	8f 28       	st.w	r7[0x8],r8
80010692:	62 28       	ld.w	r8,r1[0x8]
80010694:	08 18       	sub	r8,r4
80010696:	83 28       	st.w	r1[0x8],r8
80010698:	c6 e0       	breq	80010774 <__sfvwrite_r+0x29c>
8001069a:	08 16       	sub	r6,r4
8001069c:	08 03       	add	r3,r4
8001069e:	c6 db       	rjmp	80010578 <__sfvwrite_r+0xa0>
800106a0:	60 03       	ld.w	r3,r0[0x0]
800106a2:	60 11       	ld.w	r1,r0[0x4]
800106a4:	30 08       	mov	r8,0
800106a6:	2f 80       	sub	r0,-8
800106a8:	50 08       	stdsp	sp[0x0],r8
800106aa:	58 01       	cp.w	r1,0
800106ac:	cf a0       	breq	800106a0 <__sfvwrite_r+0x1c8>
800106ae:	40 0a       	lddsp	r10,sp[0x0]
800106b0:	58 0a       	cp.w	r10,0
800106b2:	c1 51       	brne	800106dc <__sfvwrite_r+0x204>
800106b4:	e2 c6 ff ff 	sub	r6,r1,-1
800106b8:	02 9a       	mov	r10,r1
800106ba:	30 ab       	mov	r11,10
800106bc:	06 9c       	mov	r12,r3
800106be:	f0 1f 00 37 	mcall	80010798 <__sfvwrite_r+0x2c0>
800106c2:	f8 c8 ff ff 	sub	r8,r12,-1
800106c6:	58 0c       	cp.w	r12,0
800106c8:	f1 d3 e1 16 	subne	r6,r8,r3
800106cc:	f9 b9 01 01 	movne	r9,1
800106d0:	fb f9 1a 00 	st.wne	sp[0x0],r9
800106d4:	f9 b8 00 01 	moveq	r8,1
800106d8:	fb f8 0a 00 	st.weq	sp[0x0],r8
800106dc:	02 36       	cp.w	r6,r1
800106de:	ec 04 17 80 	movls	r4,r6
800106e2:	e2 04 17 b0 	movhi	r4,r1
800106e6:	6e 59       	ld.w	r9,r7[0x14]
800106e8:	6e 25       	ld.w	r5,r7[0x8]
800106ea:	f2 05 00 05 	add	r5,r9,r5
800106ee:	0a 34       	cp.w	r4,r5
800106f0:	5f 9a       	srgt	r10
800106f2:	6e 0c       	ld.w	r12,r7[0x0]
800106f4:	6e 48       	ld.w	r8,r7[0x10]
800106f6:	10 3c       	cp.w	r12,r8
800106f8:	5f b8       	srhi	r8
800106fa:	f5 e8 00 08 	and	r8,r10,r8
800106fe:	30 0a       	mov	r10,0
80010700:	f4 08 18 00 	cp.b	r8,r10
80010704:	c0 e0       	breq	80010720 <__sfvwrite_r+0x248>
80010706:	06 9b       	mov	r11,r3
80010708:	0a 9a       	mov	r10,r5
8001070a:	f0 1f 00 22 	mcall	80010790 <__sfvwrite_r+0x2b8>
8001070e:	6e 08       	ld.w	r8,r7[0x0]
80010710:	0a 08       	add	r8,r5
80010712:	0e 9b       	mov	r11,r7
80010714:	8f 08       	st.w	r7[0x0],r8
80010716:	40 1c       	lddsp	r12,sp[0x4]
80010718:	f0 1f 00 1f 	mcall	80010794 <__sfvwrite_r+0x2bc>
8001071c:	c1 80       	breq	8001074c <__sfvwrite_r+0x274>
8001071e:	c2 68       	rjmp	8001076a <__sfvwrite_r+0x292>
80010720:	12 34       	cp.w	r4,r9
80010722:	c0 a5       	brlt	80010736 <__sfvwrite_r+0x25e>
80010724:	6e a8       	ld.w	r8,r7[0x28]
80010726:	06 9a       	mov	r10,r3
80010728:	6e 8b       	ld.w	r11,r7[0x20]
8001072a:	40 1c       	lddsp	r12,sp[0x4]
8001072c:	5d 18       	icall	r8
8001072e:	18 95       	mov	r5,r12
80010730:	e0 89 00 0e 	brgt	8001074c <__sfvwrite_r+0x274>
80010734:	c1 b8       	rjmp	8001076a <__sfvwrite_r+0x292>
80010736:	08 9a       	mov	r10,r4
80010738:	06 9b       	mov	r11,r3
8001073a:	f0 1f 00 16 	mcall	80010790 <__sfvwrite_r+0x2b8>
8001073e:	6e 08       	ld.w	r8,r7[0x0]
80010740:	08 08       	add	r8,r4
80010742:	08 95       	mov	r5,r4
80010744:	8f 08       	st.w	r7[0x0],r8
80010746:	6e 28       	ld.w	r8,r7[0x8]
80010748:	08 18       	sub	r8,r4
8001074a:	8f 28       	st.w	r7[0x8],r8
8001074c:	0a 16       	sub	r6,r5
8001074e:	c0 71       	brne	8001075c <__sfvwrite_r+0x284>
80010750:	0e 9b       	mov	r11,r7
80010752:	40 1c       	lddsp	r12,sp[0x4]
80010754:	f0 1f 00 10 	mcall	80010794 <__sfvwrite_r+0x2bc>
80010758:	c0 91       	brne	8001076a <__sfvwrite_r+0x292>
8001075a:	50 06       	stdsp	sp[0x0],r6
8001075c:	64 28       	ld.w	r8,r2[0x8]
8001075e:	0a 18       	sub	r8,r5
80010760:	85 28       	st.w	r2[0x8],r8
80010762:	c0 90       	breq	80010774 <__sfvwrite_r+0x29c>
80010764:	0a 11       	sub	r1,r5
80010766:	0a 03       	add	r3,r5
80010768:	ca 1b       	rjmp	800106aa <__sfvwrite_r+0x1d2>
8001076a:	8e 68       	ld.sh	r8,r7[0xc]
8001076c:	a7 a8       	sbr	r8,0x6
8001076e:	ae 68       	st.h	r7[0xc],r8
80010770:	3f fc       	mov	r12,-1
80010772:	c0 28       	rjmp	80010776 <__sfvwrite_r+0x29e>
80010774:	30 0c       	mov	r12,0
80010776:	2f dd       	sub	sp,-12
80010778:	d8 32       	popm	r0-r7,pc
8001077a:	00 00       	add	r0,r0
8001077c:	80 00       	ld.sh	r0,r0[0x0]
8001077e:	f1 68 80 01 	st.b	r8[-32767],r8
80010782:	08 dc       	st.w	--r4,r12
80010784:	80 00       	ld.sh	r0,r0[0x0]
80010786:	cc ba       	rjmp	8001051c <__sfvwrite_r+0x44>
80010788:	80 01       	ld.sh	r1,r0[0x0]
8001078a:	13 c8       	ld.ub	r8,r9[0x4]
8001078c:	80 01       	ld.sh	r1,r0[0x0]
8001078e:	03 38       	ld.ub	r8,r1++
80010790:	80 01       	ld.sh	r1,r0[0x0]
80010792:	0d 42       	ld.w	r2,--r6
80010794:	80 01       	ld.sh	r1,r0[0x0]
80010796:	00 04       	add	r4,r0
80010798:	80 01       	ld.sh	r1,r0[0x0]
8001079a:	0d 2c       	ld.uh	r12,r6++

8001079c <_fwalk>:
8001079c:	d4 31       	pushm	r0-r7,lr
8001079e:	30 05       	mov	r5,0
800107a0:	16 91       	mov	r1,r11
800107a2:	f8 c7 ff 28 	sub	r7,r12,-216
800107a6:	0a 92       	mov	r2,r5
800107a8:	f0 1f 00 10 	mcall	800107e8 <_fwalk+0x4c>
800107ac:	3f f3       	mov	r3,-1
800107ae:	c1 68       	rjmp	800107da <_fwalk+0x3e>
800107b0:	6e 26       	ld.w	r6,r7[0x8]
800107b2:	6e 14       	ld.w	r4,r7[0x4]
800107b4:	2f 46       	sub	r6,-12
800107b6:	c0 c8       	rjmp	800107ce <_fwalk+0x32>
800107b8:	8c 08       	ld.sh	r8,r6[0x0]
800107ba:	e4 08 19 00 	cp.h	r8,r2
800107be:	c0 70       	breq	800107cc <_fwalk+0x30>
800107c0:	8c 18       	ld.sh	r8,r6[0x2]
800107c2:	e6 08 19 00 	cp.h	r8,r3
800107c6:	c0 30       	breq	800107cc <_fwalk+0x30>
800107c8:	5d 11       	icall	r1
800107ca:	18 45       	or	r5,r12
800107cc:	2a 46       	sub	r6,-92
800107ce:	20 14       	sub	r4,1
800107d0:	ec cc 00 0c 	sub	r12,r6,12
800107d4:	58 04       	cp.w	r4,0
800107d6:	cf 14       	brge	800107b8 <_fwalk+0x1c>
800107d8:	6e 07       	ld.w	r7,r7[0x0]
800107da:	58 07       	cp.w	r7,0
800107dc:	ce a1       	brne	800107b0 <_fwalk+0x14>
800107de:	f0 1f 00 04 	mcall	800107ec <_fwalk+0x50>
800107e2:	0a 9c       	mov	r12,r5
800107e4:	d8 32       	popm	r0-r7,pc
800107e6:	00 00       	add	r0,r0
800107e8:	80 01       	ld.sh	r1,r0[0x0]
800107ea:	01 1c       	ld.sh	r12,r0++
800107ec:	80 01       	ld.sh	r1,r0[0x0]
800107ee:	01 1e       	ld.sh	lr,r0++

800107f0 <_localeconv_r>:
800107f0:	48 1c       	lddpc	r12,800107f4 <_localeconv_r+0x4>
800107f2:	5e fc       	retal	r12
800107f4:	80 01       	ld.sh	r1,r0[0x0]
800107f6:	2b a4       	sub	r4,-70

800107f8 <__smakebuf_r>:
800107f8:	d4 21       	pushm	r4-r7,lr
800107fa:	20 fd       	sub	sp,60
800107fc:	96 68       	ld.sh	r8,r11[0xc]
800107fe:	16 97       	mov	r7,r11
80010800:	18 96       	mov	r6,r12
80010802:	e2 18 00 02 	andl	r8,0x2,COH
80010806:	c3 c1       	brne	8001087e <__smakebuf_r+0x86>
80010808:	96 7b       	ld.sh	r11,r11[0xe]
8001080a:	f0 0b 19 00 	cp.h	r11,r8
8001080e:	c0 55       	brlt	80010818 <__smakebuf_r+0x20>
80010810:	1a 9a       	mov	r10,sp
80010812:	f0 1f 00 28 	mcall	800108b0 <__smakebuf_r+0xb8>
80010816:	c0 f4       	brge	80010834 <__smakebuf_r+0x3c>
80010818:	8e 65       	ld.sh	r5,r7[0xc]
8001081a:	0a 98       	mov	r8,r5
8001081c:	ab b8       	sbr	r8,0xb
8001081e:	e2 15 00 80 	andl	r5,0x80,COH
80010822:	ae 68       	st.h	r7[0xc],r8
80010824:	30 04       	mov	r4,0
80010826:	e0 68 04 00 	mov	r8,1024
8001082a:	f9 b5 01 40 	movne	r5,64
8001082e:	f0 05 17 00 	moveq	r5,r8
80010832:	c1 b8       	rjmp	80010868 <__smakebuf_r+0x70>
80010834:	40 18       	lddsp	r8,sp[0x4]
80010836:	e2 18 f0 00 	andl	r8,0xf000,COH
8001083a:	e0 48 20 00 	cp.w	r8,8192
8001083e:	5f 04       	sreq	r4
80010840:	e0 48 80 00 	cp.w	r8,32768
80010844:	c0 d1       	brne	8001085e <__smakebuf_r+0x66>
80010846:	6e b9       	ld.w	r9,r7[0x2c]
80010848:	49 b8       	lddpc	r8,800108b4 <__smakebuf_r+0xbc>
8001084a:	10 39       	cp.w	r9,r8
8001084c:	c0 91       	brne	8001085e <__smakebuf_r+0x66>
8001084e:	8e 68       	ld.sh	r8,r7[0xc]
80010850:	e0 65 04 00 	mov	r5,1024
80010854:	ab a8       	sbr	r8,0xa
80010856:	ef 45 00 50 	st.w	r7[80],r5
8001085a:	ae 68       	st.h	r7[0xc],r8
8001085c:	c0 68       	rjmp	80010868 <__smakebuf_r+0x70>
8001085e:	8e 68       	ld.sh	r8,r7[0xc]
80010860:	e0 65 04 00 	mov	r5,1024
80010864:	ab b8       	sbr	r8,0xb
80010866:	ae 68       	st.h	r7[0xc],r8
80010868:	0a 9b       	mov	r11,r5
8001086a:	0c 9c       	mov	r12,r6
8001086c:	f0 1f 00 13 	mcall	800108b8 <__smakebuf_r+0xc0>
80010870:	8e 68       	ld.sh	r8,r7[0xc]
80010872:	c0 d1       	brne	8001088c <__smakebuf_r+0x94>
80010874:	ed b8 00 09 	bld	r8,0x9
80010878:	c1 a0       	breq	800108ac <__smakebuf_r+0xb4>
8001087a:	a1 b8       	sbr	r8,0x1
8001087c:	ae 68       	st.h	r7[0xc],r8
8001087e:	ee c8 ff b9 	sub	r8,r7,-71
80010882:	8f 48       	st.w	r7[0x10],r8
80010884:	8f 08       	st.w	r7[0x0],r8
80010886:	30 18       	mov	r8,1
80010888:	8f 58       	st.w	r7[0x14],r8
8001088a:	c1 18       	rjmp	800108ac <__smakebuf_r+0xb4>
8001088c:	a7 b8       	sbr	r8,0x7
8001088e:	8f 4c       	st.w	r7[0x10],r12
80010890:	ae 68       	st.h	r7[0xc],r8
80010892:	8f 55       	st.w	r7[0x14],r5
80010894:	48 a8       	lddpc	r8,800108bc <__smakebuf_r+0xc4>
80010896:	8f 0c       	st.w	r7[0x0],r12
80010898:	8d a8       	st.w	r6[0x28],r8
8001089a:	58 04       	cp.w	r4,0
8001089c:	c0 80       	breq	800108ac <__smakebuf_r+0xb4>
8001089e:	8e 7c       	ld.sh	r12,r7[0xe]
800108a0:	f0 1f 00 08 	mcall	800108c0 <__smakebuf_r+0xc8>
800108a4:	c0 40       	breq	800108ac <__smakebuf_r+0xb4>
800108a6:	8e 68       	ld.sh	r8,r7[0xc]
800108a8:	a1 a8       	sbr	r8,0x0
800108aa:	ae 68       	st.h	r7[0xc],r8
800108ac:	2f 1d       	sub	sp,-60
800108ae:	d8 22       	popm	r4-r7,pc
800108b0:	80 01       	ld.sh	r1,r0[0x0]
800108b2:	1a 74       	tst	r4,sp
800108b4:	80 01       	ld.sh	r1,r0[0x0]
800108b6:	17 28       	ld.uh	r8,r11++
800108b8:	80 01       	ld.sh	r1,r0[0x0]
800108ba:	08 dc       	st.w	--r4,r12
800108bc:	80 01       	ld.sh	r1,r0[0x0]
800108be:	01 20       	ld.uh	r0,r0++
800108c0:	80 01       	ld.sh	r1,r0[0x0]
800108c2:	18 0c       	add	r12,r12

800108c4 <malloc>:
800108c4:	d4 01       	pushm	lr
800108c6:	48 48       	lddpc	r8,800108d4 <malloc+0x10>
800108c8:	18 9b       	mov	r11,r12
800108ca:	70 0c       	ld.w	r12,r8[0x0]
800108cc:	f0 1f 00 03 	mcall	800108d8 <malloc+0x14>
800108d0:	d8 02       	popm	pc
800108d2:	00 00       	add	r0,r0
800108d4:	00 00       	add	r0,r0
800108d6:	01 a8       	ld.ub	r8,r0[0x2]
800108d8:	80 01       	ld.sh	r1,r0[0x0]
800108da:	08 dc       	st.w	--r4,r12

800108dc <_malloc_r>:
800108dc:	d4 31       	pushm	r0-r7,lr
800108de:	f6 c8 ff f5 	sub	r8,r11,-11
800108e2:	18 95       	mov	r5,r12
800108e4:	10 97       	mov	r7,r8
800108e6:	e0 17 ff f8 	andl	r7,0xfff8
800108ea:	59 68       	cp.w	r8,22
800108ec:	f9 b7 08 10 	movls	r7,16
800108f0:	16 37       	cp.w	r7,r11
800108f2:	5f 38       	srlo	r8
800108f4:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
800108f8:	c0 50       	breq	80010902 <_malloc_r+0x26>
800108fa:	30 c8       	mov	r8,12
800108fc:	99 38       	st.w	r12[0xc],r8
800108fe:	e0 8f 01 f3 	bral	80010ce4 <_malloc_r+0x408>
80010902:	f0 1f 00 50 	mcall	80010a40 <_malloc_r+0x164>
80010906:	e0 47 01 f7 	cp.w	r7,503
8001090a:	e0 8b 00 1c 	brhi	80010942 <_malloc_r+0x66>
8001090e:	ee 03 16 03 	lsr	r3,r7,0x3
80010912:	4c d8       	lddpc	r8,80010a44 <_malloc_r+0x168>
80010914:	f0 03 00 38 	add	r8,r8,r3<<0x3
80010918:	70 36       	ld.w	r6,r8[0xc]
8001091a:	10 36       	cp.w	r6,r8
8001091c:	c0 61       	brne	80010928 <_malloc_r+0x4c>
8001091e:	ec c8 ff f8 	sub	r8,r6,-8
80010922:	70 36       	ld.w	r6,r8[0xc]
80010924:	10 36       	cp.w	r6,r8
80010926:	c0 c0       	breq	8001093e <_malloc_r+0x62>
80010928:	6c 18       	ld.w	r8,r6[0x4]
8001092a:	e0 18 ff fc 	andl	r8,0xfffc
8001092e:	6c 3a       	ld.w	r10,r6[0xc]
80010930:	ec 08 00 09 	add	r9,r6,r8
80010934:	0a 9c       	mov	r12,r5
80010936:	6c 28       	ld.w	r8,r6[0x8]
80010938:	95 28       	st.w	r10[0x8],r8
8001093a:	91 3a       	st.w	r8[0xc],r10
8001093c:	c4 68       	rjmp	800109c8 <_malloc_r+0xec>
8001093e:	2f e3       	sub	r3,-2
80010940:	c4 c8       	rjmp	800109d8 <_malloc_r+0xfc>
80010942:	ee 03 16 09 	lsr	r3,r7,0x9
80010946:	c0 41       	brne	8001094e <_malloc_r+0x72>
80010948:	ee 03 16 03 	lsr	r3,r7,0x3
8001094c:	c2 68       	rjmp	80010998 <_malloc_r+0xbc>
8001094e:	58 43       	cp.w	r3,4
80010950:	e0 8b 00 06 	brhi	8001095c <_malloc_r+0x80>
80010954:	ee 03 16 06 	lsr	r3,r7,0x6
80010958:	2c 83       	sub	r3,-56
8001095a:	c1 f8       	rjmp	80010998 <_malloc_r+0xbc>
8001095c:	59 43       	cp.w	r3,20
8001095e:	e0 8b 00 04 	brhi	80010966 <_malloc_r+0x8a>
80010962:	2a 53       	sub	r3,-91
80010964:	c1 a8       	rjmp	80010998 <_malloc_r+0xbc>
80010966:	e0 43 00 54 	cp.w	r3,84
8001096a:	e0 8b 00 06 	brhi	80010976 <_malloc_r+0x9a>
8001096e:	ee 03 16 0c 	lsr	r3,r7,0xc
80010972:	29 23       	sub	r3,-110
80010974:	c1 28       	rjmp	80010998 <_malloc_r+0xbc>
80010976:	e0 43 01 54 	cp.w	r3,340
8001097a:	e0 8b 00 06 	brhi	80010986 <_malloc_r+0xaa>
8001097e:	ee 03 16 0f 	lsr	r3,r7,0xf
80010982:	28 93       	sub	r3,-119
80010984:	c0 a8       	rjmp	80010998 <_malloc_r+0xbc>
80010986:	e0 43 05 54 	cp.w	r3,1364
8001098a:	e0 88 00 04 	brls	80010992 <_malloc_r+0xb6>
8001098e:	37 e3       	mov	r3,126
80010990:	c0 48       	rjmp	80010998 <_malloc_r+0xbc>
80010992:	ee 03 16 12 	lsr	r3,r7,0x12
80010996:	28 43       	sub	r3,-124
80010998:	4a ba       	lddpc	r10,80010a44 <_malloc_r+0x168>
8001099a:	f4 03 00 3a 	add	r10,r10,r3<<0x3
8001099e:	74 36       	ld.w	r6,r10[0xc]
800109a0:	c1 98       	rjmp	800109d2 <_malloc_r+0xf6>
800109a2:	6c 19       	ld.w	r9,r6[0x4]
800109a4:	e0 19 ff fc 	andl	r9,0xfffc
800109a8:	f2 07 01 0b 	sub	r11,r9,r7
800109ac:	58 fb       	cp.w	r11,15
800109ae:	e0 8a 00 04 	brle	800109b6 <_malloc_r+0xda>
800109b2:	20 13       	sub	r3,1
800109b4:	c1 18       	rjmp	800109d6 <_malloc_r+0xfa>
800109b6:	6c 38       	ld.w	r8,r6[0xc]
800109b8:	58 0b       	cp.w	r11,0
800109ba:	c0 b5       	brlt	800109d0 <_malloc_r+0xf4>
800109bc:	6c 2a       	ld.w	r10,r6[0x8]
800109be:	ec 09 00 09 	add	r9,r6,r9
800109c2:	0a 9c       	mov	r12,r5
800109c4:	91 2a       	st.w	r8[0x8],r10
800109c6:	95 38       	st.w	r10[0xc],r8
800109c8:	72 18       	ld.w	r8,r9[0x4]
800109ca:	a1 a8       	sbr	r8,0x0
800109cc:	93 18       	st.w	r9[0x4],r8
800109ce:	cb c8       	rjmp	80010b46 <_malloc_r+0x26a>
800109d0:	10 96       	mov	r6,r8
800109d2:	14 36       	cp.w	r6,r10
800109d4:	ce 71       	brne	800109a2 <_malloc_r+0xc6>
800109d6:	2f f3       	sub	r3,-1
800109d8:	49 ba       	lddpc	r10,80010a44 <_malloc_r+0x168>
800109da:	f4 cc ff f8 	sub	r12,r10,-8
800109de:	78 26       	ld.w	r6,r12[0x8]
800109e0:	18 36       	cp.w	r6,r12
800109e2:	c6 e0       	breq	80010abe <_malloc_r+0x1e2>
800109e4:	6c 19       	ld.w	r9,r6[0x4]
800109e6:	e0 19 ff fc 	andl	r9,0xfffc
800109ea:	f2 07 01 08 	sub	r8,r9,r7
800109ee:	58 f8       	cp.w	r8,15
800109f0:	e0 89 00 90 	brgt	80010b10 <_malloc_r+0x234>
800109f4:	99 3c       	st.w	r12[0xc],r12
800109f6:	99 2c       	st.w	r12[0x8],r12
800109f8:	58 08       	cp.w	r8,0
800109fa:	c0 55       	brlt	80010a04 <_malloc_r+0x128>
800109fc:	ec 09 00 09 	add	r9,r6,r9
80010a00:	0a 9c       	mov	r12,r5
80010a02:	ce 3b       	rjmp	800109c8 <_malloc_r+0xec>
80010a04:	e0 49 01 ff 	cp.w	r9,511
80010a08:	e0 8b 00 13 	brhi	80010a2e <_malloc_r+0x152>
80010a0c:	a3 99       	lsr	r9,0x3
80010a0e:	f4 09 00 38 	add	r8,r10,r9<<0x3
80010a12:	70 2b       	ld.w	r11,r8[0x8]
80010a14:	8d 38       	st.w	r6[0xc],r8
80010a16:	8d 2b       	st.w	r6[0x8],r11
80010a18:	97 36       	st.w	r11[0xc],r6
80010a1a:	91 26       	st.w	r8[0x8],r6
80010a1c:	a3 49       	asr	r9,0x2
80010a1e:	74 18       	ld.w	r8,r10[0x4]
80010a20:	30 1b       	mov	r11,1
80010a22:	f6 09 09 49 	lsl	r9,r11,r9
80010a26:	f1 e9 10 09 	or	r9,r8,r9
80010a2a:	95 19       	st.w	r10[0x4],r9
80010a2c:	c4 98       	rjmp	80010abe <_malloc_r+0x1e2>
80010a2e:	f2 0a 16 09 	lsr	r10,r9,0x9
80010a32:	58 4a       	cp.w	r10,4
80010a34:	e0 8b 00 0a 	brhi	80010a48 <_malloc_r+0x16c>
80010a38:	f2 0a 16 06 	lsr	r10,r9,0x6
80010a3c:	2c 8a       	sub	r10,-56
80010a3e:	c2 38       	rjmp	80010a84 <_malloc_r+0x1a8>
80010a40:	80 01       	ld.sh	r1,r0[0x0]
80010a42:	0d 80       	ld.ub	r0,r6[0x0]
80010a44:	00 00       	add	r0,r0
80010a46:	01 ac       	ld.ub	r12,r0[0x2]
80010a48:	59 4a       	cp.w	r10,20
80010a4a:	e0 8b 00 04 	brhi	80010a52 <_malloc_r+0x176>
80010a4e:	2a 5a       	sub	r10,-91
80010a50:	c1 a8       	rjmp	80010a84 <_malloc_r+0x1a8>
80010a52:	e0 4a 00 54 	cp.w	r10,84
80010a56:	e0 8b 00 06 	brhi	80010a62 <_malloc_r+0x186>
80010a5a:	f2 0a 16 0c 	lsr	r10,r9,0xc
80010a5e:	29 2a       	sub	r10,-110
80010a60:	c1 28       	rjmp	80010a84 <_malloc_r+0x1a8>
80010a62:	e0 4a 01 54 	cp.w	r10,340
80010a66:	e0 8b 00 06 	brhi	80010a72 <_malloc_r+0x196>
80010a6a:	f2 0a 16 0f 	lsr	r10,r9,0xf
80010a6e:	28 9a       	sub	r10,-119
80010a70:	c0 a8       	rjmp	80010a84 <_malloc_r+0x1a8>
80010a72:	e0 4a 05 54 	cp.w	r10,1364
80010a76:	e0 88 00 04 	brls	80010a7e <_malloc_r+0x1a2>
80010a7a:	37 ea       	mov	r10,126
80010a7c:	c0 48       	rjmp	80010a84 <_malloc_r+0x1a8>
80010a7e:	f2 0a 16 12 	lsr	r10,r9,0x12
80010a82:	28 4a       	sub	r10,-124
80010a84:	4c 8b       	lddpc	r11,80010ba4 <_malloc_r+0x2c8>
80010a86:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80010a8a:	68 28       	ld.w	r8,r4[0x8]
80010a8c:	08 38       	cp.w	r8,r4
80010a8e:	c0 e1       	brne	80010aaa <_malloc_r+0x1ce>
80010a90:	76 19       	ld.w	r9,r11[0x4]
80010a92:	a3 4a       	asr	r10,0x2
80010a94:	30 1e       	mov	lr,1
80010a96:	fc 0a 09 4a 	lsl	r10,lr,r10
80010a9a:	f3 ea 10 0a 	or	r10,r9,r10
80010a9e:	10 99       	mov	r9,r8
80010aa0:	97 1a       	st.w	r11[0x4],r10
80010aa2:	c0 a8       	rjmp	80010ab6 <_malloc_r+0x1da>
80010aa4:	70 28       	ld.w	r8,r8[0x8]
80010aa6:	08 38       	cp.w	r8,r4
80010aa8:	c0 60       	breq	80010ab4 <_malloc_r+0x1d8>
80010aaa:	70 1a       	ld.w	r10,r8[0x4]
80010aac:	e0 1a ff fc 	andl	r10,0xfffc
80010ab0:	14 39       	cp.w	r9,r10
80010ab2:	cf 93       	brcs	80010aa4 <_malloc_r+0x1c8>
80010ab4:	70 39       	ld.w	r9,r8[0xc]
80010ab6:	8d 39       	st.w	r6[0xc],r9
80010ab8:	8d 28       	st.w	r6[0x8],r8
80010aba:	91 36       	st.w	r8[0xc],r6
80010abc:	93 26       	st.w	r9[0x8],r6
80010abe:	e6 08 14 02 	asr	r8,r3,0x2
80010ac2:	30 1b       	mov	r11,1
80010ac4:	4b 84       	lddpc	r4,80010ba4 <_malloc_r+0x2c8>
80010ac6:	f6 08 09 4b 	lsl	r11,r11,r8
80010aca:	68 18       	ld.w	r8,r4[0x4]
80010acc:	10 3b       	cp.w	r11,r8
80010ace:	e0 8b 00 6f 	brhi	80010bac <_malloc_r+0x2d0>
80010ad2:	f7 e8 00 09 	and	r9,r11,r8
80010ad6:	c0 b1       	brne	80010aec <_malloc_r+0x210>
80010ad8:	e0 13 ff fc 	andl	r3,0xfffc
80010adc:	a1 7b       	lsl	r11,0x1
80010ade:	2f c3       	sub	r3,-4
80010ae0:	c0 38       	rjmp	80010ae6 <_malloc_r+0x20a>
80010ae2:	2f c3       	sub	r3,-4
80010ae4:	a1 7b       	lsl	r11,0x1
80010ae6:	f7 e8 00 09 	and	r9,r11,r8
80010aea:	cf c0       	breq	80010ae2 <_malloc_r+0x206>
80010aec:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80010af0:	06 92       	mov	r2,r3
80010af2:	1c 91       	mov	r1,lr
80010af4:	62 36       	ld.w	r6,r1[0xc]
80010af6:	c2 e8       	rjmp	80010b52 <_malloc_r+0x276>
80010af8:	6c 1a       	ld.w	r10,r6[0x4]
80010afa:	e0 1a ff fc 	andl	r10,0xfffc
80010afe:	f4 07 01 08 	sub	r8,r10,r7
80010b02:	58 f8       	cp.w	r8,15
80010b04:	e0 8a 00 15 	brle	80010b2e <_malloc_r+0x252>
80010b08:	6c 3a       	ld.w	r10,r6[0xc]
80010b0a:	6c 29       	ld.w	r9,r6[0x8]
80010b0c:	95 29       	st.w	r10[0x8],r9
80010b0e:	93 3a       	st.w	r9[0xc],r10
80010b10:	0e 99       	mov	r9,r7
80010b12:	ec 07 00 07 	add	r7,r6,r7
80010b16:	a1 a9       	sbr	r9,0x0
80010b18:	99 37       	st.w	r12[0xc],r7
80010b1a:	99 27       	st.w	r12[0x8],r7
80010b1c:	8d 19       	st.w	r6[0x4],r9
80010b1e:	ee 08 09 08 	st.w	r7[r8],r8
80010b22:	8f 2c       	st.w	r7[0x8],r12
80010b24:	8f 3c       	st.w	r7[0xc],r12
80010b26:	a1 a8       	sbr	r8,0x0
80010b28:	0a 9c       	mov	r12,r5
80010b2a:	8f 18       	st.w	r7[0x4],r8
80010b2c:	c0 d8       	rjmp	80010b46 <_malloc_r+0x26a>
80010b2e:	6c 39       	ld.w	r9,r6[0xc]
80010b30:	58 08       	cp.w	r8,0
80010b32:	c0 f5       	brlt	80010b50 <_malloc_r+0x274>
80010b34:	ec 0a 00 0a 	add	r10,r6,r10
80010b38:	74 18       	ld.w	r8,r10[0x4]
80010b3a:	a1 a8       	sbr	r8,0x0
80010b3c:	0a 9c       	mov	r12,r5
80010b3e:	95 18       	st.w	r10[0x4],r8
80010b40:	6c 28       	ld.w	r8,r6[0x8]
80010b42:	93 28       	st.w	r9[0x8],r8
80010b44:	91 39       	st.w	r8[0xc],r9
80010b46:	f0 1f 00 19 	mcall	80010ba8 <_malloc_r+0x2cc>
80010b4a:	ec cc ff f8 	sub	r12,r6,-8
80010b4e:	d8 32       	popm	r0-r7,pc
80010b50:	12 96       	mov	r6,r9
80010b52:	02 36       	cp.w	r6,r1
80010b54:	cd 21       	brne	80010af8 <_malloc_r+0x21c>
80010b56:	2f f2       	sub	r2,-1
80010b58:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80010b5c:	c0 30       	breq	80010b62 <_malloc_r+0x286>
80010b5e:	2f 81       	sub	r1,-8
80010b60:	cc ab       	rjmp	80010af4 <_malloc_r+0x218>
80010b62:	1c 98       	mov	r8,lr
80010b64:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80010b68:	c0 81       	brne	80010b78 <_malloc_r+0x29c>
80010b6a:	68 19       	ld.w	r9,r4[0x4]
80010b6c:	f6 08 11 ff 	rsub	r8,r11,-1
80010b70:	f3 e8 00 08 	and	r8,r9,r8
80010b74:	89 18       	st.w	r4[0x4],r8
80010b76:	c0 78       	rjmp	80010b84 <_malloc_r+0x2a8>
80010b78:	f0 c9 00 08 	sub	r9,r8,8
80010b7c:	20 13       	sub	r3,1
80010b7e:	70 08       	ld.w	r8,r8[0x0]
80010b80:	12 38       	cp.w	r8,r9
80010b82:	cf 10       	breq	80010b64 <_malloc_r+0x288>
80010b84:	a1 7b       	lsl	r11,0x1
80010b86:	68 18       	ld.w	r8,r4[0x4]
80010b88:	10 3b       	cp.w	r11,r8
80010b8a:	e0 8b 00 11 	brhi	80010bac <_malloc_r+0x2d0>
80010b8e:	58 0b       	cp.w	r11,0
80010b90:	c0 e0       	breq	80010bac <_malloc_r+0x2d0>
80010b92:	04 93       	mov	r3,r2
80010b94:	c0 38       	rjmp	80010b9a <_malloc_r+0x2be>
80010b96:	2f c3       	sub	r3,-4
80010b98:	a1 7b       	lsl	r11,0x1
80010b9a:	f7 e8 00 09 	and	r9,r11,r8
80010b9e:	ca 71       	brne	80010aec <_malloc_r+0x210>
80010ba0:	cf bb       	rjmp	80010b96 <_malloc_r+0x2ba>
80010ba2:	00 00       	add	r0,r0
80010ba4:	00 00       	add	r0,r0
80010ba6:	01 ac       	ld.ub	r12,r0[0x2]
80010ba8:	80 01       	ld.sh	r1,r0[0x0]
80010baa:	0d 82       	ld.ub	r2,r6[0x0]
80010bac:	68 23       	ld.w	r3,r4[0x8]
80010bae:	66 12       	ld.w	r2,r3[0x4]
80010bb0:	e0 12 ff fc 	andl	r2,0xfffc
80010bb4:	0e 32       	cp.w	r2,r7
80010bb6:	5f 39       	srlo	r9
80010bb8:	e4 07 01 08 	sub	r8,r2,r7
80010bbc:	58 f8       	cp.w	r8,15
80010bbe:	5f aa       	srle	r10
80010bc0:	f5 e9 10 09 	or	r9,r10,r9
80010bc4:	e0 80 00 a2 	breq	80010d08 <_malloc_r+0x42c>
80010bc8:	4c 88       	lddpc	r8,80010ce8 <_malloc_r+0x40c>
80010bca:	70 01       	ld.w	r1,r8[0x0]
80010bcc:	4c 88       	lddpc	r8,80010cec <_malloc_r+0x410>
80010bce:	2f 01       	sub	r1,-16
80010bd0:	70 08       	ld.w	r8,r8[0x0]
80010bd2:	0e 01       	add	r1,r7
80010bd4:	5b f8       	cp.w	r8,-1
80010bd6:	c0 40       	breq	80010bde <_malloc_r+0x302>
80010bd8:	28 11       	sub	r1,-127
80010bda:	e0 11 ff 80 	andl	r1,0xff80
80010bde:	02 9b       	mov	r11,r1
80010be0:	0a 9c       	mov	r12,r5
80010be2:	f0 1f 00 44 	mcall	80010cf0 <_malloc_r+0x414>
80010be6:	18 96       	mov	r6,r12
80010be8:	5b fc       	cp.w	r12,-1
80010bea:	c6 e0       	breq	80010cc6 <_malloc_r+0x3ea>
80010bec:	e6 02 00 08 	add	r8,r3,r2
80010bf0:	10 3c       	cp.w	r12,r8
80010bf2:	c0 32       	brcc	80010bf8 <_malloc_r+0x31c>
80010bf4:	08 33       	cp.w	r3,r4
80010bf6:	c6 81       	brne	80010cc6 <_malloc_r+0x3ea>
80010bf8:	4b fa       	lddpc	r10,80010cf4 <_malloc_r+0x418>
80010bfa:	74 09       	ld.w	r9,r10[0x0]
80010bfc:	e2 09 00 09 	add	r9,r1,r9
80010c00:	95 09       	st.w	r10[0x0],r9
80010c02:	10 36       	cp.w	r6,r8
80010c04:	c0 a1       	brne	80010c18 <_malloc_r+0x33c>
80010c06:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80010c0a:	c0 71       	brne	80010c18 <_malloc_r+0x33c>
80010c0c:	e2 02 00 02 	add	r2,r1,r2
80010c10:	68 28       	ld.w	r8,r4[0x8]
80010c12:	a1 a2       	sbr	r2,0x0
80010c14:	91 12       	st.w	r8[0x4],r2
80010c16:	c4 c8       	rjmp	80010cae <_malloc_r+0x3d2>
80010c18:	4b 5a       	lddpc	r10,80010cec <_malloc_r+0x410>
80010c1a:	74 0b       	ld.w	r11,r10[0x0]
80010c1c:	5b fb       	cp.w	r11,-1
80010c1e:	c0 31       	brne	80010c24 <_malloc_r+0x348>
80010c20:	95 06       	st.w	r10[0x0],r6
80010c22:	c0 68       	rjmp	80010c2e <_malloc_r+0x352>
80010c24:	ec 09 00 09 	add	r9,r6,r9
80010c28:	4b 3a       	lddpc	r10,80010cf4 <_malloc_r+0x418>
80010c2a:	10 19       	sub	r9,r8
80010c2c:	95 09       	st.w	r10[0x0],r9
80010c2e:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80010c32:	f0 09 11 08 	rsub	r9,r8,8
80010c36:	58 08       	cp.w	r8,0
80010c38:	f2 08 17 10 	movne	r8,r9
80010c3c:	ed d8 e1 06 	addne	r6,r6,r8
80010c40:	28 08       	sub	r8,-128
80010c42:	ec 01 00 01 	add	r1,r6,r1
80010c46:	0a 9c       	mov	r12,r5
80010c48:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80010c4c:	f0 01 01 01 	sub	r1,r8,r1
80010c50:	02 9b       	mov	r11,r1
80010c52:	f0 1f 00 28 	mcall	80010cf0 <_malloc_r+0x414>
80010c56:	4a 88       	lddpc	r8,80010cf4 <_malloc_r+0x418>
80010c58:	5b fc       	cp.w	r12,-1
80010c5a:	ec 0c 17 00 	moveq	r12,r6
80010c5e:	f9 b1 00 00 	moveq	r1,0
80010c62:	70 09       	ld.w	r9,r8[0x0]
80010c64:	0c 1c       	sub	r12,r6
80010c66:	89 26       	st.w	r4[0x8],r6
80010c68:	02 0c       	add	r12,r1
80010c6a:	12 01       	add	r1,r9
80010c6c:	a1 ac       	sbr	r12,0x0
80010c6e:	91 01       	st.w	r8[0x0],r1
80010c70:	8d 1c       	st.w	r6[0x4],r12
80010c72:	08 33       	cp.w	r3,r4
80010c74:	c1 d0       	breq	80010cae <_malloc_r+0x3d2>
80010c76:	58 f2       	cp.w	r2,15
80010c78:	e0 8b 00 05 	brhi	80010c82 <_malloc_r+0x3a6>
80010c7c:	30 18       	mov	r8,1
80010c7e:	8d 18       	st.w	r6[0x4],r8
80010c80:	c2 38       	rjmp	80010cc6 <_malloc_r+0x3ea>
80010c82:	30 59       	mov	r9,5
80010c84:	20 c2       	sub	r2,12
80010c86:	e0 12 ff f8 	andl	r2,0xfff8
80010c8a:	e6 02 00 08 	add	r8,r3,r2
80010c8e:	91 29       	st.w	r8[0x8],r9
80010c90:	91 19       	st.w	r8[0x4],r9
80010c92:	66 18       	ld.w	r8,r3[0x4]
80010c94:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80010c98:	e5 e8 10 08 	or	r8,r2,r8
80010c9c:	87 18       	st.w	r3[0x4],r8
80010c9e:	58 f2       	cp.w	r2,15
80010ca0:	e0 88 00 07 	brls	80010cae <_malloc_r+0x3d2>
80010ca4:	e6 cb ff f8 	sub	r11,r3,-8
80010ca8:	0a 9c       	mov	r12,r5
80010caa:	f0 1f 00 14 	mcall	80010cf8 <_malloc_r+0x41c>
80010cae:	49 49       	lddpc	r9,80010cfc <_malloc_r+0x420>
80010cb0:	72 0a       	ld.w	r10,r9[0x0]
80010cb2:	49 18       	lddpc	r8,80010cf4 <_malloc_r+0x418>
80010cb4:	70 08       	ld.w	r8,r8[0x0]
80010cb6:	14 38       	cp.w	r8,r10
80010cb8:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80010cbc:	49 19       	lddpc	r9,80010d00 <_malloc_r+0x424>
80010cbe:	72 0a       	ld.w	r10,r9[0x0]
80010cc0:	14 38       	cp.w	r8,r10
80010cc2:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80010cc6:	68 28       	ld.w	r8,r4[0x8]
80010cc8:	70 18       	ld.w	r8,r8[0x4]
80010cca:	e0 18 ff fc 	andl	r8,0xfffc
80010cce:	0e 38       	cp.w	r8,r7
80010cd0:	5f 39       	srlo	r9
80010cd2:	0e 18       	sub	r8,r7
80010cd4:	58 f8       	cp.w	r8,15
80010cd6:	5f aa       	srle	r10
80010cd8:	f5 e9 10 09 	or	r9,r10,r9
80010cdc:	c1 60       	breq	80010d08 <_malloc_r+0x42c>
80010cde:	0a 9c       	mov	r12,r5
80010ce0:	f0 1f 00 09 	mcall	80010d04 <_malloc_r+0x428>
80010ce4:	d8 3a       	popm	r0-r7,pc,r12=0
80010ce6:	00 00       	add	r0,r0
80010ce8:	00 00       	add	r0,r0
80010cea:	07 e0       	ld.ub	r0,r3[0x6]
80010cec:	00 00       	add	r0,r0
80010cee:	05 b8       	ld.ub	r8,r2[0x3]
80010cf0:	80 01       	ld.sh	r1,r0[0x0]
80010cf2:	16 f0       	st.b	--r11,r0
80010cf4:	00 00       	add	r0,r0
80010cf6:	07 e4       	ld.ub	r4,r3[0x6]
80010cf8:	80 01       	ld.sh	r1,r0[0x0]
80010cfa:	03 38       	ld.ub	r8,r1++
80010cfc:	00 00       	add	r0,r0
80010cfe:	07 dc       	ld.ub	r12,r3[0x5]
80010d00:	00 00       	add	r0,r0
80010d02:	07 d8       	ld.ub	r8,r3[0x5]
80010d04:	80 01       	ld.sh	r1,r0[0x0]
80010d06:	0d 82       	ld.ub	r2,r6[0x0]
80010d08:	68 26       	ld.w	r6,r4[0x8]
80010d0a:	a1 a8       	sbr	r8,0x0
80010d0c:	0e 99       	mov	r9,r7
80010d0e:	a1 a9       	sbr	r9,0x0
80010d10:	8d 19       	st.w	r6[0x4],r9
80010d12:	ec 07 00 07 	add	r7,r6,r7
80010d16:	0a 9c       	mov	r12,r5
80010d18:	89 27       	st.w	r4[0x8],r7
80010d1a:	8f 18       	st.w	r7[0x4],r8
80010d1c:	f0 1f 00 03 	mcall	80010d28 <_malloc_r+0x44c>
80010d20:	ec cc ff f8 	sub	r12,r6,-8
80010d24:	d8 32       	popm	r0-r7,pc
80010d26:	00 00       	add	r0,r0
80010d28:	80 01       	ld.sh	r1,r0[0x0]
80010d2a:	0d 82       	ld.ub	r2,r6[0x0]

80010d2c <memchr>:
80010d2c:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
80010d30:	c0 68       	rjmp	80010d3c <memchr+0x10>
80010d32:	20 1a       	sub	r10,1
80010d34:	19 88       	ld.ub	r8,r12[0x0]
80010d36:	16 38       	cp.w	r8,r11
80010d38:	5e 0c       	reteq	r12
80010d3a:	2f fc       	sub	r12,-1
80010d3c:	58 0a       	cp.w	r10,0
80010d3e:	cf a1       	brne	80010d32 <memchr+0x6>
80010d40:	5e fa       	retal	r10

80010d42 <memmove>:
80010d42:	d4 01       	pushm	lr
80010d44:	18 3b       	cp.w	r11,r12
80010d46:	c1 92       	brcc	80010d78 <memmove+0x36>
80010d48:	f6 0a 00 09 	add	r9,r11,r10
80010d4c:	12 3c       	cp.w	r12,r9
80010d4e:	c1 52       	brcc	80010d78 <memmove+0x36>
80010d50:	f8 0a 00 0b 	add	r11,r12,r10
80010d54:	30 08       	mov	r8,0
80010d56:	c0 68       	rjmp	80010d62 <memmove+0x20>
80010d58:	f2 08 07 0e 	ld.ub	lr,r9[r8]
80010d5c:	20 1a       	sub	r10,1
80010d5e:	f6 08 0b 0e 	st.b	r11[r8],lr
80010d62:	20 18       	sub	r8,1
80010d64:	58 0a       	cp.w	r10,0
80010d66:	cf 91       	brne	80010d58 <memmove+0x16>
80010d68:	d8 02       	popm	pc
80010d6a:	f6 08 07 09 	ld.ub	r9,r11[r8]
80010d6e:	20 1a       	sub	r10,1
80010d70:	f8 08 0b 09 	st.b	r12[r8],r9
80010d74:	2f f8       	sub	r8,-1
80010d76:	c0 28       	rjmp	80010d7a <memmove+0x38>
80010d78:	30 08       	mov	r8,0
80010d7a:	58 0a       	cp.w	r10,0
80010d7c:	cf 71       	brne	80010d6a <memmove+0x28>
80010d7e:	d8 02       	popm	pc

80010d80 <__malloc_lock>:
80010d80:	5e fc       	retal	r12

80010d82 <__malloc_unlock>:
80010d82:	5e fc       	retal	r12

80010d84 <__hi0bits>:
80010d84:	18 98       	mov	r8,r12
80010d86:	e0 1c 00 00 	andl	r12,0x0
80010d8a:	f0 09 15 10 	lsl	r9,r8,0x10
80010d8e:	58 0c       	cp.w	r12,0
80010d90:	f2 08 17 00 	moveq	r8,r9
80010d94:	f9 bc 00 10 	moveq	r12,16
80010d98:	f9 bc 01 00 	movne	r12,0
80010d9c:	10 9a       	mov	r10,r8
80010d9e:	f0 09 15 08 	lsl	r9,r8,0x8
80010da2:	e6 1a ff 00 	andh	r10,0xff00,COH
80010da6:	f7 bc 00 f8 	subeq	r12,-8
80010daa:	f2 08 17 00 	moveq	r8,r9
80010dae:	10 9a       	mov	r10,r8
80010db0:	f0 09 15 04 	lsl	r9,r8,0x4
80010db4:	e6 1a f0 00 	andh	r10,0xf000,COH
80010db8:	f7 bc 00 fc 	subeq	r12,-4
80010dbc:	f2 08 17 00 	moveq	r8,r9
80010dc0:	10 9a       	mov	r10,r8
80010dc2:	f0 09 15 02 	lsl	r9,r8,0x2
80010dc6:	e6 1a c0 00 	andh	r10,0xc000,COH
80010dca:	f7 bc 00 fe 	subeq	r12,-2
80010dce:	f2 08 17 00 	moveq	r8,r9
80010dd2:	58 08       	cp.w	r8,0
80010dd4:	5e 5c       	retlt	r12
80010dd6:	ed b8 00 1e 	bld	r8,0x1e
80010dda:	f9 bc 01 20 	movne	r12,32
80010dde:	f7 bc 00 ff 	subeq	r12,-1
80010de2:	5e fc       	retal	r12

80010de4 <__lo0bits>:
80010de4:	18 99       	mov	r9,r12
80010de6:	78 08       	ld.w	r8,r12[0x0]
80010de8:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
80010dec:	c1 50       	breq	80010e16 <__lo0bits+0x32>
80010dee:	ed b8 00 00 	bld	r8,0x0
80010df2:	c0 21       	brne	80010df6 <__lo0bits+0x12>
80010df4:	5e fd       	retal	0
80010df6:	10 9b       	mov	r11,r8
80010df8:	f0 0a 16 01 	lsr	r10,r8,0x1
80010dfc:	e2 1b 00 02 	andl	r11,0x2,COH
80010e00:	a3 88       	lsr	r8,0x2
80010e02:	58 0b       	cp.w	r11,0
80010e04:	f3 fa 1a 00 	st.wne	r9[0x0],r10
80010e08:	f9 bc 01 01 	movne	r12,1
80010e0c:	f3 f8 0a 00 	st.weq	r9[0x0],r8
80010e10:	f9 bc 00 02 	moveq	r12,2
80010e14:	5e fc       	retal	r12
80010e16:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
80010e1a:	f0 0b 16 10 	lsr	r11,r8,0x10
80010e1e:	58 0a       	cp.w	r10,0
80010e20:	f6 08 17 00 	moveq	r8,r11
80010e24:	f9 bc 00 10 	moveq	r12,16
80010e28:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
80010e2c:	f0 0a 16 08 	lsr	r10,r8,0x8
80010e30:	58 0b       	cp.w	r11,0
80010e32:	f7 bc 00 f8 	subeq	r12,-8
80010e36:	f4 08 17 00 	moveq	r8,r10
80010e3a:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
80010e3e:	f0 0a 16 04 	lsr	r10,r8,0x4
80010e42:	58 0b       	cp.w	r11,0
80010e44:	f7 bc 00 fc 	subeq	r12,-4
80010e48:	f4 08 17 00 	moveq	r8,r10
80010e4c:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
80010e50:	f0 0a 16 02 	lsr	r10,r8,0x2
80010e54:	58 0b       	cp.w	r11,0
80010e56:	f7 bc 00 fe 	subeq	r12,-2
80010e5a:	f4 08 17 00 	moveq	r8,r10
80010e5e:	ed b8 00 00 	bld	r8,0x0
80010e62:	c0 60       	breq	80010e6e <__lo0bits+0x8a>
80010e64:	a1 98       	lsr	r8,0x1
80010e66:	c0 31       	brne	80010e6c <__lo0bits+0x88>
80010e68:	32 0c       	mov	r12,32
80010e6a:	5e fc       	retal	r12
80010e6c:	2f fc       	sub	r12,-1
80010e6e:	93 08       	st.w	r9[0x0],r8
80010e70:	5e fc       	retal	r12

80010e72 <__mcmp>:
80010e72:	d4 01       	pushm	lr
80010e74:	18 98       	mov	r8,r12
80010e76:	76 49       	ld.w	r9,r11[0x10]
80010e78:	78 4c       	ld.w	r12,r12[0x10]
80010e7a:	12 1c       	sub	r12,r9
80010e7c:	c1 31       	brne	80010ea2 <__mcmp+0x30>
80010e7e:	2f b9       	sub	r9,-5
80010e80:	a3 69       	lsl	r9,0x2
80010e82:	12 0b       	add	r11,r9
80010e84:	f0 09 00 09 	add	r9,r8,r9
80010e88:	2e c8       	sub	r8,-20
80010e8a:	13 4e       	ld.w	lr,--r9
80010e8c:	17 4a       	ld.w	r10,--r11
80010e8e:	14 3e       	cp.w	lr,r10
80010e90:	c0 60       	breq	80010e9c <__mcmp+0x2a>
80010e92:	f9 bc 03 ff 	movlo	r12,-1
80010e96:	f9 bc 02 01 	movhs	r12,1
80010e9a:	d8 02       	popm	pc
80010e9c:	10 39       	cp.w	r9,r8
80010e9e:	fe 9b ff f6 	brhi	80010e8a <__mcmp+0x18>
80010ea2:	d8 02       	popm	pc

80010ea4 <_Bfree>:
80010ea4:	d4 21       	pushm	r4-r7,lr
80010ea6:	18 97       	mov	r7,r12
80010ea8:	16 95       	mov	r5,r11
80010eaa:	78 96       	ld.w	r6,r12[0x24]
80010eac:	58 06       	cp.w	r6,0
80010eae:	c0 91       	brne	80010ec0 <_Bfree+0x1c>
80010eb0:	31 0c       	mov	r12,16
80010eb2:	f0 1f 00 0a 	mcall	80010ed8 <_Bfree+0x34>
80010eb6:	99 36       	st.w	r12[0xc],r6
80010eb8:	8f 9c       	st.w	r7[0x24],r12
80010eba:	99 16       	st.w	r12[0x4],r6
80010ebc:	99 26       	st.w	r12[0x8],r6
80010ebe:	99 06       	st.w	r12[0x0],r6
80010ec0:	58 05       	cp.w	r5,0
80010ec2:	c0 90       	breq	80010ed4 <_Bfree+0x30>
80010ec4:	6a 19       	ld.w	r9,r5[0x4]
80010ec6:	6e 98       	ld.w	r8,r7[0x24]
80010ec8:	70 38       	ld.w	r8,r8[0xc]
80010eca:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
80010ece:	8b 0a       	st.w	r5[0x0],r10
80010ed0:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
80010ed4:	d8 22       	popm	r4-r7,pc
80010ed6:	00 00       	add	r0,r0
80010ed8:	80 01       	ld.sh	r1,r0[0x0]
80010eda:	08 c4       	st.b	r4++,r4

80010edc <_Balloc>:
80010edc:	d4 21       	pushm	r4-r7,lr
80010ede:	18 97       	mov	r7,r12
80010ee0:	16 96       	mov	r6,r11
80010ee2:	78 95       	ld.w	r5,r12[0x24]
80010ee4:	58 05       	cp.w	r5,0
80010ee6:	c0 91       	brne	80010ef8 <_Balloc+0x1c>
80010ee8:	31 0c       	mov	r12,16
80010eea:	f0 1f 00 19 	mcall	80010f4c <_Balloc+0x70>
80010eee:	99 35       	st.w	r12[0xc],r5
80010ef0:	8f 9c       	st.w	r7[0x24],r12
80010ef2:	99 15       	st.w	r12[0x4],r5
80010ef4:	99 25       	st.w	r12[0x8],r5
80010ef6:	99 05       	st.w	r12[0x0],r5
80010ef8:	6e 95       	ld.w	r5,r7[0x24]
80010efa:	6a 38       	ld.w	r8,r5[0xc]
80010efc:	58 08       	cp.w	r8,0
80010efe:	c0 b1       	brne	80010f14 <_Balloc+0x38>
80010f00:	31 0a       	mov	r10,16
80010f02:	30 4b       	mov	r11,4
80010f04:	0e 9c       	mov	r12,r7
80010f06:	f0 1f 00 13 	mcall	80010f50 <_Balloc+0x74>
80010f0a:	8b 3c       	st.w	r5[0xc],r12
80010f0c:	6e 98       	ld.w	r8,r7[0x24]
80010f0e:	70 3c       	ld.w	r12,r8[0xc]
80010f10:	58 0c       	cp.w	r12,0
80010f12:	c1 b0       	breq	80010f48 <_Balloc+0x6c>
80010f14:	6e 98       	ld.w	r8,r7[0x24]
80010f16:	70 38       	ld.w	r8,r8[0xc]
80010f18:	f0 06 00 28 	add	r8,r8,r6<<0x2
80010f1c:	70 0c       	ld.w	r12,r8[0x0]
80010f1e:	58 0c       	cp.w	r12,0
80010f20:	c0 40       	breq	80010f28 <_Balloc+0x4c>
80010f22:	78 09       	ld.w	r9,r12[0x0]
80010f24:	91 09       	st.w	r8[0x0],r9
80010f26:	c0 e8       	rjmp	80010f42 <_Balloc+0x66>
80010f28:	0e 9c       	mov	r12,r7
80010f2a:	30 17       	mov	r7,1
80010f2c:	0e 9b       	mov	r11,r7
80010f2e:	ee 06 09 47 	lsl	r7,r7,r6
80010f32:	ee ca ff fb 	sub	r10,r7,-5
80010f36:	a3 6a       	lsl	r10,0x2
80010f38:	f0 1f 00 06 	mcall	80010f50 <_Balloc+0x74>
80010f3c:	c0 60       	breq	80010f48 <_Balloc+0x6c>
80010f3e:	99 16       	st.w	r12[0x4],r6
80010f40:	99 27       	st.w	r12[0x8],r7
80010f42:	30 08       	mov	r8,0
80010f44:	99 38       	st.w	r12[0xc],r8
80010f46:	99 48       	st.w	r12[0x10],r8
80010f48:	d8 22       	popm	r4-r7,pc
80010f4a:	00 00       	add	r0,r0
80010f4c:	80 01       	ld.sh	r1,r0[0x0]
80010f4e:	08 c4       	st.b	r4++,r4
80010f50:	80 01       	ld.sh	r1,r0[0x0]
80010f52:	18 f8       	st.b	--r12,r8

80010f54 <__d2b>:
80010f54:	d4 31       	pushm	r0-r7,lr
80010f56:	20 2d       	sub	sp,8
80010f58:	16 93       	mov	r3,r11
80010f5a:	12 96       	mov	r6,r9
80010f5c:	10 95       	mov	r5,r8
80010f5e:	14 92       	mov	r2,r10
80010f60:	30 1b       	mov	r11,1
80010f62:	f0 1f 00 27 	mcall	80010ffc <__d2b+0xa8>
80010f66:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
80010f6a:	50 09       	stdsp	sp[0x0],r9
80010f6c:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
80010f70:	b5 a9       	sbr	r9,0x14
80010f72:	f0 01 16 14 	lsr	r1,r8,0x14
80010f76:	fb f9 1a 00 	st.wne	sp[0x0],r9
80010f7a:	18 94       	mov	r4,r12
80010f7c:	58 02       	cp.w	r2,0
80010f7e:	c1 e0       	breq	80010fba <__d2b+0x66>
80010f80:	fa cc ff f8 	sub	r12,sp,-8
80010f84:	18 d2       	st.w	--r12,r2
80010f86:	f0 1f 00 1f 	mcall	80011000 <__d2b+0xac>
80010f8a:	40 18       	lddsp	r8,sp[0x4]
80010f8c:	c0 d0       	breq	80010fa6 <__d2b+0x52>
80010f8e:	40 09       	lddsp	r9,sp[0x0]
80010f90:	f8 0a 11 20 	rsub	r10,r12,32
80010f94:	f2 0a 09 4a 	lsl	r10,r9,r10
80010f98:	f5 e8 10 08 	or	r8,r10,r8
80010f9c:	89 58       	st.w	r4[0x14],r8
80010f9e:	f2 0c 0a 49 	lsr	r9,r9,r12
80010fa2:	50 09       	stdsp	sp[0x0],r9
80010fa4:	c0 28       	rjmp	80010fa8 <__d2b+0x54>
80010fa6:	89 58       	st.w	r4[0x14],r8
80010fa8:	40 08       	lddsp	r8,sp[0x0]
80010faa:	58 08       	cp.w	r8,0
80010fac:	f9 b3 01 02 	movne	r3,2
80010fb0:	f9 b3 00 01 	moveq	r3,1
80010fb4:	89 68       	st.w	r4[0x18],r8
80010fb6:	89 43       	st.w	r4[0x10],r3
80010fb8:	c0 98       	rjmp	80010fca <__d2b+0x76>
80010fba:	1a 9c       	mov	r12,sp
80010fbc:	f0 1f 00 11 	mcall	80011000 <__d2b+0xac>
80010fc0:	30 13       	mov	r3,1
80010fc2:	40 08       	lddsp	r8,sp[0x0]
80010fc4:	2e 0c       	sub	r12,-32
80010fc6:	89 43       	st.w	r4[0x10],r3
80010fc8:	89 58       	st.w	r4[0x14],r8
80010fca:	58 01       	cp.w	r1,0
80010fcc:	c0 90       	breq	80010fde <__d2b+0x8a>
80010fce:	e2 c1 04 33 	sub	r1,r1,1075
80010fd2:	18 01       	add	r1,r12
80010fd4:	8d 01       	st.w	r6[0x0],r1
80010fd6:	f8 0c 11 35 	rsub	r12,r12,53
80010fda:	8b 0c       	st.w	r5[0x0],r12
80010fdc:	c0 d8       	rjmp	80010ff6 <__d2b+0xa2>
80010fde:	e6 c8 ff fc 	sub	r8,r3,-4
80010fe2:	f8 cc 04 32 	sub	r12,r12,1074
80010fe6:	a5 73       	lsl	r3,0x5
80010fe8:	8d 0c       	st.w	r6[0x0],r12
80010fea:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
80010fee:	f0 1f 00 06 	mcall	80011004 <__d2b+0xb0>
80010ff2:	18 13       	sub	r3,r12
80010ff4:	8b 03       	st.w	r5[0x0],r3
80010ff6:	08 9c       	mov	r12,r4
80010ff8:	2f ed       	sub	sp,-8
80010ffa:	d8 32       	popm	r0-r7,pc
80010ffc:	80 01       	ld.sh	r1,r0[0x0]
80010ffe:	0e dc       	st.w	--r7,r12
80011000:	80 01       	ld.sh	r1,r0[0x0]
80011002:	0d e4       	ld.ub	r4,r6[0x6]
80011004:	80 01       	ld.sh	r1,r0[0x0]
80011006:	0d 84       	ld.ub	r4,r6[0x0]

80011008 <__mdiff>:
80011008:	d4 31       	pushm	r0-r7,lr
8001100a:	74 48       	ld.w	r8,r10[0x10]
8001100c:	76 45       	ld.w	r5,r11[0x10]
8001100e:	16 97       	mov	r7,r11
80011010:	14 96       	mov	r6,r10
80011012:	10 15       	sub	r5,r8
80011014:	c1 31       	brne	8001103a <__mdiff+0x32>
80011016:	2f b8       	sub	r8,-5
80011018:	ee ce ff ec 	sub	lr,r7,-20
8001101c:	a3 68       	lsl	r8,0x2
8001101e:	f4 08 00 0b 	add	r11,r10,r8
80011022:	ee 08 00 08 	add	r8,r7,r8
80011026:	11 4a       	ld.w	r10,--r8
80011028:	17 49       	ld.w	r9,--r11
8001102a:	12 3a       	cp.w	r10,r9
8001102c:	c0 30       	breq	80011032 <__mdiff+0x2a>
8001102e:	c0 e2       	brcc	8001104a <__mdiff+0x42>
80011030:	c0 78       	rjmp	8001103e <__mdiff+0x36>
80011032:	1c 38       	cp.w	r8,lr
80011034:	fe 9b ff f9 	brhi	80011026 <__mdiff+0x1e>
80011038:	c4 a8       	rjmp	800110cc <__mdiff+0xc4>
8001103a:	58 05       	cp.w	r5,0
8001103c:	c0 64       	brge	80011048 <__mdiff+0x40>
8001103e:	0e 98       	mov	r8,r7
80011040:	30 15       	mov	r5,1
80011042:	0c 97       	mov	r7,r6
80011044:	10 96       	mov	r6,r8
80011046:	c0 28       	rjmp	8001104a <__mdiff+0x42>
80011048:	30 05       	mov	r5,0
8001104a:	6e 1b       	ld.w	r11,r7[0x4]
8001104c:	f0 1f 00 24 	mcall	800110dc <__mdiff+0xd4>
80011050:	6e 49       	ld.w	r9,r7[0x10]
80011052:	6c 44       	ld.w	r4,r6[0x10]
80011054:	99 35       	st.w	r12[0xc],r5
80011056:	2f b4       	sub	r4,-5
80011058:	f2 c5 ff fb 	sub	r5,r9,-5
8001105c:	ec 04 00 24 	add	r4,r6,r4<<0x2
80011060:	ee 05 00 25 	add	r5,r7,r5<<0x2
80011064:	2e c6       	sub	r6,-20
80011066:	2e c7       	sub	r7,-20
80011068:	f8 c8 ff ec 	sub	r8,r12,-20
8001106c:	30 0a       	mov	r10,0
8001106e:	0f 0e       	ld.w	lr,r7++
80011070:	0d 0b       	ld.w	r11,r6++
80011072:	fc 02 16 10 	lsr	r2,lr,0x10
80011076:	f6 03 16 10 	lsr	r3,r11,0x10
8001107a:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8001107e:	e4 03 01 03 	sub	r3,r2,r3
80011082:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
80011086:	fc 0b 01 0b 	sub	r11,lr,r11
8001108a:	f6 0a 00 0a 	add	r10,r11,r10
8001108e:	b0 1a       	st.h	r8[0x2],r10
80011090:	b1 4a       	asr	r10,0x10
80011092:	e6 0a 00 0a 	add	r10,r3,r10
80011096:	b0 0a       	st.h	r8[0x0],r10
80011098:	2f c8       	sub	r8,-4
8001109a:	b1 4a       	asr	r10,0x10
8001109c:	08 36       	cp.w	r6,r4
8001109e:	ce 83       	brcs	8001106e <__mdiff+0x66>
800110a0:	c0 d8       	rjmp	800110ba <__mdiff+0xb2>
800110a2:	0f 0b       	ld.w	r11,r7++
800110a4:	f6 0e 16 10 	lsr	lr,r11,0x10
800110a8:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
800110ac:	16 0a       	add	r10,r11
800110ae:	b0 1a       	st.h	r8[0x2],r10
800110b0:	b1 4a       	asr	r10,0x10
800110b2:	1c 0a       	add	r10,lr
800110b4:	b0 0a       	st.h	r8[0x0],r10
800110b6:	2f c8       	sub	r8,-4
800110b8:	b1 4a       	asr	r10,0x10
800110ba:	0a 37       	cp.w	r7,r5
800110bc:	cf 33       	brcs	800110a2 <__mdiff+0x9a>
800110be:	c0 28       	rjmp	800110c2 <__mdiff+0xba>
800110c0:	20 19       	sub	r9,1
800110c2:	11 4a       	ld.w	r10,--r8
800110c4:	58 0a       	cp.w	r10,0
800110c6:	cf d0       	breq	800110c0 <__mdiff+0xb8>
800110c8:	99 49       	st.w	r12[0x10],r9
800110ca:	d8 32       	popm	r0-r7,pc
800110cc:	30 0b       	mov	r11,0
800110ce:	f0 1f 00 04 	mcall	800110dc <__mdiff+0xd4>
800110d2:	30 18       	mov	r8,1
800110d4:	99 48       	st.w	r12[0x10],r8
800110d6:	30 08       	mov	r8,0
800110d8:	99 58       	st.w	r12[0x14],r8
800110da:	d8 32       	popm	r0-r7,pc
800110dc:	80 01       	ld.sh	r1,r0[0x0]
800110de:	0e dc       	st.w	--r7,r12

800110e0 <__lshift>:
800110e0:	d4 31       	pushm	r0-r7,lr
800110e2:	16 97       	mov	r7,r11
800110e4:	76 46       	ld.w	r6,r11[0x10]
800110e6:	f4 02 14 05 	asr	r2,r10,0x5
800110ea:	2f f6       	sub	r6,-1
800110ec:	14 93       	mov	r3,r10
800110ee:	18 94       	mov	r4,r12
800110f0:	04 06       	add	r6,r2
800110f2:	76 1b       	ld.w	r11,r11[0x4]
800110f4:	6e 28       	ld.w	r8,r7[0x8]
800110f6:	c0 38       	rjmp	800110fc <__lshift+0x1c>
800110f8:	2f fb       	sub	r11,-1
800110fa:	a1 78       	lsl	r8,0x1
800110fc:	10 36       	cp.w	r6,r8
800110fe:	fe 99 ff fd 	brgt	800110f8 <__lshift+0x18>
80011102:	08 9c       	mov	r12,r4
80011104:	f0 1f 00 1a 	mcall	8001116c <__lshift+0x8c>
80011108:	30 09       	mov	r9,0
8001110a:	18 95       	mov	r5,r12
8001110c:	f8 c8 ff ec 	sub	r8,r12,-20
80011110:	12 9a       	mov	r10,r9
80011112:	c0 38       	rjmp	80011118 <__lshift+0x38>
80011114:	10 aa       	st.w	r8++,r10
80011116:	2f f9       	sub	r9,-1
80011118:	04 39       	cp.w	r9,r2
8001111a:	cf d5       	brlt	80011114 <__lshift+0x34>
8001111c:	6e 4b       	ld.w	r11,r7[0x10]
8001111e:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
80011122:	2f bb       	sub	r11,-5
80011124:	ee c9 ff ec 	sub	r9,r7,-20
80011128:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8001112c:	58 03       	cp.w	r3,0
8001112e:	c1 30       	breq	80011154 <__lshift+0x74>
80011130:	e6 0c 11 20 	rsub	r12,r3,32
80011134:	30 0a       	mov	r10,0
80011136:	72 02       	ld.w	r2,r9[0x0]
80011138:	e4 03 09 42 	lsl	r2,r2,r3
8001113c:	04 4a       	or	r10,r2
8001113e:	10 aa       	st.w	r8++,r10
80011140:	13 0a       	ld.w	r10,r9++
80011142:	f4 0c 0a 4a 	lsr	r10,r10,r12
80011146:	16 39       	cp.w	r9,r11
80011148:	cf 73       	brcs	80011136 <__lshift+0x56>
8001114a:	91 0a       	st.w	r8[0x0],r10
8001114c:	58 0a       	cp.w	r10,0
8001114e:	c0 70       	breq	8001115c <__lshift+0x7c>
80011150:	2f f6       	sub	r6,-1
80011152:	c0 58       	rjmp	8001115c <__lshift+0x7c>
80011154:	13 0a       	ld.w	r10,r9++
80011156:	10 aa       	st.w	r8++,r10
80011158:	16 39       	cp.w	r9,r11
8001115a:	cf d3       	brcs	80011154 <__lshift+0x74>
8001115c:	08 9c       	mov	r12,r4
8001115e:	20 16       	sub	r6,1
80011160:	0e 9b       	mov	r11,r7
80011162:	8b 46       	st.w	r5[0x10],r6
80011164:	f0 1f 00 03 	mcall	80011170 <__lshift+0x90>
80011168:	0a 9c       	mov	r12,r5
8001116a:	d8 32       	popm	r0-r7,pc
8001116c:	80 01       	ld.sh	r1,r0[0x0]
8001116e:	0e dc       	st.w	--r7,r12
80011170:	80 01       	ld.sh	r1,r0[0x0]
80011172:	0e a4       	st.w	r7++,r4

80011174 <__multiply>:
80011174:	d4 31       	pushm	r0-r7,lr
80011176:	20 2d       	sub	sp,8
80011178:	76 49       	ld.w	r9,r11[0x10]
8001117a:	74 48       	ld.w	r8,r10[0x10]
8001117c:	16 96       	mov	r6,r11
8001117e:	14 95       	mov	r5,r10
80011180:	10 39       	cp.w	r9,r8
80011182:	ec 08 17 50 	movlt	r8,r6
80011186:	ea 06 17 50 	movlt	r6,r5
8001118a:	f0 05 17 50 	movlt	r5,r8
8001118e:	6c 28       	ld.w	r8,r6[0x8]
80011190:	76 43       	ld.w	r3,r11[0x10]
80011192:	74 42       	ld.w	r2,r10[0x10]
80011194:	76 1b       	ld.w	r11,r11[0x4]
80011196:	e4 03 00 07 	add	r7,r2,r3
8001119a:	10 37       	cp.w	r7,r8
8001119c:	f7 bb 09 ff 	subgt	r11,-1
800111a0:	f0 1f 00 36 	mcall	80011278 <__multiply+0x104>
800111a4:	ee c4 ff fb 	sub	r4,r7,-5
800111a8:	f8 c9 ff ec 	sub	r9,r12,-20
800111ac:	f8 04 00 24 	add	r4,r12,r4<<0x2
800111b0:	30 0a       	mov	r10,0
800111b2:	12 98       	mov	r8,r9
800111b4:	c0 28       	rjmp	800111b8 <__multiply+0x44>
800111b6:	10 aa       	st.w	r8++,r10
800111b8:	08 38       	cp.w	r8,r4
800111ba:	cf e3       	brcs	800111b6 <__multiply+0x42>
800111bc:	2f b3       	sub	r3,-5
800111be:	2f b2       	sub	r2,-5
800111c0:	ec 03 00 23 	add	r3,r6,r3<<0x2
800111c4:	ea 02 00 22 	add	r2,r5,r2<<0x2
800111c8:	ec cb ff ec 	sub	r11,r6,-20
800111cc:	50 12       	stdsp	sp[0x4],r2
800111ce:	ea ca ff ec 	sub	r10,r5,-20
800111d2:	c4 48       	rjmp	8001125a <__multiply+0xe6>
800111d4:	94 95       	ld.uh	r5,r10[0x2]
800111d6:	58 05       	cp.w	r5,0
800111d8:	c2 00       	breq	80011218 <__multiply+0xa4>
800111da:	12 98       	mov	r8,r9
800111dc:	16 96       	mov	r6,r11
800111de:	30 0e       	mov	lr,0
800111e0:	50 09       	stdsp	sp[0x0],r9
800111e2:	0d 02       	ld.w	r2,r6++
800111e4:	e4 00 16 10 	lsr	r0,r2,0x10
800111e8:	70 01       	ld.w	r1,r8[0x0]
800111ea:	70 09       	ld.w	r9,r8[0x0]
800111ec:	b1 81       	lsr	r1,0x10
800111ee:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
800111f2:	e0 05 03 41 	mac	r1,r0,r5
800111f6:	ab 32       	mul	r2,r5
800111f8:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
800111fc:	00 02       	add	r2,r0
800111fe:	e4 0e 00 0e 	add	lr,r2,lr
80011202:	b0 1e       	st.h	r8[0x2],lr
80011204:	b1 8e       	lsr	lr,0x10
80011206:	1c 01       	add	r1,lr
80011208:	b0 01       	st.h	r8[0x0],r1
8001120a:	e2 0e 16 10 	lsr	lr,r1,0x10
8001120e:	2f c8       	sub	r8,-4
80011210:	06 36       	cp.w	r6,r3
80011212:	ce 83       	brcs	800111e2 <__multiply+0x6e>
80011214:	40 09       	lddsp	r9,sp[0x0]
80011216:	91 0e       	st.w	r8[0x0],lr
80011218:	94 86       	ld.uh	r6,r10[0x0]
8001121a:	58 06       	cp.w	r6,0
8001121c:	c1 d0       	breq	80011256 <__multiply+0xe2>
8001121e:	72 02       	ld.w	r2,r9[0x0]
80011220:	12 98       	mov	r8,r9
80011222:	16 9e       	mov	lr,r11
80011224:	30 05       	mov	r5,0
80011226:	b0 12       	st.h	r8[0x2],r2
80011228:	1d 01       	ld.w	r1,lr++
8001122a:	90 82       	ld.uh	r2,r8[0x0]
8001122c:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
80011230:	ad 30       	mul	r0,r6
80011232:	e0 02 00 02 	add	r2,r0,r2
80011236:	e4 05 00 05 	add	r5,r2,r5
8001123a:	b0 05       	st.h	r8[0x0],r5
8001123c:	b1 85       	lsr	r5,0x10
8001123e:	b1 81       	lsr	r1,0x10
80011240:	2f c8       	sub	r8,-4
80011242:	ad 31       	mul	r1,r6
80011244:	90 92       	ld.uh	r2,r8[0x2]
80011246:	e2 02 00 02 	add	r2,r1,r2
8001124a:	0a 02       	add	r2,r5
8001124c:	e4 05 16 10 	lsr	r5,r2,0x10
80011250:	06 3e       	cp.w	lr,r3
80011252:	ce a3       	brcs	80011226 <__multiply+0xb2>
80011254:	91 02       	st.w	r8[0x0],r2
80011256:	2f ca       	sub	r10,-4
80011258:	2f c9       	sub	r9,-4
8001125a:	40 18       	lddsp	r8,sp[0x4]
8001125c:	10 3a       	cp.w	r10,r8
8001125e:	cb b3       	brcs	800111d4 <__multiply+0x60>
80011260:	c0 28       	rjmp	80011264 <__multiply+0xf0>
80011262:	20 17       	sub	r7,1
80011264:	58 07       	cp.w	r7,0
80011266:	e0 8a 00 05 	brle	80011270 <__multiply+0xfc>
8001126a:	09 48       	ld.w	r8,--r4
8001126c:	58 08       	cp.w	r8,0
8001126e:	cf a0       	breq	80011262 <__multiply+0xee>
80011270:	99 47       	st.w	r12[0x10],r7
80011272:	2f ed       	sub	sp,-8
80011274:	d8 32       	popm	r0-r7,pc
80011276:	00 00       	add	r0,r0
80011278:	80 01       	ld.sh	r1,r0[0x0]
8001127a:	0e dc       	st.w	--r7,r12

8001127c <__i2b>:
8001127c:	d4 21       	pushm	r4-r7,lr
8001127e:	16 97       	mov	r7,r11
80011280:	30 1b       	mov	r11,1
80011282:	f0 1f 00 04 	mcall	80011290 <__i2b+0x14>
80011286:	30 19       	mov	r9,1
80011288:	99 57       	st.w	r12[0x14],r7
8001128a:	99 49       	st.w	r12[0x10],r9
8001128c:	d8 22       	popm	r4-r7,pc
8001128e:	00 00       	add	r0,r0
80011290:	80 01       	ld.sh	r1,r0[0x0]
80011292:	0e dc       	st.w	--r7,r12

80011294 <__multadd>:
80011294:	d4 31       	pushm	r0-r7,lr
80011296:	30 08       	mov	r8,0
80011298:	12 95       	mov	r5,r9
8001129a:	16 97       	mov	r7,r11
8001129c:	18 96       	mov	r6,r12
8001129e:	76 44       	ld.w	r4,r11[0x10]
800112a0:	f6 c9 ff ec 	sub	r9,r11,-20
800112a4:	72 0b       	ld.w	r11,r9[0x0]
800112a6:	f6 0c 16 10 	lsr	r12,r11,0x10
800112aa:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
800112ae:	f4 0c 02 4c 	mul	r12,r10,r12
800112b2:	f4 0b 03 45 	mac	r5,r10,r11
800112b6:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
800112ba:	b1 85       	lsr	r5,0x10
800112bc:	18 05       	add	r5,r12
800112be:	ea 0c 15 10 	lsl	r12,r5,0x10
800112c2:	f8 0b 00 0b 	add	r11,r12,r11
800112c6:	12 ab       	st.w	r9++,r11
800112c8:	2f f8       	sub	r8,-1
800112ca:	b1 85       	lsr	r5,0x10
800112cc:	08 38       	cp.w	r8,r4
800112ce:	ce b5       	brlt	800112a4 <__multadd+0x10>
800112d0:	58 05       	cp.w	r5,0
800112d2:	c1 d0       	breq	8001130c <__multadd+0x78>
800112d4:	6e 28       	ld.w	r8,r7[0x8]
800112d6:	10 34       	cp.w	r4,r8
800112d8:	c1 45       	brlt	80011300 <__multadd+0x6c>
800112da:	6e 1b       	ld.w	r11,r7[0x4]
800112dc:	0c 9c       	mov	r12,r6
800112de:	2f fb       	sub	r11,-1
800112e0:	f0 1f 00 0c 	mcall	80011310 <__multadd+0x7c>
800112e4:	6e 4a       	ld.w	r10,r7[0x10]
800112e6:	ee cb ff f4 	sub	r11,r7,-12
800112ea:	18 93       	mov	r3,r12
800112ec:	2f ea       	sub	r10,-2
800112ee:	2f 4c       	sub	r12,-12
800112f0:	a3 6a       	lsl	r10,0x2
800112f2:	f0 1f 00 09 	mcall	80011314 <__multadd+0x80>
800112f6:	0e 9b       	mov	r11,r7
800112f8:	0c 9c       	mov	r12,r6
800112fa:	f0 1f 00 08 	mcall	80011318 <__multadd+0x84>
800112fe:	06 97       	mov	r7,r3
80011300:	e8 c8 ff ff 	sub	r8,r4,-1
80011304:	2f b4       	sub	r4,-5
80011306:	8f 48       	st.w	r7[0x10],r8
80011308:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8001130c:	0e 9c       	mov	r12,r7
8001130e:	d8 32       	popm	r0-r7,pc
80011310:	80 01       	ld.sh	r1,r0[0x0]
80011312:	0e dc       	st.w	--r7,r12
80011314:	80 00       	ld.sh	r0,r0[0x0]
80011316:	cc ba       	rjmp	800110ac <__mdiff+0xa4>
80011318:	80 01       	ld.sh	r1,r0[0x0]
8001131a:	0e a4       	st.w	r7++,r4

8001131c <__pow5mult>:
8001131c:	d4 31       	pushm	r0-r7,lr
8001131e:	14 96       	mov	r6,r10
80011320:	18 97       	mov	r7,r12
80011322:	16 94       	mov	r4,r11
80011324:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
80011328:	c0 90       	breq	8001133a <__pow5mult+0x1e>
8001132a:	20 18       	sub	r8,1
8001132c:	4a 19       	lddpc	r9,800113b0 <__pow5mult+0x94>
8001132e:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
80011332:	30 09       	mov	r9,0
80011334:	f0 1f 00 20 	mcall	800113b4 <__pow5mult+0x98>
80011338:	18 94       	mov	r4,r12
8001133a:	a3 46       	asr	r6,0x2
8001133c:	c3 70       	breq	800113aa <__pow5mult+0x8e>
8001133e:	6e 95       	ld.w	r5,r7[0x24]
80011340:	58 05       	cp.w	r5,0
80011342:	c0 91       	brne	80011354 <__pow5mult+0x38>
80011344:	31 0c       	mov	r12,16
80011346:	f0 1f 00 1d 	mcall	800113b8 <__pow5mult+0x9c>
8001134a:	99 35       	st.w	r12[0xc],r5
8001134c:	8f 9c       	st.w	r7[0x24],r12
8001134e:	99 15       	st.w	r12[0x4],r5
80011350:	99 25       	st.w	r12[0x8],r5
80011352:	99 05       	st.w	r12[0x0],r5
80011354:	6e 93       	ld.w	r3,r7[0x24]
80011356:	66 25       	ld.w	r5,r3[0x8]
80011358:	58 05       	cp.w	r5,0
8001135a:	c0 d1       	brne	80011374 <__pow5mult+0x58>
8001135c:	e0 6b 02 71 	mov	r11,625
80011360:	0e 9c       	mov	r12,r7
80011362:	f0 1f 00 17 	mcall	800113bc <__pow5mult+0xa0>
80011366:	87 2c       	st.w	r3[0x8],r12
80011368:	30 08       	mov	r8,0
8001136a:	18 95       	mov	r5,r12
8001136c:	99 08       	st.w	r12[0x0],r8
8001136e:	c0 38       	rjmp	80011374 <__pow5mult+0x58>
80011370:	06 9c       	mov	r12,r3
80011372:	18 95       	mov	r5,r12
80011374:	ed b6 00 00 	bld	r6,0x0
80011378:	c0 c1       	brne	80011390 <__pow5mult+0x74>
8001137a:	08 9b       	mov	r11,r4
8001137c:	0a 9a       	mov	r10,r5
8001137e:	0e 9c       	mov	r12,r7
80011380:	f0 1f 00 10 	mcall	800113c0 <__pow5mult+0xa4>
80011384:	08 9b       	mov	r11,r4
80011386:	18 93       	mov	r3,r12
80011388:	0e 9c       	mov	r12,r7
8001138a:	06 94       	mov	r4,r3
8001138c:	f0 1f 00 0e 	mcall	800113c4 <__pow5mult+0xa8>
80011390:	a1 56       	asr	r6,0x1
80011392:	c0 c0       	breq	800113aa <__pow5mult+0x8e>
80011394:	6a 03       	ld.w	r3,r5[0x0]
80011396:	58 03       	cp.w	r3,0
80011398:	ce c1       	brne	80011370 <__pow5mult+0x54>
8001139a:	0a 9a       	mov	r10,r5
8001139c:	0a 9b       	mov	r11,r5
8001139e:	0e 9c       	mov	r12,r7
800113a0:	f0 1f 00 08 	mcall	800113c0 <__pow5mult+0xa4>
800113a4:	8b 0c       	st.w	r5[0x0],r12
800113a6:	99 03       	st.w	r12[0x0],r3
800113a8:	ce 5b       	rjmp	80011372 <__pow5mult+0x56>
800113aa:	08 9c       	mov	r12,r4
800113ac:	d8 32       	popm	r0-r7,pc
800113ae:	00 00       	add	r0,r0
800113b0:	80 01       	ld.sh	r1,r0[0x0]
800113b2:	2b e4       	sub	r4,-66
800113b4:	80 01       	ld.sh	r1,r0[0x0]
800113b6:	12 94       	mov	r4,r9
800113b8:	80 01       	ld.sh	r1,r0[0x0]
800113ba:	08 c4       	st.b	r4++,r4
800113bc:	80 01       	ld.sh	r1,r0[0x0]
800113be:	12 7c       	tst	r12,r9
800113c0:	80 01       	ld.sh	r1,r0[0x0]
800113c2:	11 74       	ld.ub	r4,--r8
800113c4:	80 01       	ld.sh	r1,r0[0x0]
800113c6:	0e a4       	st.w	r7++,r4

800113c8 <_realloc_r>:
800113c8:	d4 31       	pushm	r0-r7,lr
800113ca:	20 1d       	sub	sp,4
800113cc:	16 94       	mov	r4,r11
800113ce:	18 92       	mov	r2,r12
800113d0:	14 9b       	mov	r11,r10
800113d2:	58 04       	cp.w	r4,0
800113d4:	c0 51       	brne	800113de <_realloc_r+0x16>
800113d6:	f0 1f 00 5b 	mcall	80011540 <_realloc_r+0x178>
800113da:	18 95       	mov	r5,r12
800113dc:	c5 b9       	rjmp	80011692 <_realloc_r+0x2ca>
800113de:	50 0a       	stdsp	sp[0x0],r10
800113e0:	f0 1f 00 59 	mcall	80011544 <_realloc_r+0x17c>
800113e4:	40 0b       	lddsp	r11,sp[0x0]
800113e6:	f6 c8 ff f5 	sub	r8,r11,-11
800113ea:	e8 c1 00 08 	sub	r1,r4,8
800113ee:	10 96       	mov	r6,r8
800113f0:	62 1c       	ld.w	r12,r1[0x4]
800113f2:	e0 16 ff f8 	andl	r6,0xfff8
800113f6:	59 68       	cp.w	r8,22
800113f8:	f9 b6 08 10 	movls	r6,16
800113fc:	16 36       	cp.w	r6,r11
800113fe:	5f 38       	srlo	r8
80011400:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
80011404:	c0 50       	breq	8001140e <_realloc_r+0x46>
80011406:	30 c8       	mov	r8,12
80011408:	30 05       	mov	r5,0
8001140a:	85 38       	st.w	r2[0xc],r8
8001140c:	c4 39       	rjmp	80011692 <_realloc_r+0x2ca>
8001140e:	18 90       	mov	r0,r12
80011410:	e0 10 ff fc 	andl	r0,0xfffc
80011414:	0c 30       	cp.w	r0,r6
80011416:	e0 84 01 13 	brge	8001163c <_realloc_r+0x274>
8001141a:	4c c8       	lddpc	r8,80011548 <_realloc_r+0x180>
8001141c:	e2 00 00 09 	add	r9,r1,r0
80011420:	70 25       	ld.w	r5,r8[0x8]
80011422:	0a 39       	cp.w	r9,r5
80011424:	c0 90       	breq	80011436 <_realloc_r+0x6e>
80011426:	72 1a       	ld.w	r10,r9[0x4]
80011428:	a1 ca       	cbr	r10,0x0
8001142a:	f2 0a 00 0a 	add	r10,r9,r10
8001142e:	74 1a       	ld.w	r10,r10[0x4]
80011430:	ed ba 00 00 	bld	r10,0x0
80011434:	c2 20       	breq	80011478 <_realloc_r+0xb0>
80011436:	72 1a       	ld.w	r10,r9[0x4]
80011438:	e0 1a ff fc 	andl	r10,0xfffc
8001143c:	f4 00 00 03 	add	r3,r10,r0
80011440:	0a 39       	cp.w	r9,r5
80011442:	c1 31       	brne	80011468 <_realloc_r+0xa0>
80011444:	ec c7 ff f0 	sub	r7,r6,-16
80011448:	0e 33       	cp.w	r3,r7
8001144a:	c1 95       	brlt	8001147c <_realloc_r+0xb4>
8001144c:	e2 06 00 09 	add	r9,r1,r6
80011450:	0c 13       	sub	r3,r6
80011452:	a1 a3       	sbr	r3,0x0
80011454:	93 13       	st.w	r9[0x4],r3
80011456:	91 29       	st.w	r8[0x8],r9
80011458:	04 9c       	mov	r12,r2
8001145a:	62 18       	ld.w	r8,r1[0x4]
8001145c:	08 95       	mov	r5,r4
8001145e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80011462:	10 46       	or	r6,r8
80011464:	83 16       	st.w	r1[0x4],r6
80011466:	c1 49       	rjmp	8001168e <_realloc_r+0x2c6>
80011468:	0c 33       	cp.w	r3,r6
8001146a:	c0 95       	brlt	8001147c <_realloc_r+0xb4>
8001146c:	72 28       	ld.w	r8,r9[0x8]
8001146e:	02 97       	mov	r7,r1
80011470:	72 39       	ld.w	r9,r9[0xc]
80011472:	93 28       	st.w	r9[0x8],r8
80011474:	91 39       	st.w	r8[0xc],r9
80011476:	ce 58       	rjmp	80011640 <_realloc_r+0x278>
80011478:	30 0a       	mov	r10,0
8001147a:	14 99       	mov	r9,r10
8001147c:	ed bc 00 00 	bld	r12,0x0
80011480:	e0 80 00 9e 	breq	800115bc <_realloc_r+0x1f4>
80011484:	62 07       	ld.w	r7,r1[0x0]
80011486:	e2 07 01 07 	sub	r7,r1,r7
8001148a:	6e 1c       	ld.w	r12,r7[0x4]
8001148c:	e0 1c ff fc 	andl	r12,0xfffc
80011490:	58 09       	cp.w	r9,0
80011492:	c5 f0       	breq	80011550 <_realloc_r+0x188>
80011494:	f8 00 00 03 	add	r3,r12,r0
80011498:	0a 39       	cp.w	r9,r5
8001149a:	c4 81       	brne	8001152a <_realloc_r+0x162>
8001149c:	14 03       	add	r3,r10
8001149e:	ec c9 ff f0 	sub	r9,r6,-16
800114a2:	12 33       	cp.w	r3,r9
800114a4:	c5 65       	brlt	80011550 <_realloc_r+0x188>
800114a6:	6e 3a       	ld.w	r10,r7[0xc]
800114a8:	6e 29       	ld.w	r9,r7[0x8]
800114aa:	95 29       	st.w	r10[0x8],r9
800114ac:	93 3a       	st.w	r9[0xc],r10
800114ae:	ee c5 ff f8 	sub	r5,r7,-8
800114b2:	e0 ca 00 04 	sub	r10,r0,4
800114b6:	e0 4a 00 24 	cp.w	r10,36
800114ba:	e0 8b 00 25 	brhi	80011504 <_realloc_r+0x13c>
800114be:	0a 99       	mov	r9,r5
800114c0:	59 3a       	cp.w	r10,19
800114c2:	e0 88 00 1a 	brls	800114f6 <_realloc_r+0x12e>
800114c6:	09 09       	ld.w	r9,r4++
800114c8:	8b 09       	st.w	r5[0x0],r9
800114ca:	09 09       	ld.w	r9,r4++
800114cc:	8f 39       	st.w	r7[0xc],r9
800114ce:	ee c9 ff f0 	sub	r9,r7,-16
800114d2:	59 ba       	cp.w	r10,27
800114d4:	e0 88 00 11 	brls	800114f6 <_realloc_r+0x12e>
800114d8:	09 0b       	ld.w	r11,r4++
800114da:	93 0b       	st.w	r9[0x0],r11
800114dc:	09 09       	ld.w	r9,r4++
800114de:	8f 59       	st.w	r7[0x14],r9
800114e0:	ee c9 ff e8 	sub	r9,r7,-24
800114e4:	e0 4a 00 24 	cp.w	r10,36
800114e8:	c0 71       	brne	800114f6 <_realloc_r+0x12e>
800114ea:	09 0a       	ld.w	r10,r4++
800114ec:	93 0a       	st.w	r9[0x0],r10
800114ee:	ee c9 ff e0 	sub	r9,r7,-32
800114f2:	09 0a       	ld.w	r10,r4++
800114f4:	8f 7a       	st.w	r7[0x1c],r10
800114f6:	09 0a       	ld.w	r10,r4++
800114f8:	12 aa       	st.w	r9++,r10
800114fa:	68 0a       	ld.w	r10,r4[0x0]
800114fc:	93 0a       	st.w	r9[0x0],r10
800114fe:	68 1a       	ld.w	r10,r4[0x4]
80011500:	93 1a       	st.w	r9[0x4],r10
80011502:	c0 78       	rjmp	80011510 <_realloc_r+0x148>
80011504:	50 08       	stdsp	sp[0x0],r8
80011506:	08 9b       	mov	r11,r4
80011508:	0a 9c       	mov	r12,r5
8001150a:	f0 1f 00 11 	mcall	8001154c <_realloc_r+0x184>
8001150e:	40 08       	lddsp	r8,sp[0x0]
80011510:	ee 06 00 09 	add	r9,r7,r6
80011514:	0c 13       	sub	r3,r6
80011516:	a1 a3       	sbr	r3,0x0
80011518:	93 13       	st.w	r9[0x4],r3
8001151a:	91 29       	st.w	r8[0x8],r9
8001151c:	04 9c       	mov	r12,r2
8001151e:	6e 18       	ld.w	r8,r7[0x4]
80011520:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80011524:	10 46       	or	r6,r8
80011526:	8f 16       	st.w	r7[0x4],r6
80011528:	cb 38       	rjmp	8001168e <_realloc_r+0x2c6>
8001152a:	14 03       	add	r3,r10
8001152c:	0c 33       	cp.w	r3,r6
8001152e:	c1 15       	brlt	80011550 <_realloc_r+0x188>
80011530:	72 28       	ld.w	r8,r9[0x8]
80011532:	72 39       	ld.w	r9,r9[0xc]
80011534:	93 28       	st.w	r9[0x8],r8
80011536:	91 39       	st.w	r8[0xc],r9
80011538:	6e 28       	ld.w	r8,r7[0x8]
8001153a:	6e 39       	ld.w	r9,r7[0xc]
8001153c:	c1 08       	rjmp	8001155c <_realloc_r+0x194>
8001153e:	00 00       	add	r0,r0
80011540:	80 01       	ld.sh	r1,r0[0x0]
80011542:	08 dc       	st.w	--r4,r12
80011544:	80 01       	ld.sh	r1,r0[0x0]
80011546:	0d 80       	ld.ub	r0,r6[0x0]
80011548:	00 00       	add	r0,r0
8001154a:	01 ac       	ld.ub	r12,r0[0x2]
8001154c:	80 01       	ld.sh	r1,r0[0x0]
8001154e:	0d 42       	ld.w	r2,--r6
80011550:	f8 00 00 03 	add	r3,r12,r0
80011554:	0c 33       	cp.w	r3,r6
80011556:	c3 35       	brlt	800115bc <_realloc_r+0x1f4>
80011558:	6e 39       	ld.w	r9,r7[0xc]
8001155a:	6e 28       	ld.w	r8,r7[0x8]
8001155c:	93 28       	st.w	r9[0x8],r8
8001155e:	91 39       	st.w	r8[0xc],r9
80011560:	e0 ca 00 04 	sub	r10,r0,4
80011564:	ee cc ff f8 	sub	r12,r7,-8
80011568:	e0 4a 00 24 	cp.w	r10,36
8001156c:	e0 8b 00 24 	brhi	800115b4 <_realloc_r+0x1ec>
80011570:	59 3a       	cp.w	r10,19
80011572:	e0 88 00 1a 	brls	800115a6 <_realloc_r+0x1de>
80011576:	09 08       	ld.w	r8,r4++
80011578:	99 08       	st.w	r12[0x0],r8
8001157a:	09 08       	ld.w	r8,r4++
8001157c:	8f 38       	st.w	r7[0xc],r8
8001157e:	ee cc ff f0 	sub	r12,r7,-16
80011582:	59 ba       	cp.w	r10,27
80011584:	e0 88 00 11 	brls	800115a6 <_realloc_r+0x1de>
80011588:	09 08       	ld.w	r8,r4++
8001158a:	99 08       	st.w	r12[0x0],r8
8001158c:	09 08       	ld.w	r8,r4++
8001158e:	8f 58       	st.w	r7[0x14],r8
80011590:	ee cc ff e8 	sub	r12,r7,-24
80011594:	e0 4a 00 24 	cp.w	r10,36
80011598:	c0 71       	brne	800115a6 <_realloc_r+0x1de>
8001159a:	09 08       	ld.w	r8,r4++
8001159c:	99 08       	st.w	r12[0x0],r8
8001159e:	ee cc ff e0 	sub	r12,r7,-32
800115a2:	09 08       	ld.w	r8,r4++
800115a4:	8f 78       	st.w	r7[0x1c],r8
800115a6:	09 08       	ld.w	r8,r4++
800115a8:	18 a8       	st.w	r12++,r8
800115aa:	68 08       	ld.w	r8,r4[0x0]
800115ac:	99 08       	st.w	r12[0x0],r8
800115ae:	68 18       	ld.w	r8,r4[0x4]
800115b0:	99 18       	st.w	r12[0x4],r8
800115b2:	c4 78       	rjmp	80011640 <_realloc_r+0x278>
800115b4:	08 9b       	mov	r11,r4
800115b6:	f0 1f 00 39 	mcall	80011698 <_realloc_r+0x2d0>
800115ba:	c4 38       	rjmp	80011640 <_realloc_r+0x278>
800115bc:	04 9c       	mov	r12,r2
800115be:	f0 1f 00 38 	mcall	8001169c <_realloc_r+0x2d4>
800115c2:	18 95       	mov	r5,r12
800115c4:	c3 a0       	breq	80011638 <_realloc_r+0x270>
800115c6:	62 18       	ld.w	r8,r1[0x4]
800115c8:	f8 c9 00 08 	sub	r9,r12,8
800115cc:	a1 c8       	cbr	r8,0x0
800115ce:	e2 08 00 08 	add	r8,r1,r8
800115d2:	10 39       	cp.w	r9,r8
800115d4:	c0 71       	brne	800115e2 <_realloc_r+0x21a>
800115d6:	72 13       	ld.w	r3,r9[0x4]
800115d8:	02 97       	mov	r7,r1
800115da:	e0 13 ff fc 	andl	r3,0xfffc
800115de:	00 03       	add	r3,r0
800115e0:	c3 08       	rjmp	80011640 <_realloc_r+0x278>
800115e2:	e0 ca 00 04 	sub	r10,r0,4
800115e6:	e0 4a 00 24 	cp.w	r10,36
800115ea:	e0 8b 00 20 	brhi	8001162a <_realloc_r+0x262>
800115ee:	08 99       	mov	r9,r4
800115f0:	18 98       	mov	r8,r12
800115f2:	59 3a       	cp.w	r10,19
800115f4:	e0 88 00 14 	brls	8001161c <_realloc_r+0x254>
800115f8:	13 0b       	ld.w	r11,r9++
800115fa:	10 ab       	st.w	r8++,r11
800115fc:	13 0b       	ld.w	r11,r9++
800115fe:	10 ab       	st.w	r8++,r11
80011600:	59 ba       	cp.w	r10,27
80011602:	e0 88 00 0d 	brls	8001161c <_realloc_r+0x254>
80011606:	13 0b       	ld.w	r11,r9++
80011608:	10 ab       	st.w	r8++,r11
8001160a:	13 0b       	ld.w	r11,r9++
8001160c:	10 ab       	st.w	r8++,r11
8001160e:	e0 4a 00 24 	cp.w	r10,36
80011612:	c0 51       	brne	8001161c <_realloc_r+0x254>
80011614:	13 0a       	ld.w	r10,r9++
80011616:	10 aa       	st.w	r8++,r10
80011618:	13 0a       	ld.w	r10,r9++
8001161a:	10 aa       	st.w	r8++,r10
8001161c:	13 0a       	ld.w	r10,r9++
8001161e:	10 aa       	st.w	r8++,r10
80011620:	72 0a       	ld.w	r10,r9[0x0]
80011622:	91 0a       	st.w	r8[0x0],r10
80011624:	72 19       	ld.w	r9,r9[0x4]
80011626:	91 19       	st.w	r8[0x4],r9
80011628:	c0 48       	rjmp	80011630 <_realloc_r+0x268>
8001162a:	08 9b       	mov	r11,r4
8001162c:	f0 1f 00 1b 	mcall	80011698 <_realloc_r+0x2d0>
80011630:	08 9b       	mov	r11,r4
80011632:	04 9c       	mov	r12,r2
80011634:	f0 1f 00 1b 	mcall	800116a0 <_realloc_r+0x2d8>
80011638:	04 9c       	mov	r12,r2
8001163a:	c2 a8       	rjmp	8001168e <_realloc_r+0x2c6>
8001163c:	00 93       	mov	r3,r0
8001163e:	02 97       	mov	r7,r1
80011640:	e6 06 01 09 	sub	r9,r3,r6
80011644:	6e 18       	ld.w	r8,r7[0x4]
80011646:	58 f9       	cp.w	r9,15
80011648:	e0 88 00 16 	brls	80011674 <_realloc_r+0x2ac>
8001164c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80011650:	ed e8 10 08 	or	r8,r6,r8
80011654:	8f 18       	st.w	r7[0x4],r8
80011656:	12 98       	mov	r8,r9
80011658:	a1 a8       	sbr	r8,0x0
8001165a:	ee 06 00 0b 	add	r11,r7,r6
8001165e:	f6 09 00 09 	add	r9,r11,r9
80011662:	97 18       	st.w	r11[0x4],r8
80011664:	72 18       	ld.w	r8,r9[0x4]
80011666:	a1 a8       	sbr	r8,0x0
80011668:	2f 8b       	sub	r11,-8
8001166a:	93 18       	st.w	r9[0x4],r8
8001166c:	04 9c       	mov	r12,r2
8001166e:	f0 1f 00 0d 	mcall	800116a0 <_realloc_r+0x2d8>
80011672:	c0 b8       	rjmp	80011688 <_realloc_r+0x2c0>
80011674:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80011678:	e7 e8 10 08 	or	r8,r3,r8
8001167c:	8f 18       	st.w	r7[0x4],r8
8001167e:	ee 03 00 03 	add	r3,r7,r3
80011682:	66 18       	ld.w	r8,r3[0x4]
80011684:	a1 a8       	sbr	r8,0x0
80011686:	87 18       	st.w	r3[0x4],r8
80011688:	04 9c       	mov	r12,r2
8001168a:	ee c5 ff f8 	sub	r5,r7,-8
8001168e:	f0 1f 00 06 	mcall	800116a4 <_realloc_r+0x2dc>
80011692:	0a 9c       	mov	r12,r5
80011694:	2f fd       	sub	sp,-4
80011696:	d8 32       	popm	r0-r7,pc
80011698:	80 01       	ld.sh	r1,r0[0x0]
8001169a:	0d 42       	ld.w	r2,--r6
8001169c:	80 01       	ld.sh	r1,r0[0x0]
8001169e:	08 dc       	st.w	--r4,r12
800116a0:	80 01       	ld.sh	r1,r0[0x0]
800116a2:	03 38       	ld.ub	r8,r1++
800116a4:	80 01       	ld.sh	r1,r0[0x0]
800116a6:	0d 82       	ld.ub	r2,r6[0x0]

800116a8 <__isinfd>:
800116a8:	14 98       	mov	r8,r10
800116aa:	fc 19 7f f0 	movh	r9,0x7ff0
800116ae:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
800116b2:	f0 0b 11 00 	rsub	r11,r8,0
800116b6:	f7 e8 10 08 	or	r8,r11,r8
800116ba:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
800116be:	f2 08 01 08 	sub	r8,r9,r8
800116c2:	f0 0c 11 00 	rsub	r12,r8,0
800116c6:	f9 e8 10 08 	or	r8,r12,r8
800116ca:	f0 0c 14 1f 	asr	r12,r8,0x1f
800116ce:	2f fc       	sub	r12,-1
800116d0:	5e fc       	retal	r12

800116d2 <__isnand>:
800116d2:	14 98       	mov	r8,r10
800116d4:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
800116d8:	f0 0c 11 00 	rsub	r12,r8,0
800116dc:	10 4c       	or	r12,r8
800116de:	fc 18 7f f0 	movh	r8,0x7ff0
800116e2:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
800116e6:	f0 0c 01 0c 	sub	r12,r8,r12
800116ea:	bf 9c       	lsr	r12,0x1f
800116ec:	5e fc       	retal	r12
800116ee:	d7 03       	nop

800116f0 <_sbrk_r>:
800116f0:	d4 21       	pushm	r4-r7,lr
800116f2:	30 08       	mov	r8,0
800116f4:	18 97       	mov	r7,r12
800116f6:	48 76       	lddpc	r6,80011710 <_sbrk_r+0x20>
800116f8:	16 9c       	mov	r12,r11
800116fa:	8d 08       	st.w	r6[0x0],r8
800116fc:	f0 1f 00 06 	mcall	80011714 <_sbrk_r+0x24>
80011700:	5b fc       	cp.w	r12,-1
80011702:	c0 51       	brne	8001170c <_sbrk_r+0x1c>
80011704:	6c 08       	ld.w	r8,r6[0x0]
80011706:	58 08       	cp.w	r8,0
80011708:	ef f8 1a 03 	st.wne	r7[0xc],r8
8001170c:	d8 22       	popm	r4-r7,pc
8001170e:	00 00       	add	r0,r0
80011710:	00 00       	add	r0,r0
80011712:	0d 94       	ld.ub	r4,r6[0x1]
80011714:	80 01       	ld.sh	r1,r0[0x0]
80011716:	18 8c       	andn	r12,r12

80011718 <__sclose>:
80011718:	d4 01       	pushm	lr
8001171a:	96 7b       	ld.sh	r11,r11[0xe]
8001171c:	f0 1f 00 02 	mcall	80011724 <__sclose+0xc>
80011720:	d8 02       	popm	pc
80011722:	00 00       	add	r0,r0
80011724:	80 01       	ld.sh	r1,r0[0x0]
80011726:	19 58       	ld.sh	r8,--r12

80011728 <__sseek>:
80011728:	d4 21       	pushm	r4-r7,lr
8001172a:	16 97       	mov	r7,r11
8001172c:	96 7b       	ld.sh	r11,r11[0xe]
8001172e:	f0 1f 00 08 	mcall	8001174c <__sseek+0x24>
80011732:	8e 68       	ld.sh	r8,r7[0xc]
80011734:	10 99       	mov	r9,r8
80011736:	ad c8       	cbr	r8,0xc
80011738:	ad a9       	sbr	r9,0xc
8001173a:	5b fc       	cp.w	r12,-1
8001173c:	ef f8 0c 06 	st.heq	r7[0xc],r8
80011740:	ef f9 1c 06 	st.hne	r7[0xc],r9
80011744:	ef fc 1a 15 	st.wne	r7[0x54],r12
80011748:	d8 22       	popm	r4-r7,pc
8001174a:	00 00       	add	r0,r0
8001174c:	80 01       	ld.sh	r1,r0[0x0]
8001174e:	1a a0       	st.w	sp++,r0

80011750 <__swrite>:
80011750:	d4 21       	pushm	r4-r7,lr
80011752:	96 68       	ld.sh	r8,r11[0xc]
80011754:	16 97       	mov	r7,r11
80011756:	14 95       	mov	r5,r10
80011758:	12 94       	mov	r4,r9
8001175a:	e2 18 01 00 	andl	r8,0x100,COH
8001175e:	18 96       	mov	r6,r12
80011760:	c0 60       	breq	8001176c <__swrite+0x1c>
80011762:	30 29       	mov	r9,2
80011764:	30 0a       	mov	r10,0
80011766:	96 7b       	ld.sh	r11,r11[0xe]
80011768:	f0 1f 00 06 	mcall	80011780 <__swrite+0x30>
8001176c:	8e 68       	ld.sh	r8,r7[0xc]
8001176e:	ad c8       	cbr	r8,0xc
80011770:	08 99       	mov	r9,r4
80011772:	0a 9a       	mov	r10,r5
80011774:	8e 7b       	ld.sh	r11,r7[0xe]
80011776:	0c 9c       	mov	r12,r6
80011778:	ae 68       	st.h	r7[0xc],r8
8001177a:	f0 1f 00 03 	mcall	80011784 <__swrite+0x34>
8001177e:	d8 22       	popm	r4-r7,pc
80011780:	80 01       	ld.sh	r1,r0[0x0]
80011782:	1a a0       	st.w	sp++,r0
80011784:	80 01       	ld.sh	r1,r0[0x0]
80011786:	18 cc       	st.b	r12++,r12

80011788 <__sread>:
80011788:	d4 21       	pushm	r4-r7,lr
8001178a:	16 97       	mov	r7,r11
8001178c:	96 7b       	ld.sh	r11,r11[0xe]
8001178e:	f0 1f 00 07 	mcall	800117a8 <__sread+0x20>
80011792:	c0 65       	brlt	8001179e <__sread+0x16>
80011794:	6f 58       	ld.w	r8,r7[0x54]
80011796:	18 08       	add	r8,r12
80011798:	ef 48 00 54 	st.w	r7[84],r8
8001179c:	d8 22       	popm	r4-r7,pc
8001179e:	8e 68       	ld.sh	r8,r7[0xc]
800117a0:	ad c8       	cbr	r8,0xc
800117a2:	ae 68       	st.h	r7[0xc],r8
800117a4:	d8 22       	popm	r4-r7,pc
800117a6:	00 00       	add	r0,r0
800117a8:	80 01       	ld.sh	r1,r0[0x0]
800117aa:	1a cc       	st.b	sp++,r12

800117ac <_close>:
800117ac:	30 28       	mov	r8,2
800117ae:	d6 73       	breakpoint
800117b0:	3f fc       	mov	r12,-1
800117b2:	35 8b       	mov	r11,88
800117b4:	58 0c       	cp.w	r12,0
800117b6:	5e 4c       	retge	r12
800117b8:	48 2a       	lddpc	r10,800117c0 <_close+0x14>
800117ba:	95 0b       	st.w	r10[0x0],r11
800117bc:	5e fc       	retal	r12
800117be:	00 00       	add	r0,r0
800117c0:	00 00       	add	r0,r0
800117c2:	0d 94       	ld.ub	r4,r6[0x1]

800117c4 <_lseek>:
800117c4:	30 58       	mov	r8,5
800117c6:	d6 73       	breakpoint
800117c8:	3f fc       	mov	r12,-1
800117ca:	35 8b       	mov	r11,88
800117cc:	58 0c       	cp.w	r12,0
800117ce:	5e 4c       	retge	r12
800117d0:	48 2a       	lddpc	r10,800117d8 <_lseek+0x14>
800117d2:	95 0b       	st.w	r10[0x0],r11
800117d4:	5e fc       	retal	r12
800117d6:	00 00       	add	r0,r0
800117d8:	00 00       	add	r0,r0
800117da:	0d 94       	ld.ub	r4,r6[0x1]

800117dc <_read>:
800117dc:	30 38       	mov	r8,3
800117de:	d6 73       	breakpoint
800117e0:	3f fc       	mov	r12,-1
800117e2:	35 8b       	mov	r11,88
800117e4:	58 0c       	cp.w	r12,0
800117e6:	5e 4c       	retge	r12
800117e8:	48 2a       	lddpc	r10,800117f0 <_read+0x14>
800117ea:	95 0b       	st.w	r10[0x0],r11
800117ec:	5e fc       	retal	r12
800117ee:	00 00       	add	r0,r0
800117f0:	00 00       	add	r0,r0
800117f2:	0d 94       	ld.ub	r4,r6[0x1]

800117f4 <_write>:
800117f4:	30 48       	mov	r8,4
800117f6:	d6 73       	breakpoint
800117f8:	3f fc       	mov	r12,-1
800117fa:	35 8b       	mov	r11,88
800117fc:	58 0c       	cp.w	r12,0
800117fe:	5e 4c       	retge	r12
80011800:	48 2a       	lddpc	r10,80011808 <_write+0x14>
80011802:	95 0b       	st.w	r10[0x0],r11
80011804:	5e fc       	retal	r12
80011806:	00 00       	add	r0,r0
80011808:	00 00       	add	r0,r0
8001180a:	0d 94       	ld.ub	r4,r6[0x1]

8001180c <isatty>:
8001180c:	30 b8       	mov	r8,11
8001180e:	d6 73       	breakpoint
80011810:	3f fc       	mov	r12,-1
80011812:	35 8b       	mov	r11,88
80011814:	58 0c       	cp.w	r12,0
80011816:	5e 4c       	retge	r12
80011818:	48 2a       	lddpc	r10,80011820 <isatty+0x14>
8001181a:	95 0b       	st.w	r10[0x0],r11
8001181c:	5e fc       	retal	r12
8001181e:	00 00       	add	r0,r0
80011820:	00 00       	add	r0,r0
80011822:	0d 94       	ld.ub	r4,r6[0x1]

80011824 <_fstat_host>:
80011824:	30 98       	mov	r8,9
80011826:	d6 73       	breakpoint
80011828:	3f fc       	mov	r12,-1
8001182a:	35 8b       	mov	r11,88
8001182c:	58 0c       	cp.w	r12,0
8001182e:	5e 4c       	retge	r12
80011830:	48 2a       	lddpc	r10,80011838 <_fstat_host+0x14>
80011832:	95 0b       	st.w	r10[0x0],r11
80011834:	5e fc       	retal	r12
80011836:	00 00       	add	r0,r0
80011838:	00 00       	add	r0,r0
8001183a:	0d 94       	ld.ub	r4,r6[0x1]

8001183c <_fstat>:
8001183c:	d4 21       	pushm	r4-r7,lr
8001183e:	21 0d       	sub	sp,64
80011840:	16 97       	mov	r7,r11
80011842:	1a 9b       	mov	r11,sp
80011844:	f0 1f 00 11 	mcall	80011888 <_fstat+0x4c>
80011848:	c0 34       	brge	8001184e <_fstat+0x12>
8001184a:	3f fc       	mov	r12,-1
8001184c:	c1 c8       	rjmp	80011884 <_fstat+0x48>
8001184e:	40 08       	lddsp	r8,sp[0x0]
80011850:	ae 08       	st.h	r7[0x0],r8
80011852:	40 18       	lddsp	r8,sp[0x4]
80011854:	ae 18       	st.h	r7[0x2],r8
80011856:	40 28       	lddsp	r8,sp[0x8]
80011858:	8f 18       	st.w	r7[0x4],r8
8001185a:	40 38       	lddsp	r8,sp[0xc]
8001185c:	ae 48       	st.h	r7[0x8],r8
8001185e:	40 48       	lddsp	r8,sp[0x10]
80011860:	ae 58       	st.h	r7[0xa],r8
80011862:	40 58       	lddsp	r8,sp[0x14]
80011864:	ae 68       	st.h	r7[0xc],r8
80011866:	40 68       	lddsp	r8,sp[0x18]
80011868:	ae 78       	st.h	r7[0xe],r8
8001186a:	40 88       	lddsp	r8,sp[0x20]
8001186c:	8f 48       	st.w	r7[0x10],r8
8001186e:	40 a8       	lddsp	r8,sp[0x28]
80011870:	8f b8       	st.w	r7[0x2c],r8
80011872:	40 c8       	lddsp	r8,sp[0x30]
80011874:	8f c8       	st.w	r7[0x30],r8
80011876:	40 d8       	lddsp	r8,sp[0x34]
80011878:	8f 58       	st.w	r7[0x14],r8
8001187a:	40 e8       	lddsp	r8,sp[0x38]
8001187c:	30 0c       	mov	r12,0
8001187e:	8f 78       	st.w	r7[0x1c],r8
80011880:	40 f8       	lddsp	r8,sp[0x3c]
80011882:	8f 98       	st.w	r7[0x24],r8
80011884:	2f 0d       	sub	sp,-64
80011886:	d8 22       	popm	r4-r7,pc
80011888:	80 01       	ld.sh	r1,r0[0x0]
8001188a:	18 24       	rsub	r4,r12

8001188c <_sbrk>:
8001188c:	d4 01       	pushm	lr
8001188e:	48 c8       	lddpc	r8,800118bc <_sbrk+0x30>
80011890:	70 09       	ld.w	r9,r8[0x0]
80011892:	58 09       	cp.w	r9,0
80011894:	c0 31       	brne	8001189a <_sbrk+0xe>
80011896:	48 b9       	lddpc	r9,800118c0 <_sbrk+0x34>
80011898:	91 09       	st.w	r8[0x0],r9
8001189a:	48 99       	lddpc	r9,800118bc <_sbrk+0x30>
8001189c:	48 aa       	lddpc	r10,800118c4 <_sbrk+0x38>
8001189e:	72 08       	ld.w	r8,r9[0x0]
800118a0:	f0 0c 00 0c 	add	r12,r8,r12
800118a4:	14 3c       	cp.w	r12,r10
800118a6:	e0 8b 00 04 	brhi	800118ae <_sbrk+0x22>
800118aa:	93 0c       	st.w	r9[0x0],r12
800118ac:	c0 68       	rjmp	800118b8 <_sbrk+0x2c>
800118ae:	f0 1f 00 07 	mcall	800118c8 <_sbrk+0x3c>
800118b2:	30 c8       	mov	r8,12
800118b4:	99 08       	st.w	r12[0x0],r8
800118b6:	3f f8       	mov	r8,-1
800118b8:	10 9c       	mov	r12,r8
800118ba:	d8 02       	popm	pc
800118bc:	00 00       	add	r0,r0
800118be:	08 0c       	add	r12,r4
800118c0:	00 00       	add	r0,r0
800118c2:	0d 98       	ld.ub	r8,r6[0x1]
800118c4:	00 00       	add	r0,r0
800118c6:	f0 00       	*unknown*
800118c8:	80 01       	ld.sh	r1,r0[0x0]
800118ca:	19 80       	ld.ub	r0,r12[0x0]

800118cc <_write_r>:
800118cc:	d4 21       	pushm	r4-r7,lr
800118ce:	16 98       	mov	r8,r11
800118d0:	18 97       	mov	r7,r12
800118d2:	10 9c       	mov	r12,r8
800118d4:	30 08       	mov	r8,0
800118d6:	14 9b       	mov	r11,r10
800118d8:	48 66       	lddpc	r6,800118f0 <_write_r+0x24>
800118da:	12 9a       	mov	r10,r9
800118dc:	8d 08       	st.w	r6[0x0],r8
800118de:	f0 1f 00 06 	mcall	800118f4 <_write_r+0x28>
800118e2:	5b fc       	cp.w	r12,-1
800118e4:	c0 51       	brne	800118ee <_write_r+0x22>
800118e6:	6c 08       	ld.w	r8,r6[0x0]
800118e8:	58 08       	cp.w	r8,0
800118ea:	ef f8 1a 03 	st.wne	r7[0xc],r8
800118ee:	d8 22       	popm	r4-r7,pc
800118f0:	00 00       	add	r0,r0
800118f2:	0d 94       	ld.ub	r4,r6[0x1]
800118f4:	80 01       	ld.sh	r1,r0[0x0]
800118f6:	17 f4       	ld.ub	r4,r11[0x7]

800118f8 <_calloc_r>:
800118f8:	d4 21       	pushm	r4-r7,lr
800118fa:	f4 0b 02 4b 	mul	r11,r10,r11
800118fe:	f0 1f 00 15 	mcall	80011950 <_calloc_r+0x58>
80011902:	18 97       	mov	r7,r12
80011904:	c2 30       	breq	8001194a <_calloc_r+0x52>
80011906:	f8 fa ff fc 	ld.w	r10,r12[-4]
8001190a:	e0 1a ff fc 	andl	r10,0xfffc
8001190e:	20 4a       	sub	r10,4
80011910:	e0 4a 00 24 	cp.w	r10,36
80011914:	e0 8b 00 18 	brhi	80011944 <_calloc_r+0x4c>
80011918:	18 98       	mov	r8,r12
8001191a:	59 3a       	cp.w	r10,19
8001191c:	e0 88 00 0f 	brls	8001193a <_calloc_r+0x42>
80011920:	30 09       	mov	r9,0
80011922:	10 a9       	st.w	r8++,r9
80011924:	10 a9       	st.w	r8++,r9
80011926:	59 ba       	cp.w	r10,27
80011928:	e0 88 00 09 	brls	8001193a <_calloc_r+0x42>
8001192c:	10 a9       	st.w	r8++,r9
8001192e:	10 a9       	st.w	r8++,r9
80011930:	e0 4a 00 24 	cp.w	r10,36
80011934:	c0 31       	brne	8001193a <_calloc_r+0x42>
80011936:	10 a9       	st.w	r8++,r9
80011938:	10 a9       	st.w	r8++,r9
8001193a:	30 09       	mov	r9,0
8001193c:	10 a9       	st.w	r8++,r9
8001193e:	91 19       	st.w	r8[0x4],r9
80011940:	91 09       	st.w	r8[0x0],r9
80011942:	c0 48       	rjmp	8001194a <_calloc_r+0x52>
80011944:	30 0b       	mov	r11,0
80011946:	f0 1f 00 04 	mcall	80011954 <_calloc_r+0x5c>
8001194a:	0e 9c       	mov	r12,r7
8001194c:	d8 22       	popm	r4-r7,pc
8001194e:	00 00       	add	r0,r0
80011950:	80 01       	ld.sh	r1,r0[0x0]
80011952:	08 dc       	st.w	--r4,r12
80011954:	80 00       	ld.sh	r0,r0[0x0]
80011956:	ce 02       	brcc	80011916 <_calloc_r+0x1e>

80011958 <_close_r>:
80011958:	d4 21       	pushm	r4-r7,lr
8001195a:	30 08       	mov	r8,0
8001195c:	18 97       	mov	r7,r12
8001195e:	48 76       	lddpc	r6,80011978 <_close_r+0x20>
80011960:	16 9c       	mov	r12,r11
80011962:	8d 08       	st.w	r6[0x0],r8
80011964:	f0 1f 00 06 	mcall	8001197c <_close_r+0x24>
80011968:	5b fc       	cp.w	r12,-1
8001196a:	c0 51       	brne	80011974 <_close_r+0x1c>
8001196c:	6c 08       	ld.w	r8,r6[0x0]
8001196e:	58 08       	cp.w	r8,0
80011970:	ef f8 1a 03 	st.wne	r7[0xc],r8
80011974:	d8 22       	popm	r4-r7,pc
80011976:	00 00       	add	r0,r0
80011978:	00 00       	add	r0,r0
8001197a:	0d 94       	ld.ub	r4,r6[0x1]
8001197c:	80 01       	ld.sh	r1,r0[0x0]
8001197e:	17 ac       	ld.ub	r12,r11[0x2]

80011980 <__errno>:
80011980:	48 28       	lddpc	r8,80011988 <__errno+0x8>
80011982:	70 0c       	ld.w	r12,r8[0x0]
80011984:	2f 4c       	sub	r12,-12
80011986:	5e fc       	retal	r12
80011988:	00 00       	add	r0,r0
8001198a:	01 a8       	ld.ub	r8,r0[0x2]

8001198c <_fclose_r>:
8001198c:	d4 21       	pushm	r4-r7,lr
8001198e:	18 96       	mov	r6,r12
80011990:	16 97       	mov	r7,r11
80011992:	58 0b       	cp.w	r11,0
80011994:	c0 31       	brne	8001199a <_fclose_r+0xe>
80011996:	16 95       	mov	r5,r11
80011998:	c5 08       	rjmp	80011a38 <_fclose_r+0xac>
8001199a:	f0 1f 00 29 	mcall	80011a3c <_fclose_r+0xb0>
8001199e:	58 06       	cp.w	r6,0
800119a0:	c0 70       	breq	800119ae <_fclose_r+0x22>
800119a2:	6c 68       	ld.w	r8,r6[0x18]
800119a4:	58 08       	cp.w	r8,0
800119a6:	c0 41       	brne	800119ae <_fclose_r+0x22>
800119a8:	0c 9c       	mov	r12,r6
800119aa:	f0 1f 00 26 	mcall	80011a40 <_fclose_r+0xb4>
800119ae:	4a 68       	lddpc	r8,80011a44 <_fclose_r+0xb8>
800119b0:	10 37       	cp.w	r7,r8
800119b2:	c0 31       	brne	800119b8 <_fclose_r+0x2c>
800119b4:	6c 07       	ld.w	r7,r6[0x0]
800119b6:	c0 a8       	rjmp	800119ca <_fclose_r+0x3e>
800119b8:	4a 48       	lddpc	r8,80011a48 <_fclose_r+0xbc>
800119ba:	10 37       	cp.w	r7,r8
800119bc:	c0 31       	brne	800119c2 <_fclose_r+0x36>
800119be:	6c 17       	ld.w	r7,r6[0x4]
800119c0:	c0 58       	rjmp	800119ca <_fclose_r+0x3e>
800119c2:	4a 38       	lddpc	r8,80011a4c <_fclose_r+0xc0>
800119c4:	10 37       	cp.w	r7,r8
800119c6:	ed f7 00 02 	ld.weq	r7,r6[0x8]
800119ca:	8e 69       	ld.sh	r9,r7[0xc]
800119cc:	30 08       	mov	r8,0
800119ce:	f0 09 19 00 	cp.h	r9,r8
800119d2:	c0 51       	brne	800119dc <_fclose_r+0x50>
800119d4:	f0 1f 00 1f 	mcall	80011a50 <_fclose_r+0xc4>
800119d8:	30 05       	mov	r5,0
800119da:	c2 f8       	rjmp	80011a38 <_fclose_r+0xac>
800119dc:	0e 9b       	mov	r11,r7
800119de:	0c 9c       	mov	r12,r6
800119e0:	f0 1f 00 1d 	mcall	80011a54 <_fclose_r+0xc8>
800119e4:	6e c8       	ld.w	r8,r7[0x30]
800119e6:	18 95       	mov	r5,r12
800119e8:	58 08       	cp.w	r8,0
800119ea:	c0 60       	breq	800119f6 <_fclose_r+0x6a>
800119ec:	6e 8b       	ld.w	r11,r7[0x20]
800119ee:	0c 9c       	mov	r12,r6
800119f0:	5d 18       	icall	r8
800119f2:	f9 b5 05 ff 	movlt	r5,-1
800119f6:	8e 68       	ld.sh	r8,r7[0xc]
800119f8:	ed b8 00 07 	bld	r8,0x7
800119fc:	c0 51       	brne	80011a06 <_fclose_r+0x7a>
800119fe:	6e 4b       	ld.w	r11,r7[0x10]
80011a00:	0c 9c       	mov	r12,r6
80011a02:	f0 1f 00 16 	mcall	80011a58 <_fclose_r+0xcc>
80011a06:	6e db       	ld.w	r11,r7[0x34]
80011a08:	58 0b       	cp.w	r11,0
80011a0a:	c0 a0       	breq	80011a1e <_fclose_r+0x92>
80011a0c:	ee c8 ff bc 	sub	r8,r7,-68
80011a10:	10 3b       	cp.w	r11,r8
80011a12:	c0 40       	breq	80011a1a <_fclose_r+0x8e>
80011a14:	0c 9c       	mov	r12,r6
80011a16:	f0 1f 00 11 	mcall	80011a58 <_fclose_r+0xcc>
80011a1a:	30 08       	mov	r8,0
80011a1c:	8f d8       	st.w	r7[0x34],r8
80011a1e:	6f 2b       	ld.w	r11,r7[0x48]
80011a20:	58 0b       	cp.w	r11,0
80011a22:	c0 70       	breq	80011a30 <_fclose_r+0xa4>
80011a24:	0c 9c       	mov	r12,r6
80011a26:	f0 1f 00 0d 	mcall	80011a58 <_fclose_r+0xcc>
80011a2a:	30 08       	mov	r8,0
80011a2c:	ef 48 00 48 	st.w	r7[72],r8
80011a30:	30 08       	mov	r8,0
80011a32:	ae 68       	st.h	r7[0xc],r8
80011a34:	f0 1f 00 07 	mcall	80011a50 <_fclose_r+0xc4>
80011a38:	0a 9c       	mov	r12,r5
80011a3a:	d8 22       	popm	r4-r7,pc
80011a3c:	80 01       	ld.sh	r1,r0[0x0]
80011a3e:	01 1c       	ld.sh	r12,r0++
80011a40:	80 01       	ld.sh	r1,r0[0x0]
80011a42:	01 e0       	ld.ub	r0,r0[0x6]
80011a44:	80 01       	ld.sh	r1,r0[0x0]
80011a46:	2b 3c       	sub	r12,-77
80011a48:	80 01       	ld.sh	r1,r0[0x0]
80011a4a:	2b 5c       	sub	r12,-75
80011a4c:	80 01       	ld.sh	r1,r0[0x0]
80011a4e:	2b 7c       	sub	r12,-73
80011a50:	80 01       	ld.sh	r1,r0[0x0]
80011a52:	01 1e       	ld.sh	lr,r0++
80011a54:	80 01       	ld.sh	r1,r0[0x0]
80011a56:	00 04       	add	r4,r0
80011a58:	80 01       	ld.sh	r1,r0[0x0]
80011a5a:	03 38       	ld.ub	r8,r1++

80011a5c <fclose>:
80011a5c:	d4 01       	pushm	lr
80011a5e:	48 48       	lddpc	r8,80011a6c <fclose+0x10>
80011a60:	18 9b       	mov	r11,r12
80011a62:	70 0c       	ld.w	r12,r8[0x0]
80011a64:	f0 1f 00 03 	mcall	80011a70 <fclose+0x14>
80011a68:	d8 02       	popm	pc
80011a6a:	00 00       	add	r0,r0
80011a6c:	00 00       	add	r0,r0
80011a6e:	01 a8       	ld.ub	r8,r0[0x2]
80011a70:	80 01       	ld.sh	r1,r0[0x0]
80011a72:	19 8c       	ld.ub	r12,r12[0x0]

80011a74 <_fstat_r>:
80011a74:	d4 21       	pushm	r4-r7,lr
80011a76:	16 98       	mov	r8,r11
80011a78:	18 97       	mov	r7,r12
80011a7a:	10 9c       	mov	r12,r8
80011a7c:	30 08       	mov	r8,0
80011a7e:	48 76       	lddpc	r6,80011a98 <_fstat_r+0x24>
80011a80:	14 9b       	mov	r11,r10
80011a82:	8d 08       	st.w	r6[0x0],r8
80011a84:	f0 1f 00 06 	mcall	80011a9c <_fstat_r+0x28>
80011a88:	5b fc       	cp.w	r12,-1
80011a8a:	c0 51       	brne	80011a94 <_fstat_r+0x20>
80011a8c:	6c 08       	ld.w	r8,r6[0x0]
80011a8e:	58 08       	cp.w	r8,0
80011a90:	ef f8 1a 03 	st.wne	r7[0xc],r8
80011a94:	d8 22       	popm	r4-r7,pc
80011a96:	00 00       	add	r0,r0
80011a98:	00 00       	add	r0,r0
80011a9a:	0d 94       	ld.ub	r4,r6[0x1]
80011a9c:	80 01       	ld.sh	r1,r0[0x0]
80011a9e:	18 3c       	cp.w	r12,r12

80011aa0 <_lseek_r>:
80011aa0:	d4 21       	pushm	r4-r7,lr
80011aa2:	16 98       	mov	r8,r11
80011aa4:	18 97       	mov	r7,r12
80011aa6:	10 9c       	mov	r12,r8
80011aa8:	30 08       	mov	r8,0
80011aaa:	14 9b       	mov	r11,r10
80011aac:	48 66       	lddpc	r6,80011ac4 <_lseek_r+0x24>
80011aae:	12 9a       	mov	r10,r9
80011ab0:	8d 08       	st.w	r6[0x0],r8
80011ab2:	f0 1f 00 06 	mcall	80011ac8 <_lseek_r+0x28>
80011ab6:	5b fc       	cp.w	r12,-1
80011ab8:	c0 51       	brne	80011ac2 <_lseek_r+0x22>
80011aba:	6c 08       	ld.w	r8,r6[0x0]
80011abc:	58 08       	cp.w	r8,0
80011abe:	ef f8 1a 03 	st.wne	r7[0xc],r8
80011ac2:	d8 22       	popm	r4-r7,pc
80011ac4:	00 00       	add	r0,r0
80011ac6:	0d 94       	ld.ub	r4,r6[0x1]
80011ac8:	80 01       	ld.sh	r1,r0[0x0]
80011aca:	17 c4       	ld.ub	r4,r11[0x4]

80011acc <_read_r>:
80011acc:	d4 21       	pushm	r4-r7,lr
80011ace:	16 98       	mov	r8,r11
80011ad0:	18 97       	mov	r7,r12
80011ad2:	10 9c       	mov	r12,r8
80011ad4:	30 08       	mov	r8,0
80011ad6:	14 9b       	mov	r11,r10
80011ad8:	48 66       	lddpc	r6,80011af0 <_read_r+0x24>
80011ada:	12 9a       	mov	r10,r9
80011adc:	8d 08       	st.w	r6[0x0],r8
80011ade:	f0 1f 00 06 	mcall	80011af4 <_read_r+0x28>
80011ae2:	5b fc       	cp.w	r12,-1
80011ae4:	c0 51       	brne	80011aee <_read_r+0x22>
80011ae6:	6c 08       	ld.w	r8,r6[0x0]
80011ae8:	58 08       	cp.w	r8,0
80011aea:	ef f8 1a 03 	st.wne	r7[0xc],r8
80011aee:	d8 22       	popm	r4-r7,pc
80011af0:	00 00       	add	r0,r0
80011af2:	0d 94       	ld.ub	r4,r6[0x1]
80011af4:	80 01       	ld.sh	r1,r0[0x0]
80011af6:	17 dc       	ld.ub	r12,r11[0x5]

80011af8 <__avr32_f64_to_u32>:
80011af8:	58 0b       	cp.w	r11,0
80011afa:	5e 6d       	retmi	0

80011afc <__avr32_f64_to_s32>:
80011afc:	f6 0c 15 01 	lsl	r12,r11,0x1
80011b00:	b5 9c       	lsr	r12,0x15
80011b02:	e0 2c 03 ff 	sub	r12,1023
80011b06:	5e 3d       	retlo	0
80011b08:	f8 0c 11 1f 	rsub	r12,r12,31
80011b0c:	16 99       	mov	r9,r11
80011b0e:	ab 7b       	lsl	r11,0xb
80011b10:	bf bb       	sbr	r11,0x1f
80011b12:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
80011b16:	f6 0c 0a 4b 	lsr	r11,r11,r12
80011b1a:	a1 79       	lsl	r9,0x1
80011b1c:	5e 2b       	reths	r11
80011b1e:	5c 3b       	neg	r11
80011b20:	5e fb       	retal	r11

80011b22 <__avr32_f64_cmp_eq>:
80011b22:	10 3a       	cp.w	r10,r8
80011b24:	f2 0b 13 00 	cpc	r11,r9
80011b28:	c0 80       	breq	80011b38 <__avr32_f64_cmp_eq+0x16>
80011b2a:	a1 7b       	lsl	r11,0x1
80011b2c:	a1 79       	lsl	r9,0x1
80011b2e:	14 4b       	or	r11,r10
80011b30:	12 4b       	or	r11,r9
80011b32:	10 4b       	or	r11,r8
80011b34:	5e 0f       	reteq	1
80011b36:	5e fd       	retal	0
80011b38:	a1 7b       	lsl	r11,0x1
80011b3a:	fc 1c ff e0 	movh	r12,0xffe0
80011b3e:	58 0a       	cp.w	r10,0
80011b40:	f8 0b 13 00 	cpc	r11,r12
80011b44:	5e 8f       	retls	1
80011b46:	5e fd       	retal	0

80011b48 <__avr32_f64_cmp_ge>:
80011b48:	1a de       	st.w	--sp,lr
80011b4a:	1a d7       	st.w	--sp,r7
80011b4c:	a1 7b       	lsl	r11,0x1
80011b4e:	5f 3c       	srlo	r12
80011b50:	a1 79       	lsl	r9,0x1
80011b52:	5f 37       	srlo	r7
80011b54:	5c fc       	rol	r12
80011b56:	fc 1e ff e0 	movh	lr,0xffe0
80011b5a:	58 0a       	cp.w	r10,0
80011b5c:	fc 0b 13 00 	cpc	r11,lr
80011b60:	e0 8b 00 1d 	brhi	80011b9a <__avr32_f64_cmp_ge+0x52>
80011b64:	58 08       	cp.w	r8,0
80011b66:	fc 09 13 00 	cpc	r9,lr
80011b6a:	e0 8b 00 18 	brhi	80011b9a <__avr32_f64_cmp_ge+0x52>
80011b6e:	58 0b       	cp.w	r11,0
80011b70:	f5 ba 00 00 	subfeq	r10,0
80011b74:	c1 50       	breq	80011b9e <__avr32_f64_cmp_ge+0x56>
80011b76:	1b 07       	ld.w	r7,sp++
80011b78:	1b 0e       	ld.w	lr,sp++
80011b7a:	58 3c       	cp.w	r12,3
80011b7c:	c0 a0       	breq	80011b90 <__avr32_f64_cmp_ge+0x48>
80011b7e:	58 1c       	cp.w	r12,1
80011b80:	c0 33       	brcs	80011b86 <__avr32_f64_cmp_ge+0x3e>
80011b82:	5e 0f       	reteq	1
80011b84:	5e 1d       	retne	0
80011b86:	10 3a       	cp.w	r10,r8
80011b88:	f2 0b 13 00 	cpc	r11,r9
80011b8c:	5e 2f       	reths	1
80011b8e:	5e 3d       	retlo	0
80011b90:	14 38       	cp.w	r8,r10
80011b92:	f6 09 13 00 	cpc	r9,r11
80011b96:	5e 2f       	reths	1
80011b98:	5e 3d       	retlo	0
80011b9a:	1b 07       	ld.w	r7,sp++
80011b9c:	d8 0a       	popm	pc,r12=0
80011b9e:	58 17       	cp.w	r7,1
80011ba0:	5f 0c       	sreq	r12
80011ba2:	58 09       	cp.w	r9,0
80011ba4:	f5 b8 00 00 	subfeq	r8,0
80011ba8:	1b 07       	ld.w	r7,sp++
80011baa:	1b 0e       	ld.w	lr,sp++
80011bac:	5e 0f       	reteq	1
80011bae:	5e fc       	retal	r12

80011bb0 <__avr32_f64_cmp_lt>:
80011bb0:	1a de       	st.w	--sp,lr
80011bb2:	1a d7       	st.w	--sp,r7
80011bb4:	a1 7b       	lsl	r11,0x1
80011bb6:	5f 3c       	srlo	r12
80011bb8:	a1 79       	lsl	r9,0x1
80011bba:	5f 37       	srlo	r7
80011bbc:	5c fc       	rol	r12
80011bbe:	fc 1e ff e0 	movh	lr,0xffe0
80011bc2:	58 0a       	cp.w	r10,0
80011bc4:	fc 0b 13 00 	cpc	r11,lr
80011bc8:	e0 8b 00 1d 	brhi	80011c02 <__avr32_f64_cmp_lt+0x52>
80011bcc:	58 08       	cp.w	r8,0
80011bce:	fc 09 13 00 	cpc	r9,lr
80011bd2:	e0 8b 00 18 	brhi	80011c02 <__avr32_f64_cmp_lt+0x52>
80011bd6:	58 0b       	cp.w	r11,0
80011bd8:	f5 ba 00 00 	subfeq	r10,0
80011bdc:	c1 50       	breq	80011c06 <__avr32_f64_cmp_lt+0x56>
80011bde:	1b 07       	ld.w	r7,sp++
80011be0:	1b 0e       	ld.w	lr,sp++
80011be2:	58 3c       	cp.w	r12,3
80011be4:	c0 a0       	breq	80011bf8 <__avr32_f64_cmp_lt+0x48>
80011be6:	58 1c       	cp.w	r12,1
80011be8:	c0 33       	brcs	80011bee <__avr32_f64_cmp_lt+0x3e>
80011bea:	5e 0d       	reteq	0
80011bec:	5e 1f       	retne	1
80011bee:	10 3a       	cp.w	r10,r8
80011bf0:	f2 0b 13 00 	cpc	r11,r9
80011bf4:	5e 2d       	reths	0
80011bf6:	5e 3f       	retlo	1
80011bf8:	14 38       	cp.w	r8,r10
80011bfa:	f6 09 13 00 	cpc	r9,r11
80011bfe:	5e 2d       	reths	0
80011c00:	5e 3f       	retlo	1
80011c02:	1b 07       	ld.w	r7,sp++
80011c04:	d8 0a       	popm	pc,r12=0
80011c06:	58 17       	cp.w	r7,1
80011c08:	5f 1c       	srne	r12
80011c0a:	58 09       	cp.w	r9,0
80011c0c:	f5 b8 00 00 	subfeq	r8,0
80011c10:	1b 07       	ld.w	r7,sp++
80011c12:	1b 0e       	ld.w	lr,sp++
80011c14:	5e 0d       	reteq	0
80011c16:	5e fc       	retal	r12

80011c18 <__avr32_f64_div>:
80011c18:	eb cd 40 ff 	pushm	r0-r7,lr
80011c1c:	f7 e9 20 0e 	eor	lr,r11,r9
80011c20:	f6 07 16 14 	lsr	r7,r11,0x14
80011c24:	a9 7b       	lsl	r11,0x9
80011c26:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
80011c2a:	a9 7a       	lsl	r10,0x9
80011c2c:	bd bb       	sbr	r11,0x1d
80011c2e:	e4 1b 3f ff 	andh	r11,0x3fff
80011c32:	ab d7       	cbr	r7,0xb
80011c34:	e0 80 00 cc 	breq	80011dcc <__avr32_f64_div_round_subnormal+0x54>
80011c38:	e0 47 07 ff 	cp.w	r7,2047
80011c3c:	e0 84 00 b5 	brge	80011da6 <__avr32_f64_div_round_subnormal+0x2e>
80011c40:	f2 06 16 14 	lsr	r6,r9,0x14
80011c44:	a9 79       	lsl	r9,0x9
80011c46:	f3 e8 13 79 	or	r9,r9,r8>>0x17
80011c4a:	a9 78       	lsl	r8,0x9
80011c4c:	bd b9       	sbr	r9,0x1d
80011c4e:	e4 19 3f ff 	andh	r9,0x3fff
80011c52:	ab d6       	cbr	r6,0xb
80011c54:	e0 80 00 e2 	breq	80011e18 <__avr32_f64_div_round_subnormal+0xa0>
80011c58:	e0 46 07 ff 	cp.w	r6,2047
80011c5c:	e0 84 00 b2 	brge	80011dc0 <__avr32_f64_div_round_subnormal+0x48>
80011c60:	0c 17       	sub	r7,r6
80011c62:	fe 37 fc 01 	sub	r7,-1023
80011c66:	fc 1c 80 00 	movh	r12,0x8000
80011c6a:	f8 03 16 01 	lsr	r3,r12,0x1
80011c6e:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
80011c72:	5c d4       	com	r4
80011c74:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
80011c78:	e6 09 06 44 	mulu.d	r4,r3,r9
80011c7c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
80011c80:	e6 05 06 44 	mulu.d	r4,r3,r5
80011c84:	ea 03 15 02 	lsl	r3,r5,0x2
80011c88:	e6 09 06 44 	mulu.d	r4,r3,r9
80011c8c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
80011c90:	e6 05 06 44 	mulu.d	r4,r3,r5
80011c94:	ea 03 15 02 	lsl	r3,r5,0x2
80011c98:	e6 09 06 44 	mulu.d	r4,r3,r9
80011c9c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
80011ca0:	e6 05 06 44 	mulu.d	r4,r3,r5
80011ca4:	ea 03 15 02 	lsl	r3,r5,0x2
80011ca8:	e6 08 06 40 	mulu.d	r0,r3,r8
80011cac:	e4 09 07 40 	macu.d	r0,r2,r9
80011cb0:	e6 09 06 44 	mulu.d	r4,r3,r9
80011cb4:	02 04       	add	r4,r1
80011cb6:	5c 05       	acr	r5
80011cb8:	a3 65       	lsl	r5,0x2
80011cba:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
80011cbe:	a3 64       	lsl	r4,0x2
80011cc0:	5c 34       	neg	r4
80011cc2:	f8 05 01 45 	sbc	r5,r12,r5
80011cc6:	e6 04 06 40 	mulu.d	r0,r3,r4
80011cca:	e4 05 07 40 	macu.d	r0,r2,r5
80011cce:	e6 05 06 44 	mulu.d	r4,r3,r5
80011cd2:	02 04       	add	r4,r1
80011cd4:	5c 05       	acr	r5
80011cd6:	ea 03 15 02 	lsl	r3,r5,0x2
80011cda:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
80011cde:	e8 02 15 02 	lsl	r2,r4,0x2
80011ce2:	e6 08 06 40 	mulu.d	r0,r3,r8
80011ce6:	e4 09 07 40 	macu.d	r0,r2,r9
80011cea:	e6 09 06 44 	mulu.d	r4,r3,r9
80011cee:	02 04       	add	r4,r1
80011cf0:	5c 05       	acr	r5
80011cf2:	a3 65       	lsl	r5,0x2
80011cf4:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
80011cf8:	a3 64       	lsl	r4,0x2
80011cfa:	5c 34       	neg	r4
80011cfc:	f8 05 01 45 	sbc	r5,r12,r5
80011d00:	e6 04 06 40 	mulu.d	r0,r3,r4
80011d04:	e4 05 07 40 	macu.d	r0,r2,r5
80011d08:	e6 05 06 44 	mulu.d	r4,r3,r5
80011d0c:	02 04       	add	r4,r1
80011d0e:	5c 05       	acr	r5
80011d10:	ea 03 15 02 	lsl	r3,r5,0x2
80011d14:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
80011d18:	e8 02 15 02 	lsl	r2,r4,0x2
80011d1c:	e6 0a 06 40 	mulu.d	r0,r3,r10
80011d20:	e4 0b 07 40 	macu.d	r0,r2,r11
80011d24:	e6 0b 06 42 	mulu.d	r2,r3,r11
80011d28:	02 02       	add	r2,r1
80011d2a:	5c 03       	acr	r3
80011d2c:	ed b3 00 1c 	bld	r3,0x1c
80011d30:	c0 90       	breq	80011d42 <__avr32_f64_div+0x12a>
80011d32:	a1 72       	lsl	r2,0x1
80011d34:	5c f3       	rol	r3
80011d36:	20 17       	sub	r7,1
80011d38:	a3 9a       	lsr	r10,0x3
80011d3a:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
80011d3e:	a3 9b       	lsr	r11,0x3
80011d40:	c0 58       	rjmp	80011d4a <__avr32_f64_div+0x132>
80011d42:	a5 8a       	lsr	r10,0x4
80011d44:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
80011d48:	a5 8b       	lsr	r11,0x4
80011d4a:	58 07       	cp.w	r7,0
80011d4c:	e0 8a 00 8b 	brle	80011e62 <__avr32_f64_div_res_subnormal>
80011d50:	e0 12 ff 00 	andl	r2,0xff00
80011d54:	e8 12 00 80 	orl	r2,0x80
80011d58:	e6 08 06 40 	mulu.d	r0,r3,r8
80011d5c:	e4 09 07 40 	macu.d	r0,r2,r9
80011d60:	e4 08 06 44 	mulu.d	r4,r2,r8
80011d64:	e6 09 06 48 	mulu.d	r8,r3,r9
80011d68:	00 05       	add	r5,r0
80011d6a:	f0 01 00 48 	adc	r8,r8,r1
80011d6e:	5c 09       	acr	r9
80011d70:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
80011d74:	58 04       	cp.w	r4,0
80011d76:	5c 25       	cpc	r5

80011d78 <__avr32_f64_div_round_subnormal>:
80011d78:	f4 08 13 00 	cpc	r8,r10
80011d7c:	f6 09 13 00 	cpc	r9,r11
80011d80:	5f 36       	srlo	r6
80011d82:	f8 06 17 00 	moveq	r6,r12
80011d86:	e4 0a 16 08 	lsr	r10,r2,0x8
80011d8a:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
80011d8e:	e6 0b 16 08 	lsr	r11,r3,0x8
80011d92:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
80011d96:	ed be 00 1f 	bld	lr,0x1f
80011d9a:	ef bb 00 1f 	bst	r11,0x1f
80011d9e:	0c 0a       	add	r10,r6
80011da0:	5c 0b       	acr	r11
80011da2:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
80011da6:	e4 1b 00 0f 	andh	r11,0xf
80011daa:	14 4b       	or	r11,r10
80011dac:	e0 81 00 a7 	brne	80011efa <__avr32_f64_div_res_subnormal+0x98>
80011db0:	f2 06 16 14 	lsr	r6,r9,0x14
80011db4:	ab d6       	cbr	r6,0xb
80011db6:	e0 46 07 ff 	cp.w	r6,2047
80011dba:	e0 81 00 a4 	brne	80011f02 <__avr32_f64_div_res_subnormal+0xa0>
80011dbe:	c9 e8       	rjmp	80011efa <__avr32_f64_div_res_subnormal+0x98>
80011dc0:	e4 19 00 0f 	andh	r9,0xf
80011dc4:	10 49       	or	r9,r8
80011dc6:	e0 81 00 9a 	brne	80011efa <__avr32_f64_div_res_subnormal+0x98>
80011dca:	c9 28       	rjmp	80011eee <__avr32_f64_div_res_subnormal+0x8c>
80011dcc:	a3 7b       	lsl	r11,0x3
80011dce:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
80011dd2:	a3 7a       	lsl	r10,0x3
80011dd4:	f5 eb 10 04 	or	r4,r10,r11
80011dd8:	e0 80 00 a0 	breq	80011f18 <__avr32_f64_div_op1_zero>
80011ddc:	f6 04 12 00 	clz	r4,r11
80011de0:	c1 70       	breq	80011e0e <__avr32_f64_div_round_subnormal+0x96>
80011de2:	c0 c3       	brcs	80011dfa <__avr32_f64_div_round_subnormal+0x82>
80011de4:	e8 05 11 20 	rsub	r5,r4,32
80011de8:	f6 04 09 4b 	lsl	r11,r11,r4
80011dec:	f4 05 0a 45 	lsr	r5,r10,r5
80011df0:	0a 4b       	or	r11,r5
80011df2:	f4 04 09 4a 	lsl	r10,r10,r4
80011df6:	08 17       	sub	r7,r4
80011df8:	c0 b8       	rjmp	80011e0e <__avr32_f64_div_round_subnormal+0x96>
80011dfa:	f4 04 12 00 	clz	r4,r10
80011dfe:	f9 b4 03 00 	movlo	r4,0
80011e02:	f7 b4 02 e0 	subhs	r4,-32
80011e06:	f4 04 09 4b 	lsl	r11,r10,r4
80011e0a:	30 0a       	mov	r10,0
80011e0c:	08 17       	sub	r7,r4
80011e0e:	a3 8a       	lsr	r10,0x2
80011e10:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
80011e14:	a3 8b       	lsr	r11,0x2
80011e16:	c1 1b       	rjmp	80011c38 <__avr32_f64_div+0x20>
80011e18:	a3 79       	lsl	r9,0x3
80011e1a:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
80011e1e:	a3 78       	lsl	r8,0x3
80011e20:	f3 e8 10 04 	or	r4,r9,r8
80011e24:	c6 f0       	breq	80011f02 <__avr32_f64_div_res_subnormal+0xa0>
80011e26:	f2 04 12 00 	clz	r4,r9
80011e2a:	c1 70       	breq	80011e58 <__avr32_f64_div_round_subnormal+0xe0>
80011e2c:	c0 c3       	brcs	80011e44 <__avr32_f64_div_round_subnormal+0xcc>
80011e2e:	e8 05 11 20 	rsub	r5,r4,32
80011e32:	f2 04 09 49 	lsl	r9,r9,r4
80011e36:	f0 05 0a 45 	lsr	r5,r8,r5
80011e3a:	0a 49       	or	r9,r5
80011e3c:	f0 04 09 48 	lsl	r8,r8,r4
80011e40:	08 16       	sub	r6,r4
80011e42:	c0 b8       	rjmp	80011e58 <__avr32_f64_div_round_subnormal+0xe0>
80011e44:	f0 04 12 00 	clz	r4,r8
80011e48:	f9 b4 03 00 	movlo	r4,0
80011e4c:	f7 b4 02 e0 	subhs	r4,-32
80011e50:	f0 04 09 49 	lsl	r9,r8,r4
80011e54:	30 08       	mov	r8,0
80011e56:	08 16       	sub	r6,r4
80011e58:	a3 88       	lsr	r8,0x2
80011e5a:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
80011e5e:	a3 89       	lsr	r9,0x2
80011e60:	cf ca       	rjmp	80011c58 <__avr32_f64_div+0x40>

80011e62 <__avr32_f64_div_res_subnormal>:
80011e62:	5c 37       	neg	r7
80011e64:	2f f7       	sub	r7,-1
80011e66:	f1 b7 04 c0 	satu	r7,0x6
80011e6a:	e0 47 00 20 	cp.w	r7,32
80011e6e:	c1 54       	brge	80011e98 <__avr32_f64_div_res_subnormal+0x36>
80011e70:	ee 06 11 20 	rsub	r6,r7,32
80011e74:	e4 07 0a 42 	lsr	r2,r2,r7
80011e78:	e6 06 09 4c 	lsl	r12,r3,r6
80011e7c:	18 42       	or	r2,r12
80011e7e:	e6 07 0a 43 	lsr	r3,r3,r7
80011e82:	f4 06 09 41 	lsl	r1,r10,r6
80011e86:	f4 07 0a 4a 	lsr	r10,r10,r7
80011e8a:	f6 06 09 4c 	lsl	r12,r11,r6
80011e8e:	18 4a       	or	r10,r12
80011e90:	f6 07 0a 4b 	lsr	r11,r11,r7
80011e94:	30 00       	mov	r0,0
80011e96:	c1 58       	rjmp	80011ec0 <__avr32_f64_div_res_subnormal+0x5e>
80011e98:	ee 06 11 20 	rsub	r6,r7,32
80011e9c:	f9 b0 00 00 	moveq	r0,0
80011ea0:	f9 bc 00 00 	moveq	r12,0
80011ea4:	c0 50       	breq	80011eae <__avr32_f64_div_res_subnormal+0x4c>
80011ea6:	f4 06 09 40 	lsl	r0,r10,r6
80011eaa:	f6 06 09 4c 	lsl	r12,r11,r6
80011eae:	e6 07 0a 42 	lsr	r2,r3,r7
80011eb2:	30 03       	mov	r3,0
80011eb4:	f4 07 0a 41 	lsr	r1,r10,r7
80011eb8:	18 41       	or	r1,r12
80011eba:	f6 07 0a 4a 	lsr	r10,r11,r7
80011ebe:	30 0b       	mov	r11,0
80011ec0:	e0 12 ff 00 	andl	r2,0xff00
80011ec4:	e8 12 00 80 	orl	r2,0x80
80011ec8:	e6 08 06 46 	mulu.d	r6,r3,r8
80011ecc:	e4 09 07 46 	macu.d	r6,r2,r9
80011ed0:	e4 08 06 44 	mulu.d	r4,r2,r8
80011ed4:	e6 09 06 48 	mulu.d	r8,r3,r9
80011ed8:	0c 05       	add	r5,r6
80011eda:	f0 07 00 48 	adc	r8,r8,r7
80011ede:	5c 09       	acr	r9
80011ee0:	30 07       	mov	r7,0
80011ee2:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
80011ee6:	00 34       	cp.w	r4,r0
80011ee8:	e2 05 13 00 	cpc	r5,r1
80011eec:	c4 6b       	rjmp	80011d78 <__avr32_f64_div_round_subnormal>
80011eee:	1c 9b       	mov	r11,lr
80011ef0:	e6 1b 80 00 	andh	r11,0x8000,COH
80011ef4:	30 0a       	mov	r10,0
80011ef6:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
80011efa:	3f fb       	mov	r11,-1
80011efc:	30 0a       	mov	r10,0
80011efe:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
80011f02:	f5 eb 10 04 	or	r4,r10,r11
80011f06:	c0 90       	breq	80011f18 <__avr32_f64_div_op1_zero>
80011f08:	1c 9b       	mov	r11,lr
80011f0a:	e6 1b 80 00 	andh	r11,0x8000,COH
80011f0e:	ea 1b 7f f0 	orh	r11,0x7ff0
80011f12:	30 0a       	mov	r10,0
80011f14:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

80011f18 <__avr32_f64_div_op1_zero>:
80011f18:	f1 e9 10 15 	or	r5,r8,r9<<0x1
80011f1c:	ce f0       	breq	80011efa <__avr32_f64_div_res_subnormal+0x98>
80011f1e:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
80011f22:	e0 44 07 ff 	cp.w	r4,2047
80011f26:	ce 41       	brne	80011eee <__avr32_f64_div_res_subnormal+0x8c>
80011f28:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
80011f2c:	ce 10       	breq	80011eee <__avr32_f64_div_res_subnormal+0x8c>
80011f2e:	ce 6b       	rjmp	80011efa <__avr32_f64_div_res_subnormal+0x98>

80011f30 <__avr32_umod64>:
80011f30:	d4 31       	pushm	r0-r7,lr
80011f32:	1a 97       	mov	r7,sp
80011f34:	20 3d       	sub	sp,12
80011f36:	10 9c       	mov	r12,r8
80011f38:	12 95       	mov	r5,r9
80011f3a:	14 9e       	mov	lr,r10
80011f3c:	16 91       	mov	r1,r11
80011f3e:	16 96       	mov	r6,r11
80011f40:	58 09       	cp.w	r9,0
80011f42:	e0 81 00 81 	brne	80012044 <__avr32_umod64+0x114>
80011f46:	16 38       	cp.w	r8,r11
80011f48:	e0 88 00 12 	brls	80011f6c <__avr32_umod64+0x3c>
80011f4c:	f0 08 12 00 	clz	r8,r8
80011f50:	c4 e0       	breq	80011fec <__avr32_umod64+0xbc>
80011f52:	f6 08 09 46 	lsl	r6,r11,r8
80011f56:	f8 08 09 4c 	lsl	r12,r12,r8
80011f5a:	f0 0b 11 20 	rsub	r11,r8,32
80011f5e:	f4 08 09 4e 	lsl	lr,r10,r8
80011f62:	f4 0b 0a 4b 	lsr	r11,r10,r11
80011f66:	f7 e6 10 06 	or	r6,r11,r6
80011f6a:	c4 18       	rjmp	80011fec <__avr32_umod64+0xbc>
80011f6c:	58 08       	cp.w	r8,0
80011f6e:	c0 51       	brne	80011f78 <__avr32_umod64+0x48>
80011f70:	30 19       	mov	r9,1
80011f72:	f2 08 0d 08 	divu	r8,r9,r8
80011f76:	10 9c       	mov	r12,r8
80011f78:	f8 08 12 00 	clz	r8,r12
80011f7c:	c0 31       	brne	80011f82 <__avr32_umod64+0x52>
80011f7e:	18 16       	sub	r6,r12
80011f80:	c3 68       	rjmp	80011fec <__avr32_umod64+0xbc>
80011f82:	f0 03 11 20 	rsub	r3,r8,32
80011f86:	f4 03 0a 4b 	lsr	r11,r10,r3
80011f8a:	f8 08 09 4c 	lsl	r12,r12,r8
80011f8e:	ec 08 09 49 	lsl	r9,r6,r8
80011f92:	ec 03 0a 43 	lsr	r3,r6,r3
80011f96:	f7 e9 10 09 	or	r9,r11,r9
80011f9a:	f8 05 16 10 	lsr	r5,r12,0x10
80011f9e:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
80011fa2:	e6 05 0d 02 	divu	r2,r3,r5
80011fa6:	f2 0e 16 10 	lsr	lr,r9,0x10
80011faa:	ec 02 02 4b 	mul	r11,r6,r2
80011fae:	fd e3 11 0e 	or	lr,lr,r3<<0x10
80011fb2:	16 3e       	cp.w	lr,r11
80011fb4:	c0 72       	brcc	80011fc2 <__avr32_umod64+0x92>
80011fb6:	18 0e       	add	lr,r12
80011fb8:	18 3e       	cp.w	lr,r12
80011fba:	c0 43       	brcs	80011fc2 <__avr32_umod64+0x92>
80011fbc:	16 3e       	cp.w	lr,r11
80011fbe:	fd dc e3 0e 	addcs	lr,lr,r12
80011fc2:	fc 0b 01 03 	sub	r3,lr,r11
80011fc6:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
80011fca:	e6 05 0d 02 	divu	r2,r3,r5
80011fce:	f3 e3 11 09 	or	r9,r9,r3<<0x10
80011fd2:	a5 36       	mul	r6,r2
80011fd4:	0c 39       	cp.w	r9,r6
80011fd6:	c0 72       	brcc	80011fe4 <__avr32_umod64+0xb4>
80011fd8:	18 09       	add	r9,r12
80011fda:	18 39       	cp.w	r9,r12
80011fdc:	c0 43       	brcs	80011fe4 <__avr32_umod64+0xb4>
80011fde:	0c 39       	cp.w	r9,r6
80011fe0:	f3 dc e3 09 	addcs	r9,r9,r12
80011fe4:	f2 06 01 06 	sub	r6,r9,r6
80011fe8:	f4 08 09 4e 	lsl	lr,r10,r8
80011fec:	f8 0a 16 10 	lsr	r10,r12,0x10
80011ff0:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
80011ff4:	ec 0a 0d 02 	divu	r2,r6,r10
80011ff8:	fc 09 16 10 	lsr	r9,lr,0x10
80011ffc:	ea 02 02 4b 	mul	r11,r5,r2
80012000:	f3 e3 11 09 	or	r9,r9,r3<<0x10
80012004:	16 39       	cp.w	r9,r11
80012006:	c0 72       	brcc	80012014 <__avr32_umod64+0xe4>
80012008:	18 09       	add	r9,r12
8001200a:	18 39       	cp.w	r9,r12
8001200c:	c0 43       	brcs	80012014 <__avr32_umod64+0xe4>
8001200e:	16 39       	cp.w	r9,r11
80012010:	f3 dc e3 09 	addcs	r9,r9,r12
80012014:	f2 0b 01 0b 	sub	r11,r9,r11
80012018:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8001201c:	f6 0a 0d 0a 	divu	r10,r11,r10
80012020:	fd eb 11 0e 	or	lr,lr,r11<<0x10
80012024:	ea 0a 02 4a 	mul	r10,r5,r10
80012028:	14 3e       	cp.w	lr,r10
8001202a:	c0 72       	brcc	80012038 <__avr32_umod64+0x108>
8001202c:	18 0e       	add	lr,r12
8001202e:	18 3e       	cp.w	lr,r12
80012030:	c0 43       	brcs	80012038 <__avr32_umod64+0x108>
80012032:	14 3e       	cp.w	lr,r10
80012034:	fd dc e3 0e 	addcs	lr,lr,r12
80012038:	fc 0a 01 0a 	sub	r10,lr,r10
8001203c:	30 0b       	mov	r11,0
8001203e:	f4 08 0a 4a 	lsr	r10,r10,r8
80012042:	c7 b8       	rjmp	80012138 <__avr32_umod64+0x208>
80012044:	16 39       	cp.w	r9,r11
80012046:	e0 8b 00 79 	brhi	80012138 <__avr32_umod64+0x208>
8001204a:	f2 09 12 00 	clz	r9,r9
8001204e:	c1 21       	brne	80012072 <__avr32_umod64+0x142>
80012050:	10 3a       	cp.w	r10,r8
80012052:	5f 2b       	srhs	r11
80012054:	0a 31       	cp.w	r1,r5
80012056:	5f ba       	srhi	r10
80012058:	f7 ea 10 0a 	or	r10,r11,r10
8001205c:	f2 0a 18 00 	cp.b	r10,r9
80012060:	c0 60       	breq	8001206c <__avr32_umod64+0x13c>
80012062:	fc 08 01 0c 	sub	r12,lr,r8
80012066:	e2 05 01 46 	sbc	r6,r1,r5
8001206a:	18 9e       	mov	lr,r12
8001206c:	0c 9b       	mov	r11,r6
8001206e:	1c 9a       	mov	r10,lr
80012070:	c6 48       	rjmp	80012138 <__avr32_umod64+0x208>
80012072:	ea 09 09 4c 	lsl	r12,r5,r9
80012076:	f2 06 11 20 	rsub	r6,r9,32
8001207a:	f6 09 09 4b 	lsl	r11,r11,r9
8001207e:	f0 09 09 42 	lsl	r2,r8,r9
80012082:	ef 46 ff f4 	st.w	r7[-12],r6
80012086:	f0 06 0a 48 	lsr	r8,r8,r6
8001208a:	18 48       	or	r8,r12
8001208c:	e2 06 0a 4c 	lsr	r12,r1,r6
80012090:	f4 09 09 43 	lsl	r3,r10,r9
80012094:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
80012098:	f4 06 0a 4a 	lsr	r10,r10,r6
8001209c:	16 4a       	or	r10,r11
8001209e:	f0 0b 16 10 	lsr	r11,r8,0x10
800120a2:	f8 0b 0d 04 	divu	r4,r12,r11
800120a6:	f4 0c 16 10 	lsr	r12,r10,0x10
800120aa:	08 91       	mov	r1,r4
800120ac:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
800120b0:	e8 0e 02 46 	mul	r6,r4,lr
800120b4:	0c 3c       	cp.w	r12,r6
800120b6:	c0 a2       	brcc	800120ca <__avr32_umod64+0x19a>
800120b8:	20 11       	sub	r1,1
800120ba:	10 0c       	add	r12,r8
800120bc:	10 3c       	cp.w	r12,r8
800120be:	c0 63       	brcs	800120ca <__avr32_umod64+0x19a>
800120c0:	0c 3c       	cp.w	r12,r6
800120c2:	f7 b1 03 01 	sublo	r1,1
800120c6:	f9 d8 e3 0c 	addcs	r12,r12,r8
800120ca:	0c 1c       	sub	r12,r6
800120cc:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
800120d0:	f8 0b 0d 04 	divu	r4,r12,r11
800120d4:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
800120d8:	08 96       	mov	r6,r4
800120da:	e8 0e 02 4e 	mul	lr,r4,lr
800120de:	1c 3b       	cp.w	r11,lr
800120e0:	c0 a2       	brcc	800120f4 <__avr32_umod64+0x1c4>
800120e2:	20 16       	sub	r6,1
800120e4:	10 0b       	add	r11,r8
800120e6:	10 3b       	cp.w	r11,r8
800120e8:	c0 63       	brcs	800120f4 <__avr32_umod64+0x1c4>
800120ea:	1c 3b       	cp.w	r11,lr
800120ec:	f7 b6 03 01 	sublo	r6,1
800120f0:	f7 d8 e3 0b 	addcs	r11,r11,r8
800120f4:	ed e1 11 01 	or	r1,r6,r1<<0x10
800120f8:	1c 1b       	sub	r11,lr
800120fa:	e2 02 06 40 	mulu.d	r0,r1,r2
800120fe:	00 9e       	mov	lr,r0
80012100:	02 9c       	mov	r12,r1
80012102:	16 3c       	cp.w	r12,r11
80012104:	e0 8b 00 08 	brhi	80012114 <__avr32_umod64+0x1e4>
80012108:	5f 06       	sreq	r6
8001210a:	06 30       	cp.w	r0,r3
8001210c:	5f ba       	srhi	r10
8001210e:	ed ea 00 0a 	and	r10,r6,r10
80012112:	c0 60       	breq	8001211e <__avr32_umod64+0x1ee>
80012114:	fc 02 01 04 	sub	r4,lr,r2
80012118:	f8 08 01 4c 	sbc	r12,r12,r8
8001211c:	08 9e       	mov	lr,r4
8001211e:	e6 0e 01 0a 	sub	r10,r3,lr
80012122:	f6 0c 01 4c 	sbc	r12,r11,r12
80012126:	ee f1 ff f4 	ld.w	r1,r7[-12]
8001212a:	f8 09 0a 4b 	lsr	r11,r12,r9
8001212e:	f4 09 0a 4a 	lsr	r10,r10,r9
80012132:	f8 01 09 4c 	lsl	r12,r12,r1
80012136:	18 4a       	or	r10,r12
80012138:	2f dd       	sub	sp,-12
8001213a:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

80012200 <_evba>:
_evba:

	.org  0x000
	// Unrecoverable Exception.
_handle_Unrecoverable_Exception:
	rjmp $
80012200:	c0 08       	rjmp	80012200 <_evba>
	...

80012204 <_handle_TLB_Multiple_Hit>:

	.org  0x004
	// TLB Multiple Hit.
_handle_TLB_Multiple_Hit:
	rjmp $
80012204:	c0 08       	rjmp	80012204 <_handle_TLB_Multiple_Hit>
	...

80012208 <_handle_Bus_Error_Data_Fetch>:

	.org  0x008
	// Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
	rjmp $
80012208:	c0 08       	rjmp	80012208 <_handle_Bus_Error_Data_Fetch>
	...

8001220c <_handle_Bus_Error_Instruction_Fetch>:

	.org  0x00C
	// Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
	rjmp $
8001220c:	c0 08       	rjmp	8001220c <_handle_Bus_Error_Instruction_Fetch>
	...

80012210 <_handle_NMI>:

	.org  0x010
	// NMI.
_handle_NMI:
	rjmp $
80012210:	c0 08       	rjmp	80012210 <_handle_NMI>
	...

80012214 <_handle_Instruction_Address>:

	.org  0x014
	// Instruction Address.
_handle_Instruction_Address:
	rjmp $
80012214:	c0 08       	rjmp	80012214 <_handle_Instruction_Address>
	...

80012218 <_handle_ITLB_Protection>:

	.org  0x018
	// ITLB Protection.
_handle_ITLB_Protection:
	rjmp $
80012218:	c0 08       	rjmp	80012218 <_handle_ITLB_Protection>
	...

8001221c <_handle_Breakpoint>:

	.org  0x01C
	// Breakpoint.
_handle_Breakpoint:
	rjmp $
8001221c:	c0 08       	rjmp	8001221c <_handle_Breakpoint>
	...

80012220 <_handle_Illegal_Opcode>:

	.org  0x020
	// Illegal Opcode.
_handle_Illegal_Opcode:
	rjmp $
80012220:	c0 08       	rjmp	80012220 <_handle_Illegal_Opcode>
	...

80012224 <_handle_Unimplemented_Instruction>:

	.org  0x024
	// Unimplemented Instruction.
_handle_Unimplemented_Instruction:
	rjmp $
80012224:	c0 08       	rjmp	80012224 <_handle_Unimplemented_Instruction>
	...

80012228 <_handle_Privilege_Violation>:

	.org  0x028
	// Privilege Violation.
_handle_Privilege_Violation:
	rjmp $
80012228:	c0 08       	rjmp	80012228 <_handle_Privilege_Violation>
	...

8001222c <_handle_Floating_Point>:

	.org  0x02C
	// Floating-Point: UNUSED IN AVR32UC and AVR32AP.
_handle_Floating_Point:
	rjmp $
8001222c:	c0 08       	rjmp	8001222c <_handle_Floating_Point>
	...

80012230 <_handle_Coprocessor_Absent>:

	.org  0x030
	// Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
	rjmp $
80012230:	c0 08       	rjmp	80012230 <_handle_Coprocessor_Absent>
	...

80012234 <_handle_Data_Address_Read>:

	.org  0x034
	// Data Address (Read).
_handle_Data_Address_Read:
	rjmp $
80012234:	c0 08       	rjmp	80012234 <_handle_Data_Address_Read>
	...

80012238 <_handle_Data_Address_Write>:

	.org  0x038
	// Data Address (Write).
_handle_Data_Address_Write:
	rjmp $
80012238:	c0 08       	rjmp	80012238 <_handle_Data_Address_Write>
	...

8001223c <_handle_DTLB_Protection_Read>:

	.org  0x03C
	// DTLB Protection (Read).
_handle_DTLB_Protection_Read:
	rjmp $
8001223c:	c0 08       	rjmp	8001223c <_handle_DTLB_Protection_Read>
	...

80012240 <_handle_DTLB_Protection_Write>:

	.org  0x040
	// DTLB Protection (Write).
_handle_DTLB_Protection_Write:
	rjmp $
80012240:	c0 08       	rjmp	80012240 <_handle_DTLB_Protection_Write>
	...

80012244 <_handle_DTLB_Modified>:

	.org  0x044
	// DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
	rjmp $
80012244:	c0 08       	rjmp	80012244 <_handle_DTLB_Modified>
	...

80012250 <_handle_ITLB_Miss>:

	.org  0x050
	// ITLB Miss.
_handle_ITLB_Miss:
	rjmp $
80012250:	c0 08       	rjmp	80012250 <_handle_ITLB_Miss>
	...

80012260 <_handle_DTLB_Miss_Read>:

	.org  0x060
	// DTLB Miss (Read).
_handle_DTLB_Miss_Read:
	rjmp $
80012260:	c0 08       	rjmp	80012260 <_handle_DTLB_Miss_Read>
	...

80012270 <_handle_DTLB_Miss_Write>:

	.org  0x070
	// DTLB Miss (Write).
_handle_DTLB_Miss_Write:
	rjmp $
80012270:	c0 08       	rjmp	80012270 <_handle_DTLB_Miss_Write>
	...

80012300 <_handle_Supervisor_Call>:

	.org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	rjmp $
80012300:	c0 08       	rjmp	80012300 <_handle_Supervisor_Call>
	...

80012304 <_int0>:
	 * RSR_INTx by the CPU upon interrupt entry. No other register is saved
	 * by hardware.
	 */
	pushm   r8-r12, lr
#endif
	// Pass the int_level parameter to the _get_interrupt_handler function.
80012304:	30 0c       	mov	r12,0
80012306:	f0 1f 00 0e 	mcall	8001233c <_int3+0xe>
8001230a:	58 0c       	cp.w	r12,0
8001230c:	f8 0f 17 10 	movne	pc,r12
	popm    r8-r12, lr
#endif
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
80012310:	d6 03       	rete

80012312 <_int1>:
	 * RSR_INTx by the CPU upon interrupt entry. No other register is saved
	 * by hardware.
	 */
	pushm   r8-r12, lr
#endif
	// Pass the int_level parameter to the _get_interrupt_handler function.
80012312:	30 1c       	mov	r12,1
80012314:	f0 1f 00 0a 	mcall	8001233c <_int3+0xe>
80012318:	58 0c       	cp.w	r12,0
8001231a:	f8 0f 17 10 	movne	pc,r12
	popm    r8-r12, lr
#endif
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
8001231e:	d6 03       	rete

80012320 <_int2>:
	 * RSR_INTx by the CPU upon interrupt entry. No other register is saved
	 * by hardware.
	 */
	pushm   r8-r12, lr
#endif
	// Pass the int_level parameter to the _get_interrupt_handler function.
80012320:	30 2c       	mov	r12,2
80012322:	f0 1f 00 07 	mcall	8001233c <_int3+0xe>
80012326:	58 0c       	cp.w	r12,0
80012328:	f8 0f 17 10 	movne	pc,r12
	popm    r8-r12, lr
#endif
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
8001232c:	d6 03       	rete

8001232e <_int3>:
	 * RSR_INTx by the CPU upon interrupt entry. No other register is saved
	 * by hardware.
	 */
	pushm   r8-r12, lr
#endif
	// Pass the int_level parameter to the _get_interrupt_handler function.
8001232e:	30 3c       	mov	r12,3
80012330:	f0 1f 00 03 	mcall	8001233c <_int3+0xe>
80012334:	58 0c       	cp.w	r12,0
80012336:	f8 0f 17 10 	movne	pc,r12
	popm    r8-r12, lr
#endif
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
8001233a:	d6 03       	rete
8001233c:	80 00       	ld.sh	r0,r0[0x0]
8001233e:	4b b8       	lddpc	r8,80012428 <C.35.14269+0x8>
	...
